{
  "title":"Rails pundit tutorial",
  "date":"2022-10-31T09:19:42.000000Z",
  "author":null,
  "id":"https://bootrails.com/blog/rails-pundit-tutorial/",
  "link":"https://bootrails.com/blog/rails-pundit-tutorial/",
  "content":"<h2 id=\"introducing-pundit\">Introducing Pundit</h2>\n<p>As you probably know, web applications need the ability to assign different roles and permissions.</p>\n<p>New developers often confuse two terms - <em>Authorization</em> and <em>Authentication</em>.</p>\n<p><a href=\"/blog/rails-authentication-with-rodauth-an-elegant-gem/\"><em>Authentication</em></a> is a method of granting access to users through the process of verifying the claimed identity of the user, device, or other entity using the user's credentials, such as username, email address, password, etc.</p>\n<p><em>Authorization</em> is a method of granting users or a group of users the ability to access data with restrictions or permission to perform only the tasks they are allowed to by assigning user roles or access levels to users or groups of users.</p>\n<p>Usually, in web applications, granting limited access distinguishes between administrators and ordinary users. This can be done with a simple boolean that determines if the user is an administrator. However, in production applications, roles and permissions are more complex.</p>\n<p>How well roles and access restrictions to actions and data are implemented determines the quality of your application.</p>\n<p>In this post, we'll implement roles and permissions in a basic Ruby on Rails application using the <a href=\"https://github.com/varvet/pundit\">Pundit gem</a>.</p>\n<p>Pundit is a gem that provides a set of helpers that guide you to use simple Ruby objects and object-oriented design patterns to create an authorization system. It's easy to use, has minimal permissions, and is great for managing role-based authorization using policies defined in simple Ruby classes.</p>\n<p>To describe how the gem works, it binds the methods of the required class to the actions of the controller by executing the method corresponding to the action when a request is received. If the response evaluates to false, access is denied and an error is thrown.</p>\n<p>To put it simply, Pundit's job is to authorize whether the user is allowed to perform an action or not. Then your policy methods return a boolean and a Pundit::NotAuthorizedError will be raised if it's false.</p>\n<h2 id=\"policies\">Policies</h2>\n<p>Each time you have to check whether something or someone is allowed to perform an action in the application you will refer to the Policy Object pattern. This pattern is used to deal with permissions and roles.</p>\n<p>For example, we have a guest user in our application. Using a guest policy object we can check if this user is able to retrieve certain resources. And if the user is an admin, we can easily change guest policy object to an admin policy object with different rules.</p>\n<p>We need to stick to these rules when working with Policy Object pattern: </p>\n<ul>\n<li>The return has to be a boolean value</li>\n<li>The logic has to be simple</li>\n<li>Inside the method, we should only call methods on the passed objects</li>\n</ul>\n<h2 id=\"how-to-work-with-pundit\">How to work with Pundit</h2>\n<ol>\n<li>\n<p>Create a Policy class that handles authorizing access to a specific type of record — whether it be a Post or User, or something else.</p>\n</li>\n<li>\n<p>Call the built-in authorization function, passing in what you need to authorize access to.</p>\n</li>\n<li>\n<p>Pundit will find the appropriate Policy class and call the Policy method that matches the name of the method you are authorizing. If it returns true, you have permission to perform the action. If not, it’ll throw an exception.</p>\n</li>\n</ol>\n<p>In which scenarios should you use them:</p>\n<p>When your application has more than one type of restricted access and restricted actions. As an example, posts can be created with the following:</p>\n<ul>\n<li>a restriction that only admins and/or editors can create posts</li>\n<li>a requirement that editors need to be verified</li>\n</ul>\n<p>By default, Pundit provides two objects to your authorization context: the User and the Record being authorized. This is enough if you have a system-wide role in your system like Admin, but not enough if you need to allow more specific context.</p>\n<p>As an example, you worked with a system that supported the concept of an Office, with different roles and offices to support. The system-wide authorization would not be able to deal with it because it is unacceptable that an admin of Office One to be able to do things to Office Two unless they are an admin of both. In this case, you would need access to 3 items: the User, the Record, and the user’s role information in the Office.</p>\n<p>Pundit provides the ability to provide additional context. You can change what is considered a user by defining a function called <code>pundit_user</code>. The object authorization context from this function will be available to your policies.</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span># inside application_controller.rb\n</span><span>\n</span><span>class ApplicationController </span><span>&lt; </span><span>ActionController</span><span>::Base\n</span><span>  </span><span>include </span><span>Pundit\n</span><span>\n</span><span>  </span><span>def </span><span>pundit_user\n</span><span>    </span><span>AuthorizationContext</span><span>.</span><span>new</span><span>(current_user, current_office)\n</span><span>  </span><span>end\n</span><span>end\n</span></code></pre>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span># inside authorization_context.rb\n</span><span>\n</span><span>class AuthorizationContext\n</span><span>  </span><span>attr_reader </span><span>:user</span><span>, </span><span>:office\n</span><span>\n</span><span>  </span><span>def </span><span>initialize</span><span>(</span><span>user</span><span>, </span><span>office</span><span>)\n</span><span>    </span><span>@</span><span>user </span><span>= user\n</span><span>    </span><span>@</span><span>office </span><span>= office\n</span><span>  </span><span>end\n</span><span>end\n</span></code></pre>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span># inside application_policy.rb\n</span><span>\n</span><span>class ApplicationPolicy\n</span><span>  </span><span>attr_reader </span><span>:request_office</span><span>, </span><span>:user</span><span>, </span><span>:record\n</span><span>\n</span><span>  </span><span>def </span><span>initialize</span><span>(</span><span>authorization_context</span><span>, </span><span>record</span><span>)\n</span><span>    </span><span>@</span><span>user </span><span>= authorization_context.user\n</span><span>    </span><span>@</span><span>office </span><span>= authorization_context.office\n</span><span>    </span><span>@</span><span>record </span><span>= record\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span>def </span><span>index?\n</span><span>    </span><span># Your policy has access to @user, @office, and @record.  \n</span><span>  </span><span>end\n</span><span>end\n</span></code></pre>\n<h2 id=\"create-an-empty-rails-app\">Create an empty Rails app</h2>\n<p>Here are the tools I used for this tutorial. </p>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>$&gt; ruby --version  \n</span><span>=&gt; 3.1.2  \n</span><span>$&gt; rails --version  \n</span><span>=&gt; 7.0.3.1\n</span><span>$&gt; node --version  \n</span><span>=&gt; 18.6.0  \n</span><span>$&gt; yarn --version  \n</span><span>=&gt; 1.22.19\n</span></code></pre>\n<p>Let's create our brand new <a href=\"blog/ruby-on-rails-mvc/\">Ruby-on-Rails</a> application. There’s a lot of ways to do this, but the easiest and cleanest way probably is to create a file named Gemfile in your working directory, and fill it like this:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>source </span><span>'</span><span>https://rubygems.org</span><span>'\n</span><span>\n</span><span>ruby </span><span>'</span><span>3.1.2</span><span>'\n</span><span>\n</span><span>gem </span><span>'</span><span>rails</span><span>'</span><span>, </span><span>'</span><span>~&gt; 7.0.3.1</span><span>'\n</span></code></pre>\n<p>And then run </p>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bundle install\n</span></code></pre>\n<p>So we can now create our application. You may want to simplify this if one day you need to create <a href=\"/blog/how-to-create-tons-rails-applications/\">multiple Rails applications</a></p>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bin/rails new myapp --database=postgresql\n</span></code></pre>\n<ul>\n<li><strong>rails</strong> is the Rails CLI (command line interface) tool</li>\n<li><strong>new</strong> tells the Rails CLI that we want to generate a new application</li>\n<li><strong>myapp</strong> is, well, your app name</li>\n<li><strong>--database=postgresql</strong> is an optional parameter that tells Rails we want to use the PostgreSQL to persist our data (by default Rails has SQLite database)</li>\n</ul>\n<p>After generating your new Rails app, you’ll need to cd into your new app and create your database.</p>\n<p>Run at terminal </p>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bin/rails db:create\n</span></code></pre>\n<p>and</p>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bin/rails db:migrate\n</span></code></pre>\n<p>Great! Now run up your development server</p>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bin/rails s\n</span></code></pre>\n<p>Make sure you can navigate to your browser at localhost:3000, and if everything has gone well, you should see the Rails default index page.</p>\n<p>Now let's add a couple of models so we have something to work with:</p>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bin/rails g model User name:string\n</span></code></pre>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bin/rails g model Article title:string body:text user:belongs_to\n</span></code></pre>\n<p>and then</p>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bin/rails db:migrate\n</span></code></pre>\n<p>We will add an enum to the <code>User</code> type to be either admin or guest. We also wrote a tutorial about <a href=\"/blog/rails-add-column/\">how to add a column</a>.\nFollow the steps to add in the migration:</p>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bin/rails g migration add_role_to_users role:integer\n</span></code></pre>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bin/rails db:migrate\n</span></code></pre>\n<p>Updating the user model:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>class User </span><span>&lt; </span><span>ApplicationRecord\n</span><span>  enum </span><span>role: </span><span>{\n</span><span>    </span><span>guest: </span><span>0</span><span>,\n</span><span>    </span><span>admin: </span><span>1\n</span><span>  }\n</span><span>  has_many </span><span>:articles\n</span><span>end\n</span></code></pre>\n<h2 id=\"pundit-gem-installation\">Pundit gem installation</h2>\n<p>It is quit easy to set up this gem. For clear instruction, you can check Gem's documentation. Now start to set up it:</p>\n<p>Add gem &quot;pundit&quot; to Gemfle:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>gem </span><span>&quot;</span><span>pundit</span><span>&quot;\n</span></code></pre>\n<p>And run</p>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>bundle install\n</span></code></pre>\n<p>Include <code>Pundit::Authorization</code> in your application controller:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>class ApplicationController </span><span>&lt; </span><span>ActionController</span><span>::Base\n</span><span>  </span><span>include Pundit</span><span>::Authorization\n</span><span>end\n</span></code></pre>\n<p><em>Optionally, you can run the generator, which will set up an application policy with some useful defaults for you:</em></p>\n<pre><code><span>rails g pundit:install\n</span></code></pre>\n<p>After generating your application policy, restart the Rails server so that Rails can pick up any classes in the new <code>app/policies/</code> directory.</p>\n<h2 id=\"adding-policies\">Adding policies:</h2>\n<pre class=\"language-shell \"><code class=\"language-shell\"><span>mkdir app/policies\n</span><span>touch app/policies/article_policy.rb\n</span></code></pre>\n<p>Our article_policy.rb with some code:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>class ArticlePolicy\n</span><span>  </span><span>attr_reader </span><span>:user</span><span>, </span><span>:article\n</span><span>\n</span><span>  </span><span>def </span><span>initialize</span><span>(</span><span>user</span><span>, </span><span>article</span><span>)\n</span><span>    </span><span>@</span><span>user </span><span>= user\n</span><span>    </span><span>@</span><span>article </span><span>= article\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span>def </span><span>show?\n</span><span>    </span><span># a condition which returns a boolean value\n</span><span>  </span><span>end\n</span><span>end\n</span></code></pre>\n<p>The <code>ArticlePolicy</code> class has the same name as that of model class, only with the &quot;Policy&quot; suffix. Given that the first argument is a <code>user</code>, in your controller, Pundit will call the <em>current_user</em> method we defined in in <code>ApplicationController</code>, to get what to send into this argument. The second argument is the model object, whose authorization you want to check. And finally, some request method is implemented for the class in this case <code>show?</code>. This will map to the name of a specific controller action. Note that the method names should correspond to controller actions suffixed with a <strong>?</strong>. So for controller actions such as new, create, update etc, the policy methods <code>new?</code>, <code>create?</code>, <code>update?</code> etc are to be defined.</p>\n<h2 id=\"adding-policy-checks\">Adding policy checks</h2>\n<p>Let's look at the required code for class ArticlePolicy:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>class ArticlePolicy\n</span><span>  </span><span>attr_reader </span><span>:user</span><span>, </span><span>:article\n</span><span>\n</span><span>  </span><span>def </span><span>initialize</span><span>(</span><span>user</span><span>, </span><span>article</span><span>)\n</span><span>    </span><span>@</span><span>user </span><span>= user\n</span><span>    </span><span>@</span><span>article </span><span>= article\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span>def </span><span>index?\n</span><span>    </span><span>true\n</span><span>    </span><span># if set to false - nobody has access\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span># Here the condition we want to check is that whether the record's creator is \n</span><span>  </span><span># current user or record is assigned to the current user.\n</span><span>  </span><span>def </span><span>show?\n</span><span>    user.has_any_role? </span><span>:admin</span><span>, </span><span>:guest </span><span>||</span><span> article.user == user\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span># Same as that of the show.\n</span><span>  </span><span>def </span><span>edit?\n</span><span>    show?\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span># Only admin and owner are allowed to update the article.\n</span><span>  </span><span>def </span><span>update?\n</span><span>    user.role == </span><span>'</span><span>admin</span><span>' </span><span>||</span><span> article.user == user\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span># For now, every user can create an article.\n</span><span>  </span><span>def </span><span>create?\n</span><span>    </span><span>true\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span># Only admin and the user that has created the article, can delete it.\n</span><span>  </span><span>def </span><span>destroy?\n</span><span>    user.role == </span><span>'</span><span>admin</span><span>' </span><span>||</span><span> article.user == user\n</span><span>  </span><span>end\n</span><span>end\n</span></code></pre>\n<p>Then go to <code>articles_controller.rb</code>:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>class ArticlesController </span><span>&lt; </span><span>ApplicationController\n</span><span>  before_action </span><span>:set_article</span><span>, </span><span>only: </span><span>%i[</span><span>show update destroy</span><span>]\n</span><span>\n</span><span>  </span><span>def </span><span>index\n</span><span>    </span><span>@</span><span>articles </span><span>= </span><span>Article</span><span>.order(</span><span>created_at: :desc</span><span>)\n</span><span>    authorize </span><span>@</span><span>articles\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span>def </span><span>show\n</span><span>    authorize </span><span>@</span><span>article\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span>def </span><span>create\n</span><span>    article = current_user.articles.</span><span>new</span><span>(article_params)\n</span><span>    authorize article\n</span><span>    article.save!\n</span><span>    respond_with_success(t(</span><span>&quot;</span><span>successfully_created</span><span>&quot;</span><span>, </span><span>entity: </span><span>&quot;</span><span>Article</span><span>&quot;</span><span>))\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span>def </span><span>update\n</span><span>    authorize </span><span>@</span><span>article\n</span><span>    </span><span>@</span><span>article</span><span>.update!(article_params)\n</span><span>    respond_with_success(t(</span><span>&quot;</span><span>successfully_updated</span><span>&quot;</span><span>, </span><span>entity: </span><span>&quot;</span><span>Article</span><span>&quot;</span><span>)\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span>def </span><span>destroy\n</span><span>    authorize </span><span>@</span><span>article\n</span><span>    </span><span>@</span><span>article</span><span>.destroy!\n</span><span>    respond_with_json\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span>private\n</span><span>\n</span><span>  </span><span>def </span><span>article_params\n</span><span>    params.</span><span>require</span><span>(</span><span>:article</span><span>).permit(</span><span>:title</span><span>, </span><span>:body</span><span>, </span><span>:user_id</span><span>)\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span>def </span><span>set_article\n</span><span>    </span><span>@</span><span>article </span><span>= </span><span>Article</span><span>.find_by!(</span><span>slug:</span><span> params[</span><span>:slug</span><span>])\n</span><span>  </span><span>end\n</span><span>end\n</span></code></pre>\n<p>Update the <code>application_controller.rb</code> to handle an error with <a href=\"/blog/how-to-use-rails-flash-messages/\">flash messages</a>:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>class ApplicationController </span><span>&lt; </span><span>ActionController</span><span>::Base\n</span><span>\n</span><span>  rescue_from </span><span>Pundit</span><span>::NotAuthorizedError, </span><span>with: :handle_authorization_error\n</span><span>\n</span><span>  </span><span>private\n</span><span>\n</span><span>  </span><span>def </span><span>handle_authorization_error\n</span><span>    flash[</span><span>:alert</span><span>] = </span><span>&quot;</span><span>You are not authorized. Access denied.</span><span>&quot;\n</span><span>    redirect_to(request.referrer </span><span>||</span><span> root_path)\n</span><span>  </span><span>end\n</span><span>end\n</span></code></pre>\n<h2 id=\"pundit-policy-scopes\">Pundit policy scopes</h2>\n<p>This allows you to let users with different authorizations see different scopes of items.</p>\n<p>For example, admins can see all articles, other users can see articles that have content not blank.</p>\n<p>Modify the <code>article_policy.rb</code>:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>class ArticlePolicy </span><span>&lt; </span><span>ApplicationPolicy\n</span><span>  </span><span># ...\n</span><span>  </span><span>class Scope </span><span>&lt; </span><span>Scope\n</span><span>    </span><span>def </span><span>resolve\n</span><span>      </span><span>if @</span><span>user</span><span>.has_role? </span><span>:admin\n</span><span>        scope.all\n</span><span>      </span><span>else\n</span><span>        scope.where.not(</span><span>body: </span><span>&quot;&quot;</span><span>)\n</span><span>      </span><span>end\n</span><span>    </span><span>end\n</span><span>  </span><span>end\n</span><span>end\n</span></code></pre>\n<p>And then add to your ArticlesController:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>class ArticlesController </span><span>&lt; </span><span>ApplicationController\n</span><span>  </span><span># existing code\n</span><span>\n</span><span>  </span><span>def </span><span>index\n</span><span>    </span><span>@</span><span>articles </span><span>= policy_scope(</span><span>Article</span><span>).order(</span><span>created_at: :desc</span><span>)\n</span><span>    authorize </span><span>@</span><span>articles\n</span><span>  </span><span>end\n</span><span>end\n</span></code></pre>\n<h2 id=\"extending-policy-with-multiple-roles\">Extending policy with multiple roles</h2>\n<p>In practice, it is quite common to require that the authorization of a particular CRUD action be different for multiple roles. Let's add to our example, say, the role 'supporter'. And now there are articles that can only be viewed by supporter users and admins. We need to create a new 'supporter' role and update our ArticlePolicy as shown below:</p>\n<pre class=\"language-ruby \"><code class=\"language-ruby\"><span>class ArticlePolicy </span><span>&lt; </span><span>ApplicationPolicy\n</span><span>  </span><span># ...\n</span><span>  </span><span>class Scope </span><span>&lt; </span><span>Scope\n</span><span>    </span><span>def </span><span>resolve\n</span><span>      </span><span>if</span><span> user.admin?\n</span><span>        scope.all\n</span><span>      </span><span>elsif</span><span> user.supporter?\n</span><span>        scope.where(</span><span>published: </span><span>true</span><span>)\n</span><span>      </span><span>else\n</span><span>        scope.where(</span><span>published: </span><span>true</span><span>, </span><span>supporter: </span><span>false</span><span>)\n</span><span>      </span><span>end\n</span><span>    </span><span>end\n</span><span>  </span><span>end\n</span><span>\n</span><span>  </span><span># ...\n</span><span>\n</span><span>  </span><span>def </span><span>show?\n</span><span>    </span><span>return</span><span> user.supporter? </span><span>||</span><span> user.admin? </span><span>if</span><span> article.published?\n</span><span>    </span><span>true\n</span><span>  </span><span>end\n</span><span>end\n</span></code></pre>\n<p>Now a normal user can’t view articles for supporters in the index view listings as we are scoping it out. Also we are authorizing the show page as to not allow non-supporter users to see supporter content.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>You have read the basics of authorization with Pundit. If you are looking for decentralized solutions for your Rails application it could be a nice one. Pundit can also be customized deeply to add your own methods or features.</p>\n<p>The policy pattern concept produces big results. Each time you have to deal with simple or complex permissions a policy object could be applied. When it comes to testing, your policies are purely Ruby objects, and your testing will be simple and fast.</p>\n"
}