{
  "title":"Zoom! Enhance!",
  "date":"2022-11-07T15:30:00.000000Z",
  "author":"James Bowen",
  "id":"584219d403596e3099e0ee9b:58462c0e15d5db6feba171c0:6360737595087879b5da3631",
  "link":"https://mmhaskell.com/blog/2022/11/7/zoom-enhance",
  "content":"\n          \n        \n        \n\n        \n          \n            \n          \n            \n              \n            \n          \n        \n          \n        \n\n        \n      \n        \n      \n\n    \n  \n\n\n  \n\n\n\n\nToday we'll be tackling the Day 20 problem from Advent of Code 2021. This problem is a fun take on the Zoom and Enhance cliche from TV dramas where cops and spies can always seem to get unrealistic details from grainy camera footage by &quot;enhancing&quot; it. We'll have a binary image and we'll need to keep applying a decoding key to expand the image.\nAs always, you can see all the nitty gritty details of the code at once by going to the GitHub repository I've made for these problems. If you're enjoying these in-depth walkthroughs, make sure to subscribe so you can stay up to date with the latest news.\nProblem Statement\nOur problem input consists of a couple sections that have &quot;binary&quot; data, where the . character represents 0 and the # character represents 1.\n..#.#..#####.#.#.#.###.##.....###.##.#..###.####..#####..#....#..#..##..##\n#..######.###...####..#..#####..##..#.#####...##.#.#..#.##..#.#......#.###\n.######.###.####...#.##.##..#..#..#####.....#.#....###..#.##......#.....#.\n.#..#..##..#...##.######.####.####.#.#...#.......#..#.#.#...####.##.#.....\n.#..#...##.#.##..#...##.#.##..###.#......#.#.......#.#.#.####.###.##...#..\n...####.#..#..#.##.#....##..#.####....##...##..#...#......#.#.......#.....\n..##..####..#...#.#.#...##..#.#..###..#####........#..####......#..#\n\n#..#.\n#....\n##..#\n..#..\n..###The first part (which actually would appear all on one line) is a 512 character decoding key. Why length 512? Well 512 = 2^9, and we'll see in a second why the ninth power is significant.\nThe second part of the input is a 2D &quot;image&quot;, represented in binary. Our goal is to &quot;enhance&quot; the image using the decoding key. How do we enhance it?\nTo get the new value at a coordinate (x, y), we have to consider the value at that coordinate together with all 8 of its neighbors.\n# . . # .\n#[. . .].\n#[# . .]#\n.[. # .].\n. . # # #The brackets show every pixel that is involved in getting the new value at the &quot;center&quot; of our grid. The way we get the value is to line up these pixels in binary: ...#...#. = 000100010. Then we get the decimal value (34 in this case). This tells us new value comes from the 34th character in the decoder key, which is #. So this middle pixel will be &quot;on&quot; after the first expansion. Since each pixel expansion factors in 9 pixels, there are 2^9 = 512 possible values, hence the length of the decoding key.\nAll transformations happen simultaneously. What is noteworthy is that for &quot;fringe&quot; pixels we must account for the boundary outside the initial image. And in fact, our image then expands into this new region! The enhanced version of our first 5x5 image actually becomes size 7x7.\n.##.##.\n#..#.#.\n##.#..#\n####..#\n.#..##.\n..##..#\n...#.#.For the easy part, we'll do this expansion twice. For the hard part, we'll do it 50 times. Our puzzle answer is the number of pixels that are lit in the final iteration.\nSolution Approach\nAt first glance, this problem is pretty straightforward. It's another &quot;state evolution&quot; problem where we take the problem in an initial state and write a function to evolve that state to the next step. Evolving a single step involves looking at the individual pixels, and applying a fairly simple algorithm to get the resulting pixel.\nThe ever-expanding range of coordinates is a little tricky. But if we use a structure that allows &quot;negative&quot; indices (and Haskell makes this easy!), it's not too bad.\nBut there's one BIG nuance though with how the &quot;infinite&quot; image works. We still have to implicitly imagine that the enhancement algorithm is applying to all the other pixels in &quot;infinite space&quot;. You would hope that, since all those pixels are surrounded by other &quot;off&quot; pixels, they remain &quot;off&quot;.\nHowever, my &quot;hard&quot; puzzle input got a decoding key with # in the 0 position, meaning that &quot;off&quot; pixels surrounded by other &quot;off&quot; pixels all turn on! Luckily, the decoder also has . in the final position, meaning that these pixels turn &quot;off&quot; again on the next step. However, we need to account for this on/off pattern of all these &quot;outside pixels&quot; since they'll affect the pixels on the fringe of our solution.\nTo that end, we'll need to keep track of the value of outer pixels throughout our algorithm - I'll refer to this as the &quot;outside bit&quot;. This will impact every layer of the solution!\nSo with that to look forward to, let's start coding!\nUtilities\nAs always, a few utilities will benefit us. From last week's look at binary numbers, we'll use a couple helpers like the Bit type and a binary-to-decimal conversion function.\ndata Bit = Zero | One\n  deriving (Eq, Ord)\n\nbitsToDecimal64 :: [Bit] -&gt; Word64\nAnother very useful idea is turning a nested list into a hash map. This helps simplify parsing a lot. We saw this function in the Day 11 Octopus Problem.\nhashMapFromNestedLists :: [[a]] -&gt; HashMap Coord2 a\nAnother idea from Day 11 was getting all 8 neighbors of a 2D coordinate. Originally, we did this with (0,0) as a hard lower bound. But we can expand this idea so that the grid bounds of the function are taken as inputs. So getNeighbors8Flex takes two additional coordinate parameters to help provide those bounds for us.\ngetNeighbors8Flex :: Coord2 -&gt; Coord2 -&gt; Coord2 -&gt; [Coord2]\ngetNeighbors8Flex (minRow, minCol) (maxRow, maxCol) (row, col) = catMaybes\n  [maybeUpLeft, maybeUp, maybeUpRight, maybeLeft, maybeRight, maybeDownLeft, maybeDown, maybeDownRight]\n  where\n    maybeUp = if row &gt; minRow then Just (row - 1, col) else Nothing\n    maybeUpRight = if row &gt; minRow &amp;&amp; col &lt; maxCol then Just (row - 1, col + 1) else Nothing\n    maybeRight = if col &lt; maxCol then Just (row, col + 1) else Nothing\n    maybeDownRight = if row &lt; maxRow &amp;&amp; col &lt; maxCol then Just (row + 1, col + 1) else Nothing\n    maybeDown = if row &lt; maxRow then Just (row + 1, col) else Nothing\n    maybeDownLeft = if row &lt; maxRow &amp;&amp; col &gt; minCol then Just (row + 1, col - 1) else Nothing\n    maybeLeft = if col &gt; minCol then Just (row, col - 1) else Nothing\n    maybeUpLeft = if row &gt; minRow &amp;&amp; col &gt; minCol then Just (row - 1, col - 1) else Nothing\nOf particular note is the way we order the results. This ordering (top, then same row, then bottom), will allow us to easily decode our values for this problem.\nAnother detail for this problem is that we'll just want to use &quot;no bounds&quot; on the coordinates with the minimum and maximum integers as the bounds.\ngetNeighbors8Unbounded :: Coord2 -&gt; [Coord2]\ngetNeighbors8Unbounded = getNeighbors8Flex (minBound, minBound) (maxBound, maxBound)\nLast but not least, we'll also rely on this old standby, the countWhere function, to quickly get the occurrence of certain values in a list.\ncountWhere :: (a -&gt; Bool) -&gt; [a] -&gt; Int\nInputs\nLike all Advent of Code problems, we'll start with parsing our input. We need to get everything into bits, but instead of 0 and 1 characters, we're dealing with the character . for off, and # for 1. So we start with a choice parser to get a single pixel.\nparsePixel :: (MonadLogger m) =&gt; ParsecT Void Text m Bit\nparsePixel = choice [char '.' &gt;&gt; return Zero, char '#' &gt;&gt; return One]\nNow we need a couple types to organize our values. The decoder map will tell us a particular bit for every index from 0-511. So we can use a hash map with Word64 as the key.\ntype DecoderMap = HashMap Word64 Bit\nFurthermore, it's easy to see how we build this decoder from a list of bits with a simple zip:\nbuildDecoder :: [Bit] -&gt; DecoderMap\nbuildDecoder input = HM.fromList (zip [0..] input)\nFor the image though, we have 2D data. So let's using a hash map over Coord2 for our ImageMap type:\ntype ImageMap = HashMap Coord2 Bit\nWe have enough tools to start writing our function now. We'll parse an initial series of pixels and build the decoder out of them, followed by a couple eol characters.\nparseInput :: (MonadLogger m) =&gt; ParsecT Void Text m (DecoderMap, ImageMap)\nparseInput = do\n  decoderMap "
}