{
  "title":"Fast Circular Substitution",
  "date":"2022-10-24T17:47:25.000000Z",
  "author":"Edward Kmett",
  "id":"http://comonad.com/reader/?p=956",
  "link":"http://comonad.com/reader/2014/fast-circular-substitution/",
  "content":"Emil Axelsson and Koen Claessen wrote a functional pearl last year about Using Circular Programs for Higher-Order Syntax.\nAbout 6 months ago I had an opportunity to play with this approach in earnest, and realized we can speed it up a great deal. This has kept coming up in conversation ever since, so I've decided to write up an article here.\nIn my bound library I exploit the fact that monads are about substitution to make a monad transformer that manages substitution for me.\nHere I'm going to take a more coupled approach.\nTo have a type system with enough complexity to be worth examining, I'll adapt Dan Doel's UPTS, which is a pure type system with universe polymorphism. I won't finish the implementation here, but from where we get it should be obvious how to finish the job.\n\nUnlike Axelsson and Claessen I'm not going to bother to abstract over my name representation.\nTo avoid losing the original name from the source, we'll just track names as strings with an integer counting the number of times it has been 'primed'. The name is purely for expository purposes, the real variable identifier is the number. We'll follow the Axelsson and Claessen convention of having the identifier assigned to each binder be larger than any one bound inside of it. If you don't need he original source names you can cull them from the representation, but they can be useful if you are representing a syntax tree for something you parsed and/or that you plan to pretty print later.\n \ndata Name = Name String Int\n   deriving (Show,Read)\n \nhint :: Name -&gt; String\nhint (Name n _) = n\n \nnameId :: Name -&gt; Int\nnameId (Name _ i) = i\n \ninstance Eq Name where\n  (==) = (==) `on` nameId\n \ninstance Ord Name where\n  compare = compare `on` nameId\n \nprime :: String -&gt; Int -&gt; Name\nprime n i = Name n (i + 1)\n \nSo what is the language I want to work with?\n \ntype Level = Int\n \ndata Constant\n  = Level\n  | LevelLiteral {-# UNPACK #-} !Level\n  | Omega\n  deriving (Eq,Ord,Show,Read,Typeable)\n \ndata Term a\n  = Free a\n  | Bound {-# UNPACK #-} !Name\n  | Constant !Constant\n  | Term a :+ {-# UNPACK #-} !Level\n  | Max  [Term a]\n  | Type !(Term a)\n  | Lam   {-# UNPACK #-} !Name !(Term a) !(Term a)\n  | Pi    {-# UNPACK #-} !Name !(Term a) !(Term a)\n  | Sigma {-# UNPACK #-} !Name !(Term a) !(Term a)\n  | App !(Term a) !(Term a)\n  | Fst !(Term a)\n  | Snd !(Term a)\n  | Pair !(Term a) !(Term a) !(Term a)\n  deriving (Show,Read,Eq,Ord,Functor,Foldable,Traversable,Typeable)\n \nThat is perhaps a bit paranoid about remaining strict, but it seemed like a good idea at the time.\nWe can define capture avoiding substitution on terms:\n \nsubst :: Eq a =&gt; a -&gt; Term a -&gt; Term a -&gt; Term a\nsubst a x y = y &gt;&gt;= \\a' -&gt;\n  if a == a'\n    then x\n    else return a'\n \nNow we finally need to implement Axelsson and Claessen's circular programming trick. Here we'll abstract over terms that allow us to find the highest bound value within them:\n \nclass Bindable t where\n  bound :: t -&gt; Int\n \nand instantiate it for our Term type\n \ninstance Bindable (Term a) where\n  bound Free{}        = 0\n  bound Bound{}       = 0 -- intentional!\n  bound Constant{}    = 0\n  bound (a :+ _)      = bound a\n  bound (Max xs)      = foldr (\\a r -&gt; bound a `max` r) 0 xs\n  bound (Type t)      = bound t\n  bound (Lam b t _)   = nameId b `max` bound t\n  bound (Pi b t _)    = nameId b `max` bound t\n  bound (Sigma b t _) = nameId b `max` bound t\n  bound (App x y)     = bound x `max`  bound y\n  bound (Fst t)       = bound t\n  bound (Snd t)       = bound t\n  bound (Pair t x y)  = bound t `max` bound x `max` bound y\n \nAs in the original pearl we avoid traversing into the body of the binders, hence the _'s in the code above.\nNow we can abstract over the pattern used to create a binder in the functional pearl, since we have multiple binder types in this syntax tree, and the code would get repetitive.\n \nbinder :: Bindable t =&gt;\n  (Name -&gt; t) -&gt;\n  (Name -&gt; t -&gt; r) -&gt;\n  String -&gt; (t -&gt; t) -&gt; r\nbinder bd c n e = c b body where\n  body = e (bd b)\n  b = prime n (bound body)\n \nlam, pi, sigma :: String -&gt; Term a -&gt; (Term a -&gt; Term a) -&gt; Term a\nlam s t   = binder Bound (`Lam` t) s\npi s t    = binder Bound (`Pi` t) s\nsigma s t = binder Bound (`Sigma` t) s\n \nWe may not always want to give names to the variables we capture, so let's define:\nlam_, pi_, sigma_ :: Term a -&gt; (Term a -&gt; Term a) -&gt; Term a\nlam_   = lam &quot;_&quot;\npi_    = pi &quot;_&quot;\nsigma_ = sigma &quot;_&quot;\n\nNow, here's the interesting part. The problem with Axelsson and Claessen's original trick is that every substitution is being handled separately. This means that if you were to write a monad for doing substitution with it, it'd actually be quite slow. You have to walk the syntax tree over and over and over.\nWe can fuse these together by making a single pass:\n \ninstantiate :: Name -&gt; t -&gt; IntMap t -&gt; IntMap t\ninstantiate = IntMap.insert . nameId\n \nrebind :: IntMap (Term b) -&gt; Term a -&gt; (a -&gt; Term b) -&gt; Term b\nrebind env xs0 f = go xs0 where\n  go = \\case\n    Free a       -&gt; f a\n    Bound b      -&gt; env IntMap.! nameId b\n    Constant c   -&gt; Constant c\n    m :+ n       -&gt; go m :+ n\n    Type t       -&gt; Type (go t)\n    Max xs       -&gt; Max (fmap go xs)\n    Lam b t e    -&gt; lam   (hint b) (go t) $ \\v -&gt;\n      rebind (instantiate b v env) e f\n    Pi b t e     -&gt; pi    (hint b) (go t) $ \\v -&gt;\n      rebind (instantiate b v env) e f\n    Sigma b t e  -&gt; sigma (hint b) (go t) $ \\v -&gt;\n      rebind (instantiate b v env) e f\n    App x y      -&gt; App (go x) (go y)\n    Fst x        -&gt; Fst (go x)\n    Snd x        -&gt; Snd (go x)\n    Pair t x y   -&gt; Pair (go t) (go x) (go y)\n \nNote that the Lam, Pi and Sigma cases just extend the current environment.\nWith that now we can upgrade the pearl's encoding to allow for an actual Monad in the same sense as bound.\n \ninstance Applicative Term where\n  pure = Free\n  (&lt; *&gt;) = ap\n \ninstance Monad Term where\n  return = Free\n  (&gt;&gt;=) = rebind IntMap.empty\n \nTo show that we can work with this syntax tree representation, let's write an evaluator from it to weak head normal form:\nFirst we'll need some helpers:\n \napply :: Term a -&gt; [Term a] -&gt; Term a\napply = foldl App\n \nrwhnf :: IntMap (Term a) -&gt;\n  [Term a] -&gt; Term a -&gt; Term a\nrwhnf env stk     (App f x)\n  = rwhnf env (rebind env x Free:stk) f\nrwhnf env (x:stk) (Lam b _ e)\n  = rwhnf (instantiate b x env) stk e\nrwhnf env stk (Fst e)\n  = case rwhnf env [] e of\n  Pair _ e' _ -&gt; rwhnf env stk e'\n  e'          -&gt; Fst e'\nrwhnf env stk (Snd e)\n  = case rwhnf env [] e of\n  Pair _ _ e' -&gt; rwhnf env stk e'\n  e'          -&gt; Snd e'\nrwhnf env stk e\n  = apply (rebind env e Free) stk\n \nThen we can start off the whnf by calling our helper with an initial starting environment:\n \nwhnf :: Term a -&gt; Term a\nwhnf = rwhnf IntMap.empty []\n \nSo what have we given up? Well, bound automatically lets you compare terms for alpha equivalence by quotienting out the placement of &quot;F&quot; terms in the syntax tree. Here we have a problem in that the identifiers we get assigned aren't necessarily canonical.\nBut we can get the same identifiers out by just using the monad above:\n \nalphaEq :: Eq a =&gt; Term a -&gt; Term a -&gt; Bool\nalphaEq = (==) `on` liftM id\n \nIt makes me a bit uncomfortable that our monad is only up to alpha equivalence and that liftM swaps out the identifiers used throughout the entire syntax tree, and we've also lost the ironclad protection against exotic terms.\nBut overall, this is a much faster version of Axelsson and Claessen's trick and it can be used as a drop-in replacement for something like bound in many cases, and unlike bound, it lets you use HOAS-style syntax for constructing lam, pi and sigma terms.\nWith pattern synonyms you can prevent the user from doing bad things as well. Once 7.10 ships you'd be able to use a bidirectional pattern synonym for Pi, Sigma and Lam to hide the real constructors behind. I'm not yet sure of the &quot;best practices&quot; in this area.\nHere's the code all in one place:\n[Download Circular.hs]\nHappy Holidays,\n-Edward\n    "
}