{
  "title":"Staged programming with typeclasses",
  "date":"2022-11-15T00:00:00.000000Z",
  "author":null,
  "id":"https://tweag.io/blog/2022-11-15-unrolling-with-typeclasses/",
  "link":"https://tweag.io/blog/2022-11-15-unrolling-with-typeclasses/",
  "content":"Staged programming consists of evaluating parts of a program at compile time\nfor greater efficiency at runtime, as some computations would have already been\nexecuted or made more efficient during compilation. The poster child for\nstaged programming is the exponential function: to compute a^b, if b is\nknown at compile time, a^b can be replaced by b explicit\nmultiplications. Staged programming allows you to write\na^5, but have the expression compile to a*a*a*a*a.\nIn Haskell, the traditional way to do staged programming is to\nreach for Template Haskell. Template Haskell\nis, after all, designed for this purpose and gives you strong\nguarantees that the produced code is indeed a*a*a*a*a, as\ndesired. On the other hand it does feel a little heavyweight and\nprogrammers, in practice, tend to avoid exposing Template Haskell in\ntheir interfaces.\nIn this blog post, I want to present another way to do staged programming that\nis more lightweight, and feels more like a native Haskell solution, but, in\nexchange, offers fewer guarantees. At its core, what is needed for staged\nprogramming is to distinguish between what is statically known and what is\ndynamically known. In Template Haskell, static and dynamic information is\nclassified by whether an expression is within a quotation or not. But there is\nanother way to signal statically-known information in Haskell: types.\nThis is what we are going to do in this blog post: passing\nstatically-known arguments at the type level. I’ve\nused this technique in linear-base.\nNatural numbers at the type level\nHaskell offers a native kind Nat of type-level natural numbers. We\ncould pass the (statically known) exponent as Nat, in fact we\neventually will, but it is difficult to consume numbers of kind Nat\nbecause GHC doesn’t know enough about them (for instance, GHC doesn’t\nknow that n+1 is equivalent to 1+n).\nInstead, we will use an inductive encoding of the natural numbers:\nthe Peano encoding.\ndata Peano\n  = Z         -- zero\n  | S Peano   -- successor of another peano number\nIn this encoding, 3 is written S (S (S Z)).\nNormally, Peano would live at the type level, and both Z and S would\nlive at the term level (they’re data constructors after all). But thanks to\nthe DataKinds extension – which allows data constructors to be promoted to\ntypes – we can also use Peano as the kind of type-level Z and S.\nNow let’s return to the power function. We will first create a typeclass\nRecurseOnPeano, that will contain the power function (and that could host\nany other recursive metaprogramming function that operates on Peanos):\nclass RecurseOnPeano (n :: Peano) where\n  power :: Int -&gt; Int\nThe power function only needs one term-level parameter: the number that will\nbe multiplied by itself n times. Indeed, the exponent is already “supplied”\nas a type-level parameter n. In fact, the signature of the power function\noutside the typeclass would be:\npower :: forall (n :: Peano). RecurseOnPeano n =&gt; Int -&gt; Int\nAt a call site, the type-level parameter n will be supplied to the function\nthrough a type application, using the dedicated @ symbol (e.g.\npower @(S (S Z)) 4). It isn’t possible to omit the type parameter n at a\ncall site because there is no way for GHC to deduce it from the type of a\nterm-level parameter of the function. So we need to enable the\nAllowAmbiguousTypes extension.\nThe implementation of the power function will be defined through two\ninstances of the RecurseOnPeano typeclass – one for the base case (n = Z),\nand one for the recursive case (n = S n') – as one would do in a term-level\nrecursive function.\nThe first instance is relatively straightforward as x^0 = 1 for every\npositive integer x:\ninstance RecurseOnPeano Z where\n  power _ = 1\nFor the second instance we want to write power @(S n) x = x * power @n x. But\nto use power @n x, n needs to fulfill the RecurseOnPeano constraint too.\nIn the end, that yields:\ninstance RecurseOnPeano n =&gt; RecurseOnPeano (S n) where\n  power x = x * power @n x\nWe now have a first working example:\n-- &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; file CompileRecurse.hs &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n\n{-# LANGUAGE KindSignatures #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE ScopedTypeVariables  #-}\n{-# LANGUAGE AllowAmbiguousTypes #-}\nmodule CompileRecurse where\nimport GHC.TypeLits\n\ndata Peano = Z | S Peano\n\nclass RecurseOnPeano (n :: Peano) where\n  power :: Int -&gt; Int\n\ninstance RecurseOnPeano Z where\n  power _ = 1\n  {-# INLINE power #-}\ninstance RecurseOnPeano n =&gt; RecurseOnPeano (S n) where\n  power x = x * power @n x\n  {-# INLINE power #-}\n\n-- &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; file Main.hs &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE DataKinds #-}\nmodule Main where\nimport CompileRecurse\n\nmain :: IO ()\nmain = print $ power @(S (S (S Z))) 2  -- this should print 8\nMany languages extensions are required for this example to work:\n\nKindSignatures permits the syntax (n :: Peano) to restrict the\nRecurseOnPeano class to types of the Peano kind.\nTypeApplications gives the @type syntax to supply type-level parameters.\nDataKinds allows us to promote the Peano data type to the kind level.\nScopedTypeVariables is needed to be able to refer to n in the body of\npower in the second instance of RecurseOnPeano.\nAllowAmbiguousTypes is needed when we declare a typeclass function in\nwhich the term-level parameters (if there are any) are not sufficient to\ninfer the type-level parameters (and thus require an explicit type\napplication at the call site).\n\nI also added {-# INLINE #-} pragmas on the power implementations, because\nwe indeed want GHC to inline these to achieve our initial goal. For such a\nsimple example, GHC would inline them by default, but it’s better to be\nexplicit about our intent here.\nYou can now validate that the power @(S (S (S Z))) 2 encoding for 2^3\nindeed prints 8 on the terminal.\nFrom Peano type-level integers to GHC Nats\nWriting S (S (S Z)) is not very convenient. We would definitely prefer to\nwrite 3 instead. And that is possible, if we allow a bit more complexity in\nour code.\nNumber literals, such as 3, when used at the type level are of kind Nat\nfrom GHC.TypeLits.\nUnfortunately, if we completely replace our home-made Peanos with GHC Nats,\nwe will run into some issues of overlapping instances in the RecurseOnPeano\ntypeclass.1\nA solution can be found by using the {-# OVERLAPPING #-} and\n{-# OVERLAPPABLE #-} pragmas, but it is quite fragile: instance selection is\nno longer driven by types or structure but rather by a manual override. And\nthe rules for such an override are rather complex,\nespecially when more than two instances are involved; in the case at hand, we\nmight want to add a third instance with a specific implementation for n = 1.\nInstead, we will add a type family (that is, a function from types to types) to\nconvert from Nats to Peanos, and add an auxiliary function power' that\nwill take a type-level Nat instead of a type-level Peano:\n-- &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; add to file CompileRecurse.hs &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n\n{-# LANGUAGE TypeOperators #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE UndecidableInstances #-}\n{-# LANGUAGE FlexibleContexts #-}\n\ntype family NatToPeano n where\n  NatToPeano 0 = Z\n  NatToPeano n = S (NatToPeano (n - 1))\n\n-- 'RecurseOnPeano (NatToPeano n) =&gt;' means that the ¨Peano equivalent of n\n-- must be an instance of RecurseOnPeano to get access to 'power'\npower' :: forall (n :: Nat). (RecurseOnPeano (NatToPeano n)) =&gt; Int -&gt; Int\npower' = power @(NatToPeano n)\n\n-- &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; change in file Main.hs &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\n\nmain = print $ power' @3 2  -- this should still print 8\nOur function is still working as expected, and is now more convenient to use!\nA look under the hood\nOur initial goal was to unroll the power' function at compile\ntime. Let’s check whether this promise holds.\nWe will create a new test file test/CompileRecurseTests.hs and set specific\nGHC options so that we can take a look at the generated Core2 code for our\nproject:\n{-# OPTIONS_GHC -O -ddump-simpl -dsuppress-all -dsuppress-uniques -ddump-to-file #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE DataKinds #-}\nmodule Main where\n\nimport CompileRecurse\n\nmyFunc :: Int -&gt; Int\nmyFunc x = power' @3 x + 1\n\nmain :: IO ()\nmain = return ()\nThe following GHC flags are used:\n\n-O enables optimizations in GHC.\n-ddump-simpl requests the Core code after the output of the simplifier.\n-dsuppress-all and -dsuppress-uniques reduce the verbosity of the output\n(otherwise, searching for a specific piece of code would become very\ntedious).\nFinally, -ddump-to-file asks for the output to be written to a file in the\nbuild directory.\n\nWith the above options, compiling and running the test suite creates a\nfile CompileRecurseTests.dump-simpl deep down in the build tree.3\nIf we ignore all the lines about $trModule, we get:\n-- RHS size: {terms: 12, types: 3, coercions: 0, joins: 0/0}\nmyFunc\n  = \\ x -&gt; case x of { I# x1 -&gt; I# (+# (*# x1 (*# x1 x1)) 1#) }\nI# is the “boxing” constructor for integers, that is, the one taking an\nunboxed integer (Int#) and creating a Haskell Int (an integer behind a\npointer). +# and *# are the equivalent of arithmetic functions + and *\nfor unboxed integers Int#.\nWe can see that myFunc\n\ntakes an Int,\nunboxes its value,\nmakes the 2 product operations corresponding to the inlined power' @3 x,\nadds 1, and finally,\nboxes the result once again to produce an Int.\n\nThere is no mention of power' here, so the function has been successfully\ninlined!\nInspection testing\nChecking manually whether or not the inlining has happened – by looking\nthrough the .dump-simpl file after every change – is really impractical.\nInstead, it is possible to use the inspection-testing\nand tasty-inspection-testing libraries to\nautomate such a process.\nTo do this, we simply need to introduce a function myFunc' – corresponding to\nwhat we expect to be the optimized and inlined form of myFunc – and then we\ncheck that both myFunc and myFunc' result in the same generated Core code\nby using the specific === comparison operator (and a little bit of Template\nHaskell too):\n{-# OPTIONS_GHC -O -dno-suppress-type-signatures -fplugin=Test.Tasty.Inspection.Plugin #-}\n{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE TemplateHaskell #-}\n\nmodule Main where\n\nimport Test.Tasty\nimport Test.Tasty.Inspection\nimport CompileRecurse\n\nmyFunc :: Int -&gt; Int\nmyFunc x = power' @3 x + 1\n\nmyFunc' :: Int -&gt; Int\nmyFunc' x = x * (x * x) + 1\n\nmain :: IO ()\nmain = defaultMain . testGroup &quot;Inspection testing of power'&quot; $\n  [ $(inspectTest $ 'myFunc === 'myFunc') ]\nRunning the test suite gives:\nInspection testing of power'\n  myFunc === myFunc': OK\n\nAll 1 tests passed (0.01s)\nIf both functions didn’t result in the same generated Core code – e.g. if we\nwrote (x * x) * x + 1 instead of x * (x * x) + 1 in myFunc' – we would\nget:\nInspection testing of power'\n  myFunc === myFunc': FAIL\n    LHS:\n        [ ... ]\n        myFunc\n          = \\ (x [Dmd=&lt;,1*U(U)&gt;] :: Int) -&gt;\n              case x of { I# x1 -&gt; I# (+# (*# x1 (*# x1 x1)) 1#) }\n    RHS:\n        [ ... ]\n        myFunc'\n          = \\ (x [Dmd=&lt;,1*U(U)&gt;] :: Int) -&gt;\n              case x of { I# x -&gt; I# (+# (*# (*# x x) x) 1#) }\n\n1 out of 1 tests failed (0.01s)\ntypeclass-blogpost&gt; Test suite inspection-tests failed\nIn this way, the correct inlining of power' can be checked automatically\nafter each change to the codebase!\nConclusion\nThis was a brief introduction to staged programming in Haskell, leveraging the\ntype (and typeclass) system as a lightweight alternative to Template Haskell.\nThe technique detailed in this article has been implemented in real-world\ncontexts to create variadic functions like printf,\nand I hope that you will find many other useful applications for it!\nI would like to give a special thank you to Arnaud Spiwack who both taught me\nthis technique in the first place, and then helped me to greatly improve this blog\npost.\n\n\n\n\n\nIn short, this is because GHC can’t distinguish between the base and\nrecursive instances with Nats as easily as it can with Peanos↩\nCore is the main intermediate language used inside GHC.↩\nIn my case, the full path was:\n.stack-work/dist/x86_64-linux-nix/Cabal-3.4.1.0/build/compile-recurse-tests/compile-recurse-tests-tmp/test/CompileRecurseTests.dump-simpl.↩\n\n\n    "
}