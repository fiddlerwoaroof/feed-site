{
  "title":"Recompilation avoidance in rules_haskell",
  "date":"2022-11-03T00:00:00.000000Z",
  "author":null,
  "id":"https://tweag.io/blog/2022-11-03-blog_recompilation/",
  "link":"https://tweag.io/blog/2022-11-03-blog_recompilation/",
  "content":"When one is programming, they may compile the same project dozens of times per day,\noften after making only small modifications.\nRecompiling all the modules each time would be extremely time-consuming and disrupt the programmer’s workflow.\nTherefore, build tools are careful to avoid recompiling files if they\nknow the result would be identical to what is already built. This is\nsometimes called recompilation avoidance.\nBazel is an open-source tool to build and test projects.\nIt is particularly well-suited for multilingual monorepos. As such,\nBazel has a strategy for recompilation avoidance.\nBazel tracks the inputs and outputs of build actions precisely in\norder to decide what files need to be recompiled after a change.\nThe exact mechanism is out of scope for this article, but well described in this blog series.\nThe simplified version is: Bazel will only rerun an action if it hasn’t been run with the same inputs before.\nOne could think that, since Bazel provides such a mechanism to prevent superfluous recompilation,\nthen developers of Bazel rules would\nnot have to worry about recompilation avoidance.\nWell, the story in this blog post would be quite uninteresting if things were so simple.\nIn this blog post I explain how I improved recompilation avoidance in\nrules_haskell, a Bazel rule set to build Haskell code.\nWhen GHC compiles a Haskell module,\nit needs the source code of the module and the interface files of all its dependencies1.\nHence, those files are given as inputs to the Bazel actions compiling a Haskell module.\nSince the interface file of a module contains all its dependencies hashes,\nany modification would trigger the recompilation of all the modules transitively depending on it.\nThat was the case in version 0.15 of rules_haskell, before the improvements discussed here.\nHow GHC deals with recompilation avoidance\nWhen compiling a module (A.hs), in addition to the object file (A.o),\nGHC generates an interface file (A.hi).\nThis file is used for sharing inter-module information that would otherwise be difficult to extract from a compiled object file.\nThese files contain various information, useful in different contexts, including:\n\nThe list of symbols it exports, including the type of all symbols and the hash of their implementation,\nImplementations of inlinable functions,\nThe list of modules and external packages it depends on,\nThe list of orphan instances.\n\nThis file is used to determine if a module which depends on A should be recompiled after A.hs has been modified.\nHowever, to determine if recompilation is required,\nnot all the information mentioned is useful.\nFor instance, the list of packages a module depends on\nis not relevant information when determining if its dependency should be recompiled.\nSimilarly, the precise implementation of functions only matters if the module is compiled with inlining turned on.\nThe relevant bits for the recompilation avoidance mechanism are summarised in an ABI (Application Binary Interface) hash, as explained in the GHC Wiki:\n\nWhen considering whether or not a module’s dependent modules need to be recompiled due to changes in the current module,\na changed ABI hash is a necessary but not sufficient condition for recompilation2.\n\nExample\nTo illustrate the mechanism, let us consider 3 simple files:\n\n\nmodule A (const, change_T0, T, not_imported) where\n\ndata T = T0 | T1\n\nnot_imported :: T\nnot_imported = T1\n\nconst :: a -&gt; b -&gt; a\nconst x y = x\n\nchange_T0 :: T -&gt; T\nchange_T0 T0 = not_imported\nchange_T0 T1 = T1\nmodule B where\n\nimport A (const, change_T0, T)\n\naux :: A.T -&gt; A.T\naux x = A.const (A.change_T0 x) x\n\nconst3 :: a -&gt; a -&gt; a -&gt; a\nconst3 x y = A.const (A.const x) (A.const y)\nmodule C where\n\nimport qualified B\n\ndata N = Z | S N\n\nconst_bis :: a -&gt; a -&gt; a\nconst_bis x = B.const3 x x\n\nThere are many changes one can make to A.hs which would change the interface file B.hi,\nbut do not affect the ABI hash of B, thus avoiding triggering the recompilation of C.hs.\nChanging the export list of A:\n- module A (const, change_T0, T, not_imported) where\n+ module A (const, change_T0, T) where\nMark a function as always being inlined:\n+ {-# INLINE const #-}\nconst :: a -&gt; b -&gt; a\nThese 2 changes affect the exports of module A,\nhence the ABI hash of A is affected.\nHowever, these changes only impact the imports of B,\nso the section on dependencies of B.hi is modified,\nbut not the ABI hash, which only hashes the exports and declarations of B.\nModify the import list of B:\n- import A (const, change_T0, T)\n+ import A (const, change_T0, T, not_imported)\nModifying the import list of B simply adds one symbol to the section regarding its imports,\nbut does not affect the part on exports, hence does not modify the ABI hash.\nIf B.hs is compiled without exposing the unfoldings of the symbols it declares3,\nthen one could make more modifications to the code, without modifying the ABI hash of B.\nOne can not only change the definiton of a function of A, but also change its type:\n- const :: a -&gt; b -&gt; a\n- const x y = x\n+ const :: a -&gt; b -&gt; b\n+ const x y = y\nModifying the type of A.const changes the ABI of A, no matter if A.hs was compiled with unfoldings exposed or not.\nThen the modifications to B are limited to its import and the implementation of functions,\nbut since no types in B are affected, if the unfoldings of B are not exposed,\nthen the ABI hash of B remains the same.\nOne can also modify the definition of a symbol in B (but not its type):\n- const3 x y = A.const (A.const x) (A.const y)\n+ const3 x y = id\nAll those modifications affect the part of the interface file of B regarding imports, hence it changes B.hi.\nSo, with version 0.15 of rules_haskell, C, which depends on B, would have been recompiled.\nHowever, those changes do not impact the ABI stored in B.hi,\nHence C is not recompiled, when using ghc --make or the most recent version of rules_haskell,\nsince it is not impacted by those changes.\nMimicking this behaviour\nNow that we have understood the mechanism used by GHC to decide if recompilation is required,\nwe want to teach Bazel to use it.\nABI files\nSince the relevant information to know if recompilation is required is the ABI hash nested inside the interface file,\nand files are the unit considered by Bazel to detect modifications,\none has to first extract this hash and put it in its own file.\nThe strategy chosen for this is to first generate the human-readable version of the interface file\n(using ghc --show-iface A.hi) and then store only the line containing the ABI hash into a file A.abi.\nTweak the caching mechanism with unused_inputs_list\nThis new file A.abi is then added to the list of inputs required to compile the modules importing A.\nHowever, it cannot completely replace the A.hi file,\nsince whenever the modification of A.hs is important enough to affect the ABI hash,\nthe whole interface file is required by GHC to compile the other modules.\nAs Bazel’s caching mechanism inspects all the inputs to know if the recompilation rule should be executed,\nadding a new file to the list of inputs can only cause recompilation to occur more often than in the previous state.\nThis is exactly the opposite of our goal,\nhence we have to somehow teach Bazel to not inspect all the inputs when deciding if a “target” should be regenerated.\nFortunately, there is a mechanism in Bazel which has exactly this effect:\ndeclaring some inputs as “unused”.\nWhen an input occurs in the unused_inputs_list,\nit is not considered in the set of inputs used to decide if regeneration of a target is required.\nHence declaring all the interface files as “unused inputs” allows us to instruct the Bazel caching mechanism not to inspect the interface files,\nbut only the associated ABI files4, when deciding which targets to regenerate.\nFurthermore, since the interface files are still in the input list,\nwhen recompilation is needed Bazel will use them,\ndespite us tagging them as “unused”.\nIt must be noted that Bazel documentation on unused_inputs_list is pretty light,\nbut mentions that “Any change in those files must not affect in any way the outputs of the action”.\nHence, the non-consideration of the inputs listed in this field when computing the hash for caching is quite expected.\nHowever, it is not clear from the documentation that Bazel can use those inputs when recompiling.\nBenchmark\nI tested this feature on Symbiont’s code base, where I modified a file which was a leaf in the dependency graph,\nwhere I added a dummy field to a record.\nThis change seemed fitting to me, since modifying a record type very\ndeep in the dependency tree affected a lot of modules transitively,\nbut not all actually need recompiling. This makes the benchmark long\nenough to observe an improvement.\nResults\n\n\nWhen running bazel build with the version 0.15 of rules_haskell (using the haskell_module, but not the ABI files): \n153 targets built in 7min 38\n\n\nWhen running bazel build with the new version of rules_haskell:\n131 targets built in 6min 41\n\n\nThis looks like a non-negligible enhancement.\nHowever, it is hard to say more without a reference.\nHence I also built the project with stack,\na widely used build system in the Haskell ecosystem:\n\nWhen running stack build --no-run-tests:\n125 modules compiled in 6min 07\n\nWe can see that our enhancement correctly avoided 22 of the 26 avoidable recompilation targets;\nan accuracy of 80%.\nIt is not on par with tools using the native recompilation avoidance mechanism of GHC (like stack)\nbecause there are more criteria used by GHC than just a change of the ABI hash, which is only a necessary condition.\nMore on the precise condition used by GHC can be found in the GHC Wiki and\nan example of unnecessary recompilation despite a change in the ABI hash of a dependency was sent to the Haskell mailing list\nClosing Remarks\nThis project was possible thanks to the generous funding from Symbiont.\nCurrently, the optimisation presented in this post is only applied to modules built using haskell_modules.\nIn this post, I presented a technique to declare some inputs as “irrelevant” when Bazel decides if recompilation is required,\napplied to the specific case of the GHC compiler.\nSince this problem seems quite common (recompilation avoidance is a problem that every language has),\nI expect it to find other applications soon.\nEspecially, I hope this post to raise awareness in the Bazel community about how useful “irrelevant for caching” inputs are,\nand would lead to a clarification of the purpose of unused_inputs_list.\n\n\n\n\nIf the module uses Template Haskell or a plugin,\nthis is not sufficient, as explained in next footnote.↩\nThis does not apply if the importing modules use Template Haskell or a plugin,\nsince in this case the result of compiling a module can depend on the implementation of imported modules,\nnot just their interfaces.\nIn both cases, to decide if a recompilation should be performed,\nGHC simply relies on the hash of the generated object file rather than just the interface file.↩\nUnfoldings of functions defined in a module X are exposed to the other modules\nif optimisations are turned on (using ghc -O) and the compiler decides that they should be included in the interface file\n(either because the definition is quite short and might be useful to enable further optimisations,\nor because the programmer added a pragma regarding inlining).↩\nEven if the target module uses Template Haskell or a plugin,\nit is safe to hide the interface files from Bazel’s caching mechanism.\nAs mentioned in previous notes, in those cases, it could happen that recompilation is required whereas no ABI hash changed.\nBut the object files of all the modules it depends on is given as input to the Bazel rule compiling this kind of module.\nHence any modification affecting an object file will trigger recompilation,\nno matter its impact on the ABI hash.↩\n\n\n    "
}