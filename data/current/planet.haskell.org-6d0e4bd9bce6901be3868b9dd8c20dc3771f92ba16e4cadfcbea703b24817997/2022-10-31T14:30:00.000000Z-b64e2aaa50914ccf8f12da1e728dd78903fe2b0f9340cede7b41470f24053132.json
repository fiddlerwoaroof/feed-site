{
  "title":"Binary Packet Parsing",
  "date":"2022-10-31T14:30:00.000000Z",
  "author":"James Bowen",
  "id":"584219d403596e3099e0ee9b:58462c0e15d5db6feba171c0:635b6a2d227cca7a1354a637",
  "link":"https://mmhaskell.com/blog/2022/10/31/binary-packet-parsing",
  "content":"Today we're back with a new problem walkthrough, this time from Day 16 of last year's Advent of Code. In some sense, the parsing section for this problem is very easy - there's not much data to read from the file. In another sense, it's actually rather hard! This problem is about parsing a binary format, similar in some sense to how network packets work. It's a good exercise in handling a few different kinds of recursive cases.\nAs with the previous parts of this series, you can take a look at the code on GitHub here. This problem also has quite a few utilities, so you can observe those as well. This article is a deep-dive code walkthrough, so having the code handy to look at might be a good idea!\nProblem Description\nFor this problem, we're decoding a binary packet. The packet is initially given as a hexadecimal string.\nA0016C880162017C3686B18A3D4780But we'll turn it into binary and start working strictly with ones and zeros. However, the decoding process gets complicated because the packet is structured in a recursive way. But let's go over some of the rules.\nPacket Header\nEvery packet has a six-bit header. The first three bits give a &quot;version number&quot; for the packet. The next three bits give a &quot;type ID&quot;. That part's easy.\nThen there are a series of rules about the rest of the information in the packet.\nLiterals\nIf the type ID is 4, the packet is a &quot;literal&quot;. We then parse the remainder of the packet in 5-bit chunks. The first bit tells us if it is the last chunk of the packet (0 means yes, 1 means there are more chunks). The four other bits in the chunk are used to construct the binary number that forms the &quot;value&quot; of the literal. The more chunks, the higher the number can be.\nOperator Sizes\nPackets that aren't literals are operators. This means they contain a variable number of subpackets.\nOperators have one bit (after the 6-bit header) giving a &quot;length&quot; type. A length type of &quot;1&quot; tells us that the following 11 bits give the number of subpackets. If the length bit is &quot;0&quot;, then the next 15 bits give the length of all the subpackets in bits.\nThe Packet Structure\nWe'll see how these work out as we parse them. But with this structure in mind, one thing we can immediately do is come up with a recursive data type for a packet. I ended up calling this PacketNode since I thought of each as a node in a tree. It's pretty easy to see how to do this. We start with a base constructor for a Literal packet that only stores the version and the packet value. Then we just add an Operator constructor that will have a list of subpackets as well as a field for the operator type.\ndata PacketNode =\n  Literal Word8 Word64 |\n  Operator Word8 Word8 [PacketNode]\n  deriving (Show)\nOnce we've parsed the packet, the &quot;questions to answer&quot; are, for the easy part, to take the sum of all the packet versions in our packet, and then to actually calculate the packet value recursively for the hard part. When we get to that part, we'll see how we use the operators to determine the value.\nSolution Approach\nThe initial &quot;parsing&quot; part of this problem is actually quite easy. But we can observe that even after we have our binary values, it's still a parsing problem! We'll have an easy enough time answering the question once we've parsed our input into a PacketNode. So the core of the problem is parsing the ones and zeros into our PacketNode.\nSince this is a parsing problem, we can actually use Megaparsec for the second part, instead of only for getting the input out of the file. Here's a possible signature for our core function:\n-- More on this type later\ndata Bit = One | Zero\n\nparsePacketNode :: (MonadLogger m) =&gt; ParsecT Void [Bit] m PacketNode\nWhereas we normally use Text as the second type parameter to ParsecT, we can also use any list type, and the library will know what to do! With this function, we'll eventually be able to break our solution into its different parts. But first, we should start with some useful helpers for all our binary parsing.\nBinary Utilities\nBinary logic comes up fairly often in Advent of Code, and there are quite a few different utilities we would want to use with these ones and zeros. We start with a data type to represent a single bit. For maximum efficiency, we'd want to use a BitVector, but we aren't too worried about that. So we'll make a simple type with two constructors.\ndata Bit = Zero | One\n  deriving (Eq, Ord)\n\ninstance Show Bit where\n  show Zero = &quot;0&quot;\n  show One = &quot;1&quot;\nOur first order of business is turning a hexadecimal character into a list of bits. Hexadecimal numbers encapsulate 4 bits. So, for example, 0 should be [Zero, Zero, Zero, Zero], 1 should be [Zero, Zero, Zero, One], and F should be [One, One, One, One]. This is a simple pattern match, but we'll also have a failure case.\nparseHexChar :: (MonadLogger m) =&gt; Char -&gt; MaybeT m [Bit]\nparseHexChar '0' = return [Zero, Zero, Zero, Zero]\nparseHexChar '1' = return [Zero, Zero, Zero, One]\nparseHexChar '2' = return [Zero, Zero, One, Zero]\nparseHexChar '3' = return [Zero, Zero, One, One]\nparseHexChar '4' = return [Zero, One, Zero, Zero]\nparseHexChar '5' = return [Zero, One, Zero, One]\nparseHexChar '6' = return [Zero, One, One, Zero]\nparseHexChar '7' = return [Zero, One, One, One]\nparseHexChar '8' = return [One, Zero, Zero, Zero]\nparseHexChar '9' = return [One, Zero, Zero, One]\nparseHexChar 'A' = return [One, Zero, One, Zero]\nparseHexChar 'B' = return [One, Zero, One, One]\nparseHexChar 'C' = return [One, One, Zero, Zero]\nparseHexChar 'D' = return [One, One, Zero, One]\nparseHexChar 'E' = return [One, One, One, Zero]\nparseHexChar 'F' = return [One, One, One, One]\nparseHexChar c = logErrorN (&quot;Invalid Hex Char: &quot; &lt;&gt; pack [c]) &gt;&gt; mzero\nIf we wanted, we could also include lowercase, but this problem doesn't require it.\nWe also want to be able to turn a list of bits into a decimal number. We'll do this for a couple different sizes of numbers. For smaller numbers (8 bits or below), we might want to return a Word8. For larger numbers we can do Word64. Calculating the decimal number is a tail recursive process, where we track the accumulated sum and the current power of 2.\nbitsToDecimal8 :: [Bit] -&gt; Word8\nbitsToDecimal8 bits = if length bits &gt; 8\n  then error (&quot;Too long! Use bitsToDecimal64! &quot; ++ show bits)\n  else btd8 0 1 (reverse bits)\n    where\n      btd8 :: Word8 -&gt; Word8 -&gt; [Bit] -&gt; Word8\n      btd8 accum _ [] = accum\n      btd8 accum mult (b : rest) = case b of\n        Zero -&gt; btd8 accum (mult * 2) rest\n        One -&gt; btd8 (accum + mult) (mult * 2) rest\n\nbitsToDecimal64 :: [Bit] -&gt; Word64\nbitsToDecimal64 bits = if length bits &gt; 64\n  then error (&quot;Too long! Use bitsToDecimalInteger! &quot; ++ (show $ bits))\n  else btd64 0 1 (reverse bits)\n    where\n      btd64 :: Word64 -&gt; Word64 -&gt; [Bit] -&gt; Word64\n      btd64 accum _ [] = accum\n      btd64 accum mult (b : rest) = case b of\n        Zero -&gt; btd64 accum (mult * 2) rest\n        One -&gt; btd64 (accum + mult) (mult * 2) rest\nLast of all, we should write a parser for reading a hexadecimal string from our file. This is easy, because Megaparsec already has a parser for a single hexadecimal character.\nparseHexadecimal :: (MonadLogger m) =&gt; ParsecT Void Text m String\nparseHexadecimal = some hexDigitChar\nBasic Bit Parsing\nWith all these utilities in place, we can get started with parsing our list of bits. As mentioned above, we want a function that generally looks like this:\nparsePacketNode :: (MonadLogger m) =&gt; ParsecT Void [Bit] m PacketNode\nHowever, we need one extra nuance. Because we have one layer that will parse several consecutive packets based on the number of bits parsed, we should also return this number as part of our function. In this way, we'll be able to determine if we're done with the subpackets of an operator packet.\nparsePacketNode :: (MonadLogger m) =&gt; ParsecT Void [Bit] m (PacketNode, Word64)\nWe'll also want a wrapper around this function so we can call it from a normal context with the list of bits as the input. This looks a lot like the existing utilities (e.g. for parsing a whole file). We use runParserT from Megaparsec and do a case-branch on the result.\nparseBits :: (MonadLogger m) =&gt; [Bit] -&gt; MaybeT m PacketNode\nparseBits bits = do\n  result "
}