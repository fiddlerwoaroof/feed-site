{
  "title":"An Unusual Application for Dijkstra",
  "date":"2022-11-15T03:30:00.000000Z",
  "author":"James Bowen",
  "id":"584219d403596e3099e0ee9b:58462c0e15d5db6feba171c0:6369c4307b8a1e54007f7103",
  "link":"https://mmhaskell.com/blog/2022/11/14/an-unusual-application-for-dijkstra",
  "content":"Today will be the final write-up for a 2021 Advent of Code problem. It will also serve as a capstone for the work on Dijkstra's algorithm I did back in the summer! This problem uses Dijkstra's algorithm, but in a more unusual way! We'll be working on Day 23 from last year. And for my part, I'll say that days 21-24 were all extremely challenging, so this is one of the &quot;final boss&quot; puzzles!\nLike our previous write-ups, this is an In-Depth walkthrough, and it's a long one! So get ready for some details! The code is available on GitHub as always so you can follow along.\nProblem Statement\nFor this puzzle, we start with a set of tokens divided into 4 rooms with a hallway allowing them to move around.\n#############\n#...........#\n###B#C#B#D###\n  #A#D#C#A#\n  #########Our goal is to rearrange the tokens so that the A tokens are both in the first room, the B tokens are in the second room, the C tokens are in the third room, and the D tokens are in the fourth room.\n#############\n#...........#\n###A#B#C#D###\n  #A#B#C#D#\n  #########However, there are a lot of restrictions on the possible moves. First, token's can't move past each other in the hall (or rooms). If D comes out of the fourth room first, we cannot then move the A in that room anywhere to the left. It could only go to a space on the right.\n#############\n#.......D...#\n###B#C#B#.###\n  #A#D#C#A#\n  #########Next, each token can only make two moves total. It can move into the hallway once, and then into its appropriate room. It can't take a side journey into a different room to make space for other tokens to pass.\nOn top of this, each token spends a certain amount of &quot;power&quot; (or &quot;energy&quot;) to move per space. The different tokens spend a different amount of energy:\nA = 1\nB = 10\nC = 100\nD = 1000So from the start position, we could spend 2000 energy to move D up to the right, and then only 9 energy to move A all the way to the left side.\n#############\n#.A.......D.#\n###B#C#B#.###\n  #A#D#C#.#\n  #########Our goal is to get the desired configuration with the least amount of energy expended.\nFor the &quot;harder&quot; version of this problem, not much changes. We just have 4 tokens per room, so more maneuvering steps are required.\n#############\n#...........#\n###B#C#B#D###\n  #D#C#B#A#\n  #D#B#A#C#\n  #A#D#C#A#\n  #########Solution Approach\nThe surprising solution approach (at least I was surprised when I realized it could work), is to treat this like a graph problem. Each &quot;state&quot; of the puzzle represents a node in the graph. Any given state has &quot;edges&quot; representing transitions to future states of the puzzle. The edges are weighted by how much energy is required in the transition.\nOnce we view the problem in this way, the solution is simple. We apply a &quot;shortest path&quot; algorithm (like Dijkstra's) using the &quot;end&quot; state of the puzzle as the destination. We'll get the series of moves that uses the least total energy.\nFor example, the first starting solution would represent one node. It would have an edge to this following puzzle state, with a weight of 2000, since a D is moving two spaces.\n#############\n#.........D.#\n###B#C#B#.###\n  #A#D#C#A#\n  #########There are some potential questions about the scale of this problem. If the potential number of nodes is too high, even Dijkstra's algorithm could take too long. And if the tokens could be placed arbitrarily anywhere in the puzzle space, our upper bound might be a factorial number like 23-P-16. This would be too large.\nHowever, as a practical matter, the solution space is much smaller than this because of the many restrictions on how tokens can actually move. So we'll end up with a solution space that is still large but not intractable.\nSolution Outline\nAs we start to outline our solution, we need to start by considering which Dijkstra library function we'll use. In order to allow monadic actions in our functions (such as logging), we'll use dijkstraM, which has the following type signature:\ndijkstraM ::\n  (Monad m, Foldable f, Num cost, Ord cost, Ord state) =&gt;\n  (state -&gt; m (f state)) -&gt;\n  (state -&gt; state -&gt; m cost) -&gt;\n  (state -&gt; m bool) -&gt;\n  state -&gt;\n  m (Maybe (cost, [state]))\nTo make this work, we need to pick the types we'll use for state and cost. For the cost, we can rely on a simple Int. For the state, we'll create a custom GraphState type that will represent the state of the solution at a particular point in time.\ndata GraphState = ...\nWe'll expand more on exactly what information goes into this type as we go along. But now that we've defined our type, we can define the three functions that we'll use as inputs to dijkstraM:\ngetNeighbors :: (MonadLogger m) =&gt; GraphState -&gt; m [GraphState]\ngetCost :: (MonadLogger m) =&gt; GraphState -&gt; GraphState -&gt; m Int\nisComplete :: (MonadLogger m) =&gt; GraphState -&gt; m Bool\nWe can (and will) add at least one more argument to partially apply, but still, this lets us outline what a full invocation of the function might look like:\nsolution :: (MonadLogger m) =&gt; GraphState -&gt; m (Maybe (Int, [GraphState])\nsolution initialState = dijkstraM getNeighbors getCost isComplete initialState\nCompleteness Check\nSo now let's start filling in these functions. We'll start with the completeness check, since that's the easiest. Because this check is run fairly often, we want to make it as quick as possible. So instead of doing a full completeness check on the state each time we call it, we'll store a specific field in the graph state called roomsFull.\ndata GraphState = GraphState\n  { roomsFull :: Int -- Initially 0, increments when we finish a room\n  ...\n  }\nThis field will be 0 when we initialize the state, and whenever we &quot;complete&quot; a room in our search path, we'll bump the number up. Checking for completeness then is as simple as checking that we've completed all 4 rooms.\nisComplete :: (MonadLogger m) =&gt; GraphState -&gt; m Bool\nisComplete gs = return (roomsFull gs == 4)\nCost\nIt would be more convenient to combine the cost with the neighbors function, like in dijkstraAssoc. But we don't have this option if we want to use a monad. Calculating the cost between two raw graph states would be a little tricky, since we'd have to go through a lot of cases to see what has actually changed.\nHowever, it gets easier if we include the &quot;last move&quot; as part of the GraphState type. So let's start defining what a Move looks like. To start, we'll include a NoMove constructor for the initial position, and we'll make a note that the GraphState will include this field.\ndata Move =\n  NoMove |\n  ...\n\ndata GraphState = GraphState\n  { lastMove :: Move\n  , roomsFull :: Int\n  ...\n  }\nSo how do we describe a move? Because the rules are so constrained, we can be sure every move has the following:\n\nA particular token that is moving.\nA particular &quot;hall space&quot; that it is moving to or from.\nA particular &quot;room&quot; that it is moving to or from.\n\nEach of these concepts is easily enumerated, so let's make some Enum types that are also indexable (we'll see why soon):\ndata Token = A | B | C | D\n  deriving (Show, Eq, Ord, Enum, Ix)\n\ndata Room = RA | RB | RC | RD\n  deriving (Show, Eq, Ord, Enum, Ix)\n\n-- Can never occupy spaces above the room like H3, H5, H7, H9\ndata HallSpace = H1 | H2 | H4 | H6 | H8 | H10 | H11\n  deriving (Show, Eq, Ord, Enum, Ix)\nNow we can describe the Move constructor with these three items, as well as two more pieces of data. First, an Int paired with the room describing the &quot;slot&quot; of the room involved. For example, the top &quot;slot&quot; of a room would be 1, the space below it would be 2, and so on. Finally, we'll include a Bool telling us if the move is leaving the room (True) or entering the room (False). This won't be necessarily for calculations, but it helps with debugging.\ndata Move =\n  NoMove |\n  Move Token HallSpace (Room, Int) Bool\n  deriving (Show, Eq, Ord)\nSo what is the cost of a move? We have to calculate the distance, and we have to know the power multiplier. So let's make two constant arrays that we'll reference. First, let's match each token to its multiplier:\ntokenPower :: A.Array Token Int\ntokenPower = A.array (A, D) [(A, 1), (B, 10), (C, 100), (D, 1000)]\nNow we want to match each pair of &quot;hall space&quot; and &quot;room&quot; with a distance measurement. This tells us how many moves it takes to get from the hall space to the space above the room. For example, the first hall space requires 2 moves to get to room A and 4 to get to room B, while the second space only requires 1 and 3 moves, respectively:\nhallRoomDistance :: A.Array (HallSpace, Room) Int\nhallRoomDistance = A.array ((H1, RA), (H11, RD))\n  [ ((H1, RA), 2), ((H1, RB), 4), ((H1, RC), 6), ((H1, RD), 8)\n  , ((H2, RA), 1), ((H2, RB), 3), ((H2, RC), 5), ((H2, RD), 7)\n  ...\n  ]\nHere's what the complete array looks like:\nhallRoomDistance :: A.Array (HallSpace, Room) Int\nhallRoomDistance = A.array ((H1, RA), (H11, RD))\n  [ ((H1, RA), 2), ((H1, RB), 4), ((H1, RC), 6), ((H1, RD), 8)\n  , ((H2, RA), 1), ((H2, RB), 3), ((H2, RC), 5), ((H2, RD), 7)\n  , ((H4, RA), 1), ((H4, RB), 1), ((H4, RC), 3), ((H4, RD), 5)\n  , ((H6, RA), 3), ((H6, RB), 1), ((H6, RC), 1), ((H6, RD), 3)\n  , ((H8, RA), 5), ((H8, RB), 3), ((H8, RC), 1), ((H8, RD), 1)\n  , ((H10, RA), 7), ((H10, RB), 5), ((H10, RC), 3), ((H10, RD), 1)\n  , ((H11, RA), 8), ((H11, RB), 6), ((H11, RC), 4), ((H11, RD), 2)\n  ]\nNow calculating the cost is fairly straightforward. We get the distance to the room, add the slot within the room, and then multiply this by the power multiplier.\ngetCost :: (MonadLogger m) =&gt; GraphState -&gt; GraphState -&gt; m Int\ngetCost _ gs = if lastMove gs == NoMove\n  then return 0\n  else do\n    let (Move token hs (rm, slot) _) = lastMove gs\n    let mult = tokenPower A.! token\n    let distance = slot + hallRoomDistance A.! (hs, rm)\n    return $ mult * distance\nFinishing the Graph State\nOur solution is starting to take on a bit more shape, but we need to complete our GraphState type before we can make further progress. But now armed with the notion of a Token, we can fill in the remaining fields that describe it. Each room has a list of tokens that are currently residing there. And then each hall space either has a token there or not, so we have Maybe Token fields for them.\ndata GraphState = GraphState\n  { lastMove :: Move\n  , roomsFull :: Int\n  , roomA :: [Token]\n  , roomB :: [Token]\n  , roomC :: [Token]\n  , roomD :: [Token]\n  , hall1 :: Maybe Token\n  , hall2 :: Maybe Token\n  , hall4 :: Maybe Token\n  , hall6 :: Maybe Token\n  , hall8 :: Maybe Token\n  , hall10 :: Maybe Token\n  , hall11 :: Maybe Token\n  }\n  deriving (Show, Eq, Ord)\nSometimes it will be useful for us to access parts of the state in a general way. We might want a function to access &quot;one of the rooms&quot; or &quot;one of the hall spaces&quot;. Some day, I might revise my solution to use proper Haskell &quot;Lenses&quot;, which would be ideal for this problem. But for now we'll define a couple simple type aliases for a RoomLens to access the tokens in a general room, and a HallLens for looking at a general hall space.\ntype RoomLens = GraphState -&gt; [Token]\ntype HallLens = GraphState -&gt; Maybe Token\nOne last piece of boilerplate we'll want will be to have &quot;split lists&quot; for each room. Each of these is a tuple of two lists. The first list is the hall spaces to the &quot;left&quot; of that room, and the second has the hall spaces to the &quot;right&quot; of the room.\nThese lists will help us answer questions like, &quot;how many empty hall spaces can we move to from this room moving left?&quot;, or &quot;what is the first token to the right of this room?&quot; For these to be useful, each hall space should also include the &quot;lens&quot; into the GraphState, so we can examine what token lives there.\nFor example, room A has H2 and H1 to its left (in that order), and then H4, H6, H8, H10 and H11 to its right. We'll match each HallSpace with its HallLens, so H1 combines with the hall1 field from GraphState, and so on.\naSplits :: ([(HallLens, HallSpace)], [(HallLens, HallSpace)])\naSplits =\n  ( [(hall2, H2), (hall1, H1)]\n  , [(hall4, H4), (hall6, H6), (hall8, H8), (hall10, H10), (hall11, H11)]\n  )\nHere's what the rest of those look like:\nbSplits :: ([(HallLens, HallSpace)], [(HallLens, HallSpace)])\nbSplits =\n  ( [(hall4, H4), (hall2, H2), (hall1, H1)]\n  , [(hall6, H6), (hall8, H8), (hall10, H10), (hall11, H11)]\n  )\n\ncSplits :: ([(HallLens, HallSpace)], [(HallLens, HallSpace)])\ncSplits =\n  ( [(hall6, H6), (hall4, H4), (hall2, H2), (hall1, H1)]\n  , [(hall8, H8), (hall10, H10), (hall11, H11)]\n  )\n\ndSplits :: ([(HallLens, HallSpace)], [(HallLens, HallSpace)])\ndSplits =\n  ( [(hall8, H8), (hall6, H6), (hall4, H4), (hall2, H2), (hall1, H1)]\n  , [(hall10, H10), (hall11, H11)]\n  )\nIt would be easy enough to use a common function with splitAt to describe all of these. But once again, we'll reference these many times throughout the solution, so using constants instead of requiring function logic could help make our code faster.\nMoves from a Particular Room\nNow it's time for the third and largest piece of the puzzle: calculating the &quot;next&quot; states, or the &quot;neighboring&quot; states of a particular graph state. This means determining what moves are possible from a particular position. This is a complex problem that we'll have to keep breaking down into smaller and smaller parts.\nWe can first observe that every move involves one room and the hallway - there are no moves from room to room. So we can divide the work by considering all the moves concerning one particular room. Then there are three cases for each room:\n\nThe room is complete; it is full of the appropriate token.\nThe room is empty or partially full of the appropriate token.\nThe room has mismatched tokens inside.\n\nIn case 1, we'll propose no moves involving this room. In case 2, we will try to find the appropriate token in the hall and bring it into the room (from either direction). In case 3, we will consider all the ways to move a token out of the room.\nWe'll do all this in a general function roomMoves. This function needs to know the room size, the appropriate token for the room, the appropriate lens for accessing the room, and finally, the split list corresponding to the room. This leads to a long type signature, but each parameter has its role:\nroomMoves ::\n  (MonadLogger m) =&gt;\n  Int -&gt;\n  Token -&gt;\n  Room -&gt;\n  RoomLens -&gt;\n  ([(HallLens, HallSpace)], [(HallLens, HallSpace)]) -&gt;\n  GraphState -&gt;\n  m [GraphState]\nroomMoves rs tok rm roomLens splits gs = ...\nFor getNeighbors, all we have to do is invoke this function once for each room and combine the results.\ngetNeighbors :: (MonadLogger m) =&gt; Int -&gt; GraphState -&gt; m [GraphState]\ngetNeighbors rs gs = do\n  arm "
}