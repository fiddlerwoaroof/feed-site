{
  "title":"Categories of Structures in Haskell",
  "date":"2022-10-24T17:47:25.000000Z",
  "author":"Dan Doel",
  "id":"http://comonad.com/reader/?p=1037",
  "link":"http://comonad.com/reader/2015/categories-of-structures-in-haskell/",
  "content":"In the last couple posts I've used some 'free' constructions, and not remarked too much on how they arise. In this post, I'd like to explore them more. This is going to be something of a departure from the previous posts, though, since I'm not going to worry about thinking precisely about bottom/domains. This is more an exercise in applying some category theory to Haskell, &quot;fast and loose&quot;.\n(Advance note: for some continuous code to look at see this file.)\nFirst, it'll help to talk about how some categories can work in Haskell. For any kind k made of * and (-&gt;), [0] we can define a category of type constructors. Objects of the category will be first-class [1] types of that kind, and arrows will be defined by the following type family:\n \nnewtype Transformer f g = Transform { ($$) :: forall i. f i ~&gt; g i }\n \ntype family (~&gt;) :: k -&gt; k -&gt; * where\n  (~&gt;) = (-&gt;)\n  (~&gt;) = Transformer\n \ntype a &lt; -&gt; b = (a -&gt; b, b -&gt; a)\ntype a &lt; ~&gt; b = (a ~&gt; b, b ~&gt; a)\n \nSo, for a base case, * has monomorphic functions as arrows, and categories for higher kinds have polymorphic functions that saturate the constructor:\n \n  Int ~&gt; Char = Int -&gt; Char\n  Maybe ~&gt; [] = forall a. Maybe a -&gt; [a]\n  Either ~&gt; (,) = forall a b. Either a b -&gt; (a, b)\n  StateT ~&gt; ReaderT = forall s m a. StateT s m a -&gt; ReaderT s m a\n \nWe can of course define identity and composition for these, and it will be handy to do so:\n \nclass Morph (p :: k -&gt; k -&gt; *) where\n  id :: p a a\n  (.) :: p b c -&gt; p a b -&gt; p a c\n \ninstance Morph (-&gt;) where\n  id x = x\n  (g . f) x = g (f x)\n \ninstance Morph ((~&gt;) :: k -&gt; k -&gt; *)\n      =&gt; Morph (Transformer :: (i -&gt; k) -&gt; (i -&gt; k) -&gt; *) where\n  id = Transform id\n  Transform f . Transform g = Transform $ f . g\n \nThese categories can be looked upon as the most basic substrates in Haskell. For instance, every type of kind * -&gt; * is an object of the relevant category, even if it's a GADT or has other structure that prevents it from being nicely functorial.\nThe category for * is of course just the normal category of types and functions we usually call Hask, and it is fairly analogous to the category of sets. One common activity in category theory is to study categories of sets equipped with extra structure, and it turns out we can do this in Haskell, as well. And it even makes some sense to study categories of structures over any of these type categories.\nWhen we equip our types with structure, we often use type classes, so that's how I'll do things here. Classes have a special status socially in that we expect people to only define instances that adhere to certain equational rules. This will take the place of equations that we are not able to state in the Haskell type system, because it doesn't have dependent types. So using classes will allow us to define more structures that we normally would, if only by convention.\nSo, if we have a kind k, then a corresponding structure will be σ :: k -&gt; Constraint. We can then define the category (k,σ) as having objects t :: k such that there is an instance σ t. Arrows are then taken to be f :: t ~&gt; u such that f &quot;respects&quot; the operations of σ.\nAs a simple example, we have:\n \n  k = *\n  σ = Monoid :: * -&gt; Constraint\n \n  Sum Integer, Product Integer, [Integer] :: (*, Monoid)\n \n  f :: (Monoid m, Monoid n) =&gt; m -&gt; n\n    if f mempty = mempty\n       f (m &lt;&gt; n) = f m &lt;&gt; f n\n \nThis is just the category of monoids in Haskell.\nAs a side note, we will sometimes be wanting to quantify over these &quot;categories of structures&quot;. There isn't really a good way to package together a kind and a structure such that they work as a unit, but we can just add a constraint to the quantification. So, to quantify over all Monoids, we'll use 'forall m. Monoid m =&gt; ...'.\nNow, once we have these categories of structures, there is an obvious forgetful functor back into the unadorned category. We can then look for free and cofree functors as adjoints to this. More symbolically:\n \n  Forget σ :: (k,σ) -&gt; k\n  Free   σ :: k -&gt; (k,σ)\n  Cofree σ :: k -&gt; (k,σ)\n \n  Free σ ⊣ Forget σ ⊣ Cofree σ\n \nHowever, what would be nicer (for some purposes) than having to look for these is being able to construct them all systematically, without having to think much about the structure σ.\nCategory theory gives a hint at this, too, in the form of Kan extensions. In category terms they look like:\n  p : C -&gt; C'\n  f : C -&gt; D\n  Ran p f : C' -&gt; D\n  Lan p f : C' -&gt; D\n\n  Ran p f c' = end (c : C). Hom_C'(c', p c) ⇒ f c\n  Lan p f c' = coend (c : c). Hom_C'(p c, c') ⊗ f c\n\nwhere ⇒ is a &quot;power&quot; and ⊗ is a copower, which are like being able to take exponentials and products by sets (or whatever the objects of the hom category are), instead of other objects within the category. Ends and coends are like universal and existential quantifiers (as are limits and colimits, but ends and coends involve mixed-variance).\nSome handy theorems relate Kan extensions and adjoint functors:\n  if L ⊣ R\n  then L = Ran R Id and R = Lan L Id\n\n  if Ran R Id exists and is absolute\n  then Ran R Id ⊣ R\n\n  if Lan L Id exists and is absolute\n  then L ⊣ Lan L Id\n\n  Kan P F is absolute iff forall G. (G . Kan P F) ~= Kan P (G . F)\n\nIt turns out we can write down Kan extensions fairly generally in Haskell. Our restricted case is:\n \n  p = Forget σ :: (k,σ) -&gt; k\n  f = Id :: (k,σ) -&gt; (k,σ)\n \n  Free   σ = Ran (Forget σ) Id :: k -&gt; (k,σ)\n  Cofree σ = Lan (Forget σ) Id :: k -&gt; (k,σ)\n \n  g :: (k,σ) -&gt; j\n  g . Free   σ = Ran (Forget σ) g\n  g . Cofree σ = Lan (Forget σ) g\n \nAs long as the final category is like one of our type constructor categories, ends are universal quantifiers, powers are function types, coends are existential quantifiers and copowers are product spaces. This only breaks down for our purposes when g is contravariant, in which case they are flipped.  For higher kinds, these constructions occur point-wise. So, we can break things down into four general cases, each with cases for each arity:\n \nnewtype Ran0 σ p (f :: k -&gt; *) a =\n  Ran0 { ran0 :: forall r. σ r =&gt; (a ~&gt; p r) -&gt; f r }\n \nnewtype Ran1 σ p (f :: k -&gt; j -&gt; *) a b =\n  Ran1 { ran1 :: forall r. σ r =&gt; (a ~&gt; p r) -&gt; f r b }\n \n-- ...\n \ndata RanOp0 σ p (f :: k -&gt; *) a =\n  forall e. σ e =&gt; RanOp0 (a ~&gt; p e) (f e)\n \n-- ...\n \ndata Lan0 σ p (f :: k -&gt; *) a =\n  forall e. σ e =&gt; Lan0 (p e ~&gt; a) (f e)\n \ndata Lan1 σ p (f :: k -&gt; j -&gt; *) a b =\n  forall e. σ e =&gt; Lan1 (p e ~&gt; a) (f e b)\n \n-- ...\n \ndata LanOp0 σ p (f :: k -&gt; *) a =\n  LanOp0 { lan0 :: forall r. σ r =&gt; (p r -&gt; a) -&gt; f r }\n \n-- ...\n \nThe more specific proposed (co)free definitions are:\n \ntype family Free   :: (k -&gt; Constraint) -&gt; k -&gt; k\ntype family Cofree :: (k -&gt; Constraint) -&gt; k -&gt; k\n \nnewtype Free0 σ a = Free0 { gratis0 :: forall r. σ r =&gt; (a ~&gt; r) -&gt; r }\ntype instance Free = Free0\n \nnewtype Free1 σ f a = Free1 { gratis1 :: forall g. σ g =&gt; (f ~&gt; g) -&gt; g a }\ntype instance Free = Free1\n \n-- ...\n \ndata Cofree0 σ a = forall e. σ e =&gt; Cofree0 (e ~&gt; a) e\ntype instance Cofree = Cofree0\n \ndata Cofree1 σ f a = forall g. σ g =&gt; Cofree1 (g ~&gt; f) (g a)\ntype instance Cofree = Cofree1\n \n-- ...\n \nWe can define some handly classes and instances for working with these types, several of which generalize existing Haskell concepts:\n \nclass Covariant (f :: i -&gt; j) where\n  comap :: (a ~&gt; b) -&gt; (f a ~&gt; f b)\n \nclass Contravariant f where\n  contramap :: (b ~&gt; a) -&gt; (f a ~&gt; f b)\n \nclass Covariant m =&gt; Monad (m :: i -&gt; i) where\n  pure :: a ~&gt; m a\n  join :: m (m a) ~&gt; m a\n \nclass Covariant w =&gt; Comonad (w :: i -&gt; i) where\n  extract :: w a ~&gt; a\n  split :: w a ~&gt; w (w a)\n \nclass Couniversal σ f | f -&gt; σ where\n  couniversal :: σ r =&gt; (a ~&gt; r) -&gt; (f a ~&gt; r)\n \nclass Universal σ f | f -&gt; σ where\n  universal :: σ e =&gt; (e ~&gt; a) -&gt; (e ~&gt; f a)\n \ninstance Covariant (Free0 σ) where\n  comap f (Free0 e) = Free0 (e . (.f))\n \ninstance Monad (Free0 σ) where\n  pure x = Free0 $ \\k -&gt; k x\n  join (Free0 e) = Free0 $ \\k -&gt; e $ \\(Free0 e) -&gt; e k\n \ninstance Couniversal σ (Free0 σ) where\n  couniversal h (Free0 e) = e h\n \n-- ...\n \nThe only unfamiliar classes here should be (Co)Universal. They are for witnessing the adjunctions that make Free σ the initial σ and Cofree σ the final σ in the relevant way. Only one direction is given, since the opposite is very easy to construct with the (co)monad structure.\nFree σ is a monad and couniversal, Cofree σ is a comonad and universal.\nWe can now try to convince ourselves that Free σ and Cofree σ are absolute Here are some examples:\n \nfree0Absolute0 :: forall g σ a. (Covariant g, σ (Free σ a))\n               =&gt; g (Free0 σ a) &lt; -&gt; Ran σ Forget g a\nfree0Absolute0 = (l, r)\n where\n l :: g (Free σ a) -&gt; Ran σ Forget g a\n l g = Ran0 $ \\k -&gt; comap (couniversal $ remember0 . k) g\n \n r :: Ran σ Forget g a -&gt; g (Free σ a)\n r (Ran0 e) = e $ Forget0 . pure\n \nfree0Absolute1 :: forall (g :: * -&gt; * -&gt; *) σ a x. (Covariant g, σ (Free σ a))\n               =&gt; g (Free0 σ a) x &lt; -&gt; Ran σ Forget g a x\nfree0Absolute1 = (l, r)\n where\n l :: g (Free σ a) x -&gt; Ran σ Forget g a x\n l g = Ran1 $ \\k -&gt; comap (couniversal $ remember0 . k) $$ g\n \n r :: Ran σ Forget g a x -&gt; g (Free σ a) x\n r (Ran1 e) = e $ Forget0 . pure\n \nfree0Absolute0Op :: forall g σ a. (Contravariant g, σ (Free σ a))\n                 =&gt; g (Free0 σ a) &lt; -&gt; RanOp σ Forget g a\nfree0Absolute0Op = (l, r)\n where\n l :: g (Free σ a) -&gt; RanOp σ Forget g a\n l = RanOp0 $ Forget0 . pure\n \n r :: RanOp σ Forget g a -&gt; g (Free σ a)\n r (RanOp0 h g) = contramap (couniversal $ remember0 . h) g\n \n-- ...\n \nAs can be seen, the definitions share a lot of structure. I'm quite confident that with the right building blocks these could be defined once for each of the four types of Kan extensions, with types like:\n \nfreeAbsolute\n  :: forall g σ a. (Covariant g, σ (Free σ a))\n  =&gt; g (Free σ a) &lt; ~&gt; Ran σ Forget g a\n \ncofreeAbsolute\n  :: forall g σ a. (Covariant g, σ (Cofree σ a))\n  =&gt; g (Cofree σ a) &lt; ~&gt; Lan σ Forget g a\n \nfreeAbsoluteOp\n  :: forall g σ a. (Contravariant g, σ (Free σ a))\n  =&gt; g (Free σ a) &lt; ~&gt; RanOp σ Forget g a\n \ncofreeAbsoluteOp\n  :: forall g σ a. (Contravariant g, σ (Cofree σ a))\n  =&gt; g (Cofree σ a) &lt; ~&gt; LanOp σ Forget g a\n \nHowever, it seems quite difficult to structure things in a way such that GHC will accept the definitions. I've successfully written freeAbsolute using some axioms, but turning those axioms into class definitions and the like seems impossible.\nAnyhow, the punchline is that we can prove absoluteness using only the premise that there is a valid σ instance for Free σ and Cofree σ. This tends to be quite easy; we just borrow the structure of the type we are quantifying over. This means that in all these cases, we are justified in saying that Free σ ⊣ Forget σ ⊣ Cofree σ, and we have a very generic presentations of (co)free structures in Haskell. So let's look at some.\nWe've already seen Free Monoid, and last time we talked about Free Applicative, and its relation to traversals. But, Applicative is to traversal as Functor is to lens, so it may be interesting to consider constructions on that. Both Free Functor and Cofree Functor make Functors:\n \ninstance Functor (Free1 Functor f) where\n  fmap f (Free1 e) = Free1 $ fmap f . e\n \ninstance Functor (Cofree1 Functor f) where\n  fmap f (Cofree1 h e) = Cofree1 h (fmap f e)\n \nAnd of course, they are (co)monads, covariant functors and (co)universal among Functors. But, it happens that I know some other types with these properties:\n \ndata CoYo f a = forall e. CoYo (e -&gt; a) (f e)\n \ninstance Covariant CoYo where\n  comap f = Transform $ \\(CoYo h e) -&gt; CoYo h (f $$ e)\n \ninstance Monad CoYo where\n  pure = Transform $ CoYo id\n  join = Transform $ \\(CoYo h (CoYo h' e)) -&gt; CoYo (h . h') e\n \ninstance Functor (CoYo f) where\n  fmap f (CoYo h e) = CoYo (f . h) e\n \ninstance Couniversal Functor CoYo where\n  couniversal tr = Transform $ \\(CoYo h e) -&gt; fmap h (tr $$ e)\n \nnewtype Yo f a = Yo { oy :: forall r. (a -&gt; r) -&gt; f r }\n \ninstance Covariant Yo where\n  comap f = Transform $ \\(Yo e) -&gt; Yo $ (f $$) . e\n \ninstance Comonad Yo where\n  extract = Transform $ \\(Yo e) -&gt; e id\n  split = Transform $ \\(Yo e) -&gt; Yo $ \\k -&gt; Yo $ \\k' -&gt; e $ k' . k\n \ninstance Functor (Yo f) where\n  fmap f (Yo e) = Yo $ \\k -&gt; e (k . f)\n \ninstance Universal Functor Yo where\n  universal tr = Transform $ \\e -&gt; Yo $ \\k -&gt; tr $$ fmap k e\n \nThese are the types involved in the (co-)Yoneda lemma. CoYo is a monad, couniversal among functors, and CoYo f is a Functor. Yo is a comonad, universal among functors, and is always a Functor. So, are these equivalent types?\n \ncoyoIso :: CoYo &lt; ~&gt; Free Functor\ncoyoIso = (Transform $ couniversal pure, Transform $ couniversal pure)\n \nyoIso :: Yo &lt; ~&gt; Cofree Functor\nyoIso = (Transform $ universal extract, Transform $ universal extract)\n \nIndeed they are. And similar identities hold for the contravariant versions of these constructions.\nI don't have much of a use for this last example. I suppose to be perfectly precise, I should point out that these uses of (Co)Yo are not actually part of the (co-)Yoneda lemma. They are two different constructions.  The (co-)Yoneda lemma can be given in terms of Kan extensions as:\n \nyoneda :: Ran Id f &lt; ~&gt; f\n \ncoyoneda :: Lan Id f &lt; ~&gt; f\n \nBut, the use of (Co)Yo to make Functors out of things that aren't necessarily is properly thought of in other terms. In short, we have some kind of category of Haskell types with only identity arrows---it is discrete. Then any type constructor, even non-functorial ones, is certainly a functor from said category (call it Haskrete) into the normal one (Hask). And there is an inclusion functor from Haskrete into Hask:\n             F\n Haskrete -----&gt; Hask\n      |        /|\n      |       /\n      |      /\nIncl  |     /\n      |    /  Ran/Lan Incl F\n      |   /\n      |  /\n      v /\n    Hask\n\nSo, (Co)Free Functor can also be thought of in terms of these Kan extensions involving the discrete category.\nTo see more fleshed out, loadable versions of the code in this post, see this file. I may also try a similar Agda development at a later date, as it may admit the more general absoluteness constructions easier.\n[0]: The reason for restricting ourselves to kinds involving only * and (-&gt;) is that they work much more simply than data kinds. Haskell values can't depend on type-level entities without using type classes. For *, this is natural, but for something like Bool -&gt; *, it is more natural for transformations to be able to inspect the booleans, and so should be something more like forall b. InspectBool b =&gt; f b -&gt; g b.\n[1]: First-class types are what you get by removing type families and synonyms from consideration. The reason for doing so is that these can't be used properly as parameters and the like, except in cases where they reduce to some other type that is first-class. For example, if we define:\n \ntype I a = a\n \neven though GHC will report I :: * -&gt; *, it is not legal to write Transform I I.\n    "
}