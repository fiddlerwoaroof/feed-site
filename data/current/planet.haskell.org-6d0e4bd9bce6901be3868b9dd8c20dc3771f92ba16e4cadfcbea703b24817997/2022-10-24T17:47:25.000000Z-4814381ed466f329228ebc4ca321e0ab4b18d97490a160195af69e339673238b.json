{
  "title":"Domains, Sets, Traversals and Applicatives",
  "date":"2022-10-24T17:47:25.000000Z",
  "author":"Dan Doel",
  "id":"http://comonad.com/reader/?p=994",
  "link":"http://comonad.com/reader/2015/domains-sets-traversals-and-applicatives/",
  "content":"Last time I looked at free monoids, and noticed that in Haskell lists don't really cut it. This is a consequence of laziness and general recursion. To model a language with those properties, one needs to use domains and monotone, continuous maps, rather than sets and total functions (a call-by-value language with general recursion would use domains and strict maps instead).\nThis time I'd like to talk about some other examples of this, and point out how doing so can (perhaps) resolve some disagreements that people have about the specific cases.\nThe first example is not one that I came up with: induction. It's sometimes said that Haskell does not have inductive types at all, or that we cannot reason about functions on its data types by induction. However, I think this is (techincally) inaccurate. What's true is that we cannot simply pretend that that our types are sets and use the induction principles for sets to reason about Haskell programs.  Instead, one has to figure out what inductive domains would be, and what their proof principles are.\nFortunately, there are some papers about doing this. The most recent (that I'm aware of) is Generic Fibrational Induction. I won't get too into the details, but it shows how one can talk about induction in a general setting, where one has a category that roughly corresponds to the type theory/programming language, and a second category of proofs that is 'indexed' by the first category's objects. Importantly, it is not required that the second category is somehow 'part of' the type theory being reasoned about, as is often the case with dependent types, although that is also a special case of their construction.\nOne of the results of the paper is that this framework can be used to talk about induction principles for types that don't make sense as sets. Specifically:\n \nnewtype Hyp = Hyp ((Hyp -&gt; Int) -&gt; Int)\n \nthe type of &quot;hyperfunctions&quot;. Instead of interpreting this type as a set, where it would effectively require a set that is isomorphic to the power set of its power set, they interpret it in the category of domains and strict functions mentioned earlier. They then construct the proof category in a similar way as one would for sets, except instead of talking about predicates as subsets, we talk about sub-domains instead. Once this is done, their framework gives a notion of induction for this type.\nThis example is suitable for ML (and suchlike), due to the strict functions, and sort of breaks the idea that we can really get away with only thinking about sets, even there. Sets are good enough for some simple examples (like flat domains where we don't care about âŠ¥), but in general we have to generalize induction itself to apply to all types in the 'good' language.\nWhile I haven't worked out how the generic induction would work out for Haskell, I have little doubt that it would, because ML actually contains all of Haskell's data types (and vice versa). So the fact that the framework gives meaning to induction for ML implies that it does so for Haskell. If one wants to know what induction for Haskell's 'lazy naturals' looks like, they can study the ML analogue of:\n \ndata LNat = Zero | Succ (() -&gt; LNat)\n \nbecause function spaces lift their codomain, and make things 'lazy'.\n----\nThe other example I'd like to talk about hearkens back to the previous article.  I explained how foldMap is the proper fundamental method of the Foldable class, because it can be massaged to look like:\n \nfoldMap :: Foldable f =&gt; f a -&gt; FreeMonoid a\n \nand lists are not the free monoid, because they do not work properly for various infinite cases.\nI also mentioned that foldMap looks a lot like traverse: \n \nfoldMap  :: (Foldable t   , Monoid m)      =&gt; (a -&gt; m)   -&gt; t a -&gt; m\ntraverse :: (Traversable t, Applicative f) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)\n \nAnd of course, we have Monoid m =&gt; Applicative (Const m), and the functions are expected to agree in this way when applicable.\nNow, people like to get in arguments about whether traversals are allowed to be infinite. I know Ed Kmett likes to argue that they can be, because he has lots of examples. But, not everyone agrees, and especially people who have papers proving things about traversals tend to side with the finite-only side. I've heard this includes one of the inventors of Traversable, Conor McBride.\nIn my opinion, the above disagreement is just another example of a situation where we have a generic notion instantiated in two different ways, and intuition about one does not quite transfer to the other. If you are working in a language like Agda or Coq (for proving), you will be thinking about traversals in the context of sets and total functions. And there, traversals are finite. But in Haskell, there are infinitary cases to consider, and they should work out all right when thinking about domains instead of sets. But I should probably put forward some argument for this position (and even if I don't need to, it leads somewhere else interesting).\nOne example that people like to give about finitary traversals is that they can be done via lists. Given a finite traversal, we can traverse to get the elements (using Const [a]), traverse the list, then put them back where we got them by traversing again (using State [a]). Usually when you see this, though, there's some subtle cheating in relying on the list to be exactly the right length for the second traversal. It will be, because we got it from a traversal of the same structure, but I would expect that proving the function is actually total to be a lot of work. Thus, I'll use this as an excuse to do my own cheating later.\nNow, the above uses lists, but why are we using lists when we're in Haskell? We know they're deficient in certain ways. It turns out that we can give a lot of the same relevant structure to the better free monoid type:\n \nnewtype FM a = FM (forall m. Monoid m =&gt; (a -&gt; m) -&gt; m) deriving (Functor)\n \ninstance Applicative FM where\n  pure x = FM ($ x)\n  FM ef &lt; *&gt; FM ex = FM $ \\k -&gt; ef $ \\f -&gt; ex $ \\x -&gt; k (f x)\n \ninstance Monoid (FM a) where\n  mempty = FM $ \\_ -&gt; mempty\n  mappend (FM l) (FM r) = FM $ \\k -&gt; l k &lt;&gt; r k\n \ninstance Foldable FM where\n  foldMap f (FM e) = e f\n \nnewtype Ap f b = Ap { unAp :: f b }\n \ninstance (Applicative f, Monoid b) =&gt; Monoid (Ap f b) where\n  mempty = Ap $ pure mempty\n  mappend (Ap l) (Ap r) = Ap $ (&lt;&gt;) &lt; $&gt; l &lt; *&gt; r\n \ninstance Traversable FM where\n  traverse f (FM e) = unAp . e $ Ap . fmap pure . f\n \nSo, free monoids are Monoids (of course), Foldable, and even Traversable. At least, we can define something with the right type that wouldn't bother anyone if it were written in a total language with the right features, but in Haskell it happens to allow various infinite things that people don't like.\nNow it's time to cheat. First, let's define a function that can take any Traversable to our free monoid:\n \ntoFreeMonoid :: Traversable t =&gt; t a -&gt; FM a\ntoFreeMonoid f = FM $ \\k -&gt; getConst $ traverse (Const . k) f\n \nNow let's define a Monoid that's not a monoid:\n \ndata Cheat a = Empty | Single a | Append (Cheat a) (Cheat a)\n \ninstance Monoid (Cheat a) where\n  mempty = Empty\n  mappend = Append\n \nYou may recognize this as the data version of the free monoid from the previous article, where we get the real free monoid by taking a quotient. using this, we can define an Applicative that's not valid:\n \nnewtype Cheating b a =\n  Cheating { prosper :: Cheat b -&gt; a } deriving (Functor)\n \ninstance Applicative (Cheating b) where\n  pure x = Cheating $ \\_ -&gt; x\n \n  Cheating f &lt; *&gt; Cheating x = Cheating $ \\c -&gt; case c of\n    Append l r -&gt; f l (x r)\n \nGiven these building blocks, we can define a function to relabel a traversable using a free monoid:\n \nrelabel :: Traversable t =&gt; t a -&gt; FM b -&gt; t b\nrelabel t (FM m) = propser (traverse (const hope) t) (m Single)\n where\n hope = Cheating $ \\c -&gt; case c of\n   Single x -&gt; x\n \nAnd we can implement any traversal by taking a trip through the free monoid:\n \nslowTraverse\n  :: (Applicative f, Traversable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)\nslowTraverse f t = fmap (relabel t) . traverse f . toFreeMonoid $ t\n \nAnd since we got our free monoid via traversing, all the partiality I hid in the above won't blow up in practice, rather like the case with lists and finite traversals.\nArguably, this is worse cheating. It relies on the exact association structure to work out, rather than just number of elements. The reason is that for infinitary cases, you cannot flatten things out, and there's really no way to detect when you have something infinitary. The finitary traversals have the luxury of being able to reassociate everything to a canonical form, while the infinite cases force us to not do any reassociating at all. So this might be somewhat unsatisfying.\nBut, what if we didn't have to cheat at all? We can get the free monoid by tweaking foldMap, and it looks like traverse, so what happens if we do the same manipulation to the latter?\nIt turns out that lens has a type for this purpose, a slight specialization of which is:\n \nnewtype Bazaar a b t =\n  Bazaar { runBazaar :: forall f. Applicative f =&gt; (a -&gt; f b) -&gt; f t }\n \nUsing this type, we can reorder traverse to get:\n \nhowBizarre :: Traversable t =&gt; t a -&gt; Bazaar a b (t b)\nhowBizarre t = Bazaar $ \\k -&gt; traverse k t\n \nBut now, what do we do with this? And what even is it? [1]\nIf we continue drawing on intuition from Foldable, we know that foldMap is related to the free monoid. Traversable has more indexing, and instead of Monoid uses Applicative. But the latter are actually related to the former; Applicatives are monoidal (closed) functors. And it turns out, Bazaar has to do with free Applicatives.\nIf we want to construct free Applicatives, we can use our universal property encoding trick:\n \nnewtype Free p f a =\n  Free { gratis :: forall g. p g =&gt; (forall x. f x -&gt; g x) -&gt; g a }\n \nThis is a higher-order version of the free p, where we parameterize over the constraint we want to use to represent structures. So Free Applicative f is the free Applicative over a type constructor f. I'll leave the instances as an exercise.\nSince free monoid is a monad, we'd expect Free p to be a monad, too.  In this case, it is a McBride style indexed monad, as seen in The Kleisli Arrows of Outrageous Fortune.\n \ntype f ~&gt; g = forall x. f x -&gt; g x\n \nembed :: f ~&gt; Free p f\nembed fx = Free $ \\k -&gt; k fx\n \ntranslate :: (f ~&gt; g) -&gt; Free p f ~&gt; Free p g\ntranslate tr (Free e) = Free $ \\k -&gt; e (k . tr)\n \ncollapse :: Free p (Free p f) ~&gt; Free p f\ncollapse (Free e) = Free $ \\k -&gt; e $ \\(Free e') -&gt; e' k\n \nThat paper explains how these are related to Atkey style indexed monads:\n \ndata At key i j where\n  At :: key -&gt; At key i i\n \ntype Atkey m i j a = m (At a j) i\n \nireturn :: IMonad m =&gt; a -&gt; Atkey m i i a\nireturn = ...\n \nibind :: IMonad m =&gt; Atkey m i j a -&gt; (a -&gt; Atkey m j k b) -&gt; Atkey m i k b\nibind = ...\n \nIt turns out, Bazaar is exactly the Atkey indexed monad derived from the Free Applicative indexed monad (with some arguments shuffled) [2]:\n \nhence :: Bazaar a b t -&gt; Atkey (Free Applicative) t b a\nhence bz = Free $ \\tr -&gt; runBazaar bz $ tr . At\n \nforth :: Atkey (Free Applicative) t b a -&gt; Bazaar a b t\nforth fa = Bazaar $ \\g -&gt; gratis fa $ \\(At a) -&gt; g a\n \nimap :: (a -&gt; b) -&gt; Bazaar a i j -&gt; Bazaar b i j\nimap f (Bazaar e) = Bazaar $ \\k -&gt; e (k . f)\n \nipure :: a -&gt; Bazaar a i i\nipure x = Bazaar ($ x)\n \n(&gt;&gt;&gt;=) :: Bazaar a j i -&gt; (a -&gt; Bazaar b k j) -&gt; Bazaar b k i\nBazaar e &gt;&gt;&gt;= f = Bazaar $ \\k -&gt; e $ \\x -&gt; runBazaar (f x) k\n \n(&gt;==&gt;) :: (s -&gt; Bazaar i o t) -&gt; (i -&gt; Bazaar a b o) -&gt; s -&gt; Bazaar a b t\n(f &gt;==&gt; g) x = f x &gt;&gt;&gt;= g\n \nAs an aside, Bazaar is also an (Atkey) indexed comonad, and the one that characterizes traversals, similar to how indexed store characterizes lenses. A Lens s t a b is equivalent to a coalgebra s -&gt; Store a b t. A traversal is a similar Bazaar coalgebra:\n \n  s -&gt; Bazaar a b t\n    ~\n  s -&gt; forall f. Applicative f =&gt; (a -&gt; f b) -&gt; f t\n    ~\n  forall f. Applicative f =&gt; (a -&gt; f b) -&gt; s -&gt; f t\n \nIt so happens that Kleisli composition of the Atkey indexed monad above (&gt;==&gt;) is traversal composition.\nAnyhow, Bazaar also inherits Applicative structure from Free Applicative:\n \ninstance Functor (Bazaar a b) where\n  fmap f (Bazaar e) = Bazaar $ \\k -&gt; fmap f (e k)\n \ninstance Applicative (Bazaar a b) where\n  pure x = Bazaar $ \\_ -&gt; pure x\n  Bazaar ef &lt; *&gt; Bazaar ex = Bazaar $ \\k -&gt; ef k &lt; *&gt; ex k\n \nThis is actually analogous to the Monoid instance for the free monoid; we just delegate to the underlying structure.\nThe more exciting thing is that we can fold and traverse over the first argument of Bazaar, just like we can with the free monoid:\n \nbfoldMap :: Monoid m =&gt; (a -&gt; m) -&gt; Bazaar a b t -&gt; m\nbfoldMap f (Bazaar e) = getConst $ e (Const . f)\n \nnewtype Comp g f a = Comp { getComp :: g (f a) } deriving (Functor)\n \ninstance (Applicative f, Applicative g) =&gt; Applicative (Comp g f) where\n  pure = Comp . pure . pure\n  Comp f &lt; *&gt; Comp x = Comp $ liftA2 (&lt; *&gt;) f x\n \nbtraverse\n  :: (Applicative f) =&gt; (a -&gt; f a') -&gt; Bazaar a b t -&gt; Bazaar a' b t\nbtraverse f (Bazaar e) = getComp $ e (c . fmap ipure . f)\n \nThis is again analogous to the free monoid code. Comp is the analogue of Ap, and we use ipure in traverse. I mentioned that Bazaar is a comonad:\n \nextract :: Bazaar b b t -&gt; t\nextract (Bazaar e) = runIdentity $ e Identity\n \nAnd now we are finally prepared to not cheat:\n \nhonestTraverse\n  :: (Applicative f, Traversable t) =&gt; (a -&gt; f b) -&gt; t a -&gt; f (t b)\nhonestTraverse f = fmap extract . btraverse f . howBizarre\n \nSo, we can traverse by first turning out Traversable into some structure that's kind of like the free monoid, except having to do with Applicative, traverse that, and then pull a result back out. Bazaar retains the information that we're eventually building back the same type of structure, so we don't need any cheating.\nTo pull this back around to domains, there's nothing about this code to object to if done in a total language. But, if we think about our free Applicative-ish structure, in Haskell, it will naturally allow infinitary expressions composed of the Applicative operations, just like the free monoid will allow infinitary monoid expressions. And this is okay, because some Applicatives can make sense of those, so throwing them away would make the type not free, in the same way that even finite lists are not the free monoid in Haskell. And this, I think, is compelling enough to say that infinite traversals are right for Haskell, just as they are wrong for Agda.\nFor those who wish to see executable code for all this, I've put a files here and here. The latter also contains some extra goodies at the end that I may talk about in further installments.\n[1] Truth be told, I'm not exactly sure.\n[2] It turns out, you can generalize Bazaar to have a correspondence for every choice of p\n \nnewtype Bizarre p a b t =\n  Bizarre { bizarre :: forall f. p f =&gt; (a -&gt; f b) -&gt; f t }\n \nhence and forth above go through with the more general types. This can be seen here.\n    "
}