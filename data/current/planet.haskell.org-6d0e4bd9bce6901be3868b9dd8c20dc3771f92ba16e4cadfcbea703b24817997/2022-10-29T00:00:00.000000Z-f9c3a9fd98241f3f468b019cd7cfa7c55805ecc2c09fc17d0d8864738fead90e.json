{
  "title":"Spooky Masks and Async Exceptions",
  "date":"2022-10-29T00:00:00.000000Z",
  "author":null,
  "id":"https://www.parsonsmatt.org/2022/10/29/spooky_masks_and_async_exceptions.html",
  "link":"https://www.parsonsmatt.org/2022/10/29/spooky_masks_and_async_exceptions.html",
  "content":"Everyone loves Haskell because it makes concurrent programming so easy!\nforkIO is great, and you’ve got STM and MVar and other fun tools that are pleasant to use.\n\nWell, then you learn about asynchronous exceptions.\nThe world seems a little scarier - an exception could be lurking around any corner!\nAnyone with your ThreadId could blast you with a killThread or throwTo and you would have no idea what happened.\n\nThe async library hides a lot of this from you by managing the forkIO and throwTo stuff for you.\nIt also makes it easy to wait on a thread to finish, and receive exceptions that the forked thread died with.\nConsider how nice the implementation of timeout is here:\n\ntimeout :: Int -&gt; IO a -&gt; IO (Maybe a)\ntimeout microseconds action = do\n  withAsync (Just &lt;$&gt; action) $ \\a0 -&gt;\n  withAsync (Nothing &lt;$ threadDelay microseconds) $ \\a1 -&gt;\n      either id id &lt;$&gt; waitEither a0 a1\n\n\nThe async library uses asynchronous exceptions to signal that a thread must die.\nThe withAsync function guarantees that the forked thread is killed off when the inner action is complete.\nSo timeout will fork a thread to run Just &lt;$&gt; action, and then fork another thread to threadDelay.\nwaitEither accepts an Async a and an Async b and returns an IO (Either a b) - whichever one finishes first determines the return type.\nIf threadDelay finishes first, then we get a Right Nothing as the return, and exits.\nThis spells doom for the action thread.\n\nBut if our brave hero is able to escape before the deadline, it’s the threadDelay that gets killed!\n\nIndeed, this is a specialization of race :: IO a -&gt; IO b -&gt; IO (Either a b), which runs two IO actions in separate threads.\nThe first to complete returns the value, and the remaining thread is sacrificed to unspeakable horrors.\n\nBut, you really shouldn’t catch or handle async exceptions yourself.\nGHC uses them to indicate “you really need to shut down extremely quickly, please handle your shit right now.”\nThreadKilled is used to end a thread’s execution, and UserInterrupt means that you got a SIGINT signal and need to stop gracefully.\nThe async package uses AsyncCancelled to, well, cancel threads.\nHowever, the base package’s Control.Exception has a footgun: if you catch-all-exceptions by matching on SomeException, then you’ll catch these async exceptions too!\n\nNow, you should pretty much never be catching SomeException, unless you really really know what you’re doing.\nBut I see it all the time:\n\nimport Control.Exception (catch)\n\nblah = \n    Just &lt;$&gt; coolThing \n        `catch` \\(SomeException e) -&gt; do\n            reportException e\n            pure Nothing\n\n\nIf coolThing receives a ThreadKilled or an AsyncCancelled or UserInterrupt or anything else from throwTo, it’ll catch it, report it, and then your program will continue running.\nThen the second Ctrl-C comes from the user, and your program halts immediately without running any cleanup.\nThis is pretty dang bad!\nYou really want your finally calls to run.\n\nYou search for a bit, and you find the safe-exceptions package.\nIt promises to make things a lot nicer by not catching async exceptions by default.\nSo our prior code block, with just a change in import, becomes much safer:\n\nimport Control.Exception.Safe (catch)\n\nblah = \n    Just &lt;$&gt; coolThing \n        `catch` \\(SomeException e) -&gt; do\n            reportException e\n            pure Nothing\n\n\nThis code will no longer catch and report an async exception.\nHowever, the blocks in your finally and bracket for cleanup will run!\n\nUnfortunately, the safe-exceptions library (and the unliftio package which uses the same behavior), have a dark secret…\n\n*thunder claps in the distance, as rain begins to fall*\n\n… they wear spooky masks while cleaning! WowowoOOOoOoOooOooOOooOooOOo\n\nNo, really, they do something like this:\n\nbracket provide cleanup action = \n    Control.Exception.bracket\n        provide\n        (\\a -&gt; \n            Control.Exception.uninterruptibleMask_ $ \n                cleanup a)\n        action\n\n\nThis code looks pretty innocuous.\nIt even says that it’s good! \n“Your cleanup function is guaranteed not to be interrupted by an asynchronous exception.”\nSo if you’re cleaning things up, and BAMM a vampire ThreadKills you, you’ll finish your cleanup before rethrowing.\nThis might just be all you need to make it out of the dungeon alive.\n\nBehind the sweet smile and innocent demeanor of the safe-exceptions package, though, is a dark mystery - and a vendetta for blood.\nWell, maybe not blood, but I guess “intercompatibility of default expectations”?\n\nA Nightmare Scenario: Night of the Living Deadlock\n\nOnce, a brave detective tried to understand how slow the database was.\nBut in her studies, she accidentally caused the the entire app to deadlock and become an unkillable zombie?!\n\nThere are three actors in this horror mystery.\nMr DA, the prime suspect.\nAlice, our detective.\nAnd Bob, the unassuming janitor.\n\nMr Database Acquisition\n\nOne of the suspected villains is Mr. Database Acquisition, a known rogue.\nUsually, Mr. Database Acquisition works quickly and effectively, but sometimes everything stops and he’s nowhere to be found.\nWe’re already recording how long he takes by measuring the job completion time, but if the job never finishes, we don’t know anything.\n\nThe database connection is provided from a resource-pool Pool, which is supposed to be thread safe and guarantee resource allocation.\nBut something seems shady about it…\n\nAlice\n\nAlice is a performance engineer and lead detective.\nShe’s interested in making the codebase faster, and to do so, she sets up inspection points to log how long things are taking.\n\nAlice cleverly sets up a phantom detective - a forked thread that occasionally checks in on Mr Database.\n\nwithAcquisitionTimer\n    :: (IO () -&gt; IO r) -&gt; IO r\nwithAcquisitionTimer action = do\n    timeSpent "
}