{
  "title":"Namespaced De Bruijn indices",
  "date":"2021-08-14T13:01:54.000000-07:00",
  "author":"Gabriel Gonzalez",
  "id":"tag:blogger.com,1999:blog-1777990983847811806.post-6319221858421997722",
  "link":"https://www.haskellforall.com/2021/08/namespaced-de-bruijn-indices.html",
  "content":"namespaced-debruijn    In this post I share a trick I use for dealing with bound variables in Dhall that I thought might be useful for other interpreted programming languages. I have no idea if this trick has been introduced before but if it has then just let me know and I’ll acknowledge any prior art here.Edit: Todd Wilson points out that Mark-Oliver Stehr’s CINNI originally introduced this idea.The brief explanation of the trick is: instead of choosing between a named or a nameless representation for bound variables you can get the best of both worlds by namespacing De Bruijn indices by variable names. This simplifies the implementation and in some cases improves the end user’s experience.The rest of this post is a longer explanation of the above summary, starting with an explanation of the trick and followed by a review of the benefits of this approach.BackgroundI’d like to first explain what I mean by “named” and “nameless” representations before I explain the trick.A named representation of the lambda calculus syntax tree typically looks something like this:data Syntax    = Variable String    | Lambda String Syntax    | Apply Syntax SyntaxFor example, if the user wrote the following Haskell-like code:\\f -&gt; \\x -&gt; f x… then that would correspond to this syntax tree:example :: Syntaxexample = Lambda &quot;f&quot; (Lambda &quot;x&quot; (Apply (Variable &quot;f&quot;) (Variable &quot;x&quot;)))The named representation has the nice property that it preserves the original variable names … well, sort of. This representation definitely preserves the variable names when you initially parse the code into the syntax tree, but if you β-reduce an expression you can potentially run into problems.For example, consider this expression:\\x -&gt; (\\y -&gt; \\x -&gt; y) x… which corresponds to this syntax tree:Lambda &quot;x&quot; (Apply (Lambda &quot;y&quot; (Lambda &quot;x&quot; (Variable &quot;y&quot;))) (Variable &quot;x&quot;))If you try to β-reduce (\\y -&gt; \\x -&gt; y) x without renaming any variables then you get the following incorrect result:\\x -&gt; \\x -&gt; xThis bug is known as “name capture” and capture-avoiding substitution requires renaming one of the variables named x so that the inner x does not shadow the outer x. For example, we could fix the problem by renaming the outer x to x1 like this:\\x1 -&gt; \\x -&gt; x1A nameless representation tries to work around these name capture issues by replacing the variable names with numeric indices (known as De Bruijn indices):data Syntax    = Variable Int    | Lambda Syntax    | Apply Syntax SyntaxFor example, code like this:\\f -&gt; \\x -&gt; f x… corresponds to this nameless representation:example :: Syntaxexample = Lambda (Lambda (Apply (Variable 1) (Variable 0)))Carefully note that the Lambda constructor now has no field for the bound variable name, so it’s as if the user had instead written:\\ -&gt; \\ -&gt; @1 @0… using @n to represent the variable whose De Bruijn index is n.The numeric De Bruijn indices refer to bound variables. Specifically, the numeric index 0 refers to the “closest” or “innermost” variable bound by a lambda:--                This 0 index …--                ↓    \\ -&gt; \\ -&gt; @1 @0--       ↑ … refers to the variable bound by this lambda… and incrementing the index moves to the next outermost lambda:--             This 1 index …--             ↓    \\ -&gt; \\ -&gt; @1 @0--  ↑ … refers to the variable bound by this lambdaDe Bruijn indices avoid name collisions between bound variables, but they require you to do additional work if you wish to preserve the original variable names. There are several ways to do so, and I’ll present my preferred approach.The trick - Part 1We can get the best of both worlds by combining the named and nameless representations into a hybrid representation like this:data Syntax    = Variable String Int    | Lambda String Syntax    | Apply Syntax SyntaxI call this representation “namespaced De Bruijn indices”.This is almost the exact same as our named representation, except that we have now added an Int field to the Variable constructor. This Int field is morally the same as the De Bruijn index in the nameless representation, except that this time the De Bruijn index is “namespaced” to a specific variable name.The easiest way to explain this is with a few examples.The following expression:\\x -&gt; \\y -&gt; \\x -&gt; x@0… corresponds to this syntax tree:Lambda &quot;x&quot; (Lambda &quot;y&quot; (Lambda &quot;x&quot; (Variable &quot;x&quot; 0)))… and this curried function returns the third function argument:--                    This …--                    ↓    \\x -&gt; \\y -&gt; \\x -&gt; x@0--               ↑ … refers to this bound variable… because that is the innermost bound variable named x.Similarly, the following expression:\\x -&gt; \\y -&gt; \\x -&gt; y@0… corresponds to this syntax tree:Lambda &quot;x&quot; (Lambda &quot;y&quot; (Lambda &quot;x&quot; (Variable &quot;y&quot; 0)))… which returns the second function argument:--                    This …--                    ↓    \\x -&gt; \\y -&gt; \\x -&gt; y@0--         ↑ … refers to this bound variable… because that is the innermost bound variable named y.Carefully note that our variable still has a De Bruijn index of 0, but we ignore the innermost bound variable named x because we also pair our De Bruijn index with name of the variable we are referring to (y) so we only count bound variables named y when resolving the De Bruijn index.Finally, the following expression:\\x -&gt; \\y -&gt; \\x -&gt; x@1… corresponds to this syntax tree:Lambda &quot;x&quot; (Lambda &quot;y&quot; (Lambda &quot;x&quot; (Variable &quot;x&quot; 1)))… which returns the first function argument:--                    This …--                    ↓    \\x -&gt; \\y -&gt; \\x -&gt; x@1--   ↑ … refers to this bound variableThe De Bruijn index is 1, which means that it refers to the second innermost (0-indexed) bound variable named x.Notice how this representation lets us refer to shadowed variables by their index. These De Bruijn indices are not an internal implementation detail, but are actually available to the user as part of the surface syntax of the language.However, we want to avoid littering the code with these De Bruijn indices, which brings us to the second part of the trick.The trick - Part 2The next step is to add syntactic sugar to the language by allowing users to omit the index in the source code, which defaults the index to 0. This means that an expression that never references shadowed variables never needs to specify a De Bruijn index.For example, instead of writing this:\\x -&gt; \\y -&gt; \\x -&gt; x@0… we can elide the index to simplify the code to:\\x -&gt; \\y -&gt; \\x -&gt; x… which will still parse as:Lambda &quot;x&quot; (Lambda &quot;y&quot; (Lambda &quot;x&quot; (Variable &quot;x&quot; 0)))Similarly, we can simplify this:\\x -&gt; \\y -&gt; \\x -&gt; y@0… to this:\\x -&gt; \\y -&gt; \\x -&gt; y… which will still parse as:Lambda &quot;x&quot; (Lambda &quot;y&quot; (Lambda &quot;x&quot; (Variable &quot;y&quot; 0)))However, we cannot use this syntactic sugar to simplify the final example:\\x -&gt; \\y -&gt; \\x -&gt; x@1… since the index is non-zero. Any code that references a shadowed variable still needs to use an explicit De Bruijn index to do so.Vice versa, we also omit zero indices when pretty-printing code. When we pretty-print this syntax tree:Lambda &quot;x&quot; (Lambda &quot;y&quot; (Lambda &quot;x&quot; (Variable &quot;x&quot; 0)))… we don’t include the index:\\x -&gt; \\y -&gt; \\x -&gt; xThis syntactic sugar ensures that most users do not need to be aware that indices exist at all when writing code. The user only encounters the indices in two scenarios:The user wishes to explicitly reference a shadowed variableFor example, in the following expression:\\x -&gt; \\y -&gt; \\x -&gt; x@1… the user might prefer to use the built-in language support for disambiguating variables of the same name rather than renaming one of the two variables named x.The indices appear in a β-reduced resultFor example, this expression has no user-visible De Bruijn indices:\\x -&gt; (\\y -&gt; \\x -&gt; y) x… but if you β-reduce the expression (I’ll cover how in the Appendix) and pretty-print the β-reduced expression then the result will introduce a non-zero De Bruijn index to disambiguate the two variables named x:\\x -&gt; \\x -&gt; x@1In fact, the latter scenario is the reason I originally adopted this trick: I wanted to be able to display β-reduced functions to the end user while preserving the original variable names as much as possible.Note that De Bruijn indices don’t appear when a β-reduced expression does not reference any shadowed variables. For example, if you β-reduce this expression:(\\f -&gt; f f) (\\x -&gt; x)… the result has no De Bruijn index (because the index is 0 and is therefore elided by the pretty-printer):\\x -&gt; xThe trick - Part 3One of the benefits of the traditional nameless representation using (non-namespaced) De Bruijn indices is that you get α-equivalence for free. Two nameless expressions are α-equivalent if they are syntactically identical. We can build upon this useful property to derive a compact algorithm for α-equivalence of “namespaced De Bruijn indices”.The trick is to recognize that namespaced De Bruijn indices reduce to ordinary De Bruijn indices in the degenerate case when you rename all variables to the same name. I’ll call this renaming process “α-reduction”.For example, if we α-reduce the following expression by renaming all of the: variables to _:\\x -&gt; \\y -&gt; \\x -&gt; x@1… then we get this result:\\_ -&gt; \\_ -&gt; \\_ -&gt; _@2See the Appendix for the α-reduction algorithm.Equipped with α-reduction, then we can derive α-equivalence: two expressions are α-equivalent if their α-reduced forms are syntactically identical.For example, this expression:\\x -&gt; x… and this expression:\\y -&gt; y… both α-reduce to:\\_ -&gt; _… so they are α-equivalent.BenefitsThere are a few benefits of using this trick that motivate me to use this in all of my interpreted languages:This trick improves the readability of β-reduced functionsβ-reduced functions preserve the original variable names and this trick doesn’t suffer from the rename-related name pollution that plagues other capture-avoiding substitution algorithms. In particular, β-reduced expressions only display De Bruijn indices when absolutely necessary (if they reference a shadowed variable) and they otherwise use the original pristine variable names.This trick simplifies the internal implementationYou don’t need to maintain two separate syntax trees for a named and nameless representation. You can use the same syntax tree for both since any named syntax tree can be α-reduced to give the equivalent nameless syntax tree.This trick enables userland support for referencing shadowed variablesI know some people think that referencing shadowed variable names is a misfeature. However, I personally feel that resolving name collisions by adding ' or _ characters to the end of variable names is less principled than having language support for resolving name collisions using optional De Bruijn indices.(Not shown) This trick can sometimes improve type errorsTo be precise, this trick improves the inferred types displayed in error messages when using explicit universal quantification.Type variables also have to avoid name collisions, so if you use the same namespaced De Bruijn representation for your types then you avoid polluting your inferred types and error messages with junk type variables like a14.This post doesn’t cover the equivalent type-level trick, but you can refer to the Dhall standard if you need an example of a language that uses this trick.ConclusionI believe that namespaced De Bruijn indices are most appropriate for languages that are (A) strongly normalizing (like Dhall) and (B) interpreted, because such languages tend to support pretty-printing β-reduced functions.I think this trick is also useful to a lesser extent for all interpreted languages, if only because the implementation is (in my opinion) simpler and more elegant than other algorithms for capture-avoiding substitution (See the Appendix below).On the other hand, compiled languages will likely not benefit much from this trick since they typically have no need to preserve the original variable names and they also will use an intermediate representation that is very different from the concrete syntax tree.Appendix - ImplementationThis section provides Haskell code specifying how to α-reduce and β-reduce a syntax tree that uses namespaced De Bruijn indices.This reference implementation is not the most efficient implementation, but it’s the simplest one which I use for pedagogical purposes. If you’re interested in efficiency then check out my Grace project, which mixes this trick with the more efficient normalization-by-evaluation algorithm.I also don’t include code for the parser or pretty-printer, because the only interesting part is the syntactic sugar for handling variables with a De Bruijn index of 0. Again, check out Grace if you want to refer to a more complete implementation.-- | Syntax treedata Syntax    = Variable String Int    | Lambda String Syntax    | Apply Syntax Syntax    deriving (Eq, Show){-| Increase the index of all bound variables matching the given variable name    This is modified from the Shifting definition in Pierce's \\&quot;Types and    Programming Languages\\&quot; by adding an additional argument for the namespace    to shift-}shift    :: Int    -- ^ The amount to shift by    -&gt; String    -- ^ The variable name to match (a.k.a. the namespace)    -&gt; Int    -- ^ The minimum bound for which indices to shift    -&gt; Syntax    -- ^ The expression to shift    -&gt; Syntaxshift offset namespace minIndex syntax =    case syntax of        Variable name index -&gt; Variable name index'          where            index'                | name == namespace &amp;&amp; minIndex &lt;= index = index + offset                | otherwise                              = index        Lambda name body -&gt; Lambda name body'          where            minIndex'                | name == namespace = minIndex + 1                | otherwise         = minIndex            body' = shift offset namespace minIndex' body        Apply function argument -&gt; Apply function' argument'          where            function' = shift offset namespace minIndex function            argument' = shift offset namespace minIndex argument{-| Substitute the given variable name and index with an expression    This is modified from the Substitution definition in Pierce's \\&quot;Types and    Programming Languages\\&quot; by adding an additional argument for the variable    index-}substitute    :: Syntax    -- ^ The expression to substitute into    -&gt; String    -- ^ The name of the variable to replace    -&gt; Int    -- ^ The index of the variable to replace    -&gt; Syntax    -- ^ The expression to substitute in place of the given variable    -&gt; Syntaxsubstitute expression name index replacement =    case expression of        Variable name' index'            | name == name' &amp;&amp; index == index' -&gt; replacement            | otherwise                        -&gt; Variable name' index'        Lambda name' body -&gt; Lambda name' body'          where            index'                | name == name' = index + 1                | otherwise     = index            shiftedBody = shift 1 name' 0 replacement            body' = substitute body name index' shiftedBody        Apply function argument -&gt; Apply function' argument'          where            function' = substitute function name index replacement            argument' = substitute argument name index replacement-- | β-reduce an expressionbetaReduce :: Syntax -&gt; SyntaxbetaReduce syntax =    case syntax of        Variable name index -&gt; Variable name index        Lambda name body -&gt; Lambda name body'          where            body' = betaReduce body        Apply function argument -&gt;            case function' of                Lambda name body -&gt; body'                  where                    shiftedArgument = shift 1 name 0 argument                    substitutedBody = substitute body name 0 shiftedArgument                    unshiftedBody = shift (-1) name 0 substitutedBody                    body' = betaReduce unshiftedBody                _ -&gt; Apply function' argument'          where            function' = betaReduce function            argument' = betaReduce argument-- | α-reduce an expressionalphaReduce :: Syntax -&gt; SyntaxalphaReduce syntax =    case syntax of        Variable name index -&gt; Variable name index        Lambda name body -&gt; Lambda &quot;_&quot; body'          where            shiftedBody = shift 1 &quot;_&quot; 0 body            substitutedBody = substitute shiftedBody name 0 (Variable &quot;_&quot; 0)            unshiftedBody = shift (-1) name 0 substitutedBody            body' = alphaReduce unshiftedBody        Apply function argument -&gt; Apply function' argument'          where            function' = alphaReduce function            argument' = alphaReduce argument-- | Returns `True` if the two input expressions are α-equivalentalphaEquivalent :: Syntax -&gt; Syntax -&gt; BoolalphaEquivalent left right = alphaReduce left == alphaReduce rightAppendix - HistoryI actually first introduced this feature in Morte, not Dhall. The idea originated from the discussion on this issue.\n    "
}