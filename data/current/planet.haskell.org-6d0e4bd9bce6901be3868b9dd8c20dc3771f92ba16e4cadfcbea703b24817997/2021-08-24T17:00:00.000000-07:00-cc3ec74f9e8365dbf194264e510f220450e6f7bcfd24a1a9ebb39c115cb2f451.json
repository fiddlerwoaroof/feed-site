{
  "title":"Daily ICFP: Day 2",
  "date":"2021-08-24T17:00:00.000000-07:00",
  "author":null,
  "id":"https://tweag.io/blog/2021-08-25-icfp2/",
  "link":"https://tweag.io/blog/2021-08-25-icfp2/",
  "content":"Daily ICFP\nSeveral Tweagers all agreed to gather notes here about our\nICFP (International Conference on Functional\nProgramming) experiences.\nOther posts in this series:\n\nICFP - Day 0\nICFP - Day 1\nICFP - Day 3\nICFP - Day 4\nICFP - Day 5\n\nDay 2 - Tuesday\nThese notes follow Noon, Arnaud, and Richard through their day at ICFP,\nroughly in order.\nRichard — Watched the video for Symbolic and Automatic Differentiation\nof\nLanguages,\nby Conal Elliott. Conal’s papers and talks are always\nvery insightful — because they are always very simple. Conal has a\nremarkable knack for taking problems that seem complex and reducing them to\ntheir essence — often, a simple compositional language. This work fits very\nmuch in this vein, describing how we can derive parsers for a language\nstraight from its definition. The talk is gentle and mind-blowing all at the\nsame time.\nNoon — Higher-Order Probabilistic Adversarial Computations\n\nWondering if this is related to Adversarial Machine Learning.\nI think maybe; but it seems to be focused on categorising types of adversaries via type theory?\nIt got quite technical for me quite quickly, but it’s at least interesting to see a totally different take on this concept!\n\nNoon — How to Evaluate Blame for Gradual Types\n\nInterested in this because I was curious about Gradual Types.\n“The Rational Programmer” - Seems cute/interesting; but also maybe a bit fraught because I think comparing the idea to the usage in economics is a mistake, as I believe it’s widely considered to be one of the biggest mistakes in economics to assume rational agents!\n\nNoon — Symbolic and Automatic Differentiation of Languages\n\nAlways relaxing to listen to Conal talk.\nI learned that the derivatives Conal talks about initially are these: Brzozowski derivative\nHe then relates this to differential calculus!\nHe then describes automatic and symbolic differentiation in this setting, and using this, builds language derivatives.\nThe conclusion is that these two things have the same structure with different interpretations. Very cool.\n\nRichard — I attended both Q&amp;A sessions for my own paper, An Existential\nCrisis Resolved: Type Inference for First-Class Existential\nTypes.\nThe first session went for 30 minutes, and the second session went for an\nhour. This is a wonderful aspect of the online format: we have as much time as\nwe want to discuss a paper. There was considerable interest in an\nimplementation. A few other tidbits:\n\nThe approach to existential types in the paper requires including\nexpressions in types. In order to compute type equality, then, we must\ndefine what expressions are equal to one another. A simple starting point\nfor an expression equivalence relation is to use syntactic equality. Thus,\n1 + 1 would equal 1 + 1, but it wouldn’t equal 2. We can get cleverer\nover time. However, there is immediately a problem: GHC might optimize an\nexpression. For example, it might change let x = 5 in 10 to be just 10\n(x was unused). But these expressions are not considered equal in types,\nso the optimization has the possibility of destroying the well-typedness of\nan expression. The solution is likely that we will have to have Core\ncoercions (a coercion is essentially a little expression that says that two\ncertain types are equal) that witness the correctness of optimization\npasses.\nRust has a feature called impl traits (I think) that are essentially\nexistentials. They seem strictly less powerful than what we’ve proposed in\nthis paper, but I need to learn more about what Rust does.\n\nNoon — How to design co-programs\n\nWhere do programs come from? Programs come from data structure.\nMostly we talk about input data structure; but should also talk about output data structure!\nIf you use this idea, you get a different algorithm for the sorting example.\nOverall I like the idea; I feel like there’s probably more fruit to be gained from it.\n\nNoon — PLTea\n\nChat 1 - Very nice chat hearing about bidirectional programs.\nChat 2 - Had a nice chat about CLaSH and formal verification.\n\nNoon — SIGPLAN CARES\n\nVery nice chat about feeling included/excluded at a conference.\nWas very well moderated by Simon Peyton-Jones; left me feeling very hopeful.\n\nNoon — Leibniz equality is isomorphic to Martin-Löf identity\n\nLooked interesting; didn’t follow it all.\nMy main conclusion: I need to learn more Agda.\n\nNoon — PLTea #2\n\nLess good; conversations were a bit dominated by one or two people.\n\nNoon — Building PL-Powered Systems for Humans\n\nDescribing interesting UIs and programming synthesis in evaluating MOOC programming tasks.\nNice discussion around how to let the users control the search space.\nInteresting paper to look into: Assuage.\nInteresting keynote idea to interview another researcher during your talk!\nMostly enjoyed the interview, but sometimes got a bit lost when there wasn’t any text/graphics to ground the conversation.\n\nArnaud — There have been several discussions on quantitative\nevaluation of programming-language tools. The first was in How to\nEvaluate Blame for Gradual\nTypes. It\nisn’t obvious from the title, but this paper is about building a model\nof the programming activity in order to be able to quantify the effect\nof error messages in the debugging process. The second such discussion\nwas during the keynote (see previous paragraph) where the difficulty\nof quantifying effects in programming language was raised and Elena\nGlassman said that she favoured qualitative evaluation. This is a very\nimportant discussion, programming languages is a field where tools and\ntechnologies are rarely evaluated for their real-world relevance\nrather than their theoretical elegance. I contend that we don’t know\nhow to evaluate programming languages yet, so it’s always exciting to\nsee people make steps in this direction.\nNoon — Dinner\n\nGot a nice intro to the ‘Granule’ programming language from Dominic Orchard and Jack Hughes.\nLearned that there is such a thing as types indexed by continuous variables!\n\nRichard — Enjoyed the trivia night, quickly becoming a SIGPLAN conference\ntradition, hosted by José Calderón and Paulette Koronkevich. We formed a team\nrather randomly at one of the conference tables and then proceeded to win.\nIt turns out that recognizing a small detail of a Hieronymus Bosch painting\ncan come in handy!\n(Richard attended less of ICFP than usual today, due to the need to execute\ntravel plans that had been delayed by Hurricane/Tropical Storm Henri over the\nweekend. More action tomorrow and future days!)\n    "
}