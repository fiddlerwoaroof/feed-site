{
  "title":"Break Gently with Pattern Synonyms",
  "date":"2022-11-02T00:00:00.000000Z",
  "author":null,
  "id":"https://www.parsonsmatt.org/2022/11/02/break-gently-pattern-syn.html",
  "link":"https://www.parsonsmatt.org/2022/11/02/break-gently-pattern-syn.html",
  "content":"This is a really brief post to call out a nice trick for providing users a nice migration message when you delete a constructor in a sum type.\n\nThe Problem\n\nYou have a sum type, and you want to delete a redundant constructor to refactor things.\n\ndata Foo \n    = Bar Int \n    | Baz Char\n    | Quux Double\n\n\nThat Quux is double trouble.\nBut if we simply delete it, then users will get a Constructor not found: Quux.\nThis isn’t super helpful.\nThey’ll have to go find where Quux came from, what package defined it, and then go see if there’s a Changelog.\nIf not, then they’ll have to dig through the Git history to see what’s going on.\nThis isn’t a fun workflow.\n\nBut, let’s say you really need end users to migrate off Quux.\nSo we’re interested in giving a compile error that has more information than Constructor not in scope.\n\nHere’s what some calling code looks like:\n\nblah :: Foo -&gt; Int\nblah x = case x of\n    Bar i -&gt; i\n    Baz c -&gt; fromEnum c\n    Quux a -&gt; 3\n\n\nwill give the output:\n\n/home/matt/patsyn.hs:24:5: error:\n    Not in scope: data constructor ‘Quux’\n   |\n24 |     Quux a -&gt; 3\n   |     ^^^^\nFailed, no modules loaded.\n\n\nFortunately, we can make this nicer.\n\nGHC gives us a neat trick called PatternSynonyms.\nThey create constructor-like things that we can match on and construct with, but that are a bit smarter.\n\nMatching\n\nLet’s redefine Quux as a pattern synonym on Foo.\nWe’ll also export it as part of the datatype definition.\n\n{-# language PatternSynonyms, ViewPatterns #-}\n\nmodule Wow (Foo (.., Quux)) where\n\ndata Foo\n    = Bar Int\n    | Baz Char\n\npattern Quux :: a -&gt; Foo\npattern Quux i "
}