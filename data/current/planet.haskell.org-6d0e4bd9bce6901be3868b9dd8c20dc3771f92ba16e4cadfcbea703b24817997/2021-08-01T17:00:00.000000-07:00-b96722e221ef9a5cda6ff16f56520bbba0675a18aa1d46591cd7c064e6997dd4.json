{
  "title":"Best practices for foreign imports",
  "date":"2021-08-01T17:00:00.000000-07:00",
  "author":"ben",
  "id":"http://www.well-typed.com/blog/2021/08/capi-usage",
  "link":"https://well-typed.com/blog/2021/08/capi-usage",
  "content":"editorial note: This is a cross-post of a post originally written for the GHC developers’ blog.\ntl;dr: When importing system libraries we strongly recommend that users use GHC’s capi calling convention. For details, see the recommendations section below.\nOne of Haskell’s strengths is its great foreign function interface: using time-tested foreign libraries or raw system calls is just a foreign import away. However, while syntactically simple, safely using foreign functions can be quite tricky. A few weeks ago we saw one facet of this problem in the keepAlive# post. This week we will look at another complexity which has recently caused us trouble: calling conventions.\n\nWhy this matters\nWith the increasing prevalance of ARM hardware with Apple’s recent releases, many latent bugs due to calling convention details are becoming more visible.\nFor instance, in #20079 it was noticed that GHCi crashes on AArch64/Darwin when the terminal window is resized. We eventually found that this was due to a bug in haskeline: ioctl, a variadic function, was imported using GHC’s ccall calling convention. The fix is straightforward: use the capi pseudo-calling convention introduced in GHC 7.10.1.\nIt turns out that incorrect ioctl imports is rather common pattern among Hackage packages. Consequently, we thought it would be helpful to offer some explicit guidance for users.\nBackground: Foreign calling conventions\nDuring a function call both the caller and the callee must agree on several operational details:\n\nwhen the function is called:\n\nwhich arguments can be passed in registers?\nin what order are the remaining arguments pushed to the stack?\nhow are variadic functions handled?\nmust the stack be aligned?\nwhere is the return address found?\n\nwhen the function returns:\n\nwho is responsible for popping the arguments from the stack?\nwhere is the return value(s) stored?\n\n\nTogether, these details are known as a calling convention and are typically implied by the operating system and target architecture. For instance, x86-64 Linux (and most other POSIX platforms) typically uses the System V amd64 calling convention whereas 32-bit Windows has no fewer than three commonly-used conventions.\nWhen compiling C source, the C compiler determines a function’s calling convention using its signature, which typically appears in a header file. However, when GHC imports a function with the usual ccall calling convention, e.g.:\nforeign import ccall &quot;hello_world&quot; helloWorld :: IO ()\nit does not have the benefit of a signature; instead it must infer the calling convention from the type given by the import. This can break in two ways:\n\nmany calling conventions treat variadic functions (e.g. printf) differently from the corresponding non-variadic signature; while it is documented that ccall does not support variadic functions, this fact is not well-known by users.\nthe type provided by the user may be wrong (e.g. using Int instead of CInt)\n\nUnfortunately, with the foreign import ccall mechanism the compiler has no way of catching such issues, potentially leaving the user with difficult-to-spot, platform-dependent soundness bugs.\nSafe foreign calls via CApiFFI\nTo address help mitigate this class of bugs, GHC 7.10 introduced a new language extension, CApiFFI, which offers a more robust way to import foreign functions. Unlike ccall, capi requires that the user specify both the foreign function’s name as well as the name of the header file where its signature can be found. For instance, one can write:\nforeign import capi &quot;stdio.h puts&quot; c_puts :: Ptr CChar -&gt; IO CInt\nTo compile this, GHC will construct a C source file which #include’s stdio.h. and defines a stub function which performs the call:\n#include &quot;stdio.h&quot;\nHsInt32 ghczuwrapperZC0ZCmainZCHelloZCputs(void* a1) {\n    return puts(a1);\n}\nThis approach brings a few advantages:\n\ncapi imports can be used to import functions defined using CPP\nthe calling convention is decided by the C compiler using the signature provided in the indicated header file, eliminating the potential for inconsistency\nvariadic functions “just work”\nit removes the need to worry about which of Windows’ zoo of supported conventions is used (see #12890, #3052)\n\nRecommendations for users\nAs a rule, the easiest code to debug is the code that you don’t need to write. Consequently, users are encouraged to use existing bindings libraries (e.g. unix) instead of defining their own foreign imports when possible.\nOf course, not all libraries have bindings available. In these cases we recommend that users use foreign import capi for imports of libraries not under their control (e.g. system libraries).\nNote, however, that capi does incur a small (arguably negligible) runtime cost due to the to the C stub. It is justifiable to use ccall to avoid this runtime cost in cases where the foreign function is shipped with a package’s cbits, where the calling convention is clear.\n    "
}