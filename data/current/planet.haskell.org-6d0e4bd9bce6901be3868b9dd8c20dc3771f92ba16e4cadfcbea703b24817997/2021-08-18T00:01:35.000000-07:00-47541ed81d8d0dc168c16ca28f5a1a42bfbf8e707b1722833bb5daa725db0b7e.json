{
  "title":"Abstraction in Reflex and CodeWorld",
  "date":"2021-08-18T00:01:35.000000-07:00",
  "author":"Chris Smith",
  "id":"https://medium.com/p/a1b42ad36923",
  "link":"https://itnext.io/abstraction-in-reflex-and-codeworld-a1b42ad36923?source=rss-18bd5acaea78------2",
  "content":"I’ve put together a neat example lately of using FRP (Functional Reactive Programming) to cleanly separate and model the interactions of the pieces of an interactive application: in this case, an RPN (Reverse Polish Notation) calculator. In this article, I present the Haskell code for this application using the Reflex FRP library and the CodeWorld graphics API.An RPN CalculatorBecause CodeWorld is a relatively low-level graphics API, we’ll be reinventing abstractions like numeric entry fields. Don’t think that’s a fundamental part of FRP! Indeed, libraries like reflex-dom provide you all the power of traditional high-level component libraries using the same FRP. But I think starting from the ground up is a nice learning experience; we can see how to work up from very simple primitives to build higher-level components, and you can apply the same abstraction techniques to build application-specific abstractions in your own code.The calculator we’ll obtain at the end of the series is at this link:CodeWorldIt definitely has some deficiencies:Rendering of very precise numbers is lacking.You cannot enter negative numbers.Lots of important operations are missing.Consider these exercises for the interested reader. I’ve only implemented enough to make the abstraction techniques clear, and never intended for this to be a production quality calculator!Basic DefinitionsIf you’re not familiar with FRP, the idea is to model the interactive parts of your software in terms of two abstractions: events and behaviors. An event is a thing that occurs at discrete moments in time, such as a key press or a mouse click. (If you’re used to conventional GUI programming, beware: in FRP, an event is not a single occurrence of the thing, but rather the entire thing which can occur many times.) A behavior is a value that changes over time, such as a mouse position. (Again, a behavior isn’t a value at a specific time, but rather the entire concept of something like a mouse position that changes over time.)Reflex adds a third abstraction that’s a sort of hybrid between the two. A dynamic value is a value that changes only at discrete points in time. Because it does change over time, its current value forms a behavior. But because it changes at discrete points in time, its updates form an event.Starting with ButtonsOne thing we’ll need for a calculator that CodeWorld doesn’t provide for us is buttons! On the one hand, buttons are pretty simple things: you click on them and they do something. However, as we’ll see, getting an intuitive and user-friendly button experience is non-trivial and worth abstracting over!Here’s a Reflex program using CodeWorld to create a simple (not very user-friendly) button.CodeWorldThe source code is:{-# LANGUAGE OverloadedStrings #-}import CodeWorld.Refleximport Control.Monad.IO.Classimport Data.Functor (($&gt;))import Data.Text (Text)import Reflexbutton :: ReflexCodeWorld t m =&gt; Text -&gt; m (Event t ())button label =  do    draw (pure (rectangle 5 2 &lt;&gt; lettering label))    clicks "
}