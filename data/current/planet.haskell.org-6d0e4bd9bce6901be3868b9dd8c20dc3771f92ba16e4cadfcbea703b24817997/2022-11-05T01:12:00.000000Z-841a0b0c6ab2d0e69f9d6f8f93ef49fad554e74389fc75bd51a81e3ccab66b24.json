{
  "title":"A map of Haskell's numeric types",
  "date":"2022-11-05T01:12:00.000000Z",
  "author":"Mark Dominus",
  "id":"tag:,2022:/prog/haskell/numbers",
  "link":"https://blog.plover.com/prog/haskell/numbers.html",
  "content":"I keep getting lost in the maze of Haskell's numeric types.  Here's\nthe map I drew to help myself out.  (I think there might have been something like\nthis in the original Haskell 1998 report.)\n\n\n\n (PNG version) (Original DOT file (The SVG\nabove is hand-edited graphviz\noutput))\n\nOvals are typeclasses.  Rectangles are types.  Black mostly-straight\narrows show instance relationships.  Most of the defined functions\nhave straightforward types like  or\n or .\nThe few exceptions are shown by wiggly colored arrows.\n\nBasic plan\n\nAfter I had meditated for a while on this picture I began to\nunderstand the underlying organization.  All numbers support  and\n.  And there are three important properties numbers might\nadditionally have:\n\n\nOrd : ordered; supports  etc.\nFractional : supports division\nEnum: supports ‘pred’ and ‘succ’ \n\n\nIntegral types are both Ord and Enum, but they are not\nFractional because integers aren't closed under division.\n\nFloating-point and rational types are Ord and Fractional but not\nEnum because there's no notion of the ‘next’ or ‘previous’ rational\nnumber.\n\nComplex numbers are numbers but not Ord because they don't admit a\ntotal ordering.  That's why Num plus Ord is called Real: it's\n‘real’ as constrasted with ‘complex’.\n\nMore stuff\n\nThat's the basic scheme.   There are some less-important elaborations:\n\nReal plus Fractional is called RealFrac.\n\nFractional numbers can be represented as exact rationals or as\nfloating point.  In the latter case they are instances of\nFloating. The Floating types are required to support a large\nfamily of functions like  and π.\n\nYou can construct a Ratio a type for any a; that's a fraction\nwhose numerators and denominators are values of type a.  If you do this, the\nRatio a that you get is a Fractional, even if a wasn't one.  In particular,\nRatio Integer is called Rational and is (of course) Fractional.\n\nShuff that don't work so good\n\nComplex Int and Complex Rational look like they should exist, but\nthey don't really. Complex a is only an instance of Num when a\nis floating-point.  This means you can't even do 3 :: Complex\nInt — there's no definition of fromInteger.\nYou can construct values of type Complex Int, but you can't do\nanything with them, not even addition and subtraction.  I think the\nroot of the problem  is that Num requires an abs\nfunction, and for complex numbers you need the sqrt function to be\nable to compute abs.\n\nComplex Int could in principle support most of the functions\nrequired by Integral (such as div and mod) but Haskell\nforecloses this too because its definition of Integral requires\nReal as a prerequisite.\n\nYou are only allowed to construct Ratio a if a is integral.\nMathematically this is a bit odd.  There is a generic construction,\ncalled the field of quotients, which takes\na ring and turns it into a field, essentially by considering all the\nformal fractions  (where ), and with \nconsidered equivalent to  exactly when .\nIf you do this with the integers, you get the rational numbers; if you\ndo it with a ring of polynomials, you get a field of rational functions, and\nso on.  If you do it to a ring that's already a field, it still\nworks, and the field you get is trivially isomorphic to the original\none.  But Haskell doesn't allow it.\n\nI had another couple of pages written about yet more ways in which the\nnumeric class hierarchy is a mess (the draft title of this article was\n&quot;Haskell's numbers are a hot mess&quot;) but I'm going to cut the scroll\nhere and leave the hot mess for another time.\n\n[ Addendum: Updated SVG and PNG to version 1.1. ]\n    "
}