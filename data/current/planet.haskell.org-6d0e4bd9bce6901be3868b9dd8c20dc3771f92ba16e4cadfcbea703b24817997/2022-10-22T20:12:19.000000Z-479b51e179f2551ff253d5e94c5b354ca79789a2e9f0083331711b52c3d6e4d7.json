{
  "title":"What does \"isomorphic\" mean (in Haskell)?",
  "date":"2022-10-22T20:12:19.000000Z",
  "author":"Gabriella Gonzalez",
  "id":"tag:blogger.com,1999:blog-1777990983847811806.post-5833984871945391183",
  "link":"https://www.haskellforall.com/2022/10/what-does-isomorphic-mean-in-haskell.html",
  "content":"What does &quot;isomorphic&quot; mean (in Haskell)    Sometimes youâ€™ll hear someone describe two things as being â€œisomorphicâ€� to one another and I wanted to explain what that means.You might have already guessed that â€œisomorphicâ€� is a synonym for â€œequivalentâ€�, and that would have been a pretty good guess. Really, the main difference between the two words is that â€œisomorphicâ€� has a more precise and more general definition than â€œequivalentâ€�.In this post I will introduce a more precise definition of â€œisomorphicâ€�, using Haskell code. This definition wonâ€™t be the fully general definition, but I still hope to give you some taste of how â€œisomorphicâ€� can denote something more than just â€œequivalentâ€�.The simple versionThe simplest and least general definition of â€œisomorphicâ€� (in Haskell) is:Two types, A, and B, are isomorphic if there exist two functions, forward and backward of the following types:forward :: A -&gt; Bbackward :: B -&gt; Aâ€¦ such that the following two equations (which I will refer to as the â€œisomorphism lawsâ€�) are true:forward . backward = idbackward . forward = idid here is the identity function from Haskellâ€™s Prelude, defined like this:id :: a -&gt; aid x = xâ€¦ and (.) is the function composition operator (also from Haskellâ€™s Prelude), defined like this:(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)(f . g) x = f (g x)According to the above definition, the types Bool -&gt; a and (a, a) are isomorphic, because we can define two functions:forward :: (Bool -&gt; a) -&gt; (a, a)forward function = (function False, function True)backward :: (a, a) -&gt; (Bool -&gt; a)backward (first, second) False = firstbackward (first, second) True  = secondâ€¦ and we can prove that those two functions satisfy the isomorphism laws using equational reasoning.Proof of the isomorphism laws (click to expand) Hereâ€™s the proof of the first isomorphism law:forward . backward-- (f . g) = \\x -&gt; f (g x)---- â€¦ where:---- f = forward-- g = backward= \\x -&gt; forward (backward x)-- x = (first, second)= \\(first, second) -&gt; forward (backward (first, second))-- forward function = (function False, function True)= \\(first, second) -&gt;    (backward (first, second) False, backward (first, second) True)-- backward (first, second) False = first-- backward (first, second) True  = second= \\(first, second) -&gt; (first, second)-- x = (first, second)---- â€¦ in reverse= \\x -&gt; x-- id x = x---- â€¦ in reverse= \\x -&gt; id x-- Î·-reduction= idâ€¦ and here is the proof of the second isomorphism law:backward . forward-- (f . g) = \\x -&gt; f (g x)---- â€¦ where:---- f = backward-- g = forward-- x = function= \\function -&gt; backward (forward function)-- forward function = (function False, function True)= \\function -&gt; backward (function False, function True)-- Î·-expand= \\function bool -&gt; backward (function False, function True) bool-- There are two possible cases:---- Case #0: bool = False-- Case #1: bool = True-- Proof for case #0: bool = False  = \\function bool -&gt; backward (function False, function True) False  -- backward (first, second) False = first  --  -- â€¦ where:  --  -- first  = function False  -- second = function True  = \\function bool -&gt; function False  -- bool = False  --  -- â€¦ in reverse  = \\function bool -&gt; function bool  -- Î·-reduction  = \\function -&gt; function  -- id x = x  --  -- â€¦ in reverse  = \\function -&gt; id function  -- Î·-reduction  = id-- Proof for case #1: bool = True  = \\function bool -&gt; backward (function False, function True) True  -- backward (first, second) True = second  --  -- â€¦ where:  --  -- first  = function False  -- second = function True  = \\function bool -&gt; function True  -- b = True  --  -- â€¦ in reverse  = \\function bool -&gt; function bool  -- Î·-reduction  = \\function -&gt; function  -- id x = x  --  -- â€¦ in reverse  = \\function -&gt; id function  -- Î·-reduction  = idWeâ€™ll use the notation A â‰… B as a short-hand for â€œA is isomorphic to Bâ€�, so we can also write:Bool -&gt; a â‰… (a, a)Whenever we declare that two types are isomorphic we need to actually specify what the forward and backwardconversion functions are and prove that they satisfy isomorphism laws. The existence of forward and backwardfunctions of the correct input and output types is not enough to establish that the two types are isomorphic.For example, suppose we changed the definition of forward to:forward :: (Bool -&gt; a) -&gt; (a, a)forward function = (function True, function False)Then forward . backward and backward . forward would still type-check and have the right type, but they would no longer be equal to id.In other words, when discussing isomorphic types, itâ€™s technically not enough that the two types are equivalent. The way in which they are equivalent matters, too, if we want to be pedantic. In practice, though, if thereâ€™s only one way to implement the two conversion functions then people wonâ€™t bother to explicitly specify them.The reason why this is important is because an isomorphism also gives us an explicit way to convert between the two types.  We're not just declaring that they're equivalent, but we're spelling out exactly how to transform each type into the other type, which is very useful!More examplesLetâ€™s speedrun through a few more examples of isomorphic types, which all parallel the rules of arithmetic:-- 0 + a = aEither Void a â‰… a-- a + (b + c) = (a + b) + cEither a (Either b c) = Either (Either a b) c-- 1 Ã— a = a((), a) â‰… a-- a Ã— (b Ã— c) = (a Ã— b) Ã— c(a, (b, c)) â‰… ((a, b), c)-- 0 Ã— a = 0(Void, a) â‰… Void-- a Ã— (b + c) = (a Ã— b) + (a Ã— c)(a, Either b c) â‰… Either (a, b) (a, c)-- a ^ 1 = a() -&gt; a â‰… a-- a ^ 0 = 1Void -&gt; a â‰… ()-- (c ^ b) ^ a = (c ^ a) ^ ba -&gt; b -&gt; c â‰… b -&gt; a -&gt; c-- (c ^ b) ^ a = c ^ (a Ã— b)a -&gt; b -&gt; c â‰… (a, b) -&gt; cExercise: implement the forward and backward functions for some of the above types and prove the isomorphism laws for each pair of functions. It will probably be very tedious to prove all of the above examples, so pick the ones that interest you the most.Intermediate tricksThis section will introduce some more advanced tricks for proving that two types are isomorphic.First, letâ€™s start with a few ground rules for working with all isomorphisms:Reflexivity: a â‰… aSymmetry: If a â‰… b then b â‰… aTransitivity: If a â‰… b and b â‰… c then a â‰… cNow letâ€™s get into some Haskell-specific rules:a newtype in Haskell is isomorphic to the underlying type if the newtype constructor is public.For example, if we were to define:newtype Name = Name { getName :: String }â€¦ then Name and String would be isomorphic (Name â‰… String), where:forward :: Name -&gt; Stringforward = getNamebackward :: String -&gt; Namebackward = NameOne such newtype that shows up pretty often when reasoning about isomorphic types is the Identitytype constructor from Data.Functor.Identity:newtype Identity a = Identity { runIdentity :: a }â€¦ where Identity a â‰… a.To see why Identity is useful, consider the following two types:newtype State s a = State { runState :: s -&gt; (a, s) }newtype StateT s m a = StateT { runStateT :: s -&gt; m (a, s) }The latter newtype is from the transformerspackage, which is how we layer on the â€œstateâ€� effect within a monad transformer stack. If you donâ€™t understand what that means, thatâ€™s okay; itâ€™s not that relevant to the point.However, the transformers package doesnâ€™t define State as above. Instead, the transformerspackage defines State like this:type State s = StateT s IdentityThe latter type synonym definition for State is equivalent (â€œisomorphicâ€�) to the newtype definition for State I provided above. In order to prove that though Iâ€™ll need to distinguish between the two State type constructors, so Iâ€™ll use a numeric subscript to distinguish them:import Data.Functor.Identity (Identity)newtype Stateâ‚€ s a = Stateâ‚€ { runState :: s -&gt; (a, s) }newtype StateT s m a = StateT { runStateT :: s -&gt; m (a, s) }type Stateâ‚� s = StateT s Identityâ€¦ and then we can prove that Stateâ‚€ is isomorphic to Stateâ‚� like this:Stateâ‚€ s a â‰… s -&gt; (a, s)â€¦ because the Stateâ‚€ newtype is isomorphic to the underlying types -&gt; (a, s) â‰… s -&gt; Identity (a, s)â€¦ because the Identity newtype is isomorphic to the underlying types -&gt; Identity (a, s) â‰… StateT s Identity aâ€¦ because the StateT newtype is isomorphic to the underlying typeStateT s Identity a = Stateâ‚� s aâ€¦ because of how the Stateâ‚� type synonym is defined.Therefore, by transitivity, we can conclude:Stateâ‚€ s a â‰… Stateâ‚� s aOkay, now letâ€™s introduce an extremely useful rule related to isomorphic types:If f is a Functor then forall r . (a -&gt; r) -&gt; f r is isomorphic to f a.Or in other words:Functor f =&gt; (forall r . (a -&gt; r) -&gt; f r) â‰… f aâ€¦ and here are the two conversion functions:{-# LANGUAGE RankNTypes #-}forward :: Functor f =&gt; (forall r . (a -&gt; r) -&gt; f r) -&gt; f aforward f = f idbackward :: Functor f =&gt; f a -&gt; (forall r . (a -&gt; r) -&gt; f r)backward fa k = fmap k faThis is essentially the Yoneda lemma in Haskell form, which is actually a bit tricky to prove. If you donâ€™t believe me, try proving the isomorphism laws for the above forward and backward functions and see how far you get. Itâ€™s much easier to rely on the fact that someone else already did the hard work of proving those isomorphism laws for us.Hereâ€™s a concrete example of the Yoneda lemma in action. Suppose that I want to prove that there is only one implementation of the identity function, id. I can do so by proving that the type of the identity function (forall a . a -&gt; a) is isomorphic to the () type (a type inhabited by exactly one value):(forall a . a -&gt; a) â‰… ()Hereâ€™s how you prove that by chaining together several isomorphic types:  (forall a . a -&gt; a)  -- a â‰… () -&gt; aâ‰… (forall a . (() -&gt; a) -&gt; a)  -- a â‰… Identity aâ‰… (forall a . (() -&gt; a) -&gt; Identity a)  -- âœ¨ Yoneda lemma (where f = Identity) âœ¨â‰… Identity ()â‰… ()â€¦ so since the () type is inhabited by exactly one value (the () term) and the () type is isomorphic to the type of id, then there is exactly one way to implement id (which is id x = x).Note: To be totally pedantic, there is exactly one way to implement id â€œup to isomorphismâ€�. This is how we say that there might be several syntactically different ways of implementing id, such as:id x = xid y = yid = \\x -&gt; xid x = y  where    y = xâ€¦ but all of those ways of implementing id are isomorphic to one another (in a slightly different sense that I have not covered), so there is essentially only one way of implementing id.Similarly, we can prove that there are exactly two ways to implement a function of type forall a . a -&gt; a -&gt; a by showing that such a type is isomorphic to Bool (a type inhabited by exactly two values):  (forall a . a -&gt; a -&gt; a)  -- a -&gt; b -&gt; c â‰… (a, b) -&gt; câ‰… (forall a . (a, a) -&gt; a)  -- (a, a) â‰… Bool -&gt; aâ‰… (forall a . (Bool -&gt; a) -&gt; a)  -- a â‰… Identity aâ‰… (forall a . (Bool -&gt; a) -&gt; Identity a)  -- âœ¨ Yoneda lemma (where f = Identity) âœ¨â‰… Identity Boolâ‰… Boolâ€¦ and in case youâ€™re curious, here are the only two possible ways to implement that type (up to isomorphism):{-# LANGUAGE ExplicitForAll #-}false :: forall a . a -&gt; a -&gt; afalse f t = ftrue :: forall a . a -&gt; a -&gt; atrue f t = tHereâ€™s one last example of using the Yoneda lemma to prove that:(forall r . (a -&gt; r) -&gt; r) â‰… aâ€¦ which you can prove like this:  (forall r . (a -&gt; r) -&gt; r)  -- Identity r â‰… râ‰… (forall r . (a -&gt; r) -&gt; Identity r)  -- âœ¨ Yoneda lemma (where f = Identity) âœ¨â‰… Identity aâ‰… aExercise: Prove that these two types are isomorphic:(forall r . (b -&gt; r) -&gt; (a -&gt; r)) â‰… a -&gt; bSolution (click to expand)   (forall r . (b -&gt; r) -&gt; (a -&gt; r))  -- a -&gt; b -&gt; c â‰… b -&gt; a -&gt; câ‰… (forall r . a -&gt; (b -&gt; r) -&gt; r)  -- r â‰… Identity râ‰… (forall r . a -&gt; (b -&gt; r) -&gt; Identity r)  -- âœ¨ Yoneda lemma (where f = Identity) âœ¨â‰… a -&gt; Identity b  -- Identity b â‰… bâ‰… a -&gt; bIsomorphismSo far weâ€™ve only used the word â€œisomorphicâ€� but there is a related word we should cover: â€œisomorphismâ€�.In Haskell, if the types A and B are â€œisomorphicâ€� then an â€œisomorphismâ€� between them is the corresponding pair of functions converting between them (i.e.Â forward and backward).The easiest way to explain this is to actually define an isomorphism type in Haskell:data Isomorphism a b = Isomorphism    { forward  :: a -&gt; b    , backward :: b -&gt; a    }For example:exampleIsomorphism :: Isomorphism ((a, b) -&gt; c) (a -&gt; b -&gt; c)exampleIsomorphism = Isomorphism{ forward = curry, backward = uncurry }However, this is not the only way we can encode an isomorphism in Haskell. For example, the lens package has an Iso type which can also represent an isomorphism:import Control.Lens (Iso', iso)exampleIso :: Iso' ((a, b) -&gt; c) (a -&gt; b -&gt; c)exampleIso = iso curry uncurryThese two types are equivalent. In fact, you might even say they are â€¦ isomorphic ğŸ‘€.{-# LANGUAGE NamedFieldPuns #-}import Control.Lens (AnIso', Iso', cloneIso, iso, review, view)data Isomorphism a b = Isomorphism    { forward  :: a -&gt; b    , backward :: b -&gt; a    }-- | We have to use `AnIso'` here instead of `Iso'` for reasons I won't go intoisomorphismIsomorphism :: Isomorphism (Isomorphism a b) (AnIso' a b)isomorphismIsomorphism = Isomorphism{ forward, backward }  where    forward :: Isomorphism a b -&gt; AnIso' a b    forward (Isomorphism f b) = iso f b    backward :: AnIso' a b -&gt; Isomorphism a b    backward iso =        Isomorphism            { forward  = view (cloneIso iso)            , backward = review (cloneIso iso)            }Generalized isomorphismsI mentioned earlier that the isomorphism definition we began with was not the fully general definition. In this section weâ€™ll slightly generalize the definition, while still sticking to something ergonomic to express within Haskell:Two types, A, and B, are isomorphic if there exist two morphisms, forward and backward of the following types:forward :: cat A Bbackward :: cat B Aâ€¦ such that cat is an instance of the Category type class and the following two equations (which I will refer to as the â€œisomorphism lawsâ€�) are true:forward . backward = idbackward . forward = idâ€¦ where (.) and id are the methods of the Category type class and not necessarily the (.) and id from the Prelude.This definition is based on the Categorytype class from the Control.Categorymodule, which is defined like this:class Category cat where    -- | the identity morphism    id :: cat a a    -- | morphism composition    (.) :: cat b c -&gt; cat a b -&gt; cat a câ€¦ and all instance of the Category class must satisfy the following three â€œcategory lawsâ€�:(f . g) . h = f . (g . h)f . id = fid . f = fIn other words, you can think of the Category class as generalizing our notion of functions to become â€œmorphismsâ€� so that we replace values of type a -&gt; b (functions) with values of type cat a b (â€œmorphismsâ€�). When we generalize our notion of functions to morphisms then we can similarly generalize our notion of isomorphisms.Of course, Haskell functions are one instance of this Category class:instance Category (-&gt;) where    id = Prelude.id    (.) = (Prelude..)â€¦ so if we take our more general definition of isomorphisms and replace cat with (-&gt;) then we get back the less general definition of isomorphisms that we started with.However, things other than functions can be instances of this Category class, too. For example, â€œmonadicâ€� functions of type Monad m =&gt; a -&gt; m b can implement Category, too, if we wrap them in a newtype:import Control.Category (Category(..))import Control.Monad ((&lt;=&lt;))-- Note: This type and instance already exists in the `Control.Arrow` modulenewtype Kleisli m a b = Kleisli{ runKleisli :: a -&gt; m b }instance Monad m =&gt; Category (Kleisli m) where    id = Kleisli return    Kleisli f . Kleisli g = Kleisli (f &lt;=&lt; g)â€¦ and that satisfies the category laws because:(f &lt;=&lt; g) &lt;=&lt; h = f &lt;=&lt; (g &lt;=&lt; h)f &lt;=&lt; return = freturn &lt;=&lt; f = fFun fact: The above category laws for the Kleisli type constructor are isomorphic to the monad laws (in a different sense of the world &quot;isomorphic&quot; that I have not covered).Once we begin to use Category instances other than functions we can begin to explore more interesting types of â€œmorphismsâ€� and â€œisomorphismsâ€�. However, in order to do so we need to generalize our Isomorphism type like this:data Isomorphism cat a b = Isomorphism    { forward  :: cat a b    , backward :: cat b a    }â€¦ so that we can store morphisms that are not necessarily functions.With that generalized Isomorphism type in hand we can now create a sample Isomorphism in a KleisliCategory:import Data.Monoid (Sum(..))import Control.Monad.Writer (Writer)writerIsomorphism :: Isomorphism (Kleisli (Writer (Sum Integer))) () ()writerIsomorphism = Isomorphism{ forward, backward }  where    forward :: Kleisli (Writer (Sum Integer)) () ()    forward = Kleisli (\\_ -&gt; tell (Sum 1))    backward :: Kleisli (Writer (Sum Integer)) () ()    backward = Kleisli (\\_ -&gt; tell (Sum (-1)))Like before, we still require that:forward . backward = idbackward . forward = idâ€¦ but in this case the (.) and id in these two isomorphism laws will be the ones for our Kleisli type instead of the ones for functions.Proof of isomorphism laws (click to expand) Iâ€™ll skip over several steps for this proof to highlight the relevant parts:forward . backward= Kleisli (\\_ -&gt; tell (Sum 1)) . Kleisli (\\_ -&gt; tell (Sum (-1)))= Kleisli ((\\_ -&gt; tell (Sum 1)) &lt;=&lt; (\\_ -&gt; tell (Sum (-1))))= Kleisli (\\_ -&gt; tell (Sum 0))= Kleisli return= idThe proof of backward . forward = id is essentially the same thing, except flipped. Note our Isomorphism effectively says that the type () is isomorphic to the type () within this Kleisli (Writer (Sum Integer)) Category, which is not a very interesting conclusion. Rather, for this Isomorphism the (slightly more) interesting bit is in the â€œmorphismsâ€� (the forward and backwarddefinitions), which are inverses of one another.Here is one last example of a non-trivial Categoryinstance with an example isomorphism:import Prelude hiding ((.), id)-- Note: This is not how the lens package works, but it's still a useful exampledata Lens a b = Lens{ view :: a -&gt; b, over :: (b -&gt; b) -&gt; (a -&gt; a) }instance Category Lens where    id = Lens{ view = id, over = id }    Lens{ view = viewL, over = overL } . Lens{ view = viewR, over = overR } =        Lens{ view = viewL . viewR, over = overR . overL }lensIsomorphism :: Isomorphism Lens Bool BoollensIsomorphism = Isomorphism{ forward, backward }  where    forward :: Lens Bool Bool    forward = Lens{ view = not, over = \\f -&gt; not . f . not }    -- There is no rule that the two morphisms can't be the same    backward :: Lens Bool Bool    backward = forwardAgain, itâ€™s not very interesting to say that Bool is isomorphic to Bool, but it is more to note that the forward lens is essentially its own inverse.Thereâ€™s one last category I want to quickly mention, which is â€¦ Isomorphism!Yes, the Isomorphism type we introduced is itself an instance of the Category class:instance Category cat =&gt; Category (Isomorphism cat) where    Isomorphism forwardL backwardL . Isomorphism forwardR backwardR =        Isomorphism (forwardL . forwardR) (backwardR . backwardL)    id = Isomorphism id idYou might even say that an â€œisomorphismâ€� is a â€œmorphismâ€� in the above Category. An â€œisoâ€�-â€œmorphismâ€�, if you will (where â€œisoâ€� means â€œsameâ€�).Furthermore, we can create an example Isomorphism in this Category of Isomorphisms:nestedIsomorphism :: Isomorphism (Isomorphism (-&gt;)) Integer IntegernestedIsomorphism =    Isomorphism        { forward  = Isomorphism{ forward = (+ 1), backward = subtract 1 }        , backward = Isomorphism{ forward = subtract 1, backward = (+ 1) }        }Okay, perhaps thatâ€™s going a bit too far, but I just wanted to end this post with a cute example of how you can keep chaining these ideas together in new ways.ConclusionIn my experience, the more you train your ability to reason formally about isomorphisms the more you broaden your ability to recognize disparate things as equivalent and draw interesting connections between them.For example, fluency with many common isomorphisms is a useful skill for API design because often there might be a way to take an API which is not very ergonomic and refactor it into an equivalent (isomorphic) API which is more ergonomic to use.\n    "
}