{
  "title":"Free Monoids in Haskell",
  "date":"2022-10-24T17:47:25.000000Z",
  "author":"Dan Doel",
  "id":"http://comonad.com/reader/?p=977",
  "link":"http://comonad.com/reader/2015/free-monoids-in-haskell/",
  "content":"It is often stated that Foldable is effectively the toList class. However, this turns out to be wrong. The real fundamental member of Foldable is foldMap (which should look suspiciously like traverse, incidentally). To understand exactly why this is, it helps to understand another surprising fact: lists are not free monoids in Haskell.\nThis latter fact can be seen relatively easily by considering another list-like type:\n \ndata SL a = Empty | SL a :&gt; a\n \ninstance Monoid (SL a) where\n  mempty = Empty\n  mappend ys Empty = ys\n  mappend ys (xs :&gt; x) = (mappend ys xs) :&gt; x\n \nsingle :: a -&gt; SL a\nsingle x = Empty :&gt; x\n \nSo, we have a type SL a of snoc lists, which are a monoid, and a function that embeds a into SL a. If (ordinary) lists were the free monoid, there would be a unique monoid homomorphism from lists to snoc lists. Such a homomorphism (call it h) would have the following properties:\n \nh [] = Empty\nh (xs &lt;&gt; ys) = h xs &lt;&gt; h ys\nh [x] = single x\n \nAnd in fact, this (together with some general facts about Haskell functions) should be enough to define h for our purposes (or any purposes, really).  So, let's consider its behavior on two values:\n \nh [1] = single 1\n \nh [1,1..] = h ([1] &lt;&gt; [1,1..]) -- [1,1..] is an infinite list of 1s\n          = h [1] &lt;&gt; h [1,1..]\n \nThis second equation can tell us what the value of h is at this infinite value, since we can consider it the definition of a possibly infinite value:\n \nx = h [1] &lt;&gt; x = fix (single 1 &lt;&gt;)\nh [1,1..] = x\n \n(single 1 ) is a strict function, so the fixed point theorem tells us that x = ⊥.\nThis is a problem, though. Considering some additional equations:\n \n[1,1..] &lt;&gt; [n] = [1,1..] -- true for all n\nh [1,1..] = ⊥\nh ([1,1..] &lt;&gt; [1]) = h [1,1..] &lt;&gt; h [1]\n                   = ⊥ &lt;&gt; single 1\n                   = ⊥ :&gt; 1\n                   ≠ ⊥\n \nSo, our requirements for h are contradictory, and no such homomorphism can exist.\nThe issue is that Haskell types are domains. They contain these extra partially defined values and infinite values. The monoid structure on (cons) lists  has infinite lists absorbing all right-hand sides, while the snoc lists are just the opposite.  \nThis also means that finite lists (or any method of implementing finite sequences) are not free monoids in Haskell. They, as domains, still contain the additional bottom element, and it absorbs all other elements, which is incorrect behavior for the free monoid: \n \npure x &lt;&gt; ⊥ = ⊥\nh ⊥ = ⊥\nh (pure x &lt;&gt; ⊥) = [x] &lt;&gt; h ⊥\n                = [x] ++ ⊥\n                = x:⊥\n                ≠ ⊥\n \nSo, what is the free monoid? In a sense, it can't be written down at all in Haskell, because we cannot enforce value-level equations, and because we don't have quotients. But, if conventions are good enough, there is a way. First, suppose we have a free monoid type FM a. Then for any other monoid m and embedding a -&gt; m, there must be a monoid homomorphism from FM a to m. We can model this as a Haskell type:\n \nforall a m. Monoid m =&gt; (a -&gt; m) -&gt; FM a -&gt; m\n \nWhere we consider the Monoid m constraint to be enforcing that m actually has valid monoid structure. Now, a trick is to recognize that this sort of universal property can be used to define types in Haskell (or, GHC at least), due to polymorphic types being first class; we just rearrange the arguments and quantifiers, and take FM a to be the polymorphic type:\n \nnewtype FM a = FM { unFM :: forall m. Monoid m =&gt; (a -&gt; m) -&gt; m }\n \nTypes defined like this are automatically universal in the right sense. [1] The only thing we have to check  is that FM a is actually a monoid over a. But that turns out to be easily witnessed:\n \nembed :: a -&gt; FM a\nembed x = FM $ \\k -&gt; k x\n \ninstance Monoid (FM a) where\n  mempty = FM $ \\_ -&gt; mempty\n  mappend (FM e1) (FM e2) = FM $ \\k -&gt; e1 k &lt;&gt; e2 k\n \nDemonstrating that the above is a proper monoid delegates to instances of Monoid being proper monoids. So as long as we trust that convention, we have a free monoid.\nHowever, one might wonder what a free monoid would look like as something closer to a traditional data type. To construct that, first ignore the required equations, and consider only the generators; we get:\n \ndata FMG a = None | Single a | FMG a :&lt;&gt; FMG a\n \nNow, the proper FM a is the quotient of this by the equations:\n \nNone :&lt;&gt; x = x = x :&lt;&gt; None\nx :&lt;&gt; (y :&lt;&gt; z) = (x :&lt;&gt; y) :&lt;&gt; z\n \nOne way of mimicking this in Haskell is to hide the implementation in a module, and only allow elimination into Monoids (again, using the convention that Monoid ensures actual monoid structure) using the function:\n \nunFMG :: forall a m. Monoid m =&gt; FMG a -&gt; (a -&gt; m) -&gt; m\nunFMG None _ = mempty\nunFMG (Single x) k = k x\nunFMG (x :&lt;&gt; y) k = unFMG x k &lt;&gt; unFMG y k\n \nThis is actually how quotients can be thought of in richer languages; the quotient does not eliminate any of the generated structure internally, it just restricts the way in which the values can be consumed. Those richer languages just allow us to prove equations, and enforce properties by proof obligations, rather than conventions and structure hiding. Also, one should note that the above should look pretty similar to our encoding of FM a using universal quantification earlier.\nNow, one might look at the above and have some objections. For one, we'd normally think that the quotient of the above type is just [a]. Second, it seems like the type is revealing something about the associativity of the operations, because defining recursive values via left nesting is different from right nesting, and this difference is observable by extracting into different monoids. But aren't monoids supposed to remove associativity as a concern? For instance:\n \nones1 = embed 1 &lt;&gt; ones1\nones2 = ones2 &lt;&gt; embed 1\n \nShouldn't we be able to prove these are the same, becuase of an argument like:\n \nones1 = embed 1 &lt;&gt; (embed 1 &lt;&gt; ...)\n      ... reassociate ...\n      = (... &lt;&gt; embed 1) &lt;&gt; embed 1\n      = ones2\n \nThe answer is that the equation we have only specifies the behavior of associating three values:\n \nx &lt;&gt; (y &lt;&gt; z) = (x &lt;&gt; y) &lt;&gt; z\n \nAnd while this is sufficient to nail down the behavior of finite values, and finitary reassociating, it does not tell us that infinitary reassociating yields the same value back. And the &quot;... reassociate ...&quot; step in the argument above was decidedly infinitary. And while the rules tell us that we can peel any finite number of copies of embed 1 to the front of ones1 or the end of ones2, it does not tell us that ones1 = ones2. And in fact it is vital for FM a to have distinct values for these two things; it is what makes it the free monoid when we're dealing with domains of lazy values.\nFinally, we can come back to Foldable. If we look at foldMap:\n \nfoldMap :: (Foldable f, Monoid m) =&gt; (a -&gt; m) -&gt; f a -&gt; m\n \nwe can rearrange things a bit, and get the type:\n \nFoldable f =&gt; f a -&gt; (forall m. Monoid m =&gt; (a -&gt; m) -&gt; m)\n \nAnd thus, the most fundamental operation of Foldable is not toList, but toFreeMonoid, and lists are not free monoids in Haskell.\n[1]: What we are doing here is noting that (co)limits are objects that internalize natural transformations, but the natural transformations expressible by quantification in GHC are already automatically internalized using quantifiers. However, one has to be careful that the quantifiers are actually enforcing the relevant naturality conditions. In many simple cases they are.\n    "
}