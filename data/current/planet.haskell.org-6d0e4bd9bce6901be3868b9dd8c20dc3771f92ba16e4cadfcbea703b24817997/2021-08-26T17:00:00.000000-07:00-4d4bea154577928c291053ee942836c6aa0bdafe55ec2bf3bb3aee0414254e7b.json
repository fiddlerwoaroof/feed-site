{
  "title":"Daily ICFP: Day 4",
  "date":"2021-08-26T17:00:00.000000-07:00",
  "author":null,
  "id":"https://tweag.io/blog/2021-08-27-icfp4/",
  "link":"https://tweag.io/blog/2021-08-27-icfp4/",
  "content":"Daily ICFP\nSeveral Tweagers all agreed to gather notes here about our\nICFP (International Conference on Functional\nProgramming) experiences.\nOther posts in this series:\n\nICFP - Day 0\nICFP - Day 1\nICFP - Day 2\nICFP - Day 3\nICFP - Day 5\n\nDay 4 - Thursday\nThese notes follow Noon and Richard through their day at ICFP,\nroughly in order. (The talks are not publicly posted at the time\nof publication of this post, but we expect they will be over the\ncoming weeks.)\nNoon — Second to last day of ICFP. I’m becoming sad that it’s\ngoing to be over! But that said, I’m really looking forward to today!\nI feel a bit relaxed as well, because from my timezone (UK) I get a bit\nof a break in the morning (as I’m starting my day at the Haskell track.)\nChesskell: A Two-Player Game at the Type Level, by Toby Bailey and Michael Gale\nNoon\n\nWhat if you were taught chess slowly by a compiler?\nChesskell uses a little bit (a lot) more memory than the Witcher 3.\nOverall a very fun talk about pushing the limits of type-level programming in GHC.\n\nRichard\nThis was such a fun talk. Chesskell is an implementation of chess such that\nany illegal move is a type error. You play by typing in a Haskell buffer to\nappend moves to the game.\nTo be clear: this is not an implementation of a chess game. It’s really only\na fun experiment to see how far Haskell’s type system can go. In this sense,\nthis project is a little dangerous: I wouldn’t want, say, a Java programmer to\ncome across Chesskell and think this is how one would implement chess in\nHaskell! With that out of the way, though, this is indeed really fun. It’s\namazing this can be done at all.\nThe talk focused mostly on limitations in GHC around its evaluation of type\nfamilies, which is unpredictably slow. We at GHC know this and are working on\nit (led by Adam Gundry of Well-Typed), but this talk really pointed out all\nour flaws. It also describes an EDSL (embedded domain-specific language) that\nstruggles with the new simplified subsumption in GHC 9. (See the\nproposal for a\ndescription.) It’s the first example I’ve come across of a program that is\nanti-simplified-subsumption in a way that cannot be easily repaired.\nExpress: applications of dynamically typed Haskell expressions, by Rudy Matela\nNoon\n\nTalking about this library\nVery cool library.\nReally cool capability to generate conjectures (equations that are true from testing) from expressions; i.e. learn things such as xs ++ [] = xs, and other interesting ideas.\nUses this to generalise property-based testing counter-examples.\nAlso does function synthesis!\nOverall I loved this talk and the idea and I think the library will only get much more awesome over time!\n\nRichard\nI really liked this talk, too. It starts with a simple idea — Haskell’s\nDynamic — and extends it with the ability to track function application and\nstore abstract variables (that is, an x that is not bound to a value, like\nwe would see in an algebraic equation). The talk then explores all manner of\napplications of this simple idea. The whole approach (simple idea leading to\nmultifarious applications) is so Haskelly.\nHaskell⁻¹: Automatic Function Inversion in Haskell, by Finn Teegen, Kai-Oliver Prott and Niels Bunkenburg.\nNoon\n\nWhen inverting, how to deal with functions that are not injective? (i.e. no unique inverse)\nIdea: Just allow multiple inverses!\nWith the plugin, any function in standard Haskell can be inverted.\nWant a “functional logic” version of Haskell, similar to Prolog.\nWent into a bit more detail about the function inversion process.\nOverall pretty interesting, and gives me more motivation that one day I’d love to investigate how GHC plugins work and what is possible with them!\n\nRichard\nThis nice talk shows another superpower of GHC: allowing plugins that can\nmanipulate Haskell source — this one, computing inverses of functions.\nWhy functional programming with linear types matters, by Tweag CEO Mathieu Boespflug\nNoon\n\nMy favourite quote: “The Spleen of Reality”\n\nRichard\nThis talk explores why Tweag is interested in linear types, focusing on two\nkey benefits: extra safety (the example given was that we don’t want our\nfunctional program to accidentally duplicate one pizza into two) and extra\nperformance (linear types can be used to ensure resource disposal, and so\nprovides a potential alternative to garbage collection and the costly latency\nGC can introduce).\nThe talk also includes an excellent introduction to linear types for anyone\nwho does not know about them.\nDesign Patterns for Parser Combinators (Functional Pearl), by Jamie Willis and Nicolas Wu\nNoon\n\nLove the code-review talk format!\nhttps://github.com/j-mie6/design-patterns-for-parser-combinators/issues/3\nhttps://github.com/j-mie6/design-patterns-for-parser-combinators/pull/6/files\nCan’t be described; you have to watch the talk. Exceptional.\n\nRichard\nAmazing talk. Do watch. And, when you do, keep in mind that everything you’re\nseeing is actually live.\nThis is one of a series of amazing talks by Nick Wu. I will endeavor to watch\nthe talk of any paper of his into perpetuity.\nOh, and there was content: a very nice description of useful design patterns\nfor parser combinators. Nothing earth-shattering here, but it’s really great\nto have all this material in one place. When I reach for parser combinators\nnext (or am mentoring someone who is), I will point them to this paper.\nNoon — Graded Monads and Type-Level Programming for Dependence Analysis, by Finnbar Keating and Michael Gale\n\nImagine working with a robot.\nWant types to reflect what we do: such as reading from the screen, writing to the screen, etc.\nGraded monads can help us do this.\n\nNoon — Sylvester: Unified, typed, notation for symbolic mathematics and proofs (short talk), by Allister Beharry\n\nPopped into this talk because I was curious about the topic.\nIt’s based in F#; not a language I’ve used a lot recently.\nMain idea is to have a language that allows for computer-algebra and general-purpose programming.\nIntegrates with other tools (say, Z3).\nI really like the idea in general, and it was nice to watch this and step outside my usual comfort zone a bit.\n\nRichard — In the afternoon PLTea, an\ninteresting conversation led to a new insight: GHC has for some time thought\nabout doing finer-grained analysis for recompilation avoidance. That is, if I\nchange one function, then I have to recompile only modules that depend on\nthat function. But I don’t think the current analysis is always quite that\nclever. And so, being cleverer would avoid spurious recompilation. The new\ninsight is that this kind of cleverness would be very helpful to IDEs trying\nto provide live code feedback: in order for an IDE to know where (say) a type\nerror is, it has to run the code through GHC. If we can compile just a tiny\npart of the file at a time (part of what would power the fine-grained\nrecompilation-avoiding dependency analysis), then this live feedback would\ncome much faster. So it’s nice to see multiple benefits from one feature! Now\nwe just have to design and implement the feature…\n    "
}