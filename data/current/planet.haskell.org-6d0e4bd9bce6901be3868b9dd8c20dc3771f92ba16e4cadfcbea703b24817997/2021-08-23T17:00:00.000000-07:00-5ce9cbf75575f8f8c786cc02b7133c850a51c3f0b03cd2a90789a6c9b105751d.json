{
  "title":"Designing New",
  "date":"2021-08-23T17:00:00.000000-07:00",
  "author":null,
  "id":"https://www.parsonsmatt.org/2021/08/24/designing_new.html",
  "link":"https://www.parsonsmatt.org/2021/08/24/designing_new.html",
  "content":"I want a better way of constructing Haskell records.\n\nLet’s compare and contrast the existing ways.\nWe’ll be using this datatype as an example:\n\ndata Env = Env\n    { accountId :: String\n    , accountPassword :: String\n    , requestHook :: Request -&gt; IO Request\n    , responseHook :: Response -&gt; IO Response\n    }\n\n\nThis type is an Env that you might see in a ReaderT Env IO integration with some external service.\nWe can attach request hooks and response hooks.\n\nFunction Arguments\n\nThe simplest and most boring way is to pass function arguments.\n\nenv :: Env\nenv = Env &quot;asdfadf&quot; &quot;hunter42&quot; pure pure\n\n\nThis is undesirable for a few reasons:\n\n\n  We have no idea what those parameters mean without looking at the datatype definition.\n  We have to pass arguments in a specific order.\n  If the type of the Env changes, then this also changes.\n  … but we don’t get a break if the field order is changed in a way that respects the types!\n\n\nConsider swapping the order of accountId and accountPassword in our data definition.\nNow everything breaks mysteriously with no type errors.\n\nUsing the function-style for constructing records is probably a bad idea.\n\nRecord Labels\n\nThe second most boring way is to use record construction syntax:\n\nenv :: Env\nenv = Env\n    { accountId = &quot;asdfasdf&quot;\n    , accountPassword = &quot;hunter42&quot;\n    , requestHook = pure\n    , responseHook = pure\n    }\n\n\nThis solves basically all the problems with function arguments.\nHowever, we’re still sensitive to changes in the record constructor.\nIf we add a new field, we must account for that in all creation sites.\nThis is annoying, especially since many new fields in records like this are designed to accommodate new functionality or customization, and most existing users want to just ignore them.\n\nA Default Record\n\nInstead of constructing a record, we’ll have end users modify an existing record.\n\ndefaultEnv :: Env\ndefaultEnv = Env\n    { accountId = &quot;&quot;\n    , accountPassword = &quot;&quot;\n    , requestHook = pure\n    , responseHook = pure\n    }\n\nenv :: Env\nenv = defaultEnv\n    { accountId = &quot;asdfasdf&quot;\n    , accountPassword = &quot;hunter42&quot;\n    }\n\n\nHowever, this is gross, for a few reasons.\nThe first is that we provide a dummy value of accountId and accountPassword, and the end user is required to fill them in.\nThere’s actually no way for us to give a warning or error if they fail to provide it.\n\nThe standard solution is to accept function arguments, but this has a nasty problem: record syntax binds tighter than anything else, even function application, so we need to do this:\n\ndefaultEnv :: String -&gt; String -&gt; Env\ndefaultEnv a p = Env a p pure pure -- brevity, forgive me\n\nenv :: Env\nenv = (defaultEnv &quot;asdfasdf&quot; &quot;hunter42&quot;)\n    { requestHook = \\req -&gt; do\n        logRequest req\n        pure req\n    }\n\n\nThat’s right - we gotta put parens around our constructor.\nWe can’t use $ here, either, because the syntax explicitly requires a value { field0 = val0, ... fieldN = valN } form.\n\nAlso now we’re back at the same problem with defaultEnv - we can mismatch our function arguments.\n\nAn Args Record\n\nThe pattern I chose for SqlBackend in persistent is to have an *Args record.\n\n{-# language DuplicateRecordFields #-}\n{-# language RecordWildCards #-}\n\ndata EnvArgs = EnvArgs\n    { accountId :: String\n    , accountPassword :: String\n    }\n\nmkEnv :: EnvArgs -&gt; Env\nmkEnv EnvArgs {..} = Env\n    { requestHook = pure\n    , responseHook = pure\n    , ..\n    }\n\nenv :: Env\nenv = mkEnv EnvArgs \n    { accountId = &quot;asdfasdf&quot;\n    , accountPassword = &quot;hunter42&quot;\n    }\n\n\nThis solves all of the above problems, but it’s a bit unsatisfying - we can’t also modify the requestHook and responseHook parameters directly in mkEnv, we have to do it outside.\n\nfullEnv :: Env\nfullEnv = \n    (mkEnv EnvArgs {..}) \n        { requestHook = \\req -&gt; do\n            log req\n            pure req\n        }\n\n\nHmm, slightly annoying syntax, again.\nBut, hey, whatever, it works.\n\nCodependent Records\n\nNo, I’m not talking about some fancy type theory.\nRecord syntax is essentially codependent on the value it is modifying, or the constructor it is using.\nWe can’t pass in a ‘record’ of stuff and use it in ways that are clever or useful.\n\nLet’s talk about the “whitespace operator.”\nWe can imagine defining it like this, for regular functions:\n\n( ) :: (a -&gt; b) -&gt; a -&gt; b\nf a = f a\n\n\nOK, it’s special built in syntax, the definition doesn’t make any sense.\nBut let’s try and write it for records now.\nRemember we need to support update and creation.\n\n( ) :: (AllowableRecord con rec result)\n    =&gt; con -&gt; rec -&gt; result\ncon rec = implementRecord con rec\n\nclass AllowableRecord con rec result where\n    implementRecord :: con -&gt; rec -&gt; result\n\n\nNow rec is something that can stand alone - it is freed from the codependent relationship with the values and constructors it serves.\nWhat is that something, though?\n\nIt could be a row type, like PureScript.\nThat’d be awesome.\n\nWell now I’ve just worked myself up into a Mood about GHC’s record syntax.\nEven with OverloadedRecordDot, Haskell’s records are still bad, they’re just not awful.\n\nIgnore Records, Use Functions\n\nThis approach eschews records entirely for updates and uses set* functions.\nIt makes for a pretty clean interface.\n\nenv :: Env\nenv = \n    addRequestHook (\\req -&gt; log req &gt;&gt; pure req)\n    $ mkEnv EnvArgs\n        { accountId = &quot;asdfasdf&quot;\n        , accountPassword = &quot;hunter42&quot;\n        }\n\naddRequestHook :: (Request -&gt; IO Request) -&gt; Env -&gt; Env\naddRequestHook newHook env = env\n    { requestHook = \\req -&gt; do\n        requestHook env req\n        newHook req\n    }\n\n\nThis is pretty tedious as a library author to write, but it gives you a better interface.\n\nIt would be nice if we could use this for construction, too.\nBut this is a challenge because the type would change with each new addition to the record.\nThe { ... } record syntax can know ahead of time how many fields there are, and GHC can issue warnings (or errors) if any are missing.\n\nType Changing Updates\n\nWe can use a type parameter for each field that is required to be set.\n\ndata EnvP a b = EnvP\n    { accountId :: a\n    , accountPassword :: b\n    , requestHook :: Request -&gt; IO Request\n    , responseHook :: Response -&gt; IO Response\n    }\n\ntype Env = EnvP String String\n\ndata Void\n\ndefaultEnv :: EnvP Void Void\ndefaultEnv = EnvP\n    { requestHook = pure\n    , responseHook = pure\n    }\n\n\nGHC will issue warnings here, but that’s okay - we know they’re undefined at the type level.\n\nNow we can write our set functions:\n\nsetAccountId :: String -&gt; EnvP a b -&gt; EnvP String b\nsetAccountId str env = env { accountId = str }\n\nsetAccountPassword :: String -&gt; EnvP a b -&gt; EnvP a String\nsetAccountPassword str env = env { accountPassword = str }\n\nenv :: Env\nenv = \n    setAccountId &quot;asdfasdf&quot; \n    $ setAccountPassword &quot;hunter42&quot;\n    $ defaultEnv\n\n\nAnd, well, this actually works out.\nIf we only expose the Env type (and maybe a pattern synonym for construction/deconstruction), this interface should be pretty safe and straightforward.\nA final mkEnv call could even put it behind a newtype wrapper, or a similar datatype, similar to the *Args pattern above.\nThe boilerplate sucks, but would be easy to TemplateHaskell away.\n\nCan OverloadedRecordDot help us here?\nWith some of the tricks in Stealing impl From Rust, sort of.\nWe can write simple setters:\n\ndata User = User { name :: String }\n\ninstance HasField &quot;setName&quot; User (String -&gt; User) where\n    getField self newName = \n        self { name = newName }\n\n\nAnd, using the One Weird Trick to defeat functional dependencies, we can write type-changing setters, too!\n\ninstance \n    HasField &quot;setAccountId&quot; (EnvP a b) (x -&gt; EnvP x b)\n  =&gt;\n    HasField &quot;setAccountId&quot; (EnvP a b) (x -&gt; EnvP x b)\n  where\n    getField self x = self { accountId = x }\n\n\nNow, to provide a good UX, we’d want to require this be String, possibly with a nice TypeError constraint that complains.\nBut this’ll work for now - we can totally write this:\n\nenv :: EnvP String Void\nenv = defaultEnv.setAccountId &quot;asdfasdf&quot;\n\n\nUnfortunately, chaining this isn’t really feasible.\n\nenv :: EnvP String String\nenv = defaultEnv.setAccountId &quot;asdfasdf&quot;.setAccountPassword &quot;hunter42&quot; \n\n\nThis fails with an error, as .setAccountPassword is attaching to &quot;asdfasdf&quot;, not the return of defaultEnv.setAccountId &quot;asdfasdf&quot;.\nSo we can work around this with parens:\n\nenv :: EnvP String String\nenv = \n    (defaultEnv.setAccountId &quot;asdfasdf&quot;).setAccountPassword &quot;hunter42&quot; \n\n\nThis gets annoying, especially as the chaining goes up.\nAssigning to intermediate values also works:\n\nenv :: EnvP String String\nenv = \n    let \n        withId = defaultEnv.setAccountId &quot;asdfasdf&quot;\n        withPassword = withId.setAccountPassword &quot;hunter42&quot; \n     in \n        withPassword\n\n\nBut, at this point, I’m wondering how this is any better than just writing\n\nenv :: EnvP String String\nenv = setAccountId &quot;asdfadsf&quot; $ setAccountPassword &quot;hunter42&quot; defaultEnv\n\n\nUnfortunately, the type errors can get a bit weird and annoying carrying around the EnvP value.\nWrapping it in a newtype or translating to a separate data structure can make errors better.\nIt also distinguishes the “create this record” and “use this record” scenarios.\n\nBack to Args\n\nAnd, yeah, ultimately, I think Args is probably the right way to go.\n\nThere’s not really much to a library for it.\nYou’d define a class like this:\n\nclass New a where\n    type Args a = r | r -&gt; a\n    \n    new :: Args a -&gt; a\n\n\nYou want the TypeFamilyDependencies annotation on Args because you want the argument type to inform the result type.\nA data family would also work, but it would not allow you to define it separately and document it with a separate type name.\nMaybe a problem, maybe not.\nIt may also be nice to vary the return type, allowing IO, for example.\nThat looks like this:\n\nclass New a where\n    type Args a = r | r -&gt; a\n    type Return a = r | r -&gt; a\n    type Return a = a\n\n    new :: Args a -&gt; Return a\n\n\nBut now we’ve just, got, like, this type class, where it takes a thing, and returns another thing (maybe in IO, maybe not?? who knows).\nAnd this is so general and lawless that making a library for it seems a bit silly.\n\nSo, instead of writing a library, I wrote a blog post.\n    "
}