{
  "title":"Combining Axum, Hyper, Tonic, and Tower for hybrid web/gRPC apps: Part 1",
  "date":"2021-08-29T17:00:00.000000-07:00",
  "author":null,
  "id":"https://www.fpcomplete.com/blog/axum-hyper-tonic-tower-part1/",
  "link":"https://www.fpcomplete.com/blog/axum-hyper-tonic-tower-part1/",
  "content":"I've played around with various web server libraries and frameworks in Rust, and found various strengths and weaknesses with them. Most recently, I put together an FP Complete solution called Zehut (which I'll blog about another time) that needed to combine a web frontend and gRPC server. I used Hyper, Tonic, and a minimal library I put together called routetype. It worked, but I was left underwhelmed. Working directly with Hyper, even with the minimal routetype layer, felt too ad-hoc.\nWhen I recently saw the release of Axum, it seemed to be speaking to many of the needs I had, especially calling out Tonic support. I decided to make an experiment of replacing the direct Hyper+routetype usage I'd used with Axum. Overall the approach works, but (like the routetype work I'd already done) involved some hairy business around the Hyper and Tower APIs.\nI've been meaning to write some blog post/tutorial/experience report for Hyper+Tower for a while now. So I decided to take this opportunity to step through these four libraries (Tower, Hyper, Axum, and Tonic), with the specific goal in mind of creating hybrid web/gRPC apps. It turned out that there was more information here than I'd anticipated. To make for easier reading, I've split this up into a four part blog post series:\n\nToday's post: overview of Tower\nUnderstanding Hyper, and first experiences with Axum\nDemonstration of Tonic for a gRPC client/server\nHow to combine Axum and Tonic services into a single service\n\nLet's dive in!\n\n  \n  \n    Subscribe to our blog via email\n  \n  Email subscriptions come from our Atom feed and are handled by follow.it. You will only receive notifications of blog posts, and can unsubscribe any time.\n\nWhat is Tower?\nThe first stop on our journey is the tower crate. To quote the docs, which state this succinctly:\n\nTower provides a simple core abstraction, the Service trait, which represents an asynchronous function taking a request and returning either a response or an error. This abstraction can be used to model both clients and servers.\n\nThis sounds fairly straightforward. To express it in Haskell syntax, I'd probably say Request -&gt; IO Response, leveraging the fact that IO handles both error handling and asynchronous I/O. But the Service trait is necessarily more complex than that simplified signature:\npub trait Service"
}