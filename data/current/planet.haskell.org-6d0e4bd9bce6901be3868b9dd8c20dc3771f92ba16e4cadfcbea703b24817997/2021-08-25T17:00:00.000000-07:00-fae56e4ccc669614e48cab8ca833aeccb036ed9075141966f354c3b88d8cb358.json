{
  "title":"Daily ICFP: Day 3",
  "date":"2021-08-25T17:00:00.000000-07:00",
  "author":null,
  "id":"https://tweag.io/blog/2021-08-26-icfp3/",
  "link":"https://tweag.io/blog/2021-08-26-icfp3/",
  "content":"Daily ICFP\nSeveral Tweagers all agreed to gather notes here about our\nICFP (International Conference on Functional\nProgramming) experiences.\nOther posts in this series:\n\nICFP - Day 0\nICFP - Day 1\nICFP - Day 2\nICFP - Day 4\nICFP - Day 5\n\nDay 3 - Wednesday\nThese notes follow Noon, Arnaud, and Richard through their day at ICFP,\nroughly in order.\nNoon — On Continuation-Passing Transformations and Expected Cost Analysis\n\nDiscussion of the difficulty of costing probabilistic algorithms (i.e. you don’t know what it will do.)\nTurns out using continuations makes it a bit easier to reason about (I didn’t quite follow the trick that makes it true),\nBut, it gives a way to think compute average-cost analysis, which seems pretty useful!\n\nNoon — Automatic Amortized Resource Analysis with the Quantum Physicist’s Method\n\nQuantum physics? I’m interested.\n“This talk doesn’t involve any quantum physics at all”. Oh well.\nIdea is to think in terms of an “energy bank” and how much your program will need over time.\nCan use this to think about time, and space.\nAnalogy to Alice and Bob having some fixed money and some fixed task (buying candy).\nTheir idea is to take a (kind-of) super-position of all kinds of ways of splitting up resources (money).\nThis helps with some technical detail of the standard amortized resource approaches (I didn’t quite get why.)\nReally enjoyable.\nDefinitely curious to take a look at this paper!\n\nArnaud — GhostCell: Separating Permissions from Data in\nRust\nThis talk addresses an important problem in the Rust programming\nlanguage: how does one write a structure with pointer sharing in Rust\n(typically: a doubly-linked list). Until now, it was either using\nunsafe features (danger!) or using a Cell type (slow and icky). In\nthis talk a new safe and efficient approach is proposed. Which would\nbe remarkable already. But the authors also proved their approach\nsafe in Coq, as part of the RustBelt project. Impressive.\nNoon — Skipping the Binder Bureaucracy with Mixed Embeddings in a Semantics Course\n\nIn learning about proofs and correctness, how to get to the good stuff faster?\nAnswer: By using features of the host/meta language.\nI’m personally unconvinced (not that I’m an expert); it seems worse to me to have implicit implementation details that students don’t quite understand.\nBut I do understand the desire to speed up getting to the good parts!\nAnd maybe this is a good technique when not teaching? Just for your own experimenting? Probably.\n\nRichard — Skipping the Binder Bureaucracy with Mixed Embeddings in a\nSemantics Course (Functional\nPearl),\nby Adam Chlipala\nThis was a nice talk about a technique Adam uses in his course on formal\nverification of programming languages using the Coq proof assistant. His goal\nis to take undergraduates, in a single semester, from no experience with Coq\nto being able to do non-trivial proofs on programming languages with e.g.\neffects or concurrency. The talk describes the use of mixed embeddings in\nhis formalization of effectful languages: use a deep embedding of the command\nlanguage but a shallow embedding of expressions. That is, the command\nstructure (e.g. write to memory, goto, etc.) is expressed using a datatype,\nbut expressions (that evaluate to some value) are just written in Coq’s native\nsyntax. This allows for e.g. proofs about commands without needing to worry at\nall about expressions (and variable binding!).\nI had previously viewed shallow embeddings as a bit of a parlor trick: if\nyou’re describing a programming language that has behavior very similar to the\none you’re writing in, you can skip some of the description. But the whole\ntrick depends on a close correspondence between the object language (that is,\nthe one you’re implementing) and the host language (that is, the one you’re\nwriting in). Yet this presentation made me realize that shallow embeddings are\nconsiderably cheaper than deep ones — in the cases when the trick works.\nCheap and cheerful is sometimes indeed better than fully general — especially\nif it allows undergrads to access advanced material so quickly.\nRichard — Catala: A Programming Language for the\nLaw,\nby Denis Merigoux, Nicolas Chataing, and Jonathan Protzenko\nI was so excited when I saw this paper in the program, as I always wondered\nhow we could take legal statutes and formalize them. This paper attempts this\nfor the tax code, where the rules are very algorithmic. (Formalizing, e.g.,\nslander laws seems harder.) The authors worked with lawyers to design a\nlanguage, Catala, that is a fully expressive functional language while using a\nsyntax easily readable by lawyers (i.e. domain experts). In the act of\ntranslating tax statutes into Catala, lawyers frequently discovered new\nambiguities in the law. In the Q&amp;A session, we even imagined writing\nQuickCheck properties over laws. (Example: you would probably want a monotonic\ntax system, where an increase in gross income never yields a decrease in\ntake-home income. Indeed, Jonathan explained that non-monotonic tax law is\nactually unconstitutional in France — yet he believes the existing tax law is\nnon-monotonic anyway.)\nThis talk filled me with optimism at the receptiveness of lawyers to this new\ntechnology. The research group is actively seeking new groups to collaborate\nwith.\nNoon — Catala: A Programming Language for the Law\n\nOne of the few (only?) talk about a paper that I had actually read before the conference!\nI’ve been fascinated with tax calculations since reading the various Piketty books.\nMotivation: Converting law into code is hard and sometimes subjective.\nIRS income tax program implemented in assembly from the 60s!\nIdea: Mix law and code together (as both are necessary for determining correctness.)\nInteresting fact: The language was at least partly co-designed by lawyers who helped pick the keywords,\nQuite liked this idea and the talk!\n\nNoon — PLTea\n\nSome interesting conversations.\n\nNoon — Programming Contest Report\n\nAn astonishing amount of work goes into this.\nRichard: Yes, it does! I’m amazed every year by the generosity of the organizers of this contest in planning and executing it.\n\nRichard — Program Chair Report\nMany conferences include a report from the program chair, including\ninformation about the number of submissions, the selection process, and how\nmany papers got accepted. Interestingly, the pandemic has had only a small\neffect on the number of submissions to ICFP, despite anecdotal evidence I’ve\nheard that submissions are down in other scientific fields. (Plausible\ntheories: less time for focused thought during school shutdowns; less ability\nto focus due to anxiety in the news; less research time for faculty who teach\ndue to the need to redesign courses to work well in a remote format.) Maybe\nthis means that interest in ICFP is actually going up, cancelling out the\nnegative effect of the pandemic. Huge thanks to Ron Garcia for chairing the\nprogram committee and to Sukyoung Ryu for chairing the conference!\nNoon — Industrial Reception\n\nHad a really enjoyable chat with the various visitors to the Tweag table. Thanks everyone for stopping by!\n\nRichard — I second that comment about the Industrial Reception. We had a\nvery nice crew of people interested both in Tweag and in research ideas. Among\nmore Tweag-centric discussions, I had a small but fascinating conversation\nabout which is more fundamental: math or computer science. I’ve felt for a few\nyears that computer science is just applied mathematics, but the way in which\ndependent types can describe fundamental mathematical concepts makes me wonder\nsometimes whether I’ve gotten the relationship backwards. As a case in point,\nI wondered aloud with a visitor to the Tweag table (I did not ask permission\nfor posting their name) about how to re-express the fundamental definitions\nabout differential calculus on manifolds using dependent types. This sounds\nvery, very fun, but I worry it will be too distracting from “real” work (like\ncontinuing to improve GHC)! We’ll see whether I can fit this in.\nRichard — How to design co-programs, by Jeremy Gibbons\nThis presentation gives a wonderfully elegant, simple approach to taking the\nfirst steps toward writing functions. There are no advanced concepts (don’t\ntrip over the word “corecursion”!) and the video shows how typed functional\nprogramming is such an aide to reasoning about how to write programs.\nRichard — Leibniz equality is isomorphic to Martin-Löf identity, parametrically, by Andreas Abel, Jesper Cockx, Dominique Devriese, Amin Timany, and Philip Wadler (presented by Phil)\nThis paper presents a proof that Leibniz equality and Martin-Löf equality are\nisomorphic. The talk gives very nice introductions to both of these concepts,\nso I am going to skip that here. As the talk concedes, the isomorphism between\nthese two notions of equality is not necessarily all that useful, but it’s\nnice to know how the proof can be done, and it’s interesting that the proof\nrequires an assumption of parametricity. The paper (and presentation!) are\nboth literate Agda, meaning that rendering the LaTeX or slides also\ntype-checks the technical content, giving greater assurance of the result.\nThis talk is a nice peek into the power of dependent types to write formal proofs!\nRichard — If other attendees at ICFP are reading this, please spend more\ntime in the lounge! A few times I cruised through the lounge looking for new\nfolks to meet and left disappointed. Somehow, last year’s ICFP did not suffer\nfrom this problem: I had many great out-of-band conversations. Maybe the\nnovelty of online conferences has worn off? I’ve still had a number of fine\nconversations this year, but it definitely feels a step down from last year.\n    "
}