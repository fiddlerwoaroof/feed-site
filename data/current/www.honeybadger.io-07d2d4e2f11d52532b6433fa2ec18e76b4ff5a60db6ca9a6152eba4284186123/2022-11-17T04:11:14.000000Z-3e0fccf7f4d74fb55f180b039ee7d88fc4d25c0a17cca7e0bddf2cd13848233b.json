{
  "title":"An Intro to dry-schema in Ruby",
  "date":"2022-11-17T04:11:14.000000Z",
  "author":"Abiodun Olowode",
  "id":"https://www.honeybadger.io/blog/ruby-dry-schema/",
  "link":"https://www.honeybadger.io/blog/ruby-dry-schema/",
  "content":"<p>The <code>dry-schema</code> gem is part of a set of gems in the <code>dry-rb</code> family. Its main focus is data-structure and value-type validation. It is a general-purpose data validation library and multiple times faster than <code>ActiveRecord/ActiveModel::Validations</code> and strong parameters. It can be used for, but is not restricted to, validating the following:</p>\n\n<ul>\n<li>Form params</li>\n<li>&quot;GET&quot; params</li>\n<li>JSON documents</li>\n<li>YAML documents</li>\n<li>Application configuration (i.e., stored in ENV)</li>\n<li>Replacement for strong-parameters</li>\n</ul>\n\n<p>If youâ€™re asking, &quot;Do I need it?&quot;, a quick example might convince you. Consider a &quot;User&quot; model with name and age attributes in a Rails app with validation for the name attribute as shown below.</p>\n\n<p><img src=\"/images/blog/posts/ruby-dry-schema/user_migration.png\" alt=\"User Migration\"></p>\n\n<p>Let's add a validation to the user model:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n  <span class=\"n\">validates</span> <span class=\"ss\">:name</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"kp\">true</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>In our Rails console, we can see the result of certain commands run:</p>\n\n<p><img src=\"/images/blog/posts/ruby-dry-schema/rails_errors.png\" alt=\"Rails Errors\"></p>\n\n<p>We observe that the error shown when the name key is missing is the same as when it's present, but its value is <code>nil</code>. This leads to some confusion about what exactly made the params unacceptable. However, with <code>dry-schema</code>, not only can the key presence be verified separately from values, but validations are also separated from the model. Let's dive into <code>dry-schema</code> and how to use it.</p>\n\n<h2 id=\"understanding-dry-schema-macros\">Understanding Dry-Schema Macros</h2>\n\n<p>Let's create a new folder named <code>dry-schema</code> and, within it, create a file called <code>user_schema.rb</code>. Within this folder, install the gem using the command <code>gem install dry-schema</code>.</p>\n\n<p>Beginning with tackling the validation error we had above, let's start with the macro called <em>filled</em>. Within the <code>user_schema.rb</code> file, we'll create a user schema and add a validation for the name field.</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">module</span> <span class=\"nn\">User</span>\n  <span class=\"nb\">require</span> <span class=\"s1\">'dry-schema'</span>\n\n  <span class=\"no\">Schema</span> <span class=\"o\">=</span> <span class=\"no\">Dry</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">.</span><span class=\"no\">Params</span> <span class=\"k\">do</span>\n    <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:name</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"ss\">:string</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Above, we have required the <code>dry-shcema</code> gem and created a schema for the user params. We have indicated that we require the name field to be present and be filled with a string. Starting an irb session, we can load the file via the command <code>load './user_schema.rb'</code>.</p>\n\n<p><img src=\"/images/blog/posts/ruby-dry-schema/user_schema_error.png\" alt=\"User Schema Errors\"></p>\n\n<p>From the above, we can see that there's a clear distinction between the error shown when a key is absent and when a value is absent. With <code>dry-schema</code>, we're not in doubt about what exactly went wrong with the params provided. Within Rails, these validations can be carried out on a model instance before it is saved, as opposed to ActiveRecord validations.</p>\n\n<p>The <code>filled</code> macro should be employed when a value is expected to be filled. This means that the value is non-nil and, in the case of a string, hash, or array value, that the value is not <code>.empty?</code>.</p>\n\n<p>The opposite of the &quot;filled&quot; macro is the &quot;maybe&quot; macro. It is used when a value can be nil. Macros are specific to the values and not the keys, which means that &quot;maybe&quot; does not in any way signify that a key can be missing or that the value type is not enforced.</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">module</span> <span class=\"nn\">User</span>\n  <span class=\"nb\">require</span> <span class=\"s1\">'dry-schema'</span>\n\n  <span class=\"no\">Schema</span> <span class=\"o\">=</span> <span class=\"no\">Dry</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">.</span><span class=\"no\">Params</span> <span class=\"k\">do</span>\n    <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:name</span><span class=\"p\">).</span><span class=\"nf\">maybe</span><span class=\"p\">(</span><span class=\"ss\">:string</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p><img src=\"/images/blog/posts/ruby-dry-schema/maybe.png\" alt=\"Maybe Schema\"></p>\n\n<p>As seen above, there are no errors when the value of the name key is empty or nil, because the &quot;maybe&quot; macro is in play. However, we get an error when the name key is not present because the key is &quot;required&quot;.\nThere are several other macros, such as hash, each, schema, and array. You can find out more about them <a href=\"https://dry-rb.org/gems/dry-schema/1.5/basics/macros/\">here</a>.</p>\n\n<h2 id=\"optional-keys\">Optional Keys</h2>\n\n<p>As stated earlier, we can declare a value optional by using the &quot;maybe&quot; macro. However, to make a key optional, the <code>optional</code> method is invoked.</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">module</span> <span class=\"nn\">User</span>\n  <span class=\"nb\">require</span> <span class=\"s1\">'dry-schema'</span>\n\n  <span class=\"no\">Schema</span> <span class=\"o\">=</span> <span class=\"no\">Dry</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">.</span><span class=\"no\">Params</span> <span class=\"k\">do</span>\n    <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:name</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"ss\">:string</span><span class=\"p\">)</span>\n    <span class=\"n\">optional</span><span class=\"p\">(</span><span class=\"ss\">:age</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"ss\">:integer</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Here, we're requiring the &quot;name&quot; key to have a string value but making it optional to supply the &quot;age&quot; key. However, if the &quot;age&quot; key is present, we expect that it must be filled with a value of integer type.</p>\n\n<p><img src=\"/images/blog/posts/ruby-dry-schema/optional_key.png\" alt=\"Optional key\"></p>\n\n<p>Notice something cool? One of the features of dry-schema is type coercion. As seen above, despite the age value being supplied as a string type, it is coerced into an integer type. Also, we have no errors when the &quot;age&quot; key is not supplied, however, when supplied, there is an insistence on it being filled with a value of integer type.</p>\n\n<h2 id=\"carrying-out-type-and-value-checks\">Carrying out Type and Value Checks</h2>\n\n<p>As seen above, we have already been introduced to two type checks for values: &quot;string&quot; and &quot;integer&quot;. However, values can be type-checked directly using the &quot;value&quot; method, and further checks can be carried out on these types, such as size checks, using built-in predicates.</p>\n\n<p>Examples:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">module</span> <span class=\"nn\">User</span>\n  <span class=\"nb\">require</span> <span class=\"s1\">'dry-schema'</span>\n\n  <span class=\"no\">Schema</span> <span class=\"o\">=</span> <span class=\"no\">Dry</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">.</span><span class=\"no\">Params</span> <span class=\"k\">do</span>\n    <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:age</span><span class=\"p\">).</span><span class=\"nf\">value</span><span class=\"p\">(</span><span class=\"ss\">:integer</span><span class=\"p\">,</span> <span class=\"ss\">gt?: </span><span class=\"mi\">18</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p><img src=\"/images/blog/posts/ruby-dry-schema/value_checks.png\" alt=\"Value Checks\"></p>\n\n<p>The first error shows us that the type is wrong, but when corrected, the second check for value is carried out using the built-in predicates. This can also be carried further down into arrays:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">module</span> <span class=\"nn\">User</span>\n  <span class=\"nb\">require</span> <span class=\"s1\">'dry-schema'</span>\n\n  <span class=\"no\">Schema</span> <span class=\"o\">=</span> <span class=\"no\">Dry</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">.</span><span class=\"no\">Params</span> <span class=\"k\">do</span>\n    <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:words</span><span class=\"p\">).</span><span class=\"nf\">value</span><span class=\"p\">(</span><span class=\"n\">array</span><span class=\"p\">[</span><span class=\"ss\">:string</span><span class=\"p\">],</span> <span class=\"ss\">size?: </span><span class=\"mi\">3</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p><img src=\"/images/blog/posts/ruby-dry-schema/arrays.png\" alt=\"Array Checks\"></p>\n\n<p>As seen above, the errors are thrown accordingly, based on the values provided and how well they conform to our requirements.\nThe dry-schema built-in predicates can also be used to check values directly without initial type checks.</p>\n\n<p>For example:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">module</span> <span class=\"nn\">User</span>\n  <span class=\"nb\">require</span> <span class=\"s1\">'dry-schema'</span>\n\n  <span class=\"no\">Schema</span> <span class=\"o\">=</span> <span class=\"no\">Dry</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">.</span><span class=\"no\">Params</span> <span class=\"k\">do</span>\n    <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:age</span><span class=\"p\">).</span><span class=\"nf\">value</span><span class=\"p\">(</span><span class=\"ss\">eql?: </span><span class=\"mi\">12</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Youâ€™ll find a list of more predicates <a href=\"https://dry-rb.org/gems/dry-schema/1.5/basics/built-in-predicates/\">here</a> and how to use them.</p>\n\n<h2 id=\"working-with-schemas\">Working with Schemas</h2>\n\n<p>To accurately work with schemas, one would need to know how to access the result of schema calls and determine whether the calls were successful. Let's assume that a school was hosting a party, and all students would have to enroll for the party; however, there are conditions to be met before being successfully enrolled. We can draw up a schema of the types and values we would accept, validate the params provide using this schema, and if successful, go ahead and enroll a student.</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">PartyEnrollment</span>\n  <span class=\"nb\">attr_accessor</span> <span class=\"ss\">:enrollment_list</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">initialize</span>\n    <span class=\"vi\">@enrollment_list</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">enroll</span><span class=\"p\">(</span><span class=\"n\">enrollment_params</span><span class=\"p\">)</span>\n    <span class=\"n\">validation</span> <span class=\"o\">=</span> <span class=\"no\">Student</span><span class=\"o\">::</span><span class=\"no\">PartySchema</span><span class=\"p\">.</span><span class=\"nf\">call</span><span class=\"p\">(</span><span class=\"n\">enrollment_params</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"n\">validation</span><span class=\"p\">.</span><span class=\"nf\">success?</span>\n      <span class=\"n\">enroll_student</span><span class=\"p\">(</span><span class=\"n\">validation</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"n\">reject_student</span><span class=\"p\">(</span><span class=\"n\">validation</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"kp\">private</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">enroll_student</span><span class=\"p\">(</span><span class=\"n\">validation</span><span class=\"p\">)</span>\n    <span class=\"n\">student_details</span> <span class=\"o\">=</span> <span class=\"n\">validation</span><span class=\"p\">.</span><span class=\"nf\">to_h</span>\n    <span class=\"n\">enrollment_list</span><span class=\"p\">.</span><span class=\"nf\">push</span><span class=\"p\">(</span><span class=\"n\">student_details</span><span class=\"p\">[</span><span class=\"ss\">:name</span><span class=\"p\">])</span>\n    <span class=\"s2\">&quot;You have been successfully enrolled&quot;</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">reject_student</span><span class=\"p\">(</span><span class=\"n\">validation</span><span class=\"p\">)</span>\n    <span class=\"n\">errors</span> <span class=\"o\">=</span> <span class=\"n\">validation</span><span class=\"p\">.</span><span class=\"nf\">errors</span><span class=\"p\">.</span><span class=\"nf\">to_h</span>\n    <span class=\"n\">errors</span><span class=\"p\">.</span><span class=\"nf\">each</span> <span class=\"k\">do</span> <span class=\"o\">|</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"o\">|</span>\n      <span class=\"nb\">puts</span> <span class=\"s2\">&quot;Your </span><span class=\"si\">#{</span><span class=\"n\">key</span><span class=\"si\">}</span><span class=\"s2\"> </span><span class=\"si\">#{</span><span class=\"n\">value</span><span class=\"p\">.</span><span class=\"nf\">first</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>As seen above, we have a <code>PartyEnrollment</code> class, which, when initialized, possesses an enrollment list. When the <code>enroll</code> method is called, we ask the <code>StudentSchema</code> to validate the parameters supplied. To determine whether the validation was successful, we have the <code>.success?</code> method, and to check whether it wasn't, we have the <code>.failure?</code> method. If successful, we proceed to the <code>enroll_student</code> method, where we see that we can access the result of this validation as a hash by calling the <code>to_h</code> method on it; otherwise, we go ahead and reject that student using the <code>reject_student</code> method, where we access the errors by calling the <code>errors</code> method on the validation and then, proceed to convert it to a hash for easy accessibility.</p>\n\n<p>Next in line would be to write the student schema to determine the rules we want to be applied. Let's assume that in our case, we would want the name and age filled, and we would be checking that the student is above 15 years of age.</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">module</span> <span class=\"nn\">Student</span>\n  <span class=\"nb\">require</span> <span class=\"s1\">'dry-schema'</span>\n\n  <span class=\"no\">PartySchema</span> <span class=\"o\">=</span> <span class=\"no\">Dry</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">.</span><span class=\"no\">Params</span> <span class=\"k\">do</span>\n    <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:name</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"ss\">:string</span><span class=\"p\">)</span>\n    <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:age</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"ss\">:integer</span><span class=\"p\">,</span> <span class=\"ss\">gt?: </span><span class=\"mi\">15</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Let's see if this works \uD83E\uDD1E.</p>\n\n<p><img src=\"/images/blog/posts/ruby-dry-schema/party.png\" alt=\"Party Checks\"></p>\n\n<h2 id=\"re-using-schemas\">Re-using Schemas</h2>\n\n<p>Schemas can be re-used. This ensures that we can keep our code dry. In addition to the example above, let's include an address to the required parameters to enable the school bus to drop students off at home after the supposed party. However, we're certain that this is not the only occasion where we would be required to save a student's address. Let's create an address schema to take care of this need:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"no\">AddressSchema</span> <span class=\"o\">=</span> <span class=\"no\">Dry</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">.</span><span class=\"no\">Params</span> <span class=\"k\">do</span>\n  <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:street</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"ss\">:string</span><span class=\"p\">)</span>\n  <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:city</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"ss\">:string</span><span class=\"p\">)</span>\n  <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:zipcode</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"ss\">:string</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>We can use the <code>AddressSchema</code> within the party schema this way:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"no\">PartySchema</span> <span class=\"o\">=</span> <span class=\"no\">Dry</span><span class=\"o\">::</span><span class=\"no\">Schema</span><span class=\"o\">.</span><span class=\"no\">Params</span> <span class=\"k\">do</span>\n  <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:name</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"ss\">:string</span><span class=\"p\">)</span>\n  <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:age</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"ss\">:integer</span><span class=\"p\">,</span> <span class=\"ss\">gt?: </span><span class=\"mi\">15</span><span class=\"p\">)</span>\n  <span class=\"n\">required</span><span class=\"p\">(</span><span class=\"ss\">:address</span><span class=\"p\">).</span><span class=\"nf\">filled</span><span class=\"p\">(</span><span class=\"no\">AddressSchema</span><span class=\"p\">)</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Attempting to enroll a student for the party without providing the proper address results in the following errors:</p>\n\n<p><img src=\"/images/blog/posts/ruby-dry-schema/address.png\" alt=\"Address Errors\"></p>\n\n<p>As seen above, the address field is being validated by the <code>AddressSchema</code>; furthermore, since the address is a hash, the error for the address is in that same format <code>{:address=&gt;{:city=&gt;[&quot;is missing&quot;],:zipcode=&gt;[&quot;is missing&quot;]}}</code>. As a result, the error we're returning to the user will need to be rewritten to take this into consideration.</p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>In the dry-schema documentation, we find the following schema-definition best practices:</p>\n\n<ul>\n<li>Be specific about the exact shape of the data, and define all the keys that you expect to be present.</li>\n<li>Specify optional keys, too, even if you don't need additional rules to be applied to their values.</li>\n<li>Specify type specs for all values.</li>\n<li>Assign schema objects to constants for convenient access.</li>\n<li>Define a base schema for your application with a common configuration.</li>\n</ul>\n\n<p>If adhered to, parameter validation can be carried out seamlessly, thereby reducing the number of errors encountered within an application. You can find more information about dry-schema in the <a href=\"https://dry-rb.org/gems/dry-schema/1.5/\">documentation</a>.</p>\n"
}