{
  "title":"A Deep Dive into Active Record Validations",
  "date":"2022-11-17T04:11:14.000000Z",
  "author":"Aestimo Kirina",
  "id":"https://www.honeybadger.io/blog/active-record-validations/",
  "link":"https://www.honeybadger.io/blog/active-record-validations/",
  "content":"<p>Many activities that used to be done offline can now be done online, from booking flights to opening bank accounts, shopping online, and much more. At the heart of it, we shouldn’t forget that data are powering all these online transactions.</p>\n\n<p>Therefore, to ensure that everything runs seamlessly, the data stored in databases must be of the right quality. However, what is an effective way to ensure data integrity, especially when a big chunk of it is user-generated? This is where data validations are useful.</p>\n\n<p>Ruby on Rails is structured on the MVC architecture. The &quot;M&quot;, also called the model layer, is responsible for managing how objects are created and stored in a database. In Rails, the model layer is run by Active Record by default, and as such, Active Record is responsible for handling the important task of data validation.</p>\n\n<p>In simple terms, validations are a set of rules that declare whether a model is valid based on various criteria. Every model object contains an <code>errors</code> collection. In valid models, this collection contains no errors and is empty. When you declare validation rules on a certain model that it fails to pass, then its errors collection will contain errors consistent with the rules you've set, and this model will not be valid.</p>\n\n<p>A simple example is checking whether a certain user input, such as an email field, contains any data after a user form is submitted. If the data is missing, an error message will be shown to the user so that he or she can provide it.</p>\n\n<p>In this article, we'll explore the different validations that come packaged with Active Record, beginning with simple ones: validating the presence of something, validating by data type, and validating by regex. We'll also cover more complex topics, such as how to use validations with Active Storage, how to write your own custom rules, including how to customize the error messages being shown to users, how to test validation rules, and more.</p>\n\n<h2 id=\"prerequisites\">Prerequisites</h2>\n\n<p>In this tutorial, we'll be using a simple app featuring Users, Plans, and Subscriptions. With this example, we should be able to cover the range of validation possibilities from the simple to the more complex ones. You can find the example app code <a href=\"https://github.com/iamaestimo/active-record-validations-tutorial\">here</a>.</p>\n\n<p>You'll also need the following:</p>\n\n<ul>\n<li>A working Rails 7 installation</li>\n<li>Bundler installed</li>\n<li>Intermediate to advanced Ruby on Rails experience</li>\n</ul>\n\n<p>This should be fun, so let's go!</p>\n\n<h2 id=\"built-in-simple-validations\">Built-in Simple Validations</h2>\n\n<h3 id=\"validating-the-presence-and-absence-of-attributes\">Validating the Presence and Absence Of Attributes</h3>\n\n<p>This simple validation is for checking the presence or, in some cases, the absence of an attribute. In the example code below, we're checking to see if the title attribute on our Post model is present before it's saved.</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\"># app/models/user.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"c1\"># validating presence</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:name</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"kp\">true</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:email</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"kp\">true</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>So, if you try to submit the form for the user model in the example code above, and it's missing either of the two fields, you will get an error and an error message that the field cannot be blank:</p>\n\n<p><img src=\"/images/blog/posts/active-record-validations/validating-presence.png\" alt=\"Validating Presence Error\"></p>\n\n<p>What about validating the absence of an attribute? Where would you utilize that, you may ask?</p>\n\n<p>Well, consider the rampant abuse of forms by bots and other automated scripts. One very simple way of filtering bot form submissions is through the use of &quot;honeypot&quot; fields.</p>\n\n<p>Here, you insert hidden form fields you are sure could never be filled by a normal human user since they would obviously not be visible to them. However, when a bot finds such a field, thinking it's one of the required form inputs, it fills it with some data. In this case, a filled-in honeypot field would indicate that our model is invalid.</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\">#app/models/user.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:honey_pot_field</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"kp\">false</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Let's look into another simple validation with an interesting use case.</p>\n\n<h3 id=\"validating-whether-two-attributes-match\">Validating Whether Two Attributes Match</h3>\n\n<p>To check if two fields submitted by a user match, such as a password field and a password confirmation field, you could use the <code>validates_confirmation_of</code> rule.</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\"># app/models/user.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"c1\"># validating presence</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:name</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"kp\">true</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:email</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"kp\">true</span>\n\n    <span class=\"c1\"># validating confirmation (that 2 fields match)</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:email_confirmation</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"kp\">true</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:email</span><span class=\"p\">,</span> <span class=\"ss\">confirmation: </span><span class=\"kp\">true</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>This validation rule works by creating a virtual attribute of the confirmation value and then comparing the two attributes to ensure that they match. In they don't, the user gets a confirmation error (we'll get into errors in detail a bit later in the article).</p>\n\n<p><img src=\"/images/blog/posts/active-record-validations/validating-confirmation.png\" alt=\"Validates confirmation error\"></p>\n\n<p>It's important to point out that the <code>validates_confirmation</code> rule only works if the confirmation field is also present (i.e., it isn’t nil), so make sure to use another rule, the <code>validates_presence_of</code>, to ensure that it's present.</p>\n\n<h3 id=\"validating-input-format\">Validating Input Format</h3>\n\n<p>Now let's go a little deeper and explore how to validate the format of user inputs using regular expressions.</p>\n\n<p>A particularly good case for using <code>validates_format_of</code> is when you need to be sure that a user is entering a valid email address (i.e., an email address that matches the format of a normal email address, not necessarily whether it's real).</p>\n\n<p>Using our example app, let's ensure that our user inputs a properly formatted email address using a regular expression. We do this by matching what the user inputs to an expected formatted string (see descriptive comments in the code example shown).</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"c1\"># must match a string that looks like an email; i.e., &lt;string 1&gt;@&lt;string 2&gt;.&lt;string 3&gt;</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:email</span><span class=\"p\">,</span> <span class=\"ss\">format: </span><span class=\"p\">{</span><span class=\"ss\">with: </span><span class=\"sr\">/\\A([^@\\s]+)@((?:[-a-z0-9]+\\.)+[a-z]{2,})\\z/</span> <span class=\"p\">}</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>If we try to create a user with an email address that doesn't fit to the expected format specified in the regex, such as &quot;smith@example&quot;, we’ll get an invalid email error:</p>\n\n<p><img src=\"/images/blog/posts/active-record-validations/email-format-validation.png\" alt=\"Email validation error\"></p>\n\n<p>Obviously, regular expressions can be more powerful than the example shown here. If the reader really wants to explore the subject, <a href=\"https://www.rubyguides.com/2015/06/ruby-regex/\">this resource</a>, although a bit dated, should provide a good starting point.</p>\n\n<p>Next, we’ll exploring another simple validation before moving on to advanced validations and error messages.</p>\n\n<h3 id=\"validating-the-length-of-an-input\">Validating the Length of an Input</h3>\n\n<p>Again, consider the password field of our example app. Let's say we want to ensure that all users enter a password with at least 8 characters and no more than 15 characters:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"c1\"># validating password length</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:password</span><span class=\"p\">,</span> <span class=\"ss\">length: </span><span class=\"mi\">8</span><span class=\"o\">..</span><span class=\"mi\">15</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>If the user supplies a password whose length is below the range specified in the validation rule, an appropriate error is shown:</p>\n\n<p><img src=\"/images/blog/posts/active-record-validations/validating-length-of-error.png\" alt=\"Validating input length\"></p>\n\n<p>For additional examples of simple validation, please see the ever dependable <a href=\"https://guides.rubyonrails.org/active_record_validations.html\">Ruby Guides</a>.</p>\n\n<p>Other simple built-in validations include:</p>\n\n<ul>\n<li>Validating inclusion, which checks whether a given input includes values from a provided set and works very well with enumerables.</li>\n<li>Validating comparison, which is used to compare two values.</li>\n</ul>\n\n<p>Before diving into advanced validations, it would be good idea to note that in Rails 7, the numericality validator now has the <code>only_numeric</code> option. This means that you now check whether a given input value is an instance of <a href=\"https://ruby-doc.org/core-3.1.1/Numeric.html\">Numeric</a>.</p>\n\n<p>Visit the <a href=\"https://guides.rubyonrails.org/active_record_validations.html\">Rails Guides</a> for more examples of built-in validations.</p>\n\n<h2 id=\"advanced-and-custom-validations\">Advanced and Custom Validations</h2>\n\n<p>Although quite useful, the validations we've looked at so far are rather simple. To do more, we would need to explore the built-in advanced validations and how to write our own custom validation rules, which will allow us to utilize more complex data validations.</p>\n\n<p>To begin, we’ll learn how to validate the uniqueness of a join model.</p>\n\n<h3 id=\"validating-the-uniqueness-of-a-join-model\">Validating the Uniqueness of a Join Model</h3>\n\n<p>Using our example, we'd like to ensure that a user can only have one subscription at any given time.</p>\n\n<p>The models from our example app are related as follows: User has many Plans through Subscriptions:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\"># app/models/user.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"n\">has_many</span> <span class=\"ss\">:subscriptions</span>\n    <span class=\"n\">has_many</span> <span class=\"ss\">:plans</span><span class=\"p\">,</span> <span class=\"ss\">through: :subscriptions</span>\n<span class=\"k\">end</span>\n</code></pre></div><div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\"># app/models/plan.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">Plan</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"n\">has_many</span> <span class=\"ss\">:subscriptions</span>\n    <span class=\"n\">has_many</span> <span class=\"ss\">:users</span><span class=\"p\">,</span> <span class=\"ss\">through: :subscriptions</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>A Subscription belongs to both the Plan and User models:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\"># app/models/subscription.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">Subscription</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n  <span class=\"n\">belongs_to</span> <span class=\"ss\">:plan</span>\n  <span class=\"n\">belongs_to</span> <span class=\"ss\">:user</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Therefore, to ensure that a User can only have a single Subscription, we would have to check that the user_id appears only once in the subscriptions join table using a uniqueness validation rule, as follows:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\"># app/models/subscription.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">Subscription</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n  <span class=\"n\">belongs_to</span> <span class=\"ss\">:plan</span>\n  <span class=\"n\">belongs_to</span> <span class=\"ss\">:user</span>\n\n  <span class=\"c1\"># ensure a user can only have a single subscription</span>\n  <span class=\"n\">validates_uniqueness_of</span> <span class=\"ss\">:user_id</span><span class=\"p\">,</span> <span class=\"ss\">scope: :plan_id</span><span class=\"p\">,</span> <span class=\"ss\">message: </span><span class=\"s2\">&quot;User can only have one subscription!&quot;</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>If you try to create an additional subscription for a user who already has one, you will get an error (customized for our example). We'll explore errors and custom messages a bit later in the article.</p>\n\n<p><img src=\"/images/blog/posts/active-record-validations/uniqueness_validation_error.png\" alt=\"Uniqueness Validation Error\"></p>\n\n<h3 id=\"conditional-validation\">Conditional Validation</h3>\n\n<p>It's important to note that all validation rules depend on the Active Model callback API. This means that you can easily use conditionals to determine whether the said validation rule can run.</p>\n\n<p>While implementing the conditional rule, you can pass in additional arguments in the form of a Ruby proc, a symbol, or a string.</p>\n\n<p>Using our example, let's say we'd like for a User to confirm their email address and, during the process, provide their phone number. In such a case, it is necessary for the User model to be persisted in the database in more than one state specifically, when a User has confirmed their email and when they have not.</p>\n\n<p>Thus, to check for the presence of the phone number field, we use a conditional validation:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"c1\"># validate phone number on condition</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:phone_number</span><span class=\"p\">,</span> <span class=\"ss\">presence: </span><span class=\"kp\">true</span><span class=\"p\">,</span> <span class=\"k\">if</span> <span class=\"ss\">:email_confirmed</span>\n\n    <span class=\"c1\"># assumes the user has confirmed their email</span>\n    <span class=\"k\">def</span> <span class=\"nf\">email_confirmed</span>\n        <span class=\"o\">!</span><span class=\"n\">confirmed</span><span class=\"p\">.</span><span class=\"nf\">blank?</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<h3 id=\"contextual-validation\">Contextual Validation</h3>\n\n<p>It is important to note that all the built-in validations happen when you save a record. However, there are instances where you'd like to modify this behavior, such as when running a particular validation on update and so forth.</p>\n\n<p>Such validations are called contextual validations because they run in a particular context. You create one by passing in the <code>:on</code> option.</p>\n\n<p>Using our example, let's assume that we want to mark a user as &quot;active&quot; when the user confirms their email address:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\"># app/models/user.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"n\">validates</span> <span class=\"ss\">:active</span><span class=\"p\">,</span> <span class=\"ss\">inclusion: </span><span class=\"p\">{</span><span class=\"ss\">in: </span><span class=\"p\">[</span><span class=\"kp\">true</span> <span class=\"kp\">false</span><span class=\"p\">]},</span> <span class=\"ss\">on: :email_confirmation</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">email_confirmation</span>\n        <span class=\"c1\"># email confirmation logic here..</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<h3 id=\"custom-validators\">Custom Validators</h3>\n\n<p>Using our example, let's say we'd like to ensure that users can only register using a business email address (i.e., we want to exclude any of the more common and standard email addresses).</p>\n\n<p>To do this, we could still use the built-in validation rules and a regular expression, but for the purposes of our tutorial, let's go the custom route.</p>\n\n<p>The first step is to create a custom validator class that inherits from ActiveModel Validator. Within it, you define a validate method in addition to any number of custom methods you'll be using in the validation process:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\"># app/validators/user_validator.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">UserValidator</span> <span class=\"o\">&lt;</span> <span class=\"no\">ActiveModel</span><span class=\"o\">::</span><span class=\"no\">Validator</span> \n    <span class=\"k\">def</span> <span class=\"nf\">validate</span><span class=\"p\">(</span><span class=\"n\">record</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">is_not_business_email</span><span class=\"p\">(</span><span class=\"n\">record</span><span class=\"p\">.</span><span class=\"nf\">email</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"kp\">true</span>\n            <span class=\"n\">record</span><span class=\"p\">.</span><span class=\"nf\">errors</span><span class=\"p\">.</span><span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"ss\">:email</span><span class=\"p\">,</span> <span class=\"s2\">&quot;This is not a business email!&quot;</span><span class=\"p\">)</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">is_not_business_email</span><span class=\"p\">(</span><span class=\"n\">email_address</span><span class=\"p\">)</span>\n        <span class=\"n\">matching_regex</span> <span class=\"o\">=</span> <span class=\"sr\">/^[\\w.+\\-]+@(live|hotmail|outlook|aol|yahoo|rocketmail|gmail)\\.com$/</span>\n        <span class=\"n\">std_email_match</span> <span class=\"o\">=</span> <span class=\"n\">email_address</span><span class=\"p\">.</span><span class=\"nf\">match</span><span class=\"p\">(</span><span class=\"n\">matching_regex</span><span class=\"p\">)</span>\n        <span class=\"n\">std_email_match</span><span class=\"p\">.</span><span class=\"nf\">present?</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Then, we need to tell our User model to use this custom validator:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\"># app/models/user.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"o\">...</span>\n    <span class=\"n\">validates_with</span> <span class=\"no\">UserValidator</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>Now, if the user now tries to register using the email address matches we've excluded, they will get an error message:</p>\n\n<p><img src=\"/images/blog/posts/active-record-validations/custom-validation-error.png\" alt=\"Custom Validator Error\"></p>\n\n<p>An interesting use-case for validation is when we need to write validation rules for handling Active Storage attachments.</p>\n\n<h3 id=\"handling-active-storage-validations\">Handling Active Storage Validations</h3>\n\n<p>When you consider why you would need validations for Active Storage attachments, it is mostly to ensure the following:</p>\n\n<ul>\n<li>Only the allowed file types are stored.</li>\n<li>The attachments are of a particular size (both in terms of height and width, and the file size).</li>\n</ul>\n\n<p>If you need checks that go beyond these, such as checking whether a certain uploaded file is of a particular mime type, then a custom validator would be the best choice.</p>\n\n<p>For the purposes of this tutorial, let's assume that Users can upload their resumes. In doing so, we need to determine whether the document they are uploading is in PDF format. How do we do this?</p>\n\n<p>The quickest way is to add a custom validation within the User model:</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"c1\"># app/models/user.rb</span>\n<span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"c1\"># Define the Active Storage attachment</span>\n    <span class=\"n\">has_one_attached</span> <span class=\"ss\">:resume</span>\n\n    <span class=\"n\">validate</span> <span class=\"ss\">:is_pdf</span>\n\n    <span class=\"kp\">private</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">is_pdf</span>\n       <span class=\"k\">if</span> <span class=\"n\">document</span><span class=\"p\">.</span><span class=\"nf\">attached?</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">document</span><span class=\"p\">.</span><span class=\"nf\">content_type</span><span class=\"p\">.</span><span class=\"nf\">in?</span><span class=\"p\">(</span><span class=\"s2\">&quot;application/pdf&quot;</span><span class=\"p\">)</span>\n        <span class=\"n\">errors</span><span class=\"p\">.</span><span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"ss\">:resume</span><span class=\"p\">,</span> <span class=\"s1\">'Resume should be PDF!'</span><span class=\"p\">)</span> \n      <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div>\n<p>You should note that this particular validation will only run when the record is saved, not when the file is uploaded.</p>\n\n<p>When you are doing lots of Active Storage validations, consider using the <a href=\"https://github.com/aki77/activestorage-validator\">Active Storage Validator</a> gem.</p>\n\n<h3 id=\"errors-and-messages\">Errors and Messages</h3>\n\n<p>The <code>errors[]</code> object is an array that contains strings with all the error messages for a given attribute. It should return empty if there are no errors.</p>\n\n<p>You can read more about it in the <a href=\"https://guides.rubyonrails.org/active_record_validations.html#working-with-validation-errors\">Rails Guides</a>.</p>\n\n<p>For the purposes of this article, let's take a look at an example showing how to pass in attributes to the error message of a particular validation rule.</p>\n<div class=\"highlight\"><pre class=\"highlight ruby\"><code><span class=\"k\">class</span> <span class=\"nc\">User</span> <span class=\"o\">&lt;</span> <span class=\"no\">ApplicationRecord</span>\n    <span class=\"c1\"># passing attributes to the name error message</span>\n    <span class=\"n\">validates_presence_of</span> <span class=\"ss\">:name</span><span class=\"p\">,</span> <span class=\"ss\">message: </span><span class=\"no\">Proc</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"p\">{</span> <span class=\"o\">|</span> <span class=\"n\">user</span><span class=\"p\">,</span> <span class=\"n\">data</span> <span class=\"o\">|</span>\n    <span class=\"s2\">&quot;</span><span class=\"si\">#{</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"ss\">:attribute</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\"> is needed for all registrations!&quot;</span> <span class=\"p\">}</span> \n<span class=\"k\">end</span>\n</code></pre></div>\n<p>When this validation fails, a custom error message is shown to the user:</p>\n\n<p><img src=\"/images/blog/posts/active-record-validations/custom-error-message.png\" alt=\"Custom Error Message\"></p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n\n<p>Application-level validations are an important method of ensuring that the data going into the database is of the right kind.</p>\n\n<p>However, they are not the only ones you can use. Depending on your application's needs, you could also implement database constraints and even client-side validations using something like Stimulus JS.</p>\n\n<p>Happy coding!</p>\n"
}