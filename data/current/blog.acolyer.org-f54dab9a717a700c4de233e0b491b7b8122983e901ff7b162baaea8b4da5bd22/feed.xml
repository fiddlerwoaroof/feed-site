<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" xmlns:georss="http://www.georss.org/georss" xmlns:geo="http://www.w3.org/2003/01/geo/wgs84_pos#">

<channel>
	<title>the morning paper</title>
	<atom:link href="https://blog.acolyer.org/feed/" rel="self" type="application/rss+xml"/>
	<link>https://blog.acolyer.org</link>
	<description>a random walk through Computer Science research, by Adrian Colyer</description>
	<lastBuildDate>Mon, 09 Aug 2021 17:03:15 +0000</lastBuildDate>
	<language>en-GB</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.6.4</generator>
<site xmlns="com-wordpress:feed-additions:1">176669287</site>	<item>
		<title>The ants and the pheromones</title>
		<link>https://blog.acolyer.org/2021/02/08/the-ants-and-the-pheromones/</link>
					<comments>https://blog.acolyer.org/2021/02/08/the-ants-and-the-pheromones/#respond</comments>
		
		<dc:creator><![CDATA[Adrian Colyer]]></dc:creator>
		<pubDate>Mon, 08 Feb 2021 06:00:00 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">https://blog.acolyer.org/?p=10120</guid>

					<description><![CDATA[I’m super excited about the new chapter emerging in our research on a programmable cloud. This is what comes after serverless, people. In this thread, a few recent talks/papers on the vision. First off — 10 minute pitch from CIDR is here. https://t.co/fEMboOGF7Q — Joe Hellerstein (@joe_hellerstein) January 28, 2021]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-jetpack-markdown"><p>TLDR; this is the last edition of The Morning Paper for now. Plus: one strand of research you won’t want to miss!</p>
<p>I was listening to a BBC Radio 4 podcast recently (<a href="https://www.bbc.co.uk/programmes/p093hcr3">More or Less: Behind the Stats &#8211; Ants and Algorithms</a>) in which the host Tim Harford is interviewing David Sumpter about his recent book, ‘<a href="https://uk.bookshop.org/books/the-ten-equations-that-rule-the-world-and-how-you-can-use-them-too/9780241404546">The ten equations that rule the world</a>.’ One of those equations, the ‘reward equation’ models how ants communicate using pheromones, and our own brains keep track of rewards using dopamine.</p>
<p>About 4 and a half minutes into the podcast Tim asks a fascinating question: the reward equation includes a decay or ‘forgetting’ parameter, so what happens if you disrupt established solutions for long enough that their hold is broken? For example, the complete disruption to our established routines that Covid has caused over the last year? The answer for ants, if you disrupt all of the pheromone trails around their nest, is that they converge on a new solution in the environment, but it won’t necessarily look the same as the one they had before the disruption. (If you’re interested in the amazing problem-solving skills of ants and how we can learn from them in computer science, I covered ‘<a href="https://blog.acolyer.org/2015/09/22/ant-algorithms-for-discrete-optimization/">Ant algorithms for discrete optimization</a>’ in a previous edition of The Morning Paper). It’s highly likely that the same thing will happen to us when we can eventually return to normal &#8211; the patterns that we establish won’t necessarily be the same as the ones we had before the series of lockdowns began.</p>
<p>The lockdowns (as I write this, we’re in another strict lockdown in England, with no end date given) have certainly disrupted my own routines. I’ve lost the time and space that I depended on for studying and writing The Morning Paper &#8211; the one-hour each way train journey on my morning commute, and more crucially with two older children both full-time studying from home, the time and space within the home for the many hours of concentrated work required. I don’t think my love of learning will ever leave me though, and at the same time I’ve been branching out and studying other things: philosophy, ethics, physics, a little maths, a little biology,&#8230; I’m really enjoying that. My love of computer science remains of course, but when we finally get to lay down our new pheromone trails and establish a new normal, I’m not sure I’m going to want to focus on computer science to the exclusion of all else. It’s been an intense six-and-a-half years doing largely that while writing the blog. For the time being then, I&#8217;m putting The Morning Paper back on pause.</p>
<p>Before I wrap up though, I can&#8217;t resist pointing you in the direction of one incredibly exciting research project from the <a href="https://hydro-project.github.io">Hydro</a> team at Berkeley&#8217;s <a href="https://rise.cs.berkeley.edu">RISELab</a>. Joe Hellerstein recently posted a whole bunch of links and resources in this Twitter thread:</p>
</div>


<blockquote class="twitter-tweet"><p lang="en" dir="ltr">I’m super excited about the new chapter emerging in our research on a programmable cloud. This is what comes after serverless, people. <br><br>In this thread, a few recent talks/papers on the vision. First off — 10 minute pitch from CIDR is here. <a href="https://t.co/fEMboOGF7Q">https://t.co/fEMboOGF7Q</a></p>— Joe Hellerstein (@joe_hellerstein) <a href="https://twitter.com/joe_hellerstein/status/1354866473932451844?ref_src=twsrc%5Etfw">January 28, 2021</a></blockquote> <script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>


<div class="wp-block-jetpack-markdown"><p>The &quot;PACT&quot; paper is here: <a href="http://cidrdb.org/cidr2021/papers/cidr2021_paper16.pdf">New Directions in Cloud Programming</a>, Cheung et al., CIDR 2021.</p>
</div>



<p></p>
]]></content:encoded>
					
					<wfw:commentRss>https://blog.acolyer.org/2021/02/08/the-ants-and-the-pheromones/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">10120</post-id>	</item>
		<item>
		<title>An overview of end-to-end entity resolution for big data</title>
		<link>https://blog.acolyer.org/2020/12/14/entity-resolution/</link>
					<comments>https://blog.acolyer.org/2020/12/14/entity-resolution/#respond</comments>
		
		<dc:creator><![CDATA[Adrian Colyer]]></dc:creator>
		<pubDate>Mon, 14 Dec 2020 05:00:00 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[Algorithms and data structures]]></category>
		<guid isPermaLink="false">https://blog.acolyer.org/?p=10115</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-jetpack-markdown"><p><a href="https://dl.acm.org/doi/abs/10.1145/3418896">An overview of end-to-end entity resolution for big data</a>, Christophides et al., ACM Computing Surveys, Dec. 2020, Article No. 127</p>
<p>The <a href="https://dl.acm.org/journal/csur">ACM Computing Surveys</a> are always a great way to get a quick orientation in a new subject area, and hot off the press is this survey on the entity resolution (aka record linking) problem. It’s an important part of many modern data workflows, and an area I’ve been wrestling with in one of my own projects.</p>
<blockquote>
<p>Entity Resolution (ER) aims to identify different descriptions that refer to the same real-world entity appearing either within or across data sources, when unique entity identifiers are not available.</p>
</blockquote>
<p>When ER is applied to records from the same data source it can be used for <em>deduplication</em>, when used to join records across data sources we call it <em>record linking</em>. Doing this well at scale is non-trivial; at its core, the problem requires comparing each entity to every other, i.e. it is quadratic in input size.</p>
<p>An individual record/document for an entity is called an <em>entity description</em>. A set of such descriptions is an <em>entity collection</em>. Two descriptions that correspond to the same real world entity are called <em>matches</em> or <em>duplicates</em>. The general flow of an ER pipeline looks like this:</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Entity-Resolution-Fig-2a.png" alt=""></p>
<ul>
<li><strong>Blocking</strong> takes input entity descriptions and assigns them to one or more <em>blocks</em> based on <em>blocking keys</em>. The point of blocking is to reduce the number of comparisons that have to be made later on &#8211; the key idea is that any two entity descriptions that have a chance of referring to the same real-world entity should end up in the same block under at least one of the blocking keys. Therefore we only have to do more detailed comparisons within blocks, but not across blocks. “<em>The key is redundancy, i.e., the act of placing every entity into multiple blocks, thus increasing the likelihood that matching entities co-occur in at least one block</em>.”</li>
<li><strong>Block processing</strong> then strives to further reduce the number of comparisons that will need to be made by eliminating <em>redundant</em> comparisons that occur in multiple blocks, and <em>superfluous</em> comparisons within blocks.</li>
<li><strong>Matching</strong> takes each pair of entity descriptions from a block and applies a similarity function to determine if they refer to the same real-world entity or not. (In an <em>iterative</em> ER process, matching and blocking may be interleaved with the results of each iteration potentially impacting the blocks).</li>
<li><strong>Clustering</strong> groups together all of the identified matches such that all the descriptions within a cluster refer to the same real-world entity. The clustering stage may infer additional indirect matching relations.</li>
</ul>
<p>The resulting clusters partition the input entity collections into a set of resolved entities.</p>
<p>ER solutions can be classified along three dimensions:</p>
<ul>
<li><strong>Schema-awareness</strong> &#8211; is there a schema to give structure to the data or not?</li>
<li><strong>The nature of the matching process</strong> &#8211; is it based on a comparison of attributes in the entity descriptions, or is there more complex matching going on such as comparing related entities to give further confidence in matching?</li>
<li><strong>The processing mode</strong> &#8211; traditional batch (with or without budget constraints), or incremental.</li>
</ul>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Entity-Resolution-Fig-3.png" alt=""></p>
<p>Let’s dive into each of the major pipeline stages in turn to get a feel for what’s involved&#8230;</p>
<h2>Blocking</h2>
<p>There’s a whole separate <a href="https://dl.acm.org/doi/10.1145/3377455">survey dedicated just to the problem of blocking for relational data</a>, so in this survey the authors focus their attention on blocking for schema-less data. There are lots of different approaches to this:</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Entity-Resolution-Table-1.png" alt=""></p>
<p>Classic approaches look at relations and attributes. For example <strong>Token Blocking</strong> makes one block for each unique token in values, regardless of the attribute. Any entity with that token in the value of any attribute is added to the block. <em>Redundancy positive</em> blocking schemes such as token blocking are those in which the probability that two descriptions match increases with the number of blocks that include both of them. For <em>redundancy neutral</em> schemes this is not the case. An example of a redundancy neutral scheme is <strong>Canopy Clustering</strong>, which uses token-based blocks, but assigns an entity to a block based on a similarity score being greater than a threshold $t_{in}$. Moreover, if the similarity score exceeds $t_{ex} (&gt; t_{in})$ then the description is not added to any further blocks.</p>
<h2>Block processing</h2>
<p>As with blocking, there are a multiplicity of approaches to block processing. <em>Block cleaning</em> methods may <em>purge</em> excessively large blocks (as these are likely to be the result of common stop-word tokens and hence less useful for matching) and <em>filter</em> the blocks a given description is present in &#8211; for example by removing the description from the largest $r%$ of the blocks it appears in. More sophisticated methods may also split and merge blocks. <em>Dynamic</em> approaches schedule block processing on the fly to maximise efficiency.</p>
<p><em>Comparison cleaning</em> methods work on redundancy positive block collections. A graph is constructed where nodes are entity descriptions, and there is an edge between every pair of nodes co-located in a block, with an edge weight representing the likelihood of a match, e.g. the number of blocks they are co-located in. Once the graph is constructed, <em>edge-pruning</em> can be used to remove lower weighted edges. There are a variety of strategies both for weighting and for pruning edges. For example, <em>Weighted Edge Pruning</em> removes all edges less than or equal to the average edge weight. After pruning, new blocks are created from the retained edges. Learning-based methods train classifiers for pruning.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Entity-Resolution-Table-2.png" alt=""></p>
<h2>Matching</h2>
<p>A matching function $M$ takes a pair of entity descriptions and measures their similarity using some similarity function $sim$. If the similarity score exceeds a given threshold they are said to match, otherwise they do not match. In a refinement the match function may also return <em>uncertain</em> for middling scores.  The similarity function could be <em>atomic</em>, such as Jaccard similarity, or <em>composite</em> (e.g., using a linear combination of several similarity functions on different attributes). Any similarity measure that satisfies non-negativity, identity, symmetry, and triangle inequality can be used.</p>
<p><em>Collective</em> based matching processes use an iterative process to uncover new matches as a result of matches already made. <em>Merging-based</em> collective techniques create a new entity description based on merging a matched pair, removing the original paired descriptions. <em>Relationship-based</em> collective techniques use relationships in the original entity graph to provide further similarity evidence. For example, <em>Collective ER</em>&#8230;</p>
<blockquote>
<p>Collective ER employs an entity graph, following the intution that two nodes are more likely to match, if their edges connect to nodes corresponding to the same entity. To capture this iterative intuitive, hierarchical agglomerative clustering is performed, where, at each iteration, the two most similar clusters are merged, until the similarity of the most similar cluster is below a threshold.</p>
</blockquote>
<p>A variety of supervised, semi-supervised, and unsupervised matching techniques have also been developed.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Entity-Resolution-Table-3.png" alt=""></p>
<p>The output of the matching process is a <em>similarity graph</em> with nodes corresponding to descriptions and edges connecting descriptions that matched, weighted by the matching probability.</p>
<h2>Clustering</h2>
<blockquote>
<p>Clustering aims to infer more edges from indirect matching relations, while discarding edges that are unlikely to connect duplicates in favor of edges with higher weights. Hence, its end result is a set of <em>entity clusters</em>, each of which comprises all descriptions that correspond to the same, distinct real-world object.</p>
</blockquote>
<p>The simplest approach is just to find <em>Connected Components</em>, but generally more advanced clustering techniques are used. For example, <em>Markov Clustering</em> uses random walks to strengthen intra-cluster edges while weakening inter-cluster ones.</p>
<h2>Making it incremental</h2>
<p>Section 8 in the survey discusses incremental approaches, but my general takeaway is that these seem rather thin on the ground, and mostly oriented towards assembling the information needed to answer an incoming query on the fly. The exception is <em>Incremental Correlation Clustering</em> which updates the clustering results on the fly based on newly created, updated, and deleted descriptions. All of the discussed approaches require schemas.</p>
<h2>Open source ER systems</h2>
<p>The survey includes an assessment of open source tools for ER, summarised in the table below.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Entity-Resolution-Table-6.png" alt=""></p>
<blockquote>
<p>&#8230;we share the view of ER as an engineering task by nature, and hence, we cannot just keep developing ER algorithms in a vacuum. In the Big Data era, we opt for <em>open-world ER systems</em> that allow one to plug-and-play different algorithms and can easily integrate with third-party tools for data exploration, data cleaning, or data analytics.</p>
</blockquote>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://blog.acolyer.org/2020/12/14/entity-resolution/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">10115</post-id>	</item>
		<item>
		<title>Bias in word embeddings</title>
		<link>https://blog.acolyer.org/2020/12/08/bias-in-word-embeddings/</link>
					<comments>https://blog.acolyer.org/2020/12/08/bias-in-word-embeddings/#respond</comments>
		
		<dc:creator><![CDATA[Adrian Colyer]]></dc:creator>
		<pubDate>Tue, 08 Dec 2020 05:00:00 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[Machine Learning]]></category>
		<guid isPermaLink="false">https://blog.acolyer.org/?p=10106</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-jetpack-markdown"><p><a href="https://dl.acm.org/doi/10.1145/3351095.3372843">Bias in word embeddings</a>, Papakyriakopoulos et al., FAT*’20</p>
<p>There are no (stochastic) parrots in this paper, but it does examine bias in word embeddings, and how that bias carries forward into models that are trained using them. There are definitely some dangers to be aware of here, but also some cause for hope as we also see that bias can be detected, measured, and mitigated.</p>
<blockquote>
<p>&#8230;we want to provide a complete overview of bias in word embeddings: its detection in the embeddings, its diffusion in algorithms using the embeddings, and its mitigation at the embeddings level and at the level of the algorithm that uses them.</p>
</blockquote>
<p>It’s been shown before (‘<a href="https://www.microsoft.com/en-us/research/publication/quantifying-reducing-stereotypes-word-embeddings/">Man is to computer programmer as woman is to homemaker?</a>’) that word embeddings contain bias. The dominant source of that bias is the input dataset itself, i.e. the text corpus that the embeddings are trained on. Bias in, bias out. David Hume put his finger on the fundamental issue at stake here back in 1737 when he wrote about the unjustified shift in stance from describing what <em>is</em> and <em>is not</em> to all of a sudden talking about what <em>ought</em> or <em>ought not</em> to be. The inputs to a machine learning model are a description of what <em>is</em>. If we train a model on them within thinking, the outputs of the model will treat what <em>is</em> as if it were what <em>ought to be</em>. We have made a sophisticated machine for reinforcing the status quo, warts and all.</p>
<p>When it comes to word embeddings this effect can be especially powerful because the embeddings isolate the words from the contexts in which they were originally used, leaving behind a static residue of bias:</p>
<blockquote>
<p>&#8230;the projection of words in a mathematical space by the embeddings consolidates stereotyping and prejudice, assigning static properties to social groups and individuals. Relations are no longer context-dependent and dynamic, and embeddings become deterministic projections of the bias of the social world. This bias is diffused into further algorithms unchanged, resulting in socially discriminative decisions.</p>
</blockquote>
<p>The authors proceed in the following manner:</p>
<ul>
<li>Firstly, they train one set of word embeddings based on the complete German wikipedia, and another set based on Facebook and Twitter content relating to the six main political parties in Germany. The training is done using <a href="https://blog.acolyer.org/2016/04/22/glove-global-vectors-for-word-representation/">GloVe</a>. To be able to compare these word embeddings (by placing them both within the same vector space), they then find the linear transformation matrix that places all words from one into the vector space of the other with minimal translation. Since the translation is linear, the normalised distance between words does not change and hence any <em>bias is preserved</em>.</li>
<li>They then measure bias in the trained embeddings</li>
<li>Having demonstrated that the word embeddings do indeed contain bias, the next step is to see if a model trained using these word embeddings exhibits bias in its outputs (which they show it does).</li>
<li>Given the resulting models does show bias, they then explore mechanisms for mitigating that bias at both the word embedding level and at the level of the final trained classifier.</li>
<li>Finally, they show how biased word embeddings can actually help us to detect the same biases in new text samples (for example, the output of a <em>language model</em>?).</li>
</ul>
<h2>Measuring bias in word embeddings</h2>
<p>Say we want to know whether a word embedding for a concept $c$ has a gender bias. We can take the cosine distance between $c$ and ‘Man’ and subtract the cosine distance between $c$ and ‘Woman’. A non-zero result reveals bias in one direction or the other, and the magnitude of the result tells us the amount of the bias. Since the study is done using the German language, which is gendered, concepts with male and female versions are represented by word <em>pairs</em>. This basic technique is used to assess bias in the trained word embeddings for professions, for Germans vs foreigners, and for homosexual vs heterosexual.</p>
<p>The results show that the trained vectors are more likely to associated women with professions such as nursing and secretarial work, whereas men are associated with roles such as policemen and commanders. Germans are linked to positive sentiments such as charm and passion, cooperation and union, while foreigners are generally linked to concepts such as immigration, law, and crime. Homosexuals are related to roles such as hairdresser or artist, and heterosexuals to blue collar professions and science. Homosexuality was associated with negative sentiments, and heterosexuality with positive ones.</p>
<p>Summaries of the most extremely biased words in both the Wikipedia and social media data sets are given in the tables below.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Biased-embeddings-Table-2.png" alt="">
<img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Biased-embeddings-Table-3.png" alt=""></p>
<blockquote>
<p>[the] results illustrate that word embeddings contain a high level of bias in them in terms of group stereotypes and prejudice. The intergroup comparison between sexes, populations, and sexual orientations revealed the existence of strong stereotypes and unbalanced evaluation of groups. Although Wikipedia contained a stronger bias in terms of stereotypes, social media contained a higher bias in terms of group prejudice.</p>
</blockquote>
<h2>Do biased word embeddings lead to biased models?</h2>
<p>The authors trained a model that took a word embedding as input and predicted whether that word has a positive or negative sentiment. To assess bias in the trained model, the authors fed names as inputs with the expectation that in the absence of bias, names should have a zero sentiment score as they are polarity independent. The chosen names were stereotypical first names for nine population groups: German, Turkish, Polish, Italian, Greek, French, US American, Russian, and Arabic. The authors also compared male and female names.</p>
<blockquote>
<p>The study illustrated the use of biased word embeddings results in the creation of biased machine learning classifiers. Models trained on the embeddings replicate the preexisting bias. Bias diffusion was proved both for sexism and xenophobia, with sentiment classifiers assigning positive sentiments to Germans and negative sentiments to foreigners. In addition, the amount of polarity for men and women in the embeddings was diffused unaltered into the models.</p>
</blockquote>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Biased-embeddings-Figure-2.png" alt=""></p>
<h2>Mitigating bias</h2>
<p>The authors investigate two different methods for bias mitigation in the sentiment classifier:</p>
<ol>
<li>Removing bias at the individual word embedding level (by making theoretically neutral words orthogonal to the <em>sentiment</em> vector, where the sentiment vector is e.g. good &#8211; bad, positive &#8211; negative etc.).</li>
<li>Removing bias at the level of the classifier by adjusting the linear hyperplane learned by the linear SVM classifier, such that this plane is orthogonal to the sentiment vector.</li>
</ol>
<p>While both methods reduce bias in the resulting classifications, the classifier-level correction is much more effective, as can be seen in the following figure.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Biased-embeddings-Figure-4.png" alt=""></p>
<p>This is because correcting embeddings for a theoretically neutral set of words still leaves other potential biases in place that weren’t corrected for. The classifier is good at finding these!</p>
<blockquote>
<p>&#8230;the classifier learns further associations between the vectors, which are not taken into consideration when debiasing at the embeddings level&#8230; Hence, we show that debiasing at the classifier level is a much better and safer methodology to follow.</p>
</blockquote>
<h2>Detecting bias in text</h2>
<p>The authors created a dataset containing an equal number of sexist and non-sexist comments from Facebook pages of German political parties. Then they trained models with LSTM and attention-based architectures to classify comments as sexist or non-sexist. Multiple variants were trained, using random embeddings, the Wikipedia embeddings, the social media embeddings, and embeddings trained on the sexist comments.</p>
<blockquote>
<p>The more similar the bias in the embeddings with the target data, the higher the ability of the classifier to detect them.</p>
</blockquote>
<p>The attention-based network architecture, when given the sexism embeddings, allowed to freely retrain them, and tested on comments only containing words with embeddings, achieved an accuracy of 92%.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/12/Biased-embeddings-Table-5.png" alt=""></p>
<h2>A call to action</h2>
<blockquote>
<p>The study showed that bias in word embeddings can result in algorithmic social discrimination, yielding negative inferences on specific social groups and individuals. Therefore, it is necessary not only to reflect on the related issues, but also to develop frameworks of action for the just use of word embeddings&#8230;</p>
</blockquote>
<p>When it comes to generative language models, one possibility that strikes me is to use the model to generate a text corpus, train word embeddings on that corpus, and then analyse them for bias. Any detected bias could then be fed back into the language model training process as a form of negative reinforcement.</p>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://blog.acolyer.org/2020/12/08/bias-in-word-embeddings/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">10106</post-id>	</item>
		<item>
		<title>Seeing is believing: a client-centric specification of database isolation</title>
		<link>https://blog.acolyer.org/2020/11/30/seeing-is-believing/</link>
					<comments>https://blog.acolyer.org/2020/11/30/seeing-is-believing/#respond</comments>
		
		<dc:creator><![CDATA[Adrian Colyer]]></dc:creator>
		<pubDate>Mon, 30 Nov 2020 05:00:00 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[Datastores]]></category>
		<guid isPermaLink="false">https://blog.acolyer.org/?p=10097</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-jetpack-markdown"><p><a href="http://www.cs.cornell.edu/lorenzo/papers/Crooks17Seeing.pdf">Seeing is believing: a client-centric specification of database isolation</a>, Crooks et al., PODC’17.</p>
<p>Last week we looked at <a href="https://blog.acolyer.org/2020/11/23/elle/">Elle</a>, which detects isolation anomalies by setting things up so that the inner workings of the database, in the form of the direct serialization graph (DSG), can be externally recovered. Today’s paper choice, ‘Seeing is believing’ also deals with the externally observable effects of a database, in this case the return values of read operations, but instead of doing this in order to detect isolation anomalies, Crooks et al. use this perspective to create new <em>definitions</em> of isolation levels.</p>
<p>It’s one of those ideas, that once it’s pointed out to you seems incredibly obvious (a hallmark of a great idea!). Isolation guarantees are a promise that a database makes to its clients. We should therefore define them in terms of effects visible to clients &#8211; as part of the specification of the external interface offered by the database. <em>How</em> the database internally fulfils that contract is of no concern to the client, so long as it does. And yet, until Crooks all the definitions, including <a href="https://blog.acolyer.org/2016/02/25/generalized-isolation-level-definitions/">Adya’s</a>, have been based on implementation concerns!</p>
<p>In theory defining isolation levels in terms of what the database does on the inside should at least be helpful to database developers &#8211; although as we’ll see in actual fact it can be over-constraining &#8211; but it leaves the much larger number of database <em>users</em> with a harder task to figure out what that means in terms of the effects visible to their applications.</p>
<blockquote>
<p>This paper introduces the first <em>state-based</em> formalization of isolation guarantees. Our approach is premised on a single observation: applications view storage systems as black-boxes that transition through a series of states, a subset of which are observed by applications.</p>
</blockquote>
<p>With isolation levels defined in terms of observable states, it becomes immediately clear to application developers what states their applications may observe, and it gives the implementors of storage systems maximum freedom in terms of how they meet the required external guarantees. In case you need any further motivation to dig in, in a panel at the Papers-we-love mini-conference earlier this month, this paper was nominated by Joe Hellerstein as a hidden gem deserving of wide visibility.</p>
<h2>A motivating example</h2>
<p>I’m going to jump ahead in the paper and start with a motivating example. Alice and Bob are joint owners of linked checking and savings accounts at a bank. The bank allows withdrawals from either account, so long as the combined balance remains positive. A withdrawal transaction is given an account and an amount, checks that the combined balance is sufficient to cover the withdrawal, and then debits the specified account by the specified amount.</p>
<p>Is this system safe (will the application invariants be broken) under snapshot isolation? The classic DSG-based definition of snapshot isolation is that it “disallows all cycles consisting of write-write and write-read dependencies and a single anti-dependency.” I’ll wait&#8230;</p>
<p>It might be helpful to know that <a href="https://blog.acolyer.org/2016/02/24/a-critique-of-ansi-sql-isolation-levels/">snapshot isolation permits write-skew</a>, and that <a href="https://blog.acolyer.org/2016/02/24/a-critique-of-ansi-sql-isolation-levels/">write skew anomalies are possible when there are integrity constraints between two or more data items</a>.</p>
<p>But it’s even easier with a state-based definition of snapshot isolation (SI). SI requires all operations in a transaction $T$ read from the same complete database state $S$ (the <em>snapshot</em> from which SI gets its name), and that $S$ precedes the transaction execution. But it does not require that the snapshot state be the most recent database state, and other transactions whose effects $T$ <em>will not observe</em> may have taken place in-between the snapshot state and the time that $T$ commits, so long as they don’t write to keys that $T$ also writes to. This matches the intuitive definition of snapshot isolation most people have. So now we can see that two withdrawal transactions could <strong>both start from the same snapshot state</strong>, in which e.g. the checking and savings account both have a balance of 30. $T_1$ checks that checking + savings has a balance greater than 40, and withdraws 40 from the checking account. $T_2$ checks that checking + savings has a balance greater than 40, and withdraws 40 from the savings account. But once both transactions have committed, the balance is negative and the application invariant has been violated!</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/11/Crooks-sketch-e1606499490743.png" alt=""></p>
<h2>Defining isolation levels in terms of state</h2>
<p>A storage system supports read and write operations over a set of keys $K$. The state $s$ of the storage system is a total function from keys to values $V$ (some keys may be mapped to $\bot$). A transaction $T$ is a sequence of read and write operations. To keep things simple we assume that all written values are unique. Applying a transaction $T$ to the state $s$ results in a new state $s’$. We say that $s$ is the <em>parent state</em> of $T$. An <em>execution</em> $e$ is a sequence of atomic state transitions.</p>
<p>If a read operation in a transaction returns some value $v$ for key $k$, then the possible <em>read states</em> of that operation are the states in $e$ that happened before the transaction started and where $k=v$. Once a write operation in a transactions writes $v$ to $k$, then all subsequent read operations for $k$ in the same transaction should return value $v$ (and for simplicity, we say that each key can be written at most once in any transaction). The <strong>pre-read</strong> predicate holds if every read operation has at least one possible read state.</p>
<p>This is all we need to start specifying the semantics of isolation levels.</p>
<blockquote>
<p>In a state-based model, isolation guarantees constrain each transaction $T \in \Large{\tau}$ in two ways. First, they limit which states among those in the candidate read sets of the operations in $T$ are admissible. Second, they restrict which states can serve as parent states for $T$.</p>
</blockquote>
<h3>Read uncommitted</h3>
<p>Anything goes &#8211; no constraints.</p>
<h3>Read Committed</h3>
<p>A transaction can commit if the pre-read predicate holds (you only read valid committed values)</p>
<h3>Snapshot Isolation</h3>
<p>If a given state is a valid read state for <em>all</em> the reads in a transaction, then this state is said to be <strong>complete</strong> with respect to that transaction.</p>
<p>There are two conditions for a transaction $T$ to commit under SI:</p>
<ol>
<li>There must exist a complete state $s$ wrt. $T$ in the execution history (this will be the snapshot state)</li>
<li>For the subset of keys that $T$ writes to, states in the execution history following $s$, up to and including the parent state of $T$, must not contain modifications to those keys. This is known as the <strong>no-conflicts</strong> condition.</li>
</ol>
<h3>Serializability</h3>
<p>A transaction $T$ can commit if its parent state is complete wrt. $T$.</p>
<h3>Strict Serializability</h3>
<p>Adds to serializability the constraint that the start time of a transaction $T$ must be later than the commit time of the transaction responsible for its parent state. (Things happen in real-time order).</p>
<h3>Other</h3>
<p>In section 4 you’ll also find state-based definitions of parallel snapshot isolation, and read atomic which I don’t have space to cover here.</p>
<p>The commit tests for each isolation level are summarised in the table below:</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/11/Crooks-Table-1.png" alt=""></p>
<h2>Understanding the snapshot isolation family</h2>
<p>In section 5.2 Crooks et al. use the state-based lens to examine the family of snapshot based guarantees that have grown up over time, including ANSI SI, Adya SI, Weak SI, Strong SI, Generalized SI, Parallel SI, Strong Session SI, Lazy Consistency (PL-2+) SI, and Prefix-Consistent SI. They find that these definitions can be compared on three dimensions:</p>
<ol>
<li><strong>time</strong>: are timestamps logical or based on real-time?</li>
<li><strong>snapshot recency</strong>: is the snapshot required to contain all transactions that committed before the transaction start time?</li>
<li><strong>state-completeness</strong>: does the snapshot have to be a <em>complete</em> state, or is a causally consistent state sufficient?</li>
</ol>
<blockquote>
<p>Grouping isolation levels in this way highlights a clean hierarchy between these definitions, and suggests that many of the newly proposed isolation levels are in fact equivalent to prior guarantees.</p>
</blockquote>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/11/Crooks-Fig-4.png" alt=""></p>
<h2>Revealing performance enhancement opportunities</h2>
<p>By removing artificial implementation constraints, definitions in terms of client-observable states gives implementers maximum freedom to find efficient strategies. The classic definition of parallel snapshot isolation (PSI) requires each datacenter to enforce snapshot isolation. This is turn makes PSI vulnerable to <em>slowdown cascades</em> in which a slow or failed node can impact operations that don’t access that node itself (because a total commit order is required across all transactions). The state-based definition shows us that a total order is not required, we only care about the ordering of transactions that the application itself can <em>perceive</em> as ordered with respect to each other. In simulation, the authors found a two orders of magnitude reduction in transaction inter-dependencies using this client-centric perspective.</p>
<h2>The last word</h2>
<blockquote>
<p>[The state-based approach] (i) maps more naturally to what applications can observe and illuminates the anomalies allowed by distinct isolation/consistency levels; (ii) makes it easy to compare isolation guarantees, leading us to prove that distinct, decade-old guarantees are in fact equivalent; and (iii) facilitates reasoning end-to-end about isolation guarantees, enabling new opportunities for performance optimization.</p>
</blockquote>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://blog.acolyer.org/2020/11/30/seeing-is-believing/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">10097</post-id>	</item>
		<item>
		<title>Elle: inferring isolation anomalies from experimental observations</title>
		<link>https://blog.acolyer.org/2020/11/23/elle/</link>
					<comments>https://blog.acolyer.org/2020/11/23/elle/#respond</comments>
		
		<dc:creator><![CDATA[Adrian Colyer]]></dc:creator>
		<pubDate>Mon, 23 Nov 2020 05:00:00 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">https://blog.acolyer.org/?p=10090</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-jetpack-markdown"><p><a href="https://people.ucsc.edu/~palvaro/elle_vldb21.pdf">Elle: inferring isolation anomalies from experimental observations</a>, Kingsbury &amp; Alvaro, VLDB’20</p>
<p>Is there anything more terrifying, and at the same time more useful, to a database vendor than Kyle Kingsbury’s <a href="https://jepsen.io/">Jepsen</a>? As the abstract to today’s paper choice wryly puts it, “<em>experience shows that many databases do not provide the isolation guarantees they claim</em>.” Jepsen captures execution histories, and then examines them for evidence of isolation anomalies. General linearizability and serializability checking are NP-complete problems due to extreme state-space explosion with increasing concurrency, and Jepsen’s main checker, <a href="https://github.com/jepsen-io/knossos">Knossos</a>, taps out on the order of hundreds of transactions.</p>
<p>Databases are in for an ‘Ell(e) of a hard time with the new checker in the Jepsen family though, <a href="https://github.com/jepsen-io/elle">Elle</a>. From the README:</p>
<blockquote>
<p>Like a clever lawyer, Elle looks for a sequence of events in a story which couldn&#8217;t possibly have happened in that order, and uses that inference to prove the story can&#8217;t be consistent.</p>
</blockquote>
<p>The paper describes how Elle works behind the scenes, and gives us a taste of Elle in action. Elle is able to check histories of <em>hundreds of thousands</em> of transactions in just <em>tens of seconds</em>. Which means whole new levels of stress for systems under test.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/11/Elle-Fig-4-e1605984865626.png" alt=""></p>
<p>In the evaluation section we see Elle being used to test two SQL databases (<a href="https://pingcap.com/products/tidb">TiDB</a>, <a href="https://www.yugabyte.com/">YugaByteDB</a>), a document database (<a href="https://fauna.com/">Fauna</a>), and a graph database (<a href="https://dgraph.io/">Dgraph</a>). By now I hardly consider it a plot-spoiler to tell you that it finds (unexpected) anomalies in all of them. You’ll find the details in §6 of the paper, and more information on the collaboration between Jepsen and the respective vendors to find and fix these issues on the <a href="https://jepsen.io/">Jepsen website</a>.</p>
<h2>What do we want from a transaction isolation checker?</h2>
<p>An ideal transaction isolation checker would be able to&#8230;</p>
<ul>
<li>Work with general patterns of transactions (not just specially chosen ones)</li>
<li>Detect many different types of anomalies, such that multiple isolation levels can be tested</li>
<li>Provide minimal reproducible bug reports when it does find a violation</li>
<li>Be efficient, so that large numbers of transactions at high levels of concurrency can be checked</li>
<li>Only report genuine anomalies (soundness)</li>
<li>Find all anomalies that exist in a history (completeness)</li>
</ul>
<p>Elle ticks all the boxes, with the exception of completeness. In practice though, Elle typically does observe <em>enough</em> of a history to detect both cyclic and non-cyclic anomalies when they occur, with a guarantee holding under certain conditions.</p>
<h2>Anomalies and the Direct Serialization Graph</h2>
<p>Adya et al. gave portable definitions of isolation levels and anomalies in their 2000 paper “<a href="https://blog.acolyer.org/2016/02/25/generalized-isolation-level-definitions/">Generalized Isolation Level Definitions</a>.” Central to the analysis is the notion of a Direct Serialization Graph (DSG). In a DSG nodes represent transactions, and edges between nodes are dependencies between transactions. There are three different types of edges possible between two transactions $T_i$ and $T_j$.</p>
<ul>
<li>a <strong>write dependency</strong> occurs when $T_j$ overwrites a value previously written by $T_i$.</li>
<li>a <strong>read dependency</strong> occurs when $T_j$ reads a value previously written by $T_i$ (ignoring the complications of predicate reads for now)</li>
<li>an <strong>anti-dependency</strong> occurs when $T_j$ overwrites a value previously read by $T_i$.</li>
</ul>
<p>The thing all these have in common is that they imply $T_j$ must follow $T_i$ in any serializable history. From this it follows that <em>any cycle in the DSG means that there cannot be a valid serial history</em>.</p>
<h2>If only&#8230;</h2>
<p>What Knossos does is identify write-read dependencies between transactions, translate these into an integer constraint problem, and feed it to a constraint solver to try and find a legitimate serial history. This works to a point but runs into the state-space explosion issues we touched on earlier with histories on the order of (small numbers of) hundreds of transactions. Moreover, when the constraint solver says “no”, we don’t have any insight into <em>why</em> the constraints couldn’t be solved.</p>
<p>This is all a lot more complex than the cycle checking needed in Adya’s model. For example, in a <em>strongly connected component</em> of a graph, every node in the component is reachable from every other node in the same component. If A is reachable from B, and B is reachable from A, we have a cycle! <a href="https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm">Tarjan’s strongly connected components algorithm</a> can find the strongly connected components in a graph in <em>linear</em> time!</p>
<p>If only we actually had one of Adya’s Direct Serialization Graphs for a given run, then we’d have the triple benefit of anomaly detection exactly matching the definitions of the anomalies, explainability of the anomalies found in terms of those definitions (show the cycle), and <em>linear runtime</em>.</p>
<blockquote>
<p>&#8230; there is one significant obstacle to working with an Adya history: <em>we don’t have it</em>. In fact, one may not even exist &#8211; the database system may not have any concept of a version order, or it might not expose that ordering information to clients.</p>
</blockquote>
<h2>Recoverability and traceability</h2>
<p>So maybe we don’t have an Adya history out of the box. But can we recover one? That is, are there <em>observations</em> we could make of the running system, that are in our control, that would let us <em>infer</em> an Adya history? We know the nodes in the graph &#8211; that’s the set of transactions we submit &#8211; and we know the operations within those transactions (the reads and writes), as well as having visibility of commit and abort operations. What we need then, is some way of determining the edges.</p>
<p>If every written value is unique, and we have a scheme that enables mapping unique values back to transactions, then when we read a value (in $T_j$), we can always tell which transaction $T_i$ must have written it. This enables us to find the read dependency edges, a property the authors call <em>recoverability</em>.</p>
<p>For a write dependency though, we need to know the transaction $T_i$ that previously wrote the value $T_j$ is overwriting. Unfortunately that history is lost at the moment the old value is overwritten. Unless&#8230; we use a datatype that supports append operations (like a string, with concat, or an array), and we follow the convention that all writes must be appends of recoverable values. Now when we read the value, the full history is contained within it. E.g., we might read the list $[(T_i, 1), (T_j, 2)]$ and know that $T_i$ first wrote the value 1, and $T_j$ subsequently wrote the value 2. This is a property the authors call <em>traceability</em>.</p>
<p>If we’ve got recoverability and traceability then with a bit more work we can also find the anti-dependency edges &#8211; we have visibility into the return values of read operations, and we just have to look for traceable writes that append to that read value.</p>
<p>Because the model also includes commit and abort operations, this process additionally enables us to detect <em>dirty updates</em> where a transaction commits a version based on reading uncommitted state, as well as corruptions (<em>garbage reads</em>) where a transaction reads a value that no-one has written!</p>
<h2>Inferring Direct Serialization Graphs</h2>
<p>An inferred direct serialization graph is a DSG constructed from the inferred dependencies between transactions using the techniques just outlined. There’s one more piece of information we can use too, since we control the processes: if process $P$ performs $T_i$ and then $T_j$ then we know that $T_i$ must come before $T_j$ in the history. Adding in these per-process dependencies means that we can strengthen consistency checking in some cases (e.g. from snapshot isolation to strong session snapshot isolation).</p>
<h2>Giving the database the benefit of the doubt</h2>
<p>Things get a bit more complicated once we allow for the possibility of in-doubt transactions:</p>
<blockquote>
<p>&#8230; when a client <em>attempts</em> to commit a transaction, but the result is unknown, e.g. due to a timeout or database crash, we leave the transaction with neither a commit nor abort operation.</p>
</blockquote>
<p>Observations made in the presence of in-doubt transactions are said to be <em>indeterminate</em>. The problem then arises that there may be <em>many</em> possible histories compatible with the observation.</p>
<p>Elle provides soundness in the face of this complication by constructing a dependency graph which is a (maximal?) <em>subgraph</em> of every possible history compatible with that observation. If a cycle is detected in the subgraph, than it must exist in all compatible histories.</p>
<h2>Putting it altogether</h2>
<p>Putting this altogether, Elle can detect cycle-based dependencies (Adya’s G0, G1c, G-single, and G2 cycles), aborted reads, intermediate reads, and dirty updates.</p>
<blockquote>
<p>In addition, there are phenomena which Adya et al.’s formalism does not admit, but which we believe (having observed them in real databases) warrant special verification.</p>
</blockquote>
<p>These are the aforementioned <em>garbage reads</em>, as well as <em>duplicate writes</em> (the same argument written multiple times) and <em>internal inconsistencies</em> (where a transactions reads a value incompatible with its own prior reads and writes).</p>
<p>I’ve only been able to give a high level appreciation in this post, rest assured the paper itself is precise in its terminology and analysis, as befits the subject matter. If these ideas have caught your interest, it’s well worth reading in full.</p>
<h2>The last word</h2>
<blockquote>
<p>Elle is effective. It has found anomalies in every database we’ve checked, ranging from internal inconsistency and aborted reads to anti-dependency cycles&#8230; Unlike solver-based checkers, Elle’s cycle-detection approach produces short witnesses of specific transactions and human-readable explanations of <em>why</em> each witness must be an instance of the claimed anomaly&#8230; We believe Elle will make the database industry safer.</p>
</blockquote>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://blog.acolyer.org/2020/11/23/elle/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">10090</post-id>	</item>
		<item>
		<title>Achieving 100Gbps intrusion prevention on a single server</title>
		<link>https://blog.acolyer.org/2020/11/16/pigasus/</link>
					<comments>https://blog.acolyer.org/2020/11/16/pigasus/#respond</comments>
		
		<dc:creator><![CDATA[Adrian Colyer]]></dc:creator>
		<pubDate>Mon, 16 Nov 2020 05:00:00 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[Hardware]]></category>
		<category><![CDATA[Networking]]></category>
		<guid isPermaLink="false">https://blog.acolyer.org/?p=10086</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-jetpack-markdown"><p><a href="https://www.usenix.org/conference/osdi20/presentation/zhao-zhipeng">Achieving 100 Gbps intrusion prevention on a single server</a>, Zhao et al., OSDI&#8217;20</p>
<p><em>Papers-we-love is hosting a <a href="https://paperswelove.org/2020/video/pwlconf-mini/">mini-event this Wednesday</a> (18th) where I’ll be leading a panel discussion including one of the authors of today’s paper choice: Justine Sherry. Please do join us if you can.</em></p>
<p>We always want more! This stems from a combination of <a href="https://en.wikipedia.org/wiki/Jevons_paradox">Jevon’s paradox</a> and the interconnectedness of systems &#8211; doing more in one area often leads to a need for more elsewhere too. At the end of the day, there are three basic ways we can increase capacity:</p>
<ol>
<li>Increasing the number of units in a system (subject to <a href="https://en.wikipedia.org/wiki/Amdahl's_law">Amdahl’s law</a>).</li>
<li>Improving the efficiency with which we can coordinate work across a collection of units (see the <a href="https://blog.acolyer.org/2015/04/29/applying-the-universal-scalability-law-to-organisations/">Universal Scalability Law</a>)</li>
<li>Increasing the amount of work we can do on a single unit</li>
</ol>
<p>Options 1 and 2 are of course the ‘scale out’ options, whereas option 3 is ‘scale up’. With more nodes and more coordination comes more complexity, both in design and operation. So while scale out has seen the majority of attention in the cloud era, it’s good to remind ourselves periodically just what we really can do on a <a href="https://adamdrake.com/command-line-tools-can-be-235x-faster-than-your-hadoop-cluster.html">single box</a> or even a <a href="https://blog.acolyer.org/2015/06/05/scalability-but-at-what-cost/">single thread</a>.</p>
<p>Today’s paper choice is a wonderful example of pushing the state of the art on a single server. We’ve been surrounding CPUs with accelerators for a long time, but at the heart of <em>Pigasus</em>‘ design is a really interesting inversion of control &#8211; the CPU isn’t coordinating and calling out to the accelerator, instead the FGPA is in charge, and the CPU is playing the support role.</p>
<h2>IDS/IPS requirements</h2>
<p>Pigasus is an Intrusion Detection / Prevention System (IDS/IPS). An IDS/IPS monitors network flows and matches incoming packets (or more strictly, Protocol Data Units, PDUs) against a set of rules. There can be tens of thousands of these rules, which are called <em>signatures</em>. A signature in turn is comprised of one or more patterns matching against either the header or the packet content, including both exact string matches and regular expressions. Patterns may span multiple packets. So before matching, the IDS/IPS has to reconstruct a TCP bytestream in the face of packet fragmentation, loss, and out-of-order delivery &#8211; a process known as <em>reassembly</em>.</p>
<p>When used in prevention mode (IPS), this all has to happen inline over incoming traffic to block any traffic with suspicious signatures. This makes the whole system latency sensitive.</p>
<p>So we need low latency, but we also need very high throughput:</p>
<blockquote>
<p>A recurring theme in IDS/IPS literature is the gap between the workloads they need to handle and the capabilities of existing hardware/software implementations. Today, we are faced with the need to build IDS/IPSes that support line rates on the order of 100Gbps with hundreds of thousands of concurrent flows and capable of matching packets against tens of thousands of rules.</p>
</blockquote>
<p>Moreover, Pigasus wants to do all this on a single server!</p>
<h2>Back of the envelope</h2>
<p>One of the joys of this paper is that you don’t just get to see the final design, you also get insight into the forces and trade-offs that led to it. Can you <em>really</em> do all this on a single server??</p>
<p>The traditional approach to integrating FPGAs in IDS/IPS processing is to have the CPU in charge, and offload specific tasks, such as regular expression parsing, to the FPGA. The baseline for comparison is <a href="https://www.snort.org/snort3">Snort 3.0</a>, “the most powerful IPS in the world” according to the Snort website. In particular, Pigasus is designed to be compatible with Snort rulesets and evaluated using the Snort Registered Ruleset (about 10K signatures). The biggest fraction of CPU time in Snort is spent in the Multi-String Pattern Matcher (MSPM) module, which is used for header and partial string matching.</p>
<blockquote>
<p>Using Amdahl’s Law, we can see that even if MSPM were offloaded to an imaginary, infinitely fast accelerator, throughput would increase by only 85% to 600Mbps/core, still requiring 166 cores to reach 100Gpbs.</p>
</blockquote>
<p>In fact, whatever module of Snort you try to offload to a hypothetical infinitely fast accelerator, you can never get close to the performance targets of Pigasus. That fixes Pigasus’ first design decision: the FPGA needs to be in charge as the primary compute platform, and the CPU will be secondary in service of it. (FPGAs are chosen because they are both energy efficient and available on SmartNICs).</p>
<p>Having settled on an FPGA-first design, this means that <em>stateful</em> packet processing for matching and reassembly needs to be performed on the FPGA. And that in turn means that the primary design constraint is the amount of FPGA memory available, especially Block RAM (BRAM). The target FPGA for Pigasus has 16MB of BRAM.</p>
<p>Of concern here is the regular expression matching performed by the Full Matcher. Regular expression matching is well studied, but state of the art hardware algorithms don’t reach the performance and memory targets needed for Pigasus. Performing RE matching on the FPGA would consume a lot of memory, and offer only marginal overall performance gains since most packets don’t touch the full matcher. This brings us to another major design decision: regular expression matching will be offloaded from the FPGA to the CPU.</p>
<h2>Introducing Pigasus</h2>
<p>Putting together everything we’ve learned so far, the overall architecture of Pigasus looks like this:</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/11/Pigasus-Fig-4-e1605368045843.png" alt=""></p>
<ul>
<li>The <strong>reassembler</strong> is responsible for ordering TCP packets. It needs to do this at line rate while maintaining state for 100K flows.</li>
<li>The <strong>multi-string pattern matcher</strong> (MSPM) does header matching for all 10,000 rules, and exact string-match filtering to determine which further rules might possibly match.</li>
<li>If the MSPM indicates a possible match, the packet and rule IDs are sent to the <strong>DMA Engine</strong>, which farms work out to the CPU for full matching.</li>
<li>The <strong>Full Matcher</strong> runs on the CPU, polling a ring buffer populated by the DMA Engine.</li>
</ul>
<p>To save the precious BRAM for the most performance sensitive tasks (reassembly and MSPM), the packet buffer and DMA Engine use the less powerful eSRAM and DRAM available on the FPGA.</p>
<p>Both the reassembler and MSPM modules required careful design to meet their performance and memory targets.</p>
<h2>The reassembler: processing fast and slow</h2>
<blockquote>
<p>The key objective of our Reassemble is to perform this re-ordering for 100K’s of flows, while operating at 100Gbps, within the memory limitations of the FPGA.</p>
</blockquote>
<p>The FPGA hardware really wants to operate in a highly parallel mode using fixed size data structures. This works well until we consider out of order packet arrival. To accomodate out-of-order packets though, a memory dense structure such as a linked list works better.</p>
<p>The solution is to divide the reassembly pipeline into a fast path handling in-order flows using fixed size buffers and constant time operations, and a slow path handling the remaining out of order flows. The constant time operations on the fast path guarantee a processing rate of 25 million packets-per-second, enough to reach the 100Gbps target at 500B+ packets. The slow path can’t take advantage of constant time operations, but fortunately is less often used as most packets arrive in order. It’s also used when inserting new flows.</p>
<p>The fast path, new flow insertion, and out-of-order processing all synchronise over shared flow state using a cuckoo-hashing based hash table design from FlowBlaze.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/11/Pigasus-Fig-6.png" alt=""></p>
<h2>MPSM: First things first</h2>
<p>There are challenges in the design of the MSPM too.</p>
<blockquote>
<p>To the best of our knowledge, there are no other hardware or software projects reporting multi-string matching of tens of thousands of strings at 100Gpbs.</p>
</blockquote>
<p>Snort 3.0 uses Intel’s Hyperscan library for MSPM. The Hyperscan string matching library is parallelisable and provides an 8x speedup over software state-machine based string matchers. But a simple translation to FPGA would blow the memory budget, requiring about 25MB of BRAM.</p>
<p>By carefully staging the work, Pigasus manages to fit everything into just 2MB of BRAM. This means it even has capacity to do more work in the MSPM stage than Snort itself does, reducing the amount of packets that need to be passed to the full matcher.</p>
<p>At the end of the day, a packet must match <em>all</em> the patterns in a signature for the rule to be triggered. The key insight in Pigasus is that some tests can be done very cheaply in terms of time and memory, while others are more memory intensive. Put this together with the realisation that most packets and most indices don’t match any rules at all and a plan emerges: make a filtering pipeline that progressively narrows. At the start of the pipeline we can afford to run lots of memory-cheap filters in parallel. Only a subset of incoming packets make it past these filters, so we need less of the more memory intensive filters running in parallel behind them to achieve the desired line rate.</p>
<blockquote>
<p>Applying this filter first allows us to use fewer replicas of subsequent data structures (which are larger and more expensive), since most bytestream indices have already been filtered out by the string matcher. This enables high (effective) parallelism with a lower memory overhead.</p>
</blockquote>
<p>This strategy is so effective that whereas Snort passes a packet to the full matcher if any filter matches, Pigasus is able to test for all string matches and further reduce the fraction of packets that head to the CPU for full-matching to just 5%. This testing is performed in parallel using a bloom-filter like representation, see §5.2 in the paper for details.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/11/Pigasus-Fig-8-e1605368027670.png" alt=""></p>
<h2>Headline results</h2>
<blockquote>
<p>Our experiments with a variety of traces show that Pigasus can support 100Gbps using an average of 5 cores and 1 FPGA, using 38x less power than a CPU-only approach.</p>
</blockquote>
<p>There’s a full evaluation in §6 of the paper which I don’t have space to cover here. The headline is that Pigasus meets its design objectives using 23-200 fewer cores than Snort, and 18-62x less power!</p>
<blockquote>
<p>The design of Pigasus is a singular proof point that a seemingly unattainable goal (&#8230;) on a single server is well within our grasp&#8230; Given the future hardware roadmaps of FPGAs and SmartNICs, we believe that our insights and successes can more broadly inform in-network acceleration beyond IDS/IPS as well.</p>
</blockquote>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://blog.acolyer.org/2020/11/16/pigasus/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">10086</post-id>	</item>
		<item>
		<title>Virtual consensus in Delos</title>
		<link>https://blog.acolyer.org/2020/11/09/delos/</link>
					<comments>https://blog.acolyer.org/2020/11/09/delos/#respond</comments>
		
		<dc:creator><![CDATA[Adrian Colyer]]></dc:creator>
		<pubDate>Mon, 09 Nov 2020 05:00:00 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[Distributed Systems]]></category>
		<guid isPermaLink="false">https://blog.acolyer.org/?p=10080</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-jetpack-markdown"><p><a href="https://www.usenix.org/conference/osdi20/presentation/balakrishnan">Virtual consensus in Delos</a>, Balakrishnan et al. (<em>Facebook, Inc.</em>), OSDI’2020</p>
<p><em>Before we dive into this paper, if you click on the link above and then download and open up the paper pdf you might notice the familiar red/orange splash of USENIX, and appreciate the fully open access. <a href="https://www.usenix.org/about">USENIX is a nonprofit organisation</a> committed to making content and research freely available &#8211; both conference proceedings and the recorded presentations of their events. Without in-person conferences this year, income is down and events are under threat. If you want to help them, you have options to <a href="https://www.usenix.org/annual-fund">donate</a>, <a href="https://www.usenix.org/membership">become a member</a>, or even talk to your organisation about becoming a <a href="https://www.usenix.org/supporters">partner, benefactor, or patron</a>. Every little helps!</em></p>
<p>Back in 2017 the engineering team at Facebook had a problem. They needed a table store to power core control plane services, which meant strong guarantees on durability, consistency, and availability. They also needed it fast &#8211; the goal was to be in production within 6 to 9 months. While ultimately this new system should be able to take advantage of the latest advances in consensus for improved performance, that’s not realistic given a 6-9 month in-production target. So realistically all that could be done was to choose an existing consensus implementation and integrate it. Integrating an existing implementation brings problems of its own though:</p>
<blockquote>
<p>Laying the system over an existing shared log such as LogDevice would allow us to reach production quickly, but also tie us for perpetuity to the fault-tolerance and performance properties of that consensus implementation.</p>
</blockquote>
<p>What Facebook needed, literally, was a <em>plan to throw one away</em>. I.e., a plan that let them get into production quickly with an existing implementation, and then be able to upgrade it later without disturbing system operation (nobody wants to take down the central control plane for maintenance!). This calls for the oldest tool in the box: a level of indirection. In other words, an API based abstraction over consensus, together with a runtime that supports hot-swapping of those implementations. The standout candidate as the API for consensus is the <em>shared log</em>.</p>
<blockquote>
<p>Recently, the shared log has gained traction as an API for consensus in research and industry. Applications can replicate state via this API by appending updates to the shared log, checking its tail, and reading back updates from it.  The consensus protocol is hidden behind the shared log API, allowing applications to bind to any implementation at deployment time.</p>
</blockquote>
<p>Behind the shared log API is a log abstraction that maps log positions to log entries. If you think of this a bit like mapping memory addresses to data in memory, then another parallel comes to mind: the <em>virtual address space</em>. One <em>logical</em> log, but with different portions of the log address space mapped to different backing shared log instances. This is the core idea in <strong>Delos</strong>, a <em>VirtualLog</em> that virtualises consensus.</p>
<blockquote>
<p>We propose the novel abstraction of a virtual shared log (or VirtualLog). The VirtualLog exposes a conventional shared log API; applications above it are oblivious to its virtualized nature. Under the hood, the VirtualLog chains multiple shared log instances (called Loglets) into a single shared log.</p>
</blockquote>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/11/Delos-Fig-1.png" alt=""></p>
<p>It’s such a powerful idea that I can imagine distributed systems implementers everywhere adopting it from now on. What does the VirtualLog give us?</p>
<p>Firstly, it solves the upgrade problem. We have an existing Loglet writing log entries into the address space. To upgrade, the portion of the address space managed by this Loglet is <em>sealed</em> to prevent further writes, and then the Loglet chain is reconfigured to add the new Loglet at the tail. That’s not just theoretical, Facebook actually did this in production while Delos was processing over 1.8 billion transactions per day. The initial version of Delos went into production after eight months using a ZooKeeper-backed Loglet implementation, and then four months later it was swapped out for a new custom-built <em>NativeLoglet</em> that gave a 10x improvement in end-to-end latency.</p>
<p>Once you have a trusted reconfiguration protocol to move from one Loglet chain configuration to another, you can do lots of interesting things. For example, Loglets might be instances of the same ordering protocol, but with different parameters, or they could be entirely different log implementations (e.g. replacing Paxos with Raft), or they could be shims over external storage systems. If you have an existing implementation with its own leader elections, internal reconfiguration, and epochs that can sit happily under the Loglet abstraction. But critically, Loglets no longer <em>need</em> to handle all of that complexity:</p>
<blockquote>
<p>While the VirtualLog’s reconfiguration mechanism can be used solely for migrating between entirely different Loglet implementations, it can also switch between different instances of the same Loglet protocol with changes to leadership, roles, parameters, and membership. As a result, the Loglet itself can be a statically configured protocol, without any internal support for reconfiguration. In fact, the Loglet does not even have to implement fault-tolerant consensus (i.e. be highly available for appends via leader election), as long as it provides a fault tolerant <code>seal</code> command, which is theoretically weaker and simpler to implement.</p>
</blockquote>
<p>This separation of concerns moves reconfiguration into the VirtualLog control plane, leaving Loglets responsible for the data plane. It makes reconfiguration easier as well as simplifying the implementation of Loglets. If a Loglet fails for appends, it is simply sealed and the VirtualLog switches to a new Loglet.</p>
<h2>Sealing</h2>
<p>A minimal Loglet needs to provide totally ordered, durable storage via the shared log API. It can do this within a static configuration with no support for role or membership changes and no leader election. What it must provide however, is a highly available <code>seal</code> command that prevents any new appends from being acknowledged.</p>
<p>Once sealed, a Loglet can never be unsealed. So we have a couple of handy properties that make implementing seal much easier than a general purpose highly available append: only one value can ever be proposed, and that value is sticky. In Facebook’s implementation of NativeLoglet, seal simply sets a bit on a quorum of servers.</p>
<p>In addition to seal, a minimal Loglet is also responsible for its own failure detection, asking the VirtualLog to reconfigure when a failure is detected, and supplying a new Loglet configuration minus the failed servers.</p>
<h2>Reconfiguration</h2>
<p>Existing consensus systems often store the configuration and epoch information inline in the same totally ordered log as other commands. For VirtualLog, that would mean writing the configuration for the new Loglet inside the log address space of the outgoing Loglet before it is sealed. And that would put more complexity onto Loglets, requiring them to be highly available for appends, not just seal.</p>
<p>The VirtualLog uses a separate MetaStore instead, whose job is to manage the configuration of the VirtualLog over time. Because reconfiguration happens less frequently than regular command sequencing, the consensus protocol for reconfiguration can favour simplicity over out-and-out performance. For Facebook’s Delos, reconfiguration latencies of 10s of ms  are ok.</p>
<p>The MetaStore exposes a single versioned register supporting a conditional write: writing requires supplying a new value and an expected existing version. Any client can initiate a reconfiguration, or complete a reconfiguration begun by another client. Reconfiguration has three steps:</p>
<ol>
<li>The client seals the current chain by sealing its active segment. A call to <code>checkTail</code> will now return the start of a new active segment. This is an idempotent operation.</li>
<li>The reconfiguring client writes a new chain to the MetaStore. Because of the conditional write, if multiple clients are racing to reconfigure, at most one one can win.</li>
<li>The reconfiguring client fetches the new chain from the MetaStore (in the case where its write failed in step 2).</li>
</ol>
<p>Clients trying to write to the old active segment after step 1 will receive a ‘sealed’ error code, and can retry after fetching the latest chain from the MetaStore.</p>
<h2>The NativeLoglet</h2>
<p>Delos currently supports three disaggregated Loglets acting as shims over external services (ZooKeeper, a LogDevice service, and a Backup service used for cold storage). It also has two of its own Loglet implementations that can be run either converged or disaggregated: the NativeLoglet and the StripingLoglet.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/11/Delos-Fig-5.png" alt=""></p>
<p>In production, Facebook use the NativeLoglet in converged form. NativeLoglet implements seal by setting a bit on a quorum of servers. It uses a a central sequencer to assign positions to commands and forward requests to LogServers. An append is considered globally committed once a majority acknowledge. If the sequencer fails, NativeLoglet simply becomes unavailable for appends.</p>
<blockquote>
<p>Practically, we found this protocol much easier to implement than fault-tolerant consensus: it took just under 4 months to implement and deploy a production-quality native Loglet.</p>
</blockquote>
<h2>Striping Loglets</h2>
<p>The StripedLoglet is where things start to get even more interesting. A StripedLoglet is responsible for one portion of the global log address space, but internally it further maps (stripes) that portion over multiple nested Loglets.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/11/Delos-Fig-7.png" alt=""></p>
<p>This provides a simple way (about 300 loc) to scale throughput. For example, a shared sequencer bottleneck can be relieved by introducing a <em>rotating sequencer</em> &#8211; multiple sequencers dividing an address space between them and sharing the same underling LogServers. Alternatively, the address space can mapped to multiple underlying LogServer clusters to increase throughput.</p>
<p>Even though it is a composite, a StripedLoglet must still be sealed as a whole even if only one of its stripes needs to be reconfigured.</p>
<h2>Delos in production</h2>
<p>The evaluation section has lots of good information on experiences running Delos in production, as well as some synthetic benchmarks. The in-production switch from a ZK Loglet to NativeLoglet was done for the first time on April 2nd 2019, and gave a 10x improvement at p99 for gets, and a 5x improvement for writes.</p>
<p>My favourite example here is a really cool use case for reconfiguration. Most of the time Delos runs with a converged Loglet implementation, since this reduces the external dependencies of a very critical system. Under a log spike though, it can be reconfigured to run with a disaggregated Loglet, giving higher throughput. A related example is when Delos is running in converged mode and e.g. two of the five converged database replicas crash. Now the database and the shared log are fate-sharing and at risk if one more node is lost&#8230;</p>
<blockquote>
<p>In this situation (which was not uncommon), we found it valuable to reconfigure the system to a disaggregated log, temporarily decoupling the fate of the database and the log. Once the database was restored to five replicas, we reconfigured back.</p>
</blockquote>
<p>The overheads of virtualisation are pleasingly low: about 100-150µs at p99 latency, 10s of ms for reconfiguration, and no impact on peak throughput.</p>
<h2>Limitations and future work</h2>
<p>It all sounds pretty amazing doesn’t it! There are a couple of limitations: (1) consensus protocols that exploit speculation or commutativity don’t currently fit under the Loglet API. “<em>In future work, we plan to extend virtual consensus to partially ordered shared logs.</em>”, and (2) there’s a latency hit for VirtualLog-driven reconfiguration which may or may not be important in your scenario.</p>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://blog.acolyer.org/2020/11/09/delos/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">10080</post-id>	</item>
		<item>
		<title>Helios: hyperscale indexing for the cloud &amp; edge (part II)</title>
		<link>https://blog.acolyer.org/2020/11/02/helios-part-ii/</link>
					<comments>https://blog.acolyer.org/2020/11/02/helios-part-ii/#respond</comments>
		
		<dc:creator><![CDATA[Adrian Colyer]]></dc:creator>
		<pubDate>Mon, 02 Nov 2020 05:00:00 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">https://blog.acolyer.org/?p=10073</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-jetpack-markdown"><p><a href="http://www.vldb.org/pvldb/vol13/p3231-potharaju.pdf">Helios: hyperscale indexing for the cloud &amp; edge</a>, Potharaju et al., PVLDB&#8217;20</p>
<p>Last time out we looked at the motivations for <a href="https://blog.acolyer.org/2020/10/26/helios-part-1/">a new reference blueprint</a> for large-scale data processing, as embodied by Helios. Today we&#8217;re going to dive into the details of Helios itself. As a reminder:</p>
<blockquote>
<p>Helios is a distributed, highly-scalable system used at Microsoft for flexible ingestion, indexing, and aggregation of large streams of real-time data that is designed to plug into relationals engines. The system collects close to a quadrillion events indexing approximately 16 trillion search keys per day from hundreds of thousands of machines across tens of data centres around the world.</p>
</blockquote>
<p>As an ingestion and indexing system, Helios separates ingestion and indexing and introduces a novel <em>bottoms-up</em> index construction algorithm. It exposes tables and secondary indices for use by relational query engines through standard access path selection mechanisms during query optimisation. As a reference blueprint, Helios&#8217; main feature is the ability to move computation to the edge.</p>
<h2>Requirements</h2>
<p>Helios is designed to ingest, index, and aggregate large streams of real-time data (tens of petabytes a day). For example, the log data generated by Azure Cosmos. It supports key use cases such as finding records relating to specific attributes (e.g. for incident support), impact and drill-down analysis, and performance monitoring and reporting. One interesting use case is in support of GDPR right to be forgotten requests, where it becomes necessary to search 10s of billions of streams to find those containing a user&#8217;s information.</p>
<p>Incoming streams can have data rates as high as 4TB/minute, with many columns to be indexed (7+ is common) and high cardinality.</p>
<h2>System design</h2>
<p>A stream table is defined by a <em>loose</em> schema which defines the sources to be monitored (as a <em>SourceList</em>) and indices to be created. For example:</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/Helios-Fig-2.png" alt=""></p>
<p>Based on the CREATE STREAM statement, Helios <em>generates an agent executable</em> to be deployed on every machine producing a log that is part of the stream.  It also generates an executable to be run on the server-side ingestion machines. The agent process accumulates and chunks incoming data into data blocks (with frequency determined by the CHUNK EVERY clause). Optionally, and central to how Helios handles high volume and velocity ingest at manageable scale and cost, <strong>the agent can also perform local processing (parsing, indexing, and aggregation)</strong> and send the resulting index entries to the ingestion clusters in a compact format.</p>
<p>Ingestion servers are stateless, running the user-defined dataflow (based on the CREATE SCHEMA statement) to process incoming blocks. Data blocks are stored in a distributed file system, and once acknowledged by the file system, an entry is written into Helio&#8217;s progress log. The progress log is used to track the progress of both data ingestion and index building. Secondary index generation (<em>hydration</em>) then happens asynchronously. The resulting index blocks are merged into a global index which maps (column, value) pairs to data block URIs.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/Helios-Fig-3.png" alt=""></p>
<p>The progress log is the only strongly synchronized component in Helios, and is deployed in quorum based rings of 5 servers.  There are multiple replicated logs each governing a partition of the data set. In this manner Helios achieves a consistent rate of 55,000 writes/second for metadata persistence.</p>
<h2>Indexing</h2>
<blockquote>
<p>A key factor in Helios&#8217;s success is asynchronous index mangement: Helios maintains <em>eventually consistent</em> indexes against the data, but exposes a strongly consistent queryable view of the underlaying data with best-effort index support.</p>
</blockquote>
<p>Helios&#8217; index is a <em>multi-level</em> (tree-based) structure that is built in a <em>bottom-up</em> manner. I.e., information is inserted at the leaves, and the index then &#8216;grows upwards&#8217; through merge and add operations. The authors point out an interesting similarity to <a href="https://blog.acolyer.org/2018/01/08/the-case-for-learned-index-structures-part-i/">learned index structures</a> here: &quot;<em>At the highest level, a learned index tries to learn a function that maps an index search key to the leaf nodes containing the search key. The Helios structure in its generic form performs exactly the same function, with the different that the mapping is not learned from data but composed from the (typically, hash) partitioning functions used by the different index levels.</em>&quot;</p>
<p>Indexing begins by scanning the progress log from the latest checkpoint, with an initial leaf node at the bottom of the tree (level 0) constructed for each chunk. No global order is imposed here, indexed keys are simply packed into leaf nodes based on arrival order. Multiple nodes at the same level may be combined into one using the <em>merge</em> operator in accordance with a <em>merge policy</em>. Just as level 0 watches blocks arrive in the progress log and follows along creating leaf nodes, so the next level up, level 1 watches the progress of leaf nodes arriving at level 0, and creates a higher level index over the leaf nodes by applying the <em>add</em> operator. Level 2 follows the progress of level 1 in a similar manner, and so on for the desired number of levels. The result is an indexing frontier that moves forward across the levels through a per-level watermark.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/Helios-Fig-6.png" alt=""></p>
<p>An index node is a collection of (key, pointers) pairs. The <strong>merge</strong> operation combines two index nodes $N_1$ and $N_2$ by taking the union of their keys, and for each key the union of the pointers. E.g. if $N_1 = {K_1 \mapsto {P_1, P_2}, K_2 \mapsto {P_3}}$ and $N_2 = {K_2 \mapsto {P_4}}$ then $N_1 \oplus N_2 = { K_1 \mapsto {P_1, P_2}, K_2 \mapsto {P_3, P_4 }}$. Helios uses a size-based merge policy in which two nodes are merged if they are both below a given size threshold.</p>
<p>The <strong>add</strong> operation creates a new node at one level up containing the union of the keys in the blocks being added, and pointers to the nodes in the level below containing entries for those keys. E.g. $N_1 + N_2 = {K_1 \mapsto {P_{N_1}}, K_2 \mapsto {P_{N_1}, P_{N_2}}}$. Helios also uses a size-based add policy, in which nodes are added (at higher and higher levels) until the size of the resulting node reaches a configurable threshold.</p>
<p>Note that the resulting structure may contain <em>orphan</em> nodes (shown in grey in the figure above) that do not have any parent in the layer above. This has implications for query processing that we&#8217;ll look at shortly.</p>
<p>Index compaction, which also takes place bottom-up, is triggered when a configurable number of data blocks have been processed.</p>
<h2>Federated indexing</h2>
<blockquote>
<p>Our initial approach towards data and index management focused towards bringing in data from all the sources into an ingestion cluster and performing the required post-processing operations (e.g. parsing, indexing, etc.). However, this approach incurs significant costs&#8230; The hierarchical/recursive indexing model gives the freedom of distributing our computation acress the agents and ingestion back-end servers, sharing the same intuition as the current trend of edge computation.</p>
</blockquote>
<p>Pre-processing on agents reduces the size of the ingestion cluster required, at the cost of consuming processing power on the source machine. In Helios production deployments, the agent typically consumes 15%-65% of a <em>single CPU core</em>, and stays under an allocated memory budget of 1.6GB.  The generated agent and ingestion code utilises a shared library called <em>Quark</em> which provides a selection of parsers, extractors, indexers, partitioners, serializers and compressors as well as query-processing operators with predicate push-down.</p>
<h2>Querying</h2>
<blockquote>
<p>Helios indexes are represented and exposed as data in easily accessible formats, available for any query engine. This allows us to democratise index usage outside of Helios, e.g. query engines can perform their own cost-based index access path selection, and index reads can independently scale without being constrained by compute resources provided by Helios. In fact, we were able to integrate Apache Spark with no changes to its optimizer/compiler.</p>
</blockquote>
<p>Due to the existence of orphan nodes, querying can&#8217;t proceed in a pure top-down manner. So Helios provides a <em>hybrid index scan</em> operator. Querying starts by <em>moving down</em> the tree from the root nodes (which are orphan nodes by definition), and then recursively repeating this process for each of the orphan nodes at the next level down <em>moving right</em>.</p>
<p>In Figure 6 above for example, we can search down the tree from $N_{21}$, but in doing so we miss any potential hits in the orphan node $N_{13}$ at the next level down. So after processing $N_{21}$ we start a new search from $N_{13}$. This in turn may miss hits in the orphan block $N_{08}$ so we then drop-down once more and move right&#8230;</p>
<h2>Helios in production</h2>
<p>Helios has multiple uses at Microsoft including supporting debugging and diagnostics, workload characterization, cluster health monitoring, deriving business insights, and performing impact analysis.</p>
<blockquote>
<p>Helios clusters have been in production for the last five years, collecting close to a quadrillion log lines per day from hundreds of thousands of machines spread across tens of datacenters.</p>
</blockquote>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://blog.acolyer.org/2020/11/02/helios-part-ii/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">10073</post-id>	</item>
		<item>
		<title>Helios: hyperscale indexing for the cloud &amp; edge – part 1</title>
		<link>https://blog.acolyer.org/2020/10/26/helios-part-1/</link>
					<comments>https://blog.acolyer.org/2020/10/26/helios-part-1/#respond</comments>
		
		<dc:creator><![CDATA[Adrian Colyer]]></dc:creator>
		<pubDate>Mon, 26 Oct 2020 05:00:00 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<category><![CDATA[Datastores]]></category>
		<guid isPermaLink="false">https://blog.acolyer.org/?p=10066</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-jetpack-markdown"><p><a href="http://www.vldb.org/pvldb/vol13/p3231-potharaju.pdf">Helios: hyperscale indexing for the cloud &amp; edge</a>, Potharaju et al., PVLDB&#8217;20</p>
<p>On the surface this is a paper about fast data ingestion from high-volume streams, with indexing to support efficient querying. As a production system within Microsoft capturing around a <em>quadrillion</em> events and indexing <em>16 trillion</em> search keys per day it would be interesting in its own right, but there&#8217;s a lot more to it than that. <strong>Helios</strong> also serves as a reference architecture for how Microsoft envisions its next generation of distributed big-data processing systems being built. These two narratives of reference architecture and ingestion/indexing system are interwoven throughout the paper. I&#8217;m going to tackle the paper in two parts, focusing today on the reference architecture, and in the next post on the details of Helios itself. What follows is a discussion of where big data systems might be heading, heavily inspired by the remarks in this paper, but with several of my own thoughts mixed in. If there&#8217;s something you disagree with, blame me first!</p>
<h2>Why do we need a new reference architecture?</h2>
<p>Cloud-native systems represent by far the largest, most distributed, computing systems in our history. And the established <a href="https://blog.acolyer.org/2020/03/09/snowflake/">cloud-native architectural principles</a> behind them aren&#8217;t changing here. But zoom out one level of abstraction, and you can also look at cloud platforms as the largest, most-centralised, computing systems in our history. We push as much data processing as possible onto warehouse-scale computers and systems software. It&#8217;s a planet-scale client-server architecture with an enormous number of mostly thin clients sharing the services of a few giant server systems. There are several pressures on such a design:</p>
<ul>
<li>The <em>volume</em> of data continues to grow &#8211; by another 2 orders of magnitude this decade according to IDC &#8211; as does the <em>velocity</em> of data arrival and the <em>variance</em> in arrival rates. At the same time, end users want results faster &#8211; from batch to real-time.</li>
</ul>
<blockquote>
<p>We are observing significant demand from users in terms of avoiding batch telemetry pipelines altogether.</p>
</blockquote>
<ul>
<li>It makes heavy use of comparatively expensive data-center computing facilities</li>
<li>It&#8217;s limited by the laws of physics in terms of end-to-end latency</li>
<li>It&#8217;s more challenging to build privacy-respecting systems when all data needs to shipped remotely to be processed</li>
</ul>
<p>The first two of these pressures combine to cause cloud systems to run into one of two limits as exemplified by this quote from the paper:</p>
<blockquote>
<p>None of our existing systems could handle these requirements adequately; either the solution <strong>did not scale</strong> or it was <strong>too expensive</strong> to capture all the desired telemetry. (<em>Emphasis mine</em>)</p>
</blockquote>
<p>Latency limits are one of the drivers pushing us towards more <strong>edge computing</strong> &#8211; a trend which began with static content distribution, then dynamic content (both of which sit on the response path), and now is extending to true edge computation (that can also help improve the request path, e.g. by local processing either eliminating or reducing the amount of data that needs to be sent on to central servers). Industrial IoT use cases are an example here.</p>
<blockquote>
<p>The emergence of edge computing has raised new challenges for big data systems&#8230; In recent years a number of distributed streaming systems have been built via either open source or industry effort (e.g. Storm, Spark Streaming, MillWheel, Dataflow, Quill). These systems however adopt a cloud-based, centralised architecture that does not include any &quot;edge computing&quot; component &#8211; they typically assum an external, independent data ingestion pipeline that directs edge streams to cloud storage endpoints such as Kafka or Event Hubs.</p>
</blockquote>
<p>On the privacy front, with increasing awareness and regulation (a good thing, imho!), it&#8217;s getting much more complex and expensive to process, store, and secure potentially sensitive data. The most cost-effective mechanism of all is not to store it centrally, and not to process it centrally. Securing data you don&#8217;t have and never saw is free! In this regard the machine learning community is ahead of the systems community, with a growing body of work on <a href="https://blog.acolyer.org/2019/06/07/towards-federated-learning-at-scale/">federated machine learning</a>.</p>
<blockquote>
<p>The GDPR directive requires that companies holding EU citizen data provide a reasonable level of protection for personal data&#8230; including erasing all personal data upon request&#8230; Finding the list of data streams that contain the user&#8217;s information requires a provenance graph (as the number of streams is in the order of 10s of billions) and an index (as each stream can span multiple peta-bytes) to avoid expensive linear scans.</p>
</blockquote>
<h2>What does the new reference architecture look like?</h2>
<p>The central idea in the Helios architecture is &#8217;embrace the edge&#8217;. Although the word federated doesn&#8217;t actually appear in the paper at all, <em>federated big-data systems</em> (c.f. federated machine learning and federated database management systems) seems a reasonable way of describing what&#8217;s going on here.</p>
<blockquote>
<p>Helios is an effort towards building a new genre of big data systems that combine the cloud and edge as a single, holistic data processing platform.</p>
</blockquote>
<p>(And by extension, we could envision end-user devices being part of that holistic platform too).</p>
<p>In the olden days we used to talk about function shipping and data shipping. Function shipping being the idea that you move the compute to the data, and data shipping being the idea that you move the data to the compute. Within todays cloud systems, a lot of function shipping takes place, but for the clients that interact with them, it&#8217;s very heavily skewed towards data shipping. In federated big-data systems perhaps the appropriate terms would be <em>function spreading</em> and <em>data spreading</em>. I.e. compute can take place at multiple different points along the path from end device to cloud (and back again), and data can be spread out across layers too. A good guiding principle for designing such a system is probably to minimise data <em>movement</em> &#8211; i.e. (1) do as much processing as possible as close to the point of data capture as possible, and only send the aggregated results downstream, and then (2) where pools of data do amass, do as much querying of that data as close to the point of data storage as possible and only send the query results back upstream.</p>
<blockquote>
<p>In Helios, this translates to coming up with efficient techniques for splitting computation between end devices, edge, and cloud.</p>
</blockquote>
<p>This split has another interesting consequence. We saw earlier that there is end-user pressure to replace batch systems with much lower latency online systems. I observe that computation split across end devices, edge, and cloud doesn&#8217;t really sit well with batch processing either. We do distributed batch processing <em>within</em> a layer (e.g. map-reduce) but across layers is different. My conclusion is that federated big-data systems are also online systems. One nice advantage of unifying batch and online processing is that we don&#8217;t need to duplicate logic:</p>
<blockquote>
<p>This solves the problem of maintaining code that needs to produce the same result in two complex distributed systems.</p>
</blockquote>
<p>Generally batch systems have higher throughput and higher latency, and as we reduce the batch size towards online systems, we lower the latency <em>and also the throughput</em>. It will be interesting to watch the throughput characteristics of federated big data systems, but it&#8217;s a challenge I think we have to take on. (Helios&#8217; throughput is plenty good enough btw.)</p>
<p>Technically, what might it look like to build a system that works in this way?</p>
<blockquote>
<p>Based on our production experience, we posit that a single engine model can (1) enable optimizations such as automatically converting recurring batch queries into streaming queries, dynamically mapping operators/computations to various layers (e.g., end device, edge, cloud), automated A/B testing for figuring out the best query execution plans, join query optimization in multi-tenant scenarios and automatic cost-based view materialisation, and (2) significantly reduce user and operational burden of having to learn and maintain multiple complex stacks.</p>
</blockquote>
<p>I&#8217;m going to throw one more requirement into the mix for next-generation big data systems. You won&#8217;t find this in the Helios paper, but it <em>is</em> something that Microsoft have articulated well in other works, notably <a href="https://blog.acolyer.org/2020/02/19/ten-year-egml-predictions/">Cloudy with a high chance of DBMS: a 10-year prediction for enterprise-grade ML </a>. From a data systems perspective, machine learning is just data processing over (usually) big data sets. We don&#8217;t really want completely separate systems for federated machine learning and federated big-data, especially as there are many data cycles between the two (ML both consuming and producing data) and ML is increasingly becoming a mainstream part of many systems and applications. See e.g. the introduction to &#8216;<a href="https://blog.acolyer.org/2020/10/19/the-case-for-a-learned-sorting-algorithm/">The case for a learned sorting algorithm</a>.&#8217;</p>
<p>The picture that forms in my mind is of a federated <a href="https://blog.acolyer.org/2015/06/17/differential-dataflow/">differential dataflow</a> style system that processes and materializes just what is needed at each layer. E.g. in the Helios case, &quot;<em>we can similarly distribute the task of data summarization &#8211; including filtering, projections, index generation, and online aggregation &#8211; to end devices</em>.&quot; One nice thing that falls out of extending such a system all the way out to the end devices is that it means the dataflow engine is effectively responsible for managing all of those pesky caches, and especially cache invalidation.</p>
<p>There might be many different layers of edge compute (e.g. 5G base stations, CDN POPs, &#8230;) between an end-(user) device and a warehouse scale computer (WSC, aka the cloud). You can think of these as concentric rings forming around WSCs, and conceptually a federated big data system can span all of them.</p>
<p>So far we&#8217;ve mostly been talking about spreading compute and data along a single path from an end device to the cloud and back again, leading to a picture like this.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/IMG_0023.jpeg" alt=""></p>
<p>But of course it&#8217;s entirely possible (and common) for a node at one layer to interact with multiple nodes at the layer below, leading to a picture more like this:</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/IMG_0024-e1603626611928.jpeg" alt=""></p>
<p>And furthermore it&#8217;s easy to imagine cases where peer-to-peer communication between nodes at the same level also makes sense:</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/IMG_0025.jpeg" alt=""></p>
<p>In general we&#8217;re looking at a dynamic dataflow topology with very large numbers of nodes.</p>
<p>Helios is a successful production example of a subset of these ideas, and we&#8217;ll look at Helios itself in much more detail in the next post. For now I&#8217;ll close with this thought:</p>
<blockquote>
<p>Helios provides one example for a specific type of computation, i.e. indexing of data. There are a number of related problems, such as resource allocation, query optimization, consistency, and fault tolerance. We believe that this is a fertile ground for future research.</p>
</blockquote>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://blog.acolyer.org/2020/10/26/helios-part-1/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">10066</post-id>	</item>
		<item>
		<title>The case for a learned sorting algorithm</title>
		<link>https://blog.acolyer.org/2020/10/19/the-case-for-a-learned-sorting-algorithm/</link>
					<comments>https://blog.acolyer.org/2020/10/19/the-case-for-a-learned-sorting-algorithm/#respond</comments>
		
		<dc:creator><![CDATA[Adrian Colyer]]></dc:creator>
		<pubDate>Mon, 19 Oct 2020 05:00:00 +0000</pubDate>
				<category><![CDATA[Uncategorized]]></category>
		<guid isPermaLink="false">https://blog.acolyer.org/?p=10059</guid>

					<description><![CDATA[]]></description>
										<content:encoded><![CDATA[
<div class="wp-block-jetpack-markdown"><p><a href="https://dl.acm.org/doi/10.1145/3318464.3389752">The case for a learned sorting algorithm</a>, Kristo, Vaidya, et al., SIGMOD’20</p>
<p><em>With thanks to Babur Muradov of <a href="https://pngset.com">pngset</a>, a Russian translation of this post is now available at <a href="https://pngset.com/ru-learned-sorting-algorithm">https://pngset.com/ru-learned-sorting-algorithm</a></em></p>
<p>We’ve watched <a href="https://blog.acolyer.org/2018/12/17/applied-machine-learning-at-facebook-a-datacenter-infrastructure-perspective/">machine learning thoroughly pervade the web giants</a>, make <a href="https://blog.acolyer.org/2019/10/07/150-successful-machine-learning-models/">serious headway in large consumer companies</a>, and begin its <a href="https://blog.acolyer.org/2020/02/19/ten-year-egml-predictions/">push into the traditional enterprise</a>. ML, then, is rapidly becoming an integral part of how we build applications of all shapes and sizes. But what about systems software? It’s earlier days there, but ‘The case for learned index structures’(<a href="https://blog.acolyer.org/2018/01/08/the-case-for-learned-index-structures-part-i/">Part 1</a> <a href="https://blog.acolyer.org/2018/01/09/the-case-for-learned-index-structures-part-ii/">Part 2</a>), <a href="https://blog.acolyer.org/2019/01/16/sagedb-a-learned-database-system/">SageDB</a> and others are showing the way.</p>
<p>Today’s paper choice builds on the work done in SageDB, and focuses on a classic computer science problem: sorting. On a 1 billion item dataset, <strong>Learned Sort</strong> outperforms the next best competitor, RadixSort, by a factor of 1.49x. What really blew me away, is that this result <em>includes</em> the time taken to train the model used!</p>
<h2>The big idea</h2>
<p>Suppose you had a model that given a data item from a list, could predict its position in a sorted version of that list. 0.239806? That&#8217;s going to be at position 287! If the model had 100% accuracy, it would give us a completed sort just by running over the dataset and putting each item in its predicted position. There&#8217;s a problem though. A model with 100% accuracy would essentially have to see every item in the full dataset and memorise its position &#8211; there&#8217;s no way training and then using such a model can be faster than just sorting, as sorting is a part of its training! But maybe we can sample a subset of the data and get a model that is a useful approximation, by learning an approximation to the CDF (cumulative distribution function).</p>
<p>If we can build a useful enough version of such a model quickly (we can, we&#8217;ll discuss how later), then we can make a fast sort by first scanning the list and putting each item into its approximate position using the model&#8217;s predictions, and then using a sorting algorithm that works well with nearly-sorted arrays (Insertion Sort) to turn the almost-sorted list into a fully sorted list. This is the essence of Learned Sort.</p>
<h2>A first try</h2>
<p>The base version of Learned Sort is an <em>out-of-place</em> sort, meaning that it copies the sorted elements into a new destination array. It uses the model to predict the slot in the destination array for each item in the list. What should happen though if the model predicts (for example) slot 287, but there&#8217;s already an entry in the destination array in that slot? This is a <em>collision</em>. The candidate solutions are:</p>
<ol>
<li><strong>Linear probing</strong>: scan the array for nearest vacant slot and put the element there</li>
<li><strong>Chaining</strong>: use a list or chain of elements for each position</li>
<li>A <strong>Spill bucket</strong>: if the destination slot is already full, just put the item into a special spill bucket. At the end of the pass, sort and merge the spill bucket with the destination array.</li>
</ol>
<p>The authors experimented with all three, and found that the spill bucket approach worked best for them.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/Learned-Sort-Fig-2.png" alt=""></p>
<p>The resulting performance depends on the quality of the model predictions, a higher quality model leads to fewer collisions, and fewer out-of-order items to be patched in the final Insertion Sort pass. Since we&#8217;re punting on the details of the model for the moment, an interesting question is what happens when you give this learned sort a perfect, zero-overhead oracle as the model? Say we want to sort all the numbers from zero to one billion. A perfect zero-overhead oracle can be built by just using the item value as the position prediction. 1456? That will go in position 1456&#8230;</p>
<p>And what did happen when the authors tried to sort the numbers using this perfect zero-overhead oracle?</p>
<blockquote>
<p>To our astonishment, in this micro-experiment we observed that the time take to distributed the keys into their final sorted position, despite a zero-overhead oracle function, took 38.7 sec and RadixSort took 37.5 sec.</p>
</blockquote>
<p>Why? If it&#8217;s high performance you&#8217;re after, you can&#8217;t ignore mechanical sympathy. Radix Sort is carefully designed to make effective use of the L2 cache and sequential memory accesses, whereas Learned Sort is making random accesses all over the destination array.</p>
<h2>Sympathy for the machine</h2>
<p>How can learned sort be adapted to make it cache-efficient? The solution is to change the first pass of Learned Sort into a cascading Bucket Sort. Instead of determining the final position in the destination array, the model prediction is used to ascertain which bucket (or bin) the element should go into.</p>
<ol>
<li>
<p>Let $f$ be the number of buckets ($f$ for fan-out). The first phase of learned sort is a cascading Bucket Sort. The initial pass uses the model predictions to place input elements into one of $f$ ordered buckets. Then each of these buckets is partitioned into a further $f$ buckets, and so on recursively until a threshold bucket size $t$ is reached. If at any stage a model prediction places in a item in a bucket that is already full, this item is just moved to a spill bucket instead.</p>
</li>
<li>
<p>Once we&#8217;re down to buckets of size $t$, each of these is approximately sorted using the model predictions to place elements at an exact predicted position within the bucket.</p>
</li>
<li>
<p>Concatenate the sorted buckets in order (some may have less than $t$ elements in them), and use Insertion Sort to patch up any discrepancies in ordering.</p>
</li>
<li>
<p>Sort and merge the spill bucket.</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/Learned-Sort-Fig-4.png" alt=""></p>
<p>The secret to good performance with Learned Sort is choosing $f$ and $t$ so that at least one cache-line per bucket fits into the cache, making memory access patterns more sequential. The trade-off in setting $f$ is as follows: larger $f$ allows us to make more use of the predictive power of the model at each step, smaller $f$ increases the chances that we can append to a given bucket without causing a cache miss. For best performance, $f$ should be set so that all the hot memory locations fit in the L2 cache. For the evaluation set-up, this meant $f$ was around 1,000.</p>
<p>The parameter $t$ influences the number of elements likely to end up in the spill bucket. Empirically the authors found that maximum performance is obtained when fewer than 5% of the elements end up in the spill bucket, which equates to a $t$ of around 100 for large datasets (see §3.1.2).</p>
<p>With these changes in place, if the number of elements to sort is close to the key domain size (e.g. sorting $2^{32}$ elements with 32-bit keys), then Learned Sort performs almost identically to Radix Sort. But when the number of elements is much smaller than the key domain size, Learne Sort can significantly outperform Radix Sort.</p>
</li>
</ol>
<h2>Oh, yes &#8211; about the model!</h2>
<p>All of this depends of course on being able to train a sufficiently accurate model that can make sufficiently fast predictions, so that the total runtime for Learned Sort, <em>including the training time</em> still beats Radix Sort. For this, the authors use the Recursive Model Index (RMI) architecture as first introduced in &#8216;<a href="https://blog.acolyer.org/2018/01/09/the-case-for-learned-index-structures-part-ii/">The case for learned index structures</a>&#8216;. In brief, RMI uses layers of simple linear models arranged in a hierarchy a bit like a mixture of experts.</p>
<blockquote>
<p>During inference, each layer of the model takes the key as an input and linearly transforms it to obtain a value, which is used as an index to pick a model in the next layer.</p>
</blockquote>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/Learned-Sort-Fig-5.png" alt=""></p>
<p>The main innovation the authors introduce here is the use of linear spline fitting for training (as opposed to e.g. linear regression with an MSE loss function). Spline fitting is cheaper to compute and gives better monotonicity (reducing the time spent in the Insertion Sort phase). Each individual spline model fits worse than its closed-form linear regression counterpart, but the hierarchy compensates. Linear splines result in 2.7x faster training, and up to 35% fewer key swaps during Insertion Sort.</p>
<h2>Evaluation</h2>
<p>On synthetic datasets containing double-precision keys following a standard normal distribution, the authors compared Learned Sort to a variety of cache-optimized and highly tuned C++ implementations of alternative sorting algorithms, presenting the most competitive alternatives in their results. The following chart shows sorting rates over input dataset sizes varying from one million to one billion items</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/Learned-Sort-Fig-8.png" alt=""></p>
<p>Learned Sort outperforms the alternative at all sizes, but the advantage is most significant when the data no longer fits into the L3 cache &#8211; an average of 30% higher throughput than the next best algorithm.</p>
<blockquote>
<p>The results show that our approach yields an average 3.38x performance improvement over C++ STL sort, which is an optimized Quick- sort hybrid, 1.49x improvement over sequential Radix Sort, and 5.54x improvement over a C++ implementation of Tim- sort, which is the default sorting function for Java and Python.</p>
</blockquote>
<p>Learned Sort&#8217;s advantage holds over real datasets as well (§6.1 for datasets included in the test), and for different element types:</p>
<p><img src="https://blog.acolyer.org/wp-content/uploads/2020/10/Learned-Sort-Fig-9.png" alt=""></p>
<blockquote>
<p>[Learned Sort] results in significant performance improvements as compared to the most competitive and widely used sorting algorithms, and marks an important step into building ML-enhanced algorithms and data structures.</p>
</blockquote>
<h2>Extensions</h2>
<p>The paper also describes several extensions to Learned Sort including sorting in-place, sorting on other key types (strings initially), and improving performance for datasets with many duplicate items.</p>
</div>
]]></content:encoded>
					
					<wfw:commentRss>https://blog.acolyer.org/2020/10/19/the-case-for-a-learned-sorting-algorithm/feed/</wfw:commentRss>
			<slash:comments>0</slash:comments>
		
		
		<post-id xmlns="com-wordpress:feed-additions:1">10059</post-id>	</item>
	</channel>
</rss>
