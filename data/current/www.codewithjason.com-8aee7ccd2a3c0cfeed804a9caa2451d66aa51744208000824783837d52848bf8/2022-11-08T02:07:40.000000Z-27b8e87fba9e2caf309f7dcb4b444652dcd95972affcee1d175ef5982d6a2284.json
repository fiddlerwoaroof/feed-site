{
  "title":"Premature generalization",
  "date":"2022-11-08T02:07:40.000000Z",
  "author":null,
  "id":"https://www.codewithjason.com/?p=2625",
  "link":"https://www.codewithjason.com/premature-generalization/",
  "content":"<p>Most programmers are familiar with the concept of premature optimization and the reasons why it’s bad. As a reminder, the main reason premature optimization is bad is because it’s an effort to solve problems that probably aren’t real. It’s more economical to wait and observe where the performance bottlenecks are than to try to predict where the bottlenecks are going to be.</p>\n<p>Perhaps fewer programmers are familiar with the idea of <b>premature generalization</b>, also known as the code smell <a href=\"https://refactoring.guru/smells/speculative-generality\">Speculative Generality</a>. Premature generalization is when you generalize a piece of code beyond its current requirements in anticipation of more general future requirements. In my experience it’s a very common mistake.</p>\n<p>Premature generalization is bad for the same exact reason premature optimization is bad: because it’s an effort to solve problems that probably aren’t real.</p>\n<p>Making a piece of code more general than it needs to be in anticipation of future needs might seem like a smart planning measure. If you can see that the code you’re writing will probably need to accommodate more use cases in the future, why not just make the code general enough now? That way you only have to write the code once.</p>\n<p>When programmers do this they’re making a bet. Sometimes their bet is right and sometimes it’s wrong. In my experience, these sorts of bets are wrong enough of the time that you lose on average. It’s like betting $50 for a 10% chance at winning $100. If you were to do that 10 times, you’d spend $500 and win just once (on average), meaning you’ll have paid $500 to win $100.</p>\n<p>It’s more economical to make your code <b>no more general than what’s called for by today’s requirements</b> and accept the risk that you might have to rework the code later to generalize it. This is also a bet but it’s a sounder one. Imagine a lottery system where you can either <b>buy a ticket for $50 for a 10% chance of winning $100</b>, or you can <b>choose <i>not</i> to play and accept a 10% chance of getting fined $30</b>. (I know it’s a weird lottery but bear with me.) If you buy a ticket ten times then on average you lose $400 because you’ve paid $500 to win $100. If ten times in a row you choose not to buy a ticket, then on average you get fined $30. So you’re obviously way better off with a policy of never buying the ticket.</p>\n<h2>Takeaways</h2>\n<ul>\n<li>Premature generalization is when you generalize a piece of code beyond its current requirements in anticipation of more general future requirements.</li>\n<li>On average, premature generalization doesn’t pay. It’s more economical to write the code in such a way as to only accommodate today’s requirements and then only generalize if and when a genuine need arises.</li>\n</ul>\n<p>The post <a rel=\"nofollow\" href=\"https://www.codewithjason.com/premature-generalization/\">Premature generalization</a> appeared first on <a rel=\"nofollow\" href=\"https://www.codewithjason.com\">Code with Jason</a>.</p>\n"
}