{
  "title":"Cohesion",
  "date":"2022-10-31T10:54:47.000000Z",
  "author":null,
  "id":"https://www.codewithjason.com/?p=2631",
  "link":"https://www.codewithjason.com/cohesion/",
  "content":"<p>Every codebase is a story. Well-designed programs tell a coherent, easy-to-understand story. Other programs are poorly designed and tell a confusing, hard-to-understand story. And it’s often the case that a program wasn’t <i>designed</i> at all, and so no attempt was made to tell a coherent story. But there’s some sort of story in the code no matter what.</p>\n<p>If a codebase is like a story, a file in a codebase is like a chapter in a book. A well written-chapter will clearly let the reader know what the most important points are and will feature those important points most prominently. A chapter is most understandable when it principally sticks to just one topic.</p>\n<p>The telling of the story may unavoidably require the conveyance of incidental details. When this happens, those incidental details will be put in their proper place and not mixed confusingly with essential points. If a detail would pose too much of a distraction or an interruption, it gets moved to a footnote or appendix or parenthetical clause.</p>\n<p>A piece of code is <b>cohesive</b> if a) everything in it shares one single idea and b) it doesn’t mix incidental details with essential points.</p>\n<p>Now let’s talk about ways that cohesion tends to get lost as well as ways to maintain cohesion.</p>\n<h2>How cohesion gets lost</h2>\n<p>Fresh new projects are usually pretty easy to work with. This is because a) when you don’t have very much code, it’s easier to keep your code organized, and b) when the total amount of code is small, you can <i>afford</i> to be fairly disorganized without hurting overall understandability too much.</p>\n<p>Things get tougher as the project grows. Entropy (the tendency for all things to decline into disorder) unavoidably sets in. Unless there are constant efforts to fight back against entropy, the codebase grows increasingly disordered. The code grows harder to understand and work with.</p>\n<p>One common manifestation of entropy is the tendency for developers to hang new methods onto objects like ornaments on a Christmas tree. A developer is tasked with adding a new behavior. He or she goes looking for the object that seems like the most fitting home for that behavior. He or she adds the new behavior, which doesn’t <i>perfectly</i> fit the object where it was placed, but the new code only makes the object 5% less cohesive, and it’s not clear where might be a better place for that behavior, so in it goes.</p>\n<p>This ornament-hanging habit is never curtailed because no individual “offense” appears to be all that bad. This is the nature of entropy: disorder sets in not because anything bad was done but simply because no one is going out of their way to stave off disorder.</p>\n<p>So, even though no individual change appears to be all that bad, the result of all these changes in aggregate is a surprisingly bad mess. The objects are huge. They confusingly mix unrelated ideas. Their essential points are obscured by incidental details. They’re virtually impossible to understand. They lack cohesion.</p>\n<p>How can this problem be prevented?</p>\n<h2>How cohesion can be preserved</h2>\n<p>The first key to maintaining cohesion is to make a clear distinction between what’s <b>essential</b> and what’s <b>incidental</b>. More specifically, a distinction must be made between what’s essential and what’s incidental with respect to the object in question.</p>\n<p>For example, let’s say I have a class called <code class=\"inline\">Appointment</code>. The concerns of <code class=\"inline\">Appointment</code> include, among other things, a start time, a client and some matters related to caching.</p>\n<p>I would say that the start time and client are <i>essential</i> concerns of the appointment and that the caching is probably <i>incidental</i>. In the story of <code class=\"inline\">Appointment</code>, start time and client are important highlights, whereas caching concerns are incidental details and should be tucked away in a footnote or appendix.</p>\n<p>That explains how to identify incidental details <i>conceptually</i> but it doesn’t explain how to separate incidental details <i>mechanically</i>. So, how do we do that?</p>\n<p>The primary way I do this is to simply move the incidental details into different objects. Let’s say for example that I have a <code class=\"inline\">Customer</code> object with certain methods including one called <code class=\"inline\">balance</code>.</p>\n<p>Over time the balance calculation becomes increasingly complicated to the point that it causes <code class=\"inline\">Customer</code> to lose cohesion. No problem: I can just move the guts of the <code class=\"inline\">balance</code> method into a new object (a PORO) called <code class=\"inline\">CustomerBalance</code> and delegate all the gory details of balance calculation to that object. Now <code class=\"inline\">Customer</code> can once again focus on the essential points and forget about the incidental details.</p>\n<p>Now, in this case it made perfect sense to recognize the concept of a customer balance as a brand new <a href=\"https://www.codewithjason.com/abstraction-in-rails/\">abstraction</a>. But it doesn’t always work out this way. In our earlier <code class=\"inline\">Appointment</code> example, for example, it’s maybe not so natural to take our caching concerns and conceive of them as a new extraction. It’s not particularly clear how that would go.</p>\n<p>What we can do in these cases, when we want to move an incidental detail out of an object but we can’t put our finger on a befitting new abstraction, is we can use a mixin instead. I view mixins as a good way to hold a bit of code which has cohesion with itself but which doesn’t quite qualify as an abstraction and so doesn’t make sense as an object. For me, mixins usually don’t have standalone value, and they’re usually only ever “mixed in” to one object as opposed to being reusable.</p>\n<p>(I could have said concern instead of mixin, but a) to me it’s a distinction without a meaningful difference, and b) <a href=\"https://www.codewithjason.com/used-intelligently-rails-concerns-great/\">concerns come along with some conceptual baggage</a> that I didn’t want to bring into the picture here.)</p>\n<p>So for our <code class=\"inline\">Appointment</code> example, we could move the caching code into a mixin in order to get it out of <code class=\"inline\">Appointment</code> so that <code class=\"inline\">Appointment</code> could once again focus solely on its essential points and forget about its incidental details.</p>\n<h2>Where to put these newly-sprouted files</h2>\n<p>When I make an object more cohesive by breaking out its incidental details into new <a href=\"https://www.codewithjason.com/what-is-a-rails-model/\">model</a> file, you might wonder where I put that new file.</p>\n<p>The short answer is that I put these files into <code class=\"inline\">app/models</code>, with additional subfolders based on the meaning of the code.</p>\n<p>So for the <code class=\"inline\">Appointment</code>, I might have <code class=\"inline\">app/models/appointment.rb</code> and <code class=\"inline\">app/models/scheduling/appointment_caching.rb</code>, provided that the caching code is related specifically to scheduling. The rationale here is that the caching logic will only ever be relevant to scheduling whereas an appointment might be viewed in multiple contexts, e.g. sometimes scheduling and sometimes billing.</p>\n<p>For the customer balance example, I might have <code class=\"inline\">app/models/customer.rb</code> and <code class=\"inline\">app/models/billing/customer_balance.rb</code>. Again, a customer balance is always a billing concern whereas a customer could be looked at through a billing lens or conceivably through some other sort of lens.</p>\n<p>Note that even though <code class=\"inline\">appointment_caching.rb</code> is a mixin or concern, I don’t put it in a <code class=\"inline\">concerns</code> or <code class=\"inline\">mixins</code> folder. That’s because I believe in <a href=\"https://www.codewithjason.com/organizing-rails-files-by-meaning/\">organizing files by meaning</a> rather than type. I find that doing so makes it easier to find what I want to find when I want to find it.</p>\n<h2>Takeaways</h2>\n<ul>\n<li>A piece of code is cohesive if a) everything in it shares single idea and b) it doesn’t mix incidental details with essential points.</li>\n<li>Cohesion naturally erodes over time due to entropy.</li>\n<li>The first key to maintaining cohesion is to make a clear distinction between what’s essential and what’s incidental.</li>\n<li>Incidental details can be moved into either new objects or into mixins/concerns in order to help preserve cohesion.</li>\n</ul>\n<p>The post <a rel=\"nofollow\" href=\"https://www.codewithjason.com/cohesion/\">Cohesion</a> appeared first on <a rel=\"nofollow\" href=\"https://www.codewithjason.com\">Code with Jason</a>.</p>\n"
}