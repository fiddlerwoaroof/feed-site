<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:cc="http://cyber.law.harvard.edu/rss/creativeCommonsRssModule.html">
    <channel>
        <title><![CDATA[Ruby Inside - Medium]]></title>
        <description><![CDATA[Ruby articles and posts - Medium]]></description>
        <link>https://medium.com/rubyinside?source=rss----235b73ea0b2e---4</link>
        <image>
            <url>https://cdn-images-1.medium.com/proxy/1*TGH72Nnw24QL3iV9IOm4VA.png</url>
            <title>Ruby Inside - Medium</title>
            <link>https://medium.com/rubyinside?source=rss----235b73ea0b2e---4</link>
        </image>
        <generator>Medium</generator>
        <lastBuildDate>Thu, 17 Nov 2022 12:50:30 GMT</lastBuildDate>
        <atom:link href="https://medium.com/feed/rubyinside" rel="self" type="application/rss+xml"/>
        <webMaster><![CDATA[yourfriends@medium.com]]></webMaster>
        <atom:link href="http://medium.superfeedr.com" rel="hub"/>
        <item>
            <title><![CDATA[What’s new in Ruby 2.7?]]></title>
            <link>https://medium.com/rubyinside/whats-new-in-ruby-2-7-79c98b265502?source=rss----235b73ea0b2e---4</link>
            <guid isPermaLink="false">https://medium.com/p/79c98b265502</guid>
            <category><![CDATA[ruby]]></category>
            <category><![CDATA[ruby-on-rails-development]]></category>
            <category><![CDATA[programming-languages]]></category>
            <category><![CDATA[software-development]]></category>
            <category><![CDATA[programming]]></category>
            <dc:creator><![CDATA[Guy Maliar]]></dc:creator>
            <pubDate>Mon, 02 Dec 2019 10:48:56 GMT</pubDate>
            <atom:updated>2020-01-04T09:39:32.111Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/600/0*7asj1rKS8d2mead_.png" /></figure><p>With Rubyconf 2019 behind us and Ruby 2.7 releasing this December, it’s the perfect time to go through what are the new features in the newest 2.x Ruby version and also the last release before 3.0.</p><p>What defines this version of Ruby is a mix of quality-of-life improvements such as <strong>Symbol#start_with? </strong>and<strong> Enumerable#filter_map, </strong>big yet often controversial features such as <strong>pattern matching </strong>and <strong>numbered arguments </strong>and bug fixes.</p><p>What also makes this version special is that it is the last one before <strong>Ruby 3.0 </strong>that is due will be released in Dec 2020 and has been presented by Matz in this year’s Rubyconf keynotes (<a href="https://www.youtube.com/watch?v=2g9R7PUCEXo&amp;list=PLE7tQUdRKcyZDE8nFrKaqkpd-XK4huygU&amp;index=2&amp;t=0s">https://www.youtube.com/watch?v=2g9R7PUCEXo&amp;list=PLE7tQUdRKcyZDE8nFrKaqkpd-XK4huygU&amp;index=2&amp;t=0s</a>) and covered by my fellow team member, <a href="https://medium.com/u/a5f2eb6f9df8">Snir David</a>, in post <a href="https://medium.com/@snird/rubyconf-2019-main-takeaways-from-the-keynote-ruby-3-0-and-the-road-ahead-b17b42cc50be">https://medium.com/@snird/rubyconf-2019-main-takeaways-from-the-keynote-ruby-3-0-and-the-road-ahead-b17b42cc50be</a>.</p><h3>Pattern Matching</h3><p>The best one line definition would be <strong>case/when + multiple assignments</strong>.</p><p>A more complete definition would be multiple patterns which some arbitrary data are checked against (<strong>case/when</strong>) and deconstructing the data according to those patterns (<strong>multiple assignments</strong>).</p><p><em>The best place to learn about pattern matching is probably the </em><a href="https://github.com/ruby/ruby/blob/master/test/ruby/test_pattern_matching.rb"><em>Ruby test files</em></a><em>.</em></p><pre>case [0, [1, 2, 3]]<br>in [a, [b, *c]]<br>  p a #=&gt; 0<br>  p b #=&gt; 1<br>  p c #=&gt; [2, 3]<br>end</pre><p>Pattern matching checks for the structure of the data so that it can be partially deconstructed as well,</p><pre>case [0, [1, 2, 3]]<br>in [0, [a, 2, b]]<br>  p a #=&gt; 1<br>  p b #=&gt; 3<br>end</pre><p>Much more information is available in the following slides which I highly recommend reading.</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fspeakerdeck.com%2Fplayer%2Fa853a73bba9d48ae88860f7c9b068334&amp;url=https%3A%2F%2Fspeakerdeck.com%2Fk_tsj%2Fpattern-matching-new-feature-in-ruby-2-dot-7&amp;image=https%3A%2F%2Fspeakerd.s3.amazonaws.com%2Fpresentations%2Fa853a73bba9d48ae88860f7c9b068334%2Fslide_0.jpg%3F510667&amp;key=a19fcc184b9711e1b4764040d3dc5c07&amp;type=text%2Fhtml&amp;schema=speakerdeck" width="710" height="399" frameborder="0" scrolling="no"><a href="https://medium.com/media/3d6ade257adcd1b46ef0a6faf7f3449f/href">https://medium.com/media/3d6ade257adcd1b46ef0a6faf7f3449f/href</a></iframe><h3>Numbered Parameters</h3><p>Numbered parameter as the default block parameter is introduced as an experimental feature, it allows us to drop the pipe definition in blocks, (|value|) and create shorter blocks with numbered parameters _1, _2, _3 etc.</p><pre>[1, 2, 10].map { _1.to_s(16) } #=&gt; [&quot;1&quot;, &quot;2&quot;, &quot;a&quot;]</pre><ul><li>Defining a local variable named _1 is still honored when present, but renders a warning</li></ul><pre>_1 = 0<br>[1].each { p _1 } # prints 0 instead of 1, but also warns.</pre><p>Some concerns have been issued by the community about how clear and/or how needed this feature actually is.</p><p>From the clarity perspective it’s quite unclear (no pun intended) what is actually better.</p><pre># bad<br>names.map { |name| name.upcase }</pre><pre># good<br>names.map(&amp;:upcase)</pre><pre># also good?<br>names.map { _1.upcase }</pre><p>I’ve thought of and found some examples of what can we do with it.</p><pre># Shorter one-liners?</pre><pre>hash = {<br>  key_1: &quot;1&quot;,<br>  key_2: &quot;2&quot;,<br>}</pre><pre>hash.map { [_1.to_s, _2.to_i] }.to_h <br># =&gt; { &quot;key_1&quot; =&gt; 1, &quot;key_2&quot; =&gt; 2 }</pre><pre># Simpler simple-one-lines that can&#39;t be otherwise written?</pre><pre>[1, 2, 3].collect { _1 ** 2 }</pre><pre># Shorter definitions of less important variables?</pre><pre><em>h = Hash.new { _1[_2] = [] }<br>h[:a].push(1)</em></pre><pre># Cleaner method chains?</pre><pre>HTTP.get(url).body.then { JSON.parse(_1, symbolize_names: true) }</pre><pre># Weird each with objects?</pre><pre>[:method_1, :method_2, :method_3].each_with_object(Post.find(1)) { _2.send(_1) }</pre><h3>Argument Forwarding</h3><p>A nice quality of life feature when we want to pass all the arguments as is,</p><pre>def foo(...)<br>  bar(...)<br>end</pre><p>All arguments to foo are forwarded to bar, including keyword and block arguments.</p><h3>Beginless Ranges</h3><p>An experimental feature with still with <a href="https://bugs.ruby-lang.org/issues/14799">some concerns</a>, beginless ranges are looked more as a feature for DSL completeness rather than usability. This feature is used mostly for comparison where we’d like to define a condition for “everything below the specified value”. Dates and numbers make the perfect example and even for version strings.</p><pre>case release_date<br>when ..1.year.ago <br>  puts &quot;ancient&quot;<br>when 1.year.ago..3.months.ago<br>  puts &quot;old&quot;<br>when 3.months.ago..Date.today<br>  puts &quot;recent&quot;<br>when Date.today..<br>  puts &quot;upcoming&quot;<br>end</pre><pre><br>ruby_version_is ...&quot;2.6&quot; do<br>  # ...<br>end</pre><h3>Flip flop operator is back</h3><p>A lesser known feature in Ruby is the flip flop operator. It has it’s root coming from Perl but isn’t used as much anymore.</p><p>The flip flop operator is a range (..) operator used between two conditions in a conditional statement. It evaluates to false until the first condition evaluates to true and stays true until the second condition evaluates to true.</p><pre>(1..10).each { |i| puts i if (i == 5) .. (i == 8) }<br>5<br>6<br>7<br>8<br>=&gt; 1..10</pre><h3>Array#intersection</h3><p>The equivalent to:</p><pre>[ 1, 1, 3, 5 ] &amp; [ 3, 2, 1 ]                 #=&gt; [ 1, 3 ]<br>[ &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;z&#39; ] &amp; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ]   #=&gt; [ &#39;a&#39;, &#39;b&#39; ]</pre><p>Can now be written as:</p><pre>[ 1, 1, 3, 5 ].<strong>intersection</strong>([ 3, 2, 1 ])                #=&gt; [ 1, 3 ]<br>[ &#39;a&#39;, &#39;b&#39;, &#39;b&#39;, &#39;z&#39; ].<strong>intersection</strong>([ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ])  #=&gt; [ &#39;a&#39;, &#39;b&#39; ]</pre><h3>Enumerable#filter_map</h3><p>select and map are often used to transform an array while filtering some items out completely.</p><p>Up until now it would have been possible with</p><pre>[1, 2, 3].select { |x| x.odd? }.map { |x| x.to_s }<br>[1, 2, 3].map { |x| x.to_s if x.odd? }.compact <br>[1, 2, 3].each_with_object([]) { |x, m| m.push(x.to_s) if x.odd? }</pre><p>filter_map allows us to pair the two together and solve the problem faster.</p><pre>[1, 2, 3].filter_map {|x| x.odd? ? x.to_s : nil } #=&gt; [&quot;1&quot;, &quot;3&quot;]</pre><h3>Enumerable#tally</h3><p>The way to count the amount of repetitions of a specific value in an Enumerable would have been one of the followings:</p><pre>array<br>  .group_by { |v| v }<br>  .map { |k, v| [k, v.size] }<br>  .to_h</pre><pre>array<br>  .group_by { |v| v }<br>  .transform_values(&amp;:size)<br><br>array.each_with_object(Hash.new(0)) { |v, h| h[v] += 1 }</pre><p>As of 2.7 we can instead use tally :</p><pre>[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;A&quot;].tally #=&gt; {&quot;A&quot;=&gt;2, &quot;B&quot;=&gt;2, &quot;C&quot;=&gt;1}</pre><h3>Enumerator.produce</h3><p>Enumerator.produce(initial, &amp;block), will produce an infinite sequence where each next element is calculated by applying block to previous.</p><pre>require &#39;date&#39;</pre><pre>dates = Enumerator.produce(Date.today, &amp;:next) #=&gt; infinite sequence of dates<br>dates.detect(&amp;:tuesday?) #=&gt; next tuesday</pre><pre># easy Fibonacci<br>Enumerator.produce([0, 1]) { |f0, f1| [f1, f0 + f1] }.take(10).map(&amp;:first)</pre><p>Or for pagination (taken directly from <a href="https://bugs.ruby-lang.org/issues/14781">https://bugs.ruby-lang.org/issues/14781</a>)</p><pre>require &#39;octokit&#39;</pre><pre>Octokit.stargazers(&#39;rails/rails&#39;)</pre><pre>p Enumerator.generate(Octokit.last_response) { |response| response.rels[:next].get }<br>            .first(3)<br>            .flat_map(&amp;:data)<br>            .map { |h| h[:login] } <br># =&gt; [&quot;wycats&quot;, &quot;brynary&quot;, &quot;macournoyer&quot;, &quot;topfunky&quot;, &quot;tomtt&quot;, &quot;jamesgolick&quot;, ...</pre><p>A very short and well explanation is available here.</p><p><a href="https://blog.saeloun.com/2019/11/27/ruby-2-7-enumerator-produce.html">Ruby 2.7 adds Enumerator#produce</a></p><h3>Symbol#start_with? / Symbol#end_with?</h3><p>Just some convenience methods that behave like <strong>String#start_with?</strong> and <strong>String#end_with?</strong></p><h3>Keyword Arguments spec changes</h3><p>Keyword arguments assignments spec is changing a little bit with additional warnings and deprecation warnings that will probably be hapenning next year with Ruby 3.</p><p>Taken directly from the Ruby NEWS,</p><ul><li>When a method call passes a Hash at the last argument, and when it passes no keywords, and when the called method accepts keywords, a warning is emitted. <em>To continue treating as keywords, add a double splat operator to avoid the warning and ensure correct behavior in Ruby 3.</em></li></ul><pre>def foo(key: 42); end; foo({key: 42})   # warned<br>def foo(**kw);    end; foo({key: 42})   # warned<br>def foo(key: 42); end; foo(**{key: 42}) # OK<br>def foo(**kw);    end; foo(**{key: 42}) # OK</pre><ul><li>When a method call passes keywords to a method that accepts keywords, but it does not pass enough required positional arguments, the keywords are treated as a final required positional argument, and a warning is emitted. <em>Pass the argument as a hash instead of keywords to avoid the warning and ensure correct behavior in Ruby 3.</em></li></ul><pre>def foo(h, **kw); end; foo(key: 42)      # warned<br>def foo(h, key: 42); end; foo(key: 42)   # warned<br>def foo(h, **kw); end; foo({key: 42})    # OK<br>def foo(h, key: 42); end; foo({key: 42}) # OK</pre><ul><li>When a method accepts specific keywords but not a keyword splat, and a hash or keywords splat is passed to the method that includes both Symbol and non-Symbol keys, the hash will continue to be split, and a warning will be emitted. <em>You will need to update the calling code to pass separate hashes to ensure correct behavior in Ruby 3.</em></li></ul><pre>def foo(h={}, key: 42); end; foo(&quot;key&quot; =&gt; 43, key: 42)   # warned<br>def foo(h={}, key: 42); end; foo({&quot;key&quot; =&gt; 43, key: 42}) # warned<br>def foo(h={}, key: 42); end; foo({&quot;key&quot; =&gt; 43}, key: 42) # OK</pre><ul><li>If a method does not accept keywords, and is called with keywords, the keywords are still treated as a positional hash, with no warning.<em> This behavior will continue to work in Ruby 3.</em></li></ul><pre>def foo(opt={});  end; foo( key: 42 )   # OK</pre><ul><li>Accept non-symbols keyword arguments if method accepts arbitrary keywords</li></ul><pre>def foo(**kw); p kw; end; foo(&quot;str&quot; =&gt; 1) #=&gt; {&quot;str&quot;=&gt;1}</pre><p><em>Most of the examples here are either taken from my imagination or from the Ruby NEWS file, Ruby Issue Tracking System or other blog posts, if there’s any credit missing please let me know.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=79c98b265502" width="1" height="1" alt=""><hr><p><a href="https://medium.com/rubyinside/whats-new-in-ruby-2-7-79c98b265502">What’s new in Ruby 2.7?</a> was originally published in <a href="https://medium.com/rubyinside">Ruby Inside</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A Q&A with Noah Gibbs]]></title>
            <link>https://medium.com/rubyinside/a-q-a-with-noah-gibbs-576c06e90376?source=rss----235b73ea0b2e---4</link>
            <guid isPermaLink="false">https://medium.com/p/576c06e90376</guid>
            <category><![CDATA[ruby-on-rails]]></category>
            <category><![CDATA[ruby]]></category>
            <dc:creator><![CDATA[Glenn Goodrich]]></dc:creator>
            <pubDate>Mon, 19 Aug 2019 15:10:20 GMT</pubDate>
            <atom:updated>2019-08-19T15:10:20.366Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1000/1*xoeK5Yv-XtjxaIZgq0uVwA.png" /></figure><h4>Author of ‘Rebuilding Rails’ and Ruby performance benchmarker extraordinaire</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><p>Noah is a Ruby Fellow at <a href="https://engineering.appfolio.com">AppFolio</a> and has authored countless articles and given many presentations on benchmarking Ruby and Rails. He has also built benchmarking tools, including <a href="https://github.com/noahgibbs/rails_ruby_bench">an official benchmark for Ruby 3x3</a>.</p><p>💬 <em>We’re grateful that he’s taken the time to answer a few of our questions:</em></p><p><strong>What first inspired you to start benchmarking Ruby so fervently?</strong></p><p>When I was chosen for the Ruby Fellow role, I knew I needed to work on performance. That’s what they were specifically looking for! I tried a few things including different Ruby compile options, different kinds of profiling… You can see some of that in my early articles. But what worked (for me, for readers, for the Core team) turned out to be the benchmarking. Sometimes you try a few things and find a sweet spot!</p><p><strong>What do you see as the largest impact item in Ruby 3x3 when it comes to better performance?</strong></p><p>It’s hard to narrow Ruby 3x3 performance down — there are so many little fixes! But for non-Rails code, <a href="https://blog.bigbinary.com/2019/03/05/mjit-support-in-ruby-2-6.html">MJIT</a> is huge. For Rails, probably a change to how Ruby handles TraceFunc in Ruby 2.5 that added nearly 10% to the overall speed.</p><p><strong>What’s the most challenging aspect of your benchmarks?</strong></p><p>The most challenging aspect, always, is being sure enough (but never 100%!) that I’m right. Measuring and interpretation are hard, and often I can’t be sure what a result means. Re-running tests and extra measurements help, but you’re never utterly sure. You’ve probably noticed that a lot of my conclusions sound nuanced (“X is probably true,” “Y seems very unlikely.”) That’s why!</p><p><strong>What’s the most worrisome item on the current Ruby roadmap, in your opinion?</strong></p><p>I’m not sure I’d call any item on the roadmap “worrisome” — progress is pretty good and we have 18 months left. Static type tools took longer to get really started, but new tools like <a href="https://sorbet.org">Sorbet</a> are in surprisingly good shape. We’ll get there. I think real-world Rails performance is going to finish at more like double speed than triple. It’s at about 172% speed in Ruby 2.6. That should make sense — a lot of Rails time is in the database, or libev or other C extensions and Ruby’s speed doesn’t affect it. In those cases I’m pretty happy with “only” doubling the end-to-end speed. Especially in a mature 20+-year-old language!</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*U9-mKbyj1UuSP15zYVvaVw.png" /></figure><blockquote>This Q&amp;A first appeared in Ruby Weekly Issue #460 — <a href="https://rubyweekly.com/?utm_source=rubyinside&amp;utm_medium=medium&amp;utm_content=noahgibbs_qa">a free, one-weekly email digest of the latest Ruby news and articles</a>.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=576c06e90376" width="1" height="1" alt=""><hr><p><a href="https://medium.com/rubyinside/a-q-a-with-noah-gibbs-576c06e90376">A Q&amp;A with Noah Gibbs</a> was originally published in <a href="https://medium.com/rubyinside">Ruby Inside</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A Deep Dive into Routing and Controller Dispatch in Rails]]></title>
            <link>https://medium.com/rubyinside/a-deep-dive-into-routing-and-controller-dispatch-in-rails-8bf58c2cf3b5?source=rss----235b73ea0b2e---4</link>
            <guid isPermaLink="false">https://medium.com/p/8bf58c2cf3b5</guid>
            <category><![CDATA[coding]]></category>
            <category><![CDATA[ruby-on-rails]]></category>
            <category><![CDATA[rails-6]]></category>
            <category><![CDATA[rails-5]]></category>
            <dc:creator><![CDATA[Alex Taylor]]></dc:creator>
            <pubDate>Mon, 18 Mar 2019 10:23:17 GMT</pubDate>
            <atom:updated>2019-03-18T10:23:17.364Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*XNvXZOdhUL5WVWjgtGsFMw.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/photos/3oZi_wdTiBc?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Shah Safwan</a> on <a href="https://unsplash.com/search/photos/railway?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>Rails has a lot of magic that we often take for granted. A lot is going on the behind the clever, elegant abstractions that Rails provides us as users of the framework. And at a certain point, I find it’s useful to peek behind the curtain and see how things really work.</p><p>But opening the Rails source code can be absolutely daunting at first. It can feel like a jungle of abstractions and metaprogramming. A large part of this is due to the nature of object-oriented programming: by its nature, it’s not easy to follow a step-by-step path that would be taken at runtime. Sometimes, it helps to have a guide.</p><p>With this in mind, let’s take some time to explore how routing works in Rails. How does a web request accepted by Rack make it all the way to your Rails controller?</p><h3>Familiar territory</h3><p>For the purposes of this example, consider a Rails app with a single route and controller:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7c0183dceaa268f75be5e24e8ed24570/href">https://medium.com/media/7c0183dceaa268f75be5e24e8ed24570/href</a></iframe><p>In this app, a GET request to /users will be routed to the UsersController. But how?</p><h3>Orientation</h3><p>A lot of collaboration happens to get from request to controller, so it will be useful to get a bird’s eye view before diving in. Here’s a diagram that shows how routes defined in routes.rb are registered within Rails at boot time. We’ll explore these classes in more detail shortly:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*9XWR-4Bz6VMw6sJml2QBXw.png" /><figcaption>The objects involved in route configuration. As we’ll see, Journey is also a part of the framework, but it’s useful to think of it separately when considering its responsibilities.</figcaption></figure><p>And here’s the sequence of events that occurs when we make our GET request to /users:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Hs7GiHDww8xAMIirA7Vh2w.png" /><figcaption>How a request to /users makes its way through Rails and into our UsersController.</figcaption></figure><h3>routes.rb</h3><p>The file you know and love! From a Rails framework perspective, this is the public interface. Declare your routes in this file, and Rails will take care of figuring out how to route a request to the right controller.</p><h3>RouteSet</h3><p>I kind of lied when I said routes.rb was the public interface. It’s really a DSL to the public interface. The RouteSet is the actual class that acts as the entry point for route configuration in a Rails application. It’s most famous for the #draw method, which we’ve just used in routes.rb:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d71a73f4bf84c156ef674ab217c66f5f/href">https://medium.com/media/d71a73f4bf84c156ef674ab217c66f5f/href</a></iframe><p>At runtime, RouteSet is responsible for coordinating the entire operation that we’re about to dive into: it receives the incoming web request, and collaborates with the objects below to determine how the request makes it into our application code.</p><h3>Journey::Routes</h3><p>Once upon a time, Journey was <a href="https://github.com/rails/journey">a standalone gem</a>, before it was merged into ActionPack. It focuses on routes, and figuring out how to route an incoming request. It doesn’t know about Rails at all, nor does it care — give it a set of routes, then pass it a request, and it will route that request to the first route that matches.</p><p>How it performs the routing in an efficient way is fascinating, and there’s <a href="https://www.youtube.com/watch?v=lEC-QoZeBkM">a great talk from Vaidehi Joshi</a> that goes into detail on the internals of Journey. I highly recommend it!</p><p>Journey::Routes holds on to the routes that our Rails app knows about. RouteSet delegates to it whenever a new route is registered at startup, whether that’s from routes.rb, an engine, or a gem like <a href="https://github.com/plataformatec/devise">Devise</a> that defines its own routes.</p><h3>Journey::Route</h3><p>If we think ofJourney::Routes like an array, then Journey::Route objects are the elements inside. In addition to the metadata you’d expect this object to hold on to, like the path of the route, it also holds a reference to app, which will get invoked if that route is chosen to serve the request.</p><p>In this way, each Journey::Route is kind of like a tiny web app that responds to a single endpoint. It has no knowledge of other routes aside from its own, but it can guide our request in the right direction when the time comes.</p><h3>RouteSet::Dispatcher</h3><p>Contrary to what you might think, the app that lives inside of each Journey::Route object is not some reference to the controller. There’s one more level of indirection here, as a means of keeping Rails code separate from the routing logic that Journey concerns itself with.</p><p>Dispatcher is a small class which is responsible for instantiating the controller and passing along our request, along with an empty response object. It’s invoked when a suitable route is identified for a request. It has no knowledge about <em>how</em> a request arrived on its doorstep, but it knows what to do when it sees our request: instantiate the UsersController and hand it our request. As we’ll see, it acts as an <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">object factory</a> for our controllers, removing the need for us to declare our controller classes anywhere outside of the classes themselves.</p><p>This might seem like an almost needless indirection, but it’s worthwhile considering thatDispatcher&#39;s position between routing logic and controller classes allows either to change without affecting the other.</p><h3>Journey::Router</h3><p>Journey::Routes knows nothing about requests. It knows about routes, and it will quickly and efficiently identify the correct one for the request. So in order to map an incoming request to a route, we need something that knows about a request <em>and</em> a route. Enter Router.</p><p>It’s Router that actually invokes the Dispatcher once a route has been found.</p><h3><em>UsersController</em></h3><p>Hey, we know what this is already! Welcome home. 😌 Now let’s connect the dots.</p><h3>Back to where it all began…</h3><p>Let’s circle back to our routes file:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/13170bfb15643dd7103a5814a0598703/href">https://medium.com/media/13170bfb15643dd7103a5814a0598703/href</a></iframe><p>When Rails is booting, <a href="https://github.com/rails/rails/blob/v6.0.0.beta2/railties/lib/rails/engine.rb#L533-L537">a new </a><a href="https://github.com/rails/rails/blob/v6.0.0.beta2/railties/lib/rails/engine.rb#L533-L537">RouteSet gets instantiated</a>. It evaluates the contents of the routes file and builds up a RouteSet.</p><p>Because RouteSet is the source of truth for all available endpoints in our application, it’s also first in line to receive a request from the outside world, after passing through Rack and various middleware. That’s right, this humble class buried in ActionPack is the Walmart greeter of our application, ready with a smile and a wave as soon as a request comes through the door.</p><p>In order for RouteSet to accept the request after it’s travelled through Rack and any middleware, it needs to implement Rack’s interface, which is as simple as implementing call:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/7fee6cff1a939d82e3e1d4c18e849bfb/href">https://medium.com/media/7fee6cff1a939d82e3e1d4c18e849bfb/href</a></iframe><p>Here we build a new request object. This will end up being a fresh instance of ActionDispatch::Request, populated from env, which is the incoming hash that Rack serves us.</p><p>After doing some string gymnastics on the incoming path, we pass the request off to @router, which is an instance of Journey::Router. We pass it a request and ask it to serve that request.</p><p>In Journey::Router#serve, we iterate through the routes that match the path in the request:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/97b3eebc5bb853576876531eea530cd6/href">https://medium.com/media/97b3eebc5bb853576876531eea530cd6/href</a></iframe><p>Pay special attention to this line:</p><pre>req.path_parameters = set_params.merge parameters</pre><pre># `req.path_parameters` is now a hash that<br># might look familiar:</pre><pre>{:controller=&gt;&quot;users&quot;, :action=&gt;&quot;index&quot;}</pre><p>Notice that we’re actually enriching the request object itself with metadata that’s returned from the find_routes method. This is quite subtle, but it’s how Journey communicates with the rest of the system. Once it identifies a matching route for the request, it “stamps” that knowledge onto the request itself, so that subsequent objects that deal with the request (like Dispatcher) know how to proceed. Foreshadowing!</p><p>Anyway, when a match is finally found, we ask the route’s app to serve the request, then return the familiar array from any Rack app of status, headers, and body.</p><p>The reason for all this indirection is separation of concerns. In theory, Journey can function perfectly fine outside of a Rails application, and as a result it’s abstracted the concept of an “app” into anything that implements Rack’s interface.</p><p>It’s here that Rails comes back into the picture. As I mentioned before, each object behind route.app is actually an instance of Dispatcher:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ab1a1f742a6377acdf54cf690d8da04c/href">https://medium.com/media/ab1a1f742a6377acdf54cf690d8da04c/href</a></iframe><p>Dispatcher is our entry point back into Rails land. It knows that a request is served by a controller, and it knows that the way to talk to a Rails controller is to send it a #dispatch method and pass along the action, the request object, and a fresh new ActionDispatch::Response object to write the response into.</p><p>Notice that in the #controller method above, we punt the question of which class to use to the request itself. When our request was first born, it had no idea who should be handling its request; it was just a glorified hash with a ton of metadata coming from the outside world. But thankfully, it passed through Journey&#39;s hands, who imbued it with a few crucial pieces of data:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6b71940a6ba8331b3ff5a9a2e6999902/href">https://medium.com/media/6b71940a6ba8331b3ff5a9a2e6999902/href</a></iframe><p>Armed with this knowledge, the request object itself is now in a position to answer the question, “which controller should serve my request?”</p><p>Here’s what that looks like in the Request object:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/8d4e2898e2ae2e121406e875bc10fa52/href">https://medium.com/media/8d4e2898e2ae2e121406e875bc10fa52/href</a></iframe><p>Buried deep in the Rails framework is a great example of the <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">Factory Pattern</a> at work. We want to automagically choose the right class to handle our incoming request, and we don’t want to hardcode a list of all of our controllers anywhere, because that would be a pain. Since we now have a string, “users”, that tells us which controller this request wants to go to, we can build up the official class name, UsersController, and use #constantize to turn that into the class constant. Along with help from Dispatcher, which ends up invoking the method above, we have a way of instantiating the right controller for the request at runtime.</p><p>This is also a great example of the <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">Open/Closed principle</a>. Since Rails makes the assumption that your controllers are going to be named a certain way, you’re free to define a new controller simply by creating a new class that follows the naming convention, and defining its matching route. At no point do you have to update some ungainly mapping of route -&gt; controller, or even register your controller anywhere. It’s the adherence to this principle that powers the Rails mantra of convention over configuration.</p><p>Now we’re getting really close: a message has been sent to the UsersController! Through a series of intermediary methods, we finally invoke the method #index on the controller:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/172e4e3acaee01d78880159ddf56d1b6/href">https://medium.com/media/172e4e3acaee01d78880159ddf56d1b6/href</a></iframe><p>It looks like a lot, but ultimately we’re just using Ruby’s send method to invoke the correct action on our controller instance. Simplified, it might look something like this:</p><pre>UsersController.new(request, response).send(:index)</pre><h3>Unwinding the Abstraction</h3><p>We just looked at a lot of objects. It can be hard to follow the path of execution when we need to bounce around so many different files. As a reminder, here’s the sequence of events again:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Hs7GiHDww8xAMIirA7Vh2w.png" /></figure><p>Another way to help clarify our understanding could be to reduce all of these steps down to a single method. Stripping away some of the abstraction, it might end up looking something like this:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/6271c58f1ba4eb987a29d550e74170d8/href">https://medium.com/media/6271c58f1ba4eb987a29d550e74170d8/href</a></iframe><h3>Conclusion</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*TorCbm0Tg-6IV1Jjqf_6XA.jpeg" /><figcaption>Photo by <a href="https://unsplash.com/photos/Q47eNv_UvfM?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Dmitrii Vaccinium</a> on <a href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></figcaption></figure><p>If you made it this far, congratulations! 🎉 As you can see, there’s a lot going on behind the scenes, but hopefully this has helped to demystify some of the magic and appreciate the object-oriented principles at work.</p><p>Next time you add a new controller to your Rails app, sit back and appreciate just how much heavy lifting Rails is doing to take care of the details.</p><p>If you want to explore this code further, run bundle open actionpack from your Rails app’s directory and have a look at the classes we’ve explored, or <a href="https://github.com/rails/rails/tree/master/actionpack">check out the </a><a href="https://github.com/rails/rails/tree/master/actionpack">actionpack code on GitHub</a>. Have fun!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8bf58c2cf3b5" width="1" height="1" alt=""><hr><p><a href="https://medium.com/rubyinside/a-deep-dive-into-routing-and-controller-dispatch-in-rails-8bf58c2cf3b5">A Deep Dive into Routing and Controller Dispatch in Rails</a> was originally published in <a href="https://medium.com/rubyinside">Ruby Inside</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[What’s coming to Rails 6.0?]]></title>
            <link>https://medium.com/rubyinside/whats-coming-to-rails-6-0-8ec79eea66da?source=rss----235b73ea0b2e---4</link>
            <guid isPermaLink="false">https://medium.com/p/8ec79eea66da</guid>
            <category><![CDATA[ruby]]></category>
            <category><![CDATA[web-development]]></category>
            <category><![CDATA[engineering]]></category>
            <category><![CDATA[ruby-on-rails]]></category>
            <category><![CDATA[software-development]]></category>
            <dc:creator><![CDATA[Guy Maliar]]></dc:creator>
            <pubDate>Thu, 14 Feb 2019 13:17:11 GMT</pubDate>
            <atom:updated>2019-04-15T14:51:50.425Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5cukG51YzB3wniCfQ2b7kg.png" /></figure><p>Rails 6.0 will be released soon and it’s packed with many features that both smaller and bigger applications will benefit from, as it feels like many improvements around speed and scalability were introduced in Rails 6.</p><p><strong>I’ve read through the CHANGELOGs of all Rails parts (ActiveRecord, ActionPack, ActiveSupport, etc.) and picked some of the features that I found the most interesting.</strong></p><p>Two new additions to the Rails family are Action Mailbox and Action Text that come straight out of Basecamp.</p><h3>Active Record</h3><h4>Add basic API for connection switching to support multiple databases</h4><p>Connection switching support has been on my list for a long time, I’ve used the <a href="https://github.com/thiagopradi/octopus">Octopus gem</a> a few times before as well, but it always felt a little bit clunky in my opinion.</p><p><a href="https://medium.com/u/179816037ba8">Eileen M. Uchitelle</a> has extracted out of Github’s codebase and into Rails’ this amazing feature, a native solution to switch database connections for specific models and/or specific queries.</p><p>The code is available as part of the pull request, <a href="https://github.com/rails/rails/pull/34052">https://github.com/rails/rails/pull/34052</a>, it’s documented amazingly and very easy to follow through.</p><pre>class AnimalsModel &lt; ApplicationRecord<br>  self.abstract_class = true<br><br>  connects_to database: { writing: :animals_primary, reading: :animals_replica }<br>end<br><br>class Dog &lt; AnimalsModel<br>  # connected to both the animals_primary db for writing and the animals_replica for reading<br>end</pre><p>Slow queries in jobs can be read from a replica using a simple API</p><pre>ActiveRecord::Base.connected_to(database: :slow_replica) do<br>  SlowReplicaModel.first<br>end</pre><p>And the database.yml file is simply a little bit longer</p><pre>development:<br>  primary:<br>    database: my_primary_db<br>    user: root<br>  primary_replica:<br>    database: my_primary_db<br>    user: ro_user<br>    replica: true<br>  animals:<br>    database: my_animals_db<br>    user: root<br>  animals_replica<br>    database: my_animals_db<br>    user: ro_user<br>    replica: true</pre><h3>DHH on Twitter</h3><p>Eileen has been killing it! Extracting feature after feature from GitHub. Rails 6 is going to be special. Big thanks to @github for supporting this work and being a core pillar of the Rails community ✌️❤️ https://t.co/EOIWlgmH0q</p><h3>Aaron Patterson on Twitter</h3><p>I&#39;m really excited to see parts of GitHub&#39;s app pushed upstream. Great work @eileencodes!!! https://t.co/VN2pNyImG5</p><p><a href="https://medium.com/u/5759c01113e0">Gannon McGibbon</a> later added some more amazing code supporting hash and url configs in database hash of ActiveRecord::Base.connected_to which open up these possibilities</p><pre>User.connected_to(database: { writing: &quot;postgres://foo&quot; }) do<br>  User.create!(name: &quot;Gannon&quot;)<br>end<br><br>config = { &quot;adapter&quot; =&gt; &quot;sqlite3&quot;, &quot;database&quot; =&gt; &quot;db/readonly.sqlite3&quot; }<br>User.connected_to(database: { reading: config }) do<br>  User.count<br>end</pre><h4>Add Relation#pick as short-hand for single-value plucks</h4><p>Just as the name suggests pick can pluck single-values</p><pre>Person.where(id: 1).pick(:name, :email_address)<br># SELECT people.name, people.email_address FROM people WHERE id = 1 LIMIT 1<br># =&gt; [&#39;David&#39;, &#39;david@loudthinking.com&#39;]</pre><h4>Add ActiveRecord::Base.create_or_find_by/! to deal with the SELECT/INSERT race condition</h4><p>A while back, <a href="https://medium.com/u/54bcbf647830">DHH</a> have started YouTube series called <a href="https://www.youtube.com/playlist?list=PL9wALaIpe0Py6E_oHCgTrD6FvFETwJLlx">On Writing Software Well</a> which later became part of the <a href="https://www.youtube.com/channel/UCdx5Dk3EWTe2i8YDA7bfl6g">Getting Better YouTube</a> page, on one of the videos he shows his technique for addressing the issues with find_or_create_by and the alternative create_or_find_by which relies on a database unique constraint. The code itself is fairly intuitive and is taken directly from the <a href="https://github.com/rails/rails/blob/4cb1438b57067d637c79d49d0662c43b5b4e64c2/activerecord/lib/active_record/relation.rb#L203-L207">Rails sourcecode</a>.</p><pre>def create_or_find_by(attributes, &amp;block)<br>  transaction(requires_new: true) { create(attributes, &amp;block) }<br>rescue ActiveRecord::RecordNotUnique<br>  find_by!(attributes)<br>end</pre><p><a href="https://github.com/rails/rails/blob/4cb1438b57067d637c79d49d0662c43b5b4e64c2/activerecord/lib/active_record/relation.rb#L177-L202">There are several drawbacks to this solution which are stated</a> and I suggest reading them before using this solution.</p><h4>Make the implicit order column configurable</h4><p>For applications that don’t use sequential IDs this one is golden. When using UUIDs as default column identifier, first and last methods no longer make sense. Now we will be able to set the order of the records with a single line of configuration.</p><pre>class User &lt; ActiveRecord::Base<br>  self.implicit_order_column = &quot;created_at&quot;<br>end </pre><h3>Action Mailbox</h3><p>Action Mailbox is introduced in the sixth version of Ruby on Rails, I’m sure many posts will be written about it in the near future and it’s pretty exciting. Action Mailbox provides a set of tools that will allow applications to better integrate with inbound emails flows.</p><p>The basics are covered at <a href="https://edgeguides.rubyonrails.org/action_mailbox_basics.html">Action Mailbox Basics Rails Guide</a> but a few cool ideas would be conversations that happen automatically in both a platform and email and are interchangeable, think about Github comments from emails, help desk emails that turn into tickets or even GDPR delete requests.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/350294199e1d3d5437cc9dd1e6e0a3e9/href">https://medium.com/media/350294199e1d3d5437cc9dd1e6e0a3e9/href</a></iframe><p>The documentation to set up Action Mailbox is available at <a href="https://edgeguides.rubyonrails.org/action_mailbox_basics.html">https://edgeguides.rubyonrails.org/action_mailbox_basics.html</a>, it covers the required configuration of Action Mailbox available providers.</p><p>Pay attention that Action Mailbox requires Active Job and Active Storage as part of it’s and a database table. Most of the class documentation is also available at <a href="https://github.com/rails/rails/blob/master/actionmailbox/lib/action_mailbox/base.rb">ActionMailbox::Base class documentation</a>, <a href="https://github.com/rails/rails/blob/master/actionmailbox/app/models/action_mailbox/inbound_email.rb">ActionMailbox::InboundEmail class documentation</a> and working with a parsed email is done by using the <a href="https://github.com/mikel/mail">Mail gem</a>.</p><h3>Action Text</h3><p>Action Text is an implementation of the new <a href="https://trix-editor.org/">Trix editor by Basecamp</a> bundled into ActiveRecord models. It exposes a has_rich_text method that we can apply to models and Action Text will take care of the rest. Action Text requires ActiveStorage and some database tables to persist it’s metadata, so be aware that you’d want to switch to an ActiveStorage provider that does not persist to disk if you’re working on applications that require more than one server.</p><p>The documentation is available at the <a href="https://edgeguides.rubyonrails.org/action_text_overview.html">Rails Guides</a> and it’s pretty self-explanatory.</p><h3>Action Pack</h3><h4>Introduce ActionDispatch::HostAuthorization</h4><p>Host Authorization is a new middleware that guards against DNS rebinding attacks by explicitly permitting the hosts a request can be sent to. More information about the attack itself is available in this <a href="https://medium.com/@brannondorsey/attacking-private-networks-from-the-internet-with-dns-rebinding-ea7098a2d325">Medium post</a> and in <a href="https://danielmiessler.com/blog/dns-rebinding-explained/">Daniel Miessler’s DNS Rebinding attack explained</a>.</p><p>By default it’s set for all Rails 6 applications and allows in development the following hosts IPAddr.new(“0.0.0.0/0”), IPAddr.new(“::/0”), “localhost”] it supports arrays of RegExp, Proc, IPAddr and String or a single String in the configuration. What this means is that with Rails 6, we will need to explicitly set our domains in the environments configuration files.</p><p>More information is available at the <a href="https://github.com/rails/rails/blob/5da63c1d5664b6499be3c05f12bedddd2079ffb4/actionpack/lib/action_dispatch/middleware/host_authorization.rb">HostAuthoriation code</a> and <a href="https://github.com/rails/rails/blob/5da63c1d5664b6499be3c05f12bedddd2079ffb4/actionpack/test/dispatch/host_authorization_test.rb">HostAuthorization tests</a>.</p><h4>Purpose metadata for signed/encrypted cookies</h4><p>Rails can now thwart attacks that attempt to copy signed/encrypted value of a cookie and use it as the value of another cookie.</p><p>It does so by stashing the cookie-name in the purpose field which is then signed/encrypted along with the cookie value. Then, on a server-side read, we verify the cookie-names and discard any attacked cookies.</p><p>Enable action_dispatch.use_cookies_with_metadata to use this feature, which writes cookies with the new purpose and expiry metadata embedded.</p><h4>Pass along arguments to underlying GET method in #follow_redirect!</h4><p>It’s possible to pass parameters to the underlying GET request in a follow_redirect! by adding an additional arguments to the method.</p><pre>def create<br>  # do stuff<br>  follow_redirect!(params: { user: params[:user_id] })<br>end</pre><h3>Action View</h3><h4>Add allocations to template rendering instrumentation</h4><p><a href="https://medium.com/u/64e4f5eee153">Aaron Patterson</a> is on an ever-long performance optimization quest and his latest addition is allocations. Rails 6 will report on allocations made in views, which will allow developers be aware of how much time is spent in allocating and garbage collecting objects in the process’ memory.</p><pre>  Rendered posts/_form.html.erb (Duration: 7.1ms | Allocations: 6004)<br>  Rendered posts/new.html.erb within layouts/application (Duration: 8.3ms | Allocations: 6654)<br>Completed 200 OK in 858ms (Views: 848.4ms | ActiveRecord: 0.4ms | Allocations: 1539564)</pre><h3>Active Job</h3><h4>Added enqueue_retry.active_job, retry_stopped.active_job, and discard.active_job instrumentation hooks</h4><p>Rails has a very extensive instrumentation hooks built into Active Support and it spans across the entire framework.</p><p>It allows subscribing on specific events that happen throughout the lifecycle of requests, SQL queries and jobs and report them for example to a Prometheus instance.</p><p>With the addition of enqueue_retry.active_job , retry_stopped.active_job and discard.active_job it is easier to instrument based on jobs’ status.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/477d51c0c75c0134d006d8654bd63fb4/href">https://medium.com/media/477d51c0c75c0134d006d8654bd63fb4/href</a></iframe><h4>Allow passing multiple exceptions to #retry_on and #discard_on</h4><p>It’s now possible to retry on multiple exceptions</p><pre>retry_on Errno::ECONNREFUSED, SocketError, <strong>Timeout::Error</strong>, attempts: 5</pre><h3>Active Model</h3><h4>Allows configurable attribute name for #has_secure_password</h4><p>This still defaults to an attribute named &#39;password&#39;, causing no breaking change. There is a new method #authenticate_XXX where XXX is the configured attribute name, making the existing #authenticate now an alias for this when the attribute is the default &#39;password&#39;.</p><pre>class User &lt; ActiveRecord::Base<br>  has_secure_password :recovery_password, validations: false<br>end</pre><pre>user = User.new()<br>user.recovery_password = &quot;42password&quot;<br>user.recovery_password_digest # =&gt; &quot;$2a$04$iOfhwahFymCs5weB3BNH/uX...&quot;<br>user.authenticate_recovery_password(&#39;42password&#39;) # =&gt; user</pre><h3>Active Storage</h3><h4>Uploaded files assigned to a record are persisted to storage when the record is saved instead of immediately</h4><p>In rails 5.2 files were persisted immediately when assigned</p><pre>@user.avatar = params[:avatar]</pre><p>Rather when @user.save was called, the behavior now is as expected</p><h4>Use the <a href="https://github.com/janko-m/image_processing">ImageProcessing</a> gem for Active Storage variants, and deprecate the MiniMagick backend</h4><p>ImageProcessing support some better macros such as :resize_to_fit, :resize_to_fill and also has built in <a href="https://jcupitt.github.io/libvips/">libvips</a> which is in an alternative to ImageMagick.</p><p>The change is also easily configurable using the usual Rails configuration</p><pre>Rails.application.config.active_storage.variant_processor = :vips</pre><h3>Action Cable</h3><h4>Merge <a href="https://github.com/palkan/action-cable-testing">action-cable-testing</a> into Rails</h4><p>This is a pretty cool addition, it lets us test action cable interactions more easily.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/2f51e9f548460d9bfae516ee7ea5e2ec/href">https://medium.com/media/2f51e9f548460d9bfae516ee7ea5e2ec/href</a></iframe><h4>The ActionCable javascript package has been converted from CoffeeScript to ES2015, and we now publish the source code in the npm distribution</h4><p>I personally prefer ES2015 javascript to Coffeescript so I think it’s great.</p><h3>Action Mailer</h3><h4>Add MailDeliveryJob for delivering both regular and parameterized mail, deprecate using DeliveryJob and Parameterized::DeliveryJob</h4><p>DeliveryJob and Parameterized::DeliveryJob are deprecated in favor of MailDeliveryJob it is used for sending emails outside of the request-response cycle.</p><h3>Action Support</h3><h4>Adds parallel testing to Rails</h4><p>Parallel testing was a little bit hard up until Rails 6 especially in CI systems when you needed isolation between processes and interference with the database. I’ve written some weird database.yml s that rely on an environment variable that creates multiple databases in each of the CI build. Starting Rails 6 that would no longer be necessary as it is possible to just specify in Minitest</p><pre><strong>class</strong> <strong>ActiveSupport::</strong>TestCase<br>  parallelize(workers: 2, with: :processes) # or :threads<br><strong>end</strong></pre><p>or through environment variable PARALLEL_WORKERS and it’ll create the database with a numbered suffix.</p><p>More information is available in <a href="https://medium.com/u/8f91200d4e96">Bogdan</a>’s <a href="https://bogdanvlviv.com/posts/ruby/rails/what-is-new-in-rails-6_0.html#parallel-testing">What Is New In Rails 6.0</a></p><h4>Add support for tracing constant autoloads</h4><p>Tracing constant autoloads is pretty easy now if you’re having trouble with autoloading constants on file changes.</p><p>Create an initializer called autoload_trace.rb and add the following code</p><pre>if Rails.env.development?<br>  ActiveSupport::Dependencies.logger = Rails.logger<br>  ActiveSupport::Dependencies.verbose = true<br>end</pre><h4>Add cpu_time, idle_time, and allocations to ActiveSupport::Notifications::Event</h4><pre>ActiveSupport::Notifications.subscribe(&#39;wait&#39;) do |event|<br>  @event = event<br>end<br><br>ActiveSupport::Notifications.instrument(&#39;wait&#39;) do<br>  sleep 1<br>end<br><br>p @event.allocations # =&gt; 7<br>p @event.cpu_time    # =&gt; 0.256<br>p @event.idle_time   # =&gt; 1003.2399</pre><h3>Zeitwerk</h3><p>Zeitwerk is a new code loader for Ruby. It is efficient, thread-safe, and matches Ruby semantics for constants.</p><p>Given a conventional file structure, Zeitwerk loads your project’s classes and modules on demand meaning you don’t need to write require calls for your own files.</p><p>To enable it in Rails 6, simply set</p><p>config.autoloader = :zeitwerk</p><p>in your environment files.</p><p>More info here: <a href="https://github.com/fxn/zeitwerk">https://github.com/fxn/zeitwerk</a> and here: <a href="https://github.com/rails/rails/pull/35235">https://github.com/rails/rails/pull/35235</a></p><p>Thanks to <a href="https://medium.com/u/396ab91a0ea4">Sean Handley</a> for pointing it out and writing this content about Zeitwerk!</p><h3>General</h3><h4>Rails 6 requires Ruby 2.5.0 or newer</h4><p>In order to upgrade to Rails 6 we must upgrade to Ruby 2.5+, quite obvious.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=8ec79eea66da" width="1" height="1" alt=""><hr><p><a href="https://medium.com/rubyinside/whats-coming-to-rails-6-0-8ec79eea66da">What’s coming to Rails 6.0?</a> was originally published in <a href="https://medium.com/rubyinside">Ruby Inside</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A Weird and Wonderful Trip through Ruby’s Standard Library]]></title>
            <link>https://medium.com/rubyinside/a-weird-and-wonderful-trip-through-rubys-standard-library-762ddcf7a908?source=rss----235b73ea0b2e---4</link>
            <guid isPermaLink="false">https://medium.com/p/762ddcf7a908</guid>
            <category><![CDATA[ruby]]></category>
            <category><![CDATA[programming]]></category>
            <dc:creator><![CDATA[Alex Taylor]]></dc:creator>
            <pubDate>Tue, 22 Jan 2019 10:20:06 GMT</pubDate>
            <atom:updated>2019-01-22T10:20:05.890Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/960/1*7Ofhv1tam2PMBtzB78Mn9A.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><p>You’ve probably heard the news by now — <a href="http://engineering.appfolio.com/appfolio-engineering/2018/11/26/bundler-is-built-into-ruby-260preview3">Bundler is getting merged into Ruby core</a>! It’s great to see that projects like Bundler, which have become so central to the Ruby experience, are becoming part of Ruby in a deep way.</p><p>It also got me thinking: what else is in there? I use Ruby primarily for writing web applications, but Ruby’s rich history as a scripting language means that there’s lots of functionality I don’t use every day, and probably lots that I don’t even know existed.</p><p>So, I decided to find out. I spent some time looking through the <a href="https://ruby-doc.org/stdlib-2.5.3/">standard library documentation</a>, keeping my eyes peeled for things I didn’t recognize. I found some pretty weird and wonderful things, and I wanted to share some of my favourites.</p><p>Ready for some contrived examples? Let’s go!</p><h3>Shellwords</h3><p>First up: the Shellwords module. It provides a few nice methods which make it easier to build and parse shell commands from within Ruby.</p><p>For example: let’s say you have a filename with an apostrophe in it, and you want to use cat to get the contents of the file. (I did say these were contrived, didn’t I? 😉)</p><p>You could do something like this:</p><pre>$&gt; filename = &quot;Alex&#39;s Notes.txt&quot;<br>$&gt; `cat #{filename}`</pre><p>But bash doesn’t like unescaped single quotes, so you end up with an error:</p><pre>sh: -c: line 0: unexpected EOF while looking for matching `&#39;&#39;<br>sh: -c: line 1: syntax error: unexpected end of file<br>=&gt; &quot;&quot;</pre><p>Never fear! #shellescape is here!</p><pre>$&gt; `cat #{filename.shellescape}`<br>=&gt; &quot;Apostrophes in a filename? 🤔&quot;</pre><p>Hurray, your problem is solved! Although you might want to have a chat with whoever put that apostrophe there in the first place…</p><h3>English: for when you want less $$</h3><p>Pop quiz: what does $$ return?</p><p>If your answer is “why, the current process ID, of course!”, then I suppose you can skip this section.</p><p>For the rest of us, Ruby’s $$ is an homage to Perl, and returns the ID of the current system process. But it’s not the most developer-friendly of names, so Ruby’s English module provides some helpful aliases: $PROCESS_ID and $PID.</p><p>This is a pretty small thing, but I think it’s a perfect example of Matz’s original goal with Ruby, which was to create a language that’s understood by humans first and computers second.</p><p>English provides a handful of these aliases. Another useful one is $CHILD_STATUS, which will return the exit code of the last shell command:</p><pre>$&gt; `exit 42`<br>=&gt; &quot;&quot;</pre><pre>$&gt; $CHILD_STATUS   # or $? for the purists<br>=&gt; #&lt;Process::Status: pid 25566 exit 42&gt;</pre><h3>Prime</h3><p>If you require the Prime module, Ruby can tell you if a number is prime:</p><pre>$&gt; 5.prime?<br>=&gt; true</pre><p>Ok, cool.</p><p>But did you know that Ruby has not one, not two, but <em>two-and-a-half*</em> implementations for determining the primality of a number?</p><p>First up, there’s TrialDivision, a brute-force approach which divides the number in question by other smaller numbers until it has a definitive answer.</p><p>There’s also EratosthenesSieve, which as you can probably tell from the name, was invented over 2,000 years ago by a Greek mathematician. Go figure!</p><pre>$&gt; Prime::EratosthenesGenerator.new.take(10)<br>=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</pre><pre>$&gt; Prime.take(10)   # uses Eratosthenes under the hood, by default<br>=&gt; [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</pre><p>*Last, and probably least — this is why there’s only two and a <em>half</em>, after all — we have Generator23. This is a special one, because it doesn’t actually generate prime numbers, but rather numbers which are not divisible by 2 or 3. This is a clever optimization invented by Mathematicians to make validating a prime more memory-efficient. As such, this generator is used by #prime?, along with some additional computations, to check primality.</p><h3>Abbrev</h3><p>This is probably the weirdest and most wonderful module I found in my spelunking. According to the docs, Abbrev:</p><blockquote>Calculates the set of unique abbreviations for a given set of strings.</blockquote><p>Interesting… let’s see it in action:</p><pre>$&gt; require &#39;abbrev&#39;<br>=&gt; true</pre><pre>$&gt; %w(ruby rules).abbrev<br>=&gt; {<br>     &quot;ruby&quot;=&gt;&quot;ruby&quot;,<br>     &quot;rub&quot;=&gt;&quot;ruby&quot;,<br>     &quot;rules&quot;=&gt;&quot;rules&quot;,<br>     &quot;rule&quot;=&gt;&quot;rules&quot;,<br>     &quot;rul&quot;=&gt;&quot;rules&quot;<br>   }</pre><p>Give Abbrev an array of strings, and it will give you a hash where those words become the values, and each key is a way of unambiguously referring to that word. In the example above, since both words start with “ru”, we have to get more specific if we want to refer to one or the other.</p><p>This module is arguably limited in its use cases, but it’s elegant and wonderful nonetheless. I just love that data structure: taking advantage of a hash’s unique keys and having it point back to the original word? 👌👌</p><p>The only uses of Abbrev I can find are in <a href="https://docs.ruby-lang.org/en/2.1.0/RDoc/RI/Driver.html#method-i-expand_class">RDoc,</a> and <a href="https://github.com/ruby/ruby/blob/trunk/tool/redmine-backporter.rb#L578">a miscellaneous script in Ruby core</a>, but I imagine one could put it to good use in things that need command-line autocompletion.</p><p>Or, you could use it to write your very own Unambiguous Nickname Generator!</p><pre>$&gt; names = %w(Alex Amy Ayla Amanda)<br>$&gt; names.abbrev.keys.select { |n| n.length &gt; 2 }</pre><pre>=&gt; [&quot;Alex&quot;, &quot;Ale&quot;, &quot;Amy&quot;, &quot;Ayla&quot;, &quot;Ayl&quot;, &quot;Amanda&quot;, &quot;Amand&quot;, &quot;Aman&quot;, &quot;Ama&quot;]</pre><p>From now on, call me Ale. 🍻</p><h3>Last, but not least…</h3><p>Chances are you’ve made an HTTP request from your Ruby program at some point. You probably used Net::HTTP (or maybe another gem that uses it under the hood).</p><p>But let me ask you this — have you ever <em>checked your e-mail</em> with Ruby?</p><p>🥁 🥁 🥁</p><p>Introducing Net::POP3!</p><p>That’s right, you can check your e-mail without ever leaving IRB:</p><pre>$&gt; inbox = Net::POP3.new(&#39;pop.gmail.com&#39;)<br>=&gt; #&lt;Net::POP3 pop.gmail.com: open=false&gt;</pre><pre>$&gt; inbox.start(&#39;your-email-here@gmail.com&#39;, &#39;supersecret&#39;)<br>=&gt; #&lt;Net::POP3 pop.gmail.com: open=true&gt;</pre><pre>$&gt; inbox.each_mail { |m| puts m.pop.split(&quot;\n&quot;).grep(/Subject/) }<br>Subject: Hello IRB!</pre><pre>$&gt; pop.finish<br>=&gt; &quot;+OK Farewell.&quot;</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/960/1*9OmCiwlDMb-c680nahcjAQ.png" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h3>Conclusion</h3><p>What a ride! I hope I’ve opened your mind to some new possibilities with the language you know and love. I certainly learned a ton, and digging into these weird, dusty corners of Ruby just makes me love it even more. ❤️</p><p>Have you found any other fun Ruby modules, or can you think of another use for Abbrev? Let me know!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=762ddcf7a908" width="1" height="1" alt=""><hr><p><a href="https://medium.com/rubyinside/a-weird-and-wonderful-trip-through-rubys-standard-library-762ddcf7a908">A Weird and Wonderful Trip through Ruby’s Standard Library</a> was originally published in <a href="https://medium.com/rubyinside">Ruby Inside</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[A Modern Web Application With Rails]]></title>
            <link>https://medium.com/rubyinside/a-modern-web-application-with-rails-da3deb48014c?source=rss----235b73ea0b2e---4</link>
            <guid isPermaLink="false">https://medium.com/p/da3deb48014c</guid>
            <category><![CDATA[react-native]]></category>
            <category><![CDATA[rails]]></category>
            <category><![CDATA[webpacker]]></category>
            <category><![CDATA[javascript]]></category>
            <category><![CDATA[react]]></category>
            <dc:creator><![CDATA[Alessandro Rodi]]></dc:creator>
            <pubDate>Tue, 22 Jan 2019 10:14:53 GMT</pubDate>
            <atom:updated>2019-03-24T17:06:18.437Z</atom:updated>
            <content:encoded><![CDATA[<h4>It is time to wrap up some learnings from the last years and give suggestions for the choices to take tomorrow.</h4><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*v5iBj2F5mLwQPpFC2zxzsQ.jpeg" /></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><p>Things changed a lot since Basecamp introduced Rails in 2005, but without even going that far away, things changed a lot even in the last five years.</p><p><strong>In this article, I will not tell you how great is Ruby On Rails, but I’ll give you suggestions on the decisions to take when you will realise your next web application.</strong> The things I propose derive from six years of experience developing RoR applications for <a href="https://www.renuo.ch/en">Renuo</a>. As a Web Agency, we have the advantage to be always on the edge of technologies. Every new project we start (and we have many every year), we can learn from the previous ones and get better, introduce new technologies and try new ways of doing things. This is the reason why the following suggestions are well founded.</p><p>Five years ago we were happy Rails developers. We were ruling the world, and we were teaching everyone how easy and fast was to develop a Web Application.</p><p>It was possible to bring an idea from concept to production in days, instead of months. Our estimates went down from days to hours, and our clients could finally afford to implement their ideas without spending a hundred thousand dollars.</p><p>Then, about five years ago, another revolution started, and having a standard client-server application seemed not to be enough anymore: if you were not joining the SPA (single page application) train, embrace whatever Javascript framework, and split your application in microservices, you were going to be off the market soon.</p><p>Very few voices were speaking out of the choir, and (almost) everyone started this adventure in the world of multi-tier applications. <br>Rails, in the meantime, was not putting a lot of effort trying to keep up with the hype of these technologies. Some concrete things have been implemented during this period, in particular, Turbolinks and API Only mode.</p><p><strong>Turbolinks</strong> was aiming to make our “old-fashioned” client-server application as fast as a Javascript Frontend Application, while <strong>Rails API</strong> was telling everyone “<em>Hey! We are here, and we can perfectly serve data to your frontend applications if you like.</em>”.</p><p>If you didn’t see them, the following are some excellent articles of out-of-the-choir voice:</p><ul><li><a href="https://m.signalvnoise.com/the-majestic-monolith-29166d022228">The Majestic Monolith</a></li><li><a href="https://www.youtube.com/watch?v=Xkjo7iKkQlY">Turbolinks: I can’t believe is not native</a></li><li><a href="https://medium.com/@jmanrubia/escaping-the-spa-rabbit-hole-with-turbolinks-903f942bf52c">Escaping the SPA hole</a></li></ul><h3>What that period left us</h3><p>Very few applications were meant to be developed as a SPA. In the apex of this craziness, I saw very simple CRUDs being developed as multi-tier applications.</p><p>Requirement: <em>“I need two static pages and a page with a list of artists. As an admin, I want to manage these artists by creating, editing and deleting them. They have a name, description and a photo”.</em></p><p>I saw the following:</p><pre>rails new my_new_important_client<br>rails generate scaffold artists name:string description:text<br>git push heroku master</pre><p>turned into months of work! No kidding…the screenshot is real:</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Pdt-SlBHQzhGTcsiXWokmA.png" /><figcaption>Yes, Redmine is simple and efficient.</figcaption></figure><p>Of course, five years later the project does not even build and we lost a lot of money (poor choices should never be on the customer…).</p><h3>A new era: <strong>I am done with this</strong></h3><p>I decided to not struggle anymore with multi-tiers, impossible Docker configurations to run system tests, redefine APIs every time I want to change a comma, move all my components logic to the browser, waiting minutes for my project to compile, define my routes twice and, in the end, hear complaints about SEO performance, wrong redirects and conflicting versions between frontend and backend.</p><p>Starting from tomorrow, in most of the cases, start your project with a pure, latest version, Rails application. Throw Sprockets away and configure <a href="https://github.com/rails/webpacker">Webpacker</a>. That’s it. <strong>Rails -sprockets +webpacker.</strong></p><ul><li>Don’t plan a multi-tier application.</li><li>Don’t plan APIs from the beginning unless you need them for an external app.</li><li>Most important: don’t split your application in separate apps.</li></ul><p><strong>Keep everything in a Monolith and embrace it.</strong></p><ul><li>Keep your application clean by making it modular</li><li>Use service objects to wrap your logic into simple Ruby objects</li><li>Choose the best frontend framework for your needs.</li></ul><p>In the next sections, I will cover some of the decisions you have to take when starting the development of a new application and tell you what I would choose.</p><h3>Shall I use a frontend framework?</h3><p>It doesn’t matter. Wrong question. Setup Webpacker. <br>There is absolutely nothing that Sprockets does, that Webpacker cannot do, but there are tons of features that Webpacker has and Sprockets is missing. And let me immediately answer your question: <em>“I just need some lines of Javascript, why should I setup Webpacker?”</em>. <strong>Because is the right tool for the right job.</strong> It does not add complexity. It does not add any overhead. It will be basically invisible for you.</p><p>I wrote already some articles on how to <a href="https://medium.com/@coorasse/goodbye-sprockets-welcome-webpacker-3-0-ff877fb8fa79">migrate to Webpacker from Sprockets</a>, or how to use some of the <a href="https://medium.com/@coorasse/react-hot-reload-in-ruby-on-rails-5d534db665d">cool features it offers</a>, and more will come.</p><p><strong>Stop using JS libraries wrapped in always out-of-date gems: is wrong.</strong></p><p>Webpacker allows you to go with plain and simple Javascript (default) or configure the framework that best fits your needs (React, Vue or Angular). <strong>Zero configuration. It just works.</strong></p><p>When you will go live, as it was for Sprockets, everything will be compiled and packed properly and will be deployed in your public folder.</p><p>And now, you have access to the full library of NPM packages.</p><h3>We don’t want two applications</h3><p>Let’s state this clearly: <strong>having two applications costs more</strong>. And is not double: is much more. Please look at this very sophisticated graph where I put in relation the number of apps you have to maintain with the costs to develop a new feature.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/600/1*W_u2nGkeeP0F7c6ta9mvkw.png" /></figure><p>These are the numbers I usually keep in mind: in a monolith, to realise a feature, you spend 1&#39;000$. With two layers, you will need 4&#39;000$. If you have a Backend, a Vue frontend and an Android app, you will need 9&#39;000$.</p><p>To realise a CRUD with Rails will take you about one hour. If you have a Rails Backend and a separate Angular app, once you define and implement the APIs, document and test them, implement the pages, routes and logics in Angular and deploy everything, you spent already more than four hours. It is a fact and there is nothing wrong with it. <strong>You are simply using the wrong tool for the job.</strong></p><p>Even if your client is a millionaire, this does not allow you to charge him more for something extremely simple and that can be obtained in much less time.</p><p>By not splitting your application, you will be able to code everything in one place and make changes to both Backend and Frontend in one place, open a single Pull Request, and keep your code consistent at any time.</p><h3>Frontend development</h3><p>The development of your frontend has never been so easy. Thanks to <a href="https://medium.com/rubyinside/hot-module-reloading-with-webpacker-b663643a60b1">Hot module reloading</a>, your frontend development is going to be a breath. That’s one of the advantages of using Webpacker I was talking before. Take into consideration, right from the beginning, to realise your application responsive. And not only responsive but with mobile first in mind. Take any CSS framework you prefer and that will help you to quickly build your frontend components. We often use Bootstrap, but when you use Angular or React you may opt for other solutions. Nowadays having an app realised with mobile-first in mind, has never been so important: the reason is that in order to avoid developing a second application for Android and IOS, you should definitely realise a PWA. By doing so, your mobile version of the app will be installable in most devices (without going through the app store!) and will provide a pretty good experience to your users.</p><p>If you want to release your application in the Play Store or App Store, you may take a look at <a href="https://github.com/turbolinks">Turbolinks adapters</a> (<a href="https://github.com/turbolinks/turbolinks-android/wiki/Turbolinks-Android-Adapter-1.x-Deprecation">android is deprecated at the time of writing</a>).</p><p>None of these solutions will give your app the look and feel of a native application. If your client wants a Native App, none of the ones proposed above is a viable solution. But your client needs also to be aware of the costs of a native application. If he wants both a Web and a Native App, it will cost, and this must be clear from the beginning.</p><p>Talking about framework choice, at the moment we tend to use one of the followings, depending on the needs:</p><ul><li><strong>StimulusJS</strong>: perfect for applications with just a little bit of Javascript. No complex behaviours or components needed.</li><li><strong>ReactJS</strong>: when some more complex components are needed, and we want some more fancy user interactions, we use React. React is our choice because we can also share the code, in the future, with a Native App, that we usually code using ReactNative.</li><li><strong>Angular:</strong> this is the framework we adopt when the client needs a SPA.</li></ul><h3>Native applications</h3><p>We never use Rails API mode. The reason is simply that at some point (usually very early), the client will need some administrator interface. Even without the API Only mode you can still extend <strong>ActionController</strong>::<strong>API </strong>instead of <strong>ActionController</strong>::<strong>Base </strong>and you will be able to realise a simple web page to advertise the product online.</p><p>For what concerns the APIs we usually proceed directly with <a href="https://jsonapi.org/">JsonAPI Standard</a>. Using a standard will save you an incredible amount of time. APIs are one of those topics where your team will be able to spend hours and hours in infinite discussions on how they should look and behave. Well, good news: someone already discussed that for you. Go with the standard and stick to it. A <a href="https://github.com/Netflix/fast_jsonapi">wonderful gem</a>, developed by Netflix, allows you to quickly build all your endpoints and expose JsonAPI compliant APIs. Another (not so wonderful) <a href="https://github.com/Netflix/restful-jsonapi">gem</a> allows you to read the same format. On the Frontend, you have a <a href="https://jsonapi.org/implementations/#client-libraries-javascript">vast choice</a> of libraries to work with the same standard.</p><h3>System Tests</h3><p>One of the biggest advantages of this approach is the possibility to use Rails built-it System Tests to perform high-level end to end tests on your application. Since you have the two layers packed together, you can use Capybara to navigate your Angular frontend and use Ruby to write your tests, without the need of any other Test Framework. Writing e2e tests for an application composed of a backend and a frontend, communicating through APIs was really frustrating. Our approach was to use orchestrated Docker instances connected to each other, and a third Docker container where the tests were running. This container was taking care of many pain-points: resetting the state between each test, cleaning the database of the Backend application, seeding the database for each test, waiting and synchronising the different components and, finally, running the tests. This solution allowed us to have proper, isolated, e2e tests. Of course, <strong>we had to pay a big price in terms of time</strong> to realise it and make it running on a CI.</p><p><strong>Not anymore. </strong>Today I wrap my layers in one, single, monolith and enjoy the simplicity of <a href="https://guides.rubyonrails.org/testing.html#implementing-a-system-test">Rails System tests</a>. They allow me to have isolated, fully independent, tests. Entirely wrapped in a single transaction to speed up the cleaning and seeding process of each test. Capybara offers me a clean syntax to interact with my Frontend and it’s perfectly designed to work also with Frontend frameworks like React or Angular. No need to manually synchronise or wait for components to be rendered in the Browser. Capybara will take care of it for me. Finally, the possibility to connect to different engines gives me full flexibility to test <strong>entirely </strong>my app on many different scenarios/browsers/ screen resolutions. Parallel tests are also coming to Rails 6, native in the framework. I couldn’t ask for more.</p><p><strong>Zero configuration. Nothing to “re-invent”. It just works.</strong></p><h3>The power of Javascript</h3><p>I’d like to focus again on an important point: I am not saying <em>“don’t use Javascript frameworks”. </em>What I am saying is to <strong>wait until you need one</strong> and pack it together with Rails using Webpacker. A JS framework will probably allow you to have a faster user interaction and decrease the loading time for some pages. Rails is known for not being the fastest framework, but pre-optimization is the source of all evil. There are many tools built-in in Rails that you should use to make your life easier, like Turbolinks. Turbolinks comes as an NPM package as well, so you can perfectly use it in combination with the other libraries you will decide to integrate. It will make your navigation between pages faster and will integrate perfectly with React or Stimulus when you will decide to use them. <strong>Don’t rush for performance on day zero. </strong>Wait until you have a working product and improve it step-by-step. This is also the reason why you should start by using just Javascript and ignore Coffescript, Typescript, Dart, or Flow. You will get there when (and if) you need them. Use ECMAScript6</p><h3>Take Home Message</h3><p>There are more tools today than ever to develop a Web Application. And today, more than ever, is easy to get off the rails during the development of a project. As a Web Agency, we need to keep trying new technologies and keep high our level of criticism over them. We use side or smaller projects to try out new stuff, and use well established and stable technologies for our clients. We learn from our mistakes and believe that today, Ruby On Rails is the best way to go for a new Web Applications. <strong>It allows our clients to jump straight into the market and test their ideas.</strong> It allows us to develop in an Agile way and approach improvements step by step. Webpacker was the missing piece to use all the power of newest Javascript frameworks without the struggle and costs of managing two different applications. You can do the same and convince your clients that less is better, that they do not need to be on the edge of technologies at all costs because they have to focus on selling the product. Once your product works, you will have all the time and money to refine it and improve it further with the certainty of a stable framework behind, that runs applications used by millions of users every day as GitHub or AirBnB.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=da3deb48014c" width="1" height="1" alt=""><hr><p><a href="https://medium.com/rubyinside/a-modern-web-application-with-rails-da3deb48014c">A Modern Web Application With Rails</a> was originally published in <a href="https://medium.com/rubyinside">Ruby Inside</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Top Ruby Weekly links of 2018]]></title>
            <link>https://medium.com/rubyinside/the-top-ruby-weekly-links-of-2018-4b1dc99bd171?source=rss----235b73ea0b2e---4</link>
            <guid isPermaLink="false">https://medium.com/p/4b1dc99bd171</guid>
            <category><![CDATA[ruby]]></category>
            <category><![CDATA[performance]]></category>
            <category><![CDATA[serverless]]></category>
            <category><![CDATA[pattern-matching]]></category>
            <category><![CDATA[ruby-on-rails]]></category>
            <dc:creator><![CDATA[Chris Brandrick]]></dc:creator>
            <pubDate>Mon, 24 Dec 2018 21:29:49 GMT</pubDate>
            <atom:updated>2018-12-24T21:44:38.800Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*U7BPimsPuh6rs902Nf73sQ.jpeg" /></figure><p>We’re closing out the year by looking back at some of the biggest developments from across the Ruby landscape.</p><p>Here’s <strong>what Ruby devs clicked on in 2018</strong>, based on data from <a href="https://rubyweekly.com/?utm_source=medium&amp;utm_campaign=roundup&amp;utm_content=ruby2018">the Ruby Weekly newsletter</a>. <em>You can also see </em><a href="https://rubyweekly.com/issues/430"><em>our email roundup of 2018 right here</em></a><em>.</em></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*U9-mKbyj1UuSP15zYVvaVw.png" /></figure><h4><a href="https://weblog.rubyonrails.org/2018/10/3/introducing-action-text-for-rails-6/">Introducing Action Text for Rails 6</a></h4><p><a href="https://medium.com/u/54bcbf647830">DHH</a> | <a href="https://rubyweekly.com/issues/419">Shared in October’s Issue 419</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*5gmb5YBbQ94xytkK.jpg" /></figure><p>The most popular link in 2018 was about <em>Action Text</em>, a new framework coming to Rails 6 to make it easier to edit and display rich text content. It leans upon Basecamp’s <a href="https://rubyweekly.com/link/57033/web">Trix editor</a> and DHH recorded <a href="https://rubyweekly.com/link/57034/web">a screencast showing how it works</a>.</p><blockquote><a href="https://weblog.rubyonrails.org/2018/10/3/introducing-action-text-for-rails-6/"><em>weblog.rubyonrails.org</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="https://medium.com/openwhisk/ruby-goes-serverless-apache-openwhisk-adds-native-support-for-ruby-7134faee14e">A Future for Serverless Ruby?</a></h4><p><a href="https://medium.com/u/85c252cbfcde">Justin Halsall</a>| <a href="https://rubyweekly.com/issues/417">Shared in Issue 417</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/0*KJRpobJ0Aojwg8wD.jpg" /></figure><p>Ruby has been a long overlooked language when it comes to serverless but OpenWhisk, an open source serverless system, added native support earlier this year.</p><blockquote><a href="https://medium.com/openwhisk/ruby-goes-serverless-apache-openwhisk-adds-native-support-for-ruby-7134faee14e"><em>medium.com/openwhisk</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="https://github.com/learnbyexample/Command-line-text-processing/blob/master/ruby_one_liners.md">An Epic Collection of Ruby One-Liners</a></h4><p>Sundeep Agarwal | <a href="https://rubyweekly.com/issues/389">Shared in Issue 389</a></p><p>Ruby isn’t just for building webapps, y’know. It’s an amazing Swiss army knife for anyone at the command line and these examples could help you out with a lot of menial tasks.</p><blockquote><a href="https://github.com/learnbyexample/Command-line-text-processing/blob/master/ruby_one_liners.md"><em>github.com/learnbyexample</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="https://rollbar.com/blog/top-10-ruby-on-rails-errors/">Top 10 errors from 1,000+ Ruby on Rails projects (and how to avoid them)</a></h4><p><a href="https://medium.com/u/a18f3371f68c">Phil Nash</a>| <a href="https://rubyweekly.com/issues/396">Shared in Issue 396</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/864/0*x8CD1HjHSjE0V6_r.png" /></figure><p>Analysis of the ten most common errors from over 1,000 Rails projects monitored by Rollbar, along with advice on avoiding such errors yourself.</p><blockquote><a href="https://rollbar.com/blog/top-10-ruby-on-rails-errors/"><em>rollbar.com/blog</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="https://bugs.ruby-lang.org/issues/14709">Bringing Proper Pattern Matching to Ruby</a></h4><p>Victor Shepelev| <a href="https://rubyweekly.com/issues/396">Shared in Issue 396</a></p><p>Ruby Weekly readers are clearly interested in Ruby continuing to add new features as the second most popular link this year followed a <a href="https://rubykaigi.org/2017/presentations/yotii23.html">presentation at RubyKaigi</a>, proposing a way to add pattern matching to Ruby.</p><p><a href="https://bugs.ruby-lang.org/issues/14709#note-9">Matz’s conclusion</a> was that he liked the <em>idea</em> but not the syntax and further suggestions are sought.</p><blockquote><a href="https://bugs.ruby-lang.org/issues/14709"><em>bugs.ruby-lang.org</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="https://www.ruby-lang.org/en/news/2017/12/25/ruby-2-5-0-released/">Ruby 2.5 Released: A Faster Step Forward</a></h4><p>Yui Naruse | <a href="https://rubyweekly.com/issues/381">Shared in January’s Issue 381</a></p><p>With Ruby 2.6 just around the corner, it’s no surprise to see the Ruby 2.5 release make our list. We shared the release details back in our January 2018 issue.</p><p>Version 2.5 was 5–10% faster than 2.4, hashes get new <a href="https://rubyweekly.com/link/34762/web">transform_keys</a> and slice methods, ERB was twice as fast, and more.</p><blockquote><a href="https://www.ruby-lang.org/en/news/2017/12/25/ruby-2-5-0-released/"><em>ruby-lang.org</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="https://bogdanvlviv.com/posts/ruby/rails/what-is-new-in-rails-6_0.html">What’s New in Rails 6.0</a></h4><p><a href="https://medium.com/u/8f91200d4e96">Bogdan</a> | <a href="https://rubyweekly.com/issues/420">Shared in Issue 420</a></p><p>Rails 6 isn’t out just yet, but this page links to a variety of interesting pull requests and commits related to the next major version of Rails.</p><blockquote><a href="https://bogdanvlviv.com/posts/ruby/rails/what-is-new-in-rails-6_0.html"><em>bogdanvlviv.com</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="http://engineering.appfolio.com/appfolio-engineering/2018/2/4/how-fast-is-ruby-250">How Fast is Ruby 2.5?</a></h4><p>Noah Gibbs| <a href="https://rubyweekly.com/issues/385">Shared in Issue 385</a></p><p>2018 was the year of Ruby 2.5 and it’s been one of the most stable and impressive major Ruby releases I can remember while offering relatively modest performance improvements.</p><blockquote><a href="http://engineering.appfolio.com/appfolio-engineering/2018/2/4/how-fast-is-ruby-250"><em>engineering.appfolio.com</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="https://saveriomiroddi.github.io/An-overview-of-ruby-gui-development-in-2018/">An Overview of Ruby GUI Development in 2018</a></h4><p>Saverio Miroddi | <a href="https://rubyweekly.com/issues/390">Shared in Issue 390</a></p><p>It’s not often written about but building graphical apps in Ruby <em>is</em> a thing, and here’s a comparison of the most popular approaches.</p><blockquote><a href="https://saveriomiroddi.github.io/An-overview-of-ruby-gui-development-in-2018/"><em>saveriomiroddi.github.io</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="http://tenderlovemaking.com/2018/02/12/speeding-up-ruby-with-shared-strings.html">Speeding Up Ruby with Shared Strings</a></h4><p><a href="https://medium.com/u/64e4f5eee153">Aaron Patterson</a> | <a href="https://rubyweekly.com/issues/386">Shared in Issue 386</a></p><figure><img alt="" src="https://cdn-images-1.medium.com/max/360/0*Gu6Xt10ter7D5b9e.png" /></figure><p>An in-depth explanation of a patch to Ruby that both reduces memory and speeds up performance (with require going 35% faster).</p><blockquote><a href="http://tenderlovemaking.com/2018/02/12/speeding-up-ruby-with-shared-strings.html"><em>tenderlovemaking.com</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="https://www.mikeperham.com/2018/02/28/ruby-optimization-with-one-magic-comment/">Ruby Optimization with One Magic Comment</a></h4><p><a href="https://medium.com/u/af70e27c4c08">Mike Perham</a> | <a href="https://rubyweekly.com/issues/388">Shared in Issue 388</a></p><p>Back in March, Mike Perham of Sidekiq fame explained how freezing your strings can help performance quite a bit and how Ruby 2.3+ can help make this easier.</p><blockquote><a href="https://www.mikeperham.com/2018/02/28/ruby-optimization-with-one-magic-comment/"><em>mikeperham.com</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4><a href="https://www.monterail.com/blog/actionable-tips-to-improve-web-performance-with-rails">Actionable Tips to Improve Web Performance with Rails</a></h4><p>Radek Markiewicz | <a href="https://rubyweekly.com/issues/400">Shared in Issue 400</a></p><p>Based on a talk from Wroclove.rb, the tools and tricks listed here will result in better Rails and general Web performance.</p><blockquote><a href="https://www.monterail.com/blog/actionable-tips-to-improve-web-performance-with-rails"><em>monterail.com</em></a></blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*U9-mKbyj1UuSP15zYVvaVw.png" /></figure><p><strong>Thanks for taking a look back with us</strong>. 👏</p><blockquote>Want more like this? <a href="https://rubyweekly.com/?utm_source=medium&amp;utm_campaign=roundup&amp;utm_content=ruby2018">Subscribe to the Ruby Weekly newsletter</a>.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=4b1dc99bd171" width="1" height="1" alt=""><hr><p><a href="https://medium.com/rubyinside/the-top-ruby-weekly-links-of-2018-4b1dc99bd171">The Top Ruby Weekly links of 2018</a> was originally published in <a href="https://medium.com/rubyinside">Ruby Inside</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Disassembling Rails — Template Rendering (2)]]></title>
            <link>https://medium.com/rubyinside/disassembling-rails-template-rendering-2-a99214c6fde8?source=rss----235b73ea0b2e---4</link>
            <guid isPermaLink="false">https://medium.com/p/a99214c6fde8</guid>
            <category><![CDATA[disassembling-rails]]></category>
            <category><![CDATA[ruby-on-rails]]></category>
            <category><![CDATA[rails]]></category>
            <dc:creator><![CDATA[Stan Lo]]></dc:creator>
            <pubDate>Tue, 18 Dec 2018 10:08:22 GMT</pubDate>
            <atom:updated>2018-12-19T04:39:05.249Z</atom:updated>
            <cc:license>https://creativecommons.org/publicdomain/mark/1.0/</cc:license>
            <content:encoded><![CDATA[<h3>Disassembling Rails — Template Rendering (2)</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*OkfaE1rHye6sKD-SRNQznQ.jpeg" /></figure><p>This is the second part of <a href="https://medium.com/rubyinside/disassembling-rails-template-rendering-1-51795f579577">Disassembling Rails — Template Rendering</a> <em>(it’s about half a year ago, sorry!)</em>. In this post, I’m going to explain<strong> how does Rails renders your templates from Ruby objects</strong>.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4>File to checkout</h4><pre>- actionview/lib/action_view/renderer/template_renderer.rb<br>- actionview/lib/action_view/template.rb</pre><h4>Recall the previous step</h4><p>At the end of the last post, I showed you that Rails will read your template files and initialize template objects using them.</p><pre># actionview/lib/action_view/template/resolver.rb<br><br>def query(path, details, formats, outside_app_allowed)<br>  query = build_query(path, details)<br><br>  template_paths = find_template_paths(query)<br>  ......<br>  template_paths.map do |template|<br>    ......    <br>    contents = File.binread(template)<br><br>    Template.new(contents, File.expand_path(template), handler,<br>      virtual_path: path.virtual,<br>      format: format,<br>      variant: variant,<br>      updated_at: mtime(template)<br>    )<br>  end<br>end</pre><h4>How does Rails use the template object?</h4><p>After ActionView::TemplateRenderer found the template, it’ll call #render_template and pass the template object as an argument. Also notice that it passes the layout and locals as well, and they are extracted from the options.</p><pre># actionview/lib/action_view/renderer/template_renderer.rb<br><br>module ActionView<br>  class TemplateRenderer &lt; AbstractRenderer #:nodoc:<br>    def render(context, options)<br>      ……<br>      # Found your template<br>      template = determine_template(options)<br>      ……<br>      render_template(template, options[:layout], options[:locals])<br>    end<br>  end<br>end</pre><p>And then this is #render_template</p><pre>def render_template(template, layout_name = nil, locals = nil)<br>  .....<br><br>  render_with_layout(layout_name, locals) do |layout|<br>    # instrumenting block<br>      template.render(view, locals) { |*name| view._layout_for(*name) }<br>    # end<br>  end<br>end</pre><p>You can see that the actual rendering is wrapped with render_with_layout block. I&#39;m going to skip this part today though, there will be another post to explain the layout rendering.</p><h4>Template#render</h4><p>Template#render does its job in two steps: compile the template&#39;s content into a method (yes, a ruby method), and call that method. Simple enough, right?</p><pre>def render(view, locals, buffer = nil, &amp;block)<br>  ......<br>  compile!(view)<br>  view.send(method_name, locals, buffer, &amp;block)<br>end</pre><h4>What does <strong>compile</strong> mean?</h4><p>It means that Rails will define a method on ActionView::Base (more correctly, ActionView::CompiledTemplates) and that method will take locals and return a string. Let me explain it with examples: assume we want to render a say_hi template that takes one local:</p><pre># say_hi.erb<br>Hi &lt;%= name %&gt;</pre><p>And after it’s compiled to a method, it’ll be something like this to Rails:</p><pre>def say_hi(local_assigns)<br>  name = local_assigns[:name]<br>  “Hi #{name}”<br>end<br><br>view.say_hi(name: &quot;Stan&quot;)<br>#=&gt; Hi Stan</pre><p>So how does it do that? Well, Rails takes full advantage to Ruby’s meta-programming support. Especially the module_eval method. This is how it&#39;s done:</p><pre>require &quot;erb&quot;<br># let&#39;s pretend it&#39;s ActionView::Base<br>class View<br>end<br><br>class Template<br>  def initialize(name, content)<br>    @name = name<br>    @content = content<br>  end<br> <br>  def render(view)<br>    compile(view)<br>    view.send(@name)<br>  end<br>  <br>  def compile(view)<br>    # we only need to compile it once<br>    return if @compiled<br>    # use erb as template engine<br>    body = ERB.new(@content).src<br>    src = &lt;&lt;-end_src<br>      def #{@name}<br>        #{body}<br>      end<br>    end_src<br>    <br>    view.singleton_class.module_eval(src)<br><br>      @compiled = true<br>  end<br>end<br><br>view = View.new<br>template = Template.new(&quot;say_hi&quot;, &quot;Hi!&quot;)<br>template.render(view) #=&gt; Hi!<br>view.methods.first #=&gt; :say_hi</pre><p>But how about the locals? How can we pass locals dynamically if Rails only defines one method once for every template? To me, that’s the most brilliant part of this design. Let us update the code a little bit:</p><pre>require &quot;erb&quot;<br><br>class View<br>end<br><br>class Template<br>  def initialize(name, content, locals)<br>    @name = name<br>    @content = content<br>    @locals = locals<br>  end<br> <br>  def render(view, local_assigns)<br>    compile(view)<br>    view.send(@name, local_assigns)<br>  end<br>  <br>  def compile(view)<br>    return if @compiled<br>    body = ERB.new(@content).src<br><br>    src = &lt;&lt;-end_src<br>      def #{@name}(local_assigns)<br>        #{locals_code}<br>        #{body}<br>      end<br>    end_src<br>    <br>    view.singleton_class.module_eval(src)<br><br>      @compiled = true<br>  end<br><br>  def locals_code<br>    @locals.map do |local|<br>      &quot;#{local} = local_assigns[:#{local}]&quot;<br>    end.join(&quot;\n&quot;)<br>  end<br>end<br><br>view = View.new<br>template = Template.new(&quot;say_hi&quot;, &quot;Hi! &lt;%= name %&gt;&quot;, [:name])<br>template.render(view, name: &quot;Stan&quot;) #=&gt; Hi! Stan</pre><p>In our example, the full definition of say_hi method will be:<br> ``<br> def say_hi(local_assigns)<br> # generated bylocals_code`<br> name = local_assigns[:name]</p><p># belows are generated by ERB, and expanded for readibility<br> _erbout = +’’<br> _erbout.&lt;&lt; “Hi! “.freeze<br> erbout.&lt;&lt;(( name ).tos)<br> _erbout<br> end<br> ```</p><p>Isn’t it clever? I was impressed when I first read this implementation. And it’s been around for a decade!</p><p>Of course, the actual #compile method is far more complicated for handling different cases, we can <a href="https://github.com/rails/rails/blob/5-2-stable/actionview/lib/action_view/template.rb#L281">check it here</a> if you&#39;re interested.</p><p>BTW, you can check this mechanism in Rails console by yourself.</p><pre># remember to rename the `posts` snd `posts/index` to what you really have in your app</pre><pre>paths = ActionController::Base.view_paths<br>view = ActionView::Base.new(paths)<br><br># we don&#39;t have the compiled method yet<br>view.methods.grep(/posts/) #=&gt; []<br><br># this render is from action_view/helpers/rendering_helper.rb, remember?<br>view.render(template: &quot;posts/index&quot;)<br><br># we have it now!<br>view.methods.grep(/posts/) #=&gt; [:_app_views_posts_index_html_erb___4416254959938662165_70267190542480]</pre><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h4>Summary</h4><p>To me, ActionView is a beautifully designed library. It finds and renders templates elegantly. And the fundamental design is barely changed in the past 10 years and doesn&#39;t really have any serious issue! I&#39;ve learned a lot of stuff from reading its codebase, how you can find some time to dig into it as well, it&#39;s a great investment :-)</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=a99214c6fde8" width="1" height="1" alt=""><hr><p><a href="https://medium.com/rubyinside/disassembling-rails-template-rendering-2-a99214c6fde8">Disassembling Rails — Template Rendering (2)</a> was originally published in <a href="https://medium.com/rubyinside">Ruby Inside</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Destructuring in Ruby]]></title>
            <link>https://medium.com/rubyinside/destructuring-in-ruby-9e9bd2be0360?source=rss----235b73ea0b2e---4</link>
            <guid isPermaLink="false">https://medium.com/p/9e9bd2be0360</guid>
            <category><![CDATA[functional-programming]]></category>
            <category><![CDATA[ruby]]></category>
            <dc:creator><![CDATA[Brandon Weaver]]></dc:creator>
            <pubDate>Thu, 25 Oct 2018 21:47:57 GMT</pubDate>
            <atom:updated>2018-10-25T21:47:57.178Z</atom:updated>
            <content:encoded><![CDATA[<h3>Destructuring Methods in Ruby</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*vt-7HRcdFyrr_UAXIn8YhA.png" /><figcaption>It’s blocks all the way down!</figcaption></figure><p>What if I told you there was a way to do this in Ruby?:</p><pre>destructure def adds(a: 1, b: 2)<br>  a + b<br>end</pre><pre>adds(a: 1, b: 2)<br># =&gt; 3</pre><pre>adds(OpenStruct.new(a: 1, b: 2))<br># =&gt; 3</pre><pre>Foo = Struct.new(:a, :b)</pre><pre>adds(Foo.new(1,2))<br># =&gt; 3</pre><p>Well there is, and it’s quite the trip down the ol’ black magic rabbit hole. Shall we take a look?</p><h3>Destructure</h3><p>Here’s the code in its entirety we’re looking at today:</p><pre>def destructure(method_name)<br>  meta_klass  = class &lt;&lt; self; self end<br>  method_proc = method(method_name)</pre><pre>  unless method_proc.parameters.all? { |t, _| t == :key }<br>    raise &quot;Only works with keyword arguments&quot;<br>  end</pre><pre>  arguments = method_proc.parameters.map(&amp;:last)</pre><pre>  destructure_proc = -&gt; object {<br>    values = if object.is_a?(Hash)<br>      object<br>    else<br>      arguments.map { |a| [a, object.public_send(a)] }.to_h<br>    end</pre><pre>    method_proc.call(values)<br>  }</pre><pre>  meta_klass.send(:define_method, method_name, destructure_proc)</pre><pre>  method_name<br>end</pre><p>Now I purposely left comments out of this one, unlike the earlier tweet where I initially mentioned this (SPOILERS):</p><h3>Brandon Weaver on Twitter</h3><p>I really enjoy destructuring, so much in fact that I found a way to make Ruby do it too!</p><p>Now what in the world is that actually doing? Let’s step through it!</p><h3>Definition of a Method</h3><p>The first trick involved actually defining the method, as seen in the first part of the article:</p><pre>destructure def adds(a: 1, b: 2)<br>  a + b<br>end</pre><p>In newer versions of Ruby, the defining of a method returns the method name as a Symbol:</p><pre>def foo; end<br>=&gt; :foo</pre><p>destructure is merely a method which takes in a Symbol:</p><pre>def destructure(method_name)</pre><p>But what exactly it’s doing with that name, now that’s another matter entirely.</p><h3>Meta Klass</h3><p>So if we wanted to overwrite a method dynamically in Ruby in place, how would we go about doing it? How about creating a meta reference to the class?:</p><pre>meta_klass  = class &lt;&lt; self; self end</pre><p>This allows us to, at the end of the method, redefine the given method with a totally new body:</p><pre>meta_klass.send(:define_method, method_name, destructure_proc)</pre><p>How do we get the original method’s body though?</p><h3>The Method method</h3><p>Ruby comes with a method called quite literally method for converting a symbol representing a method name into a proc:</p><pre>def add(a, b) a + b end<br>=&gt; :add</pre><pre>method(:add)<br>=&gt; #&lt;Method: Object#add&gt;</pre><pre>method(:add).call(1, 2)<br>=&gt; 3</pre><p>That means we can make a reference to what the method used to do that we can call whenever we want. Sometimes if I’m in a particularly block-averse mood I may even do something like this:</p><pre>`curl json_source.com/users.json`.yield_self(&amp;JSON.method(:parse))</pre><p>Not that I advocate that, no no no, just that it does have some use in enabling my particularly hacky REPL Ruby habits which should never see the light of production, amen.</p><p>That’s great and all, but how do we know about the arguments?</p><h3>Parameters!</h3><p>Procs and Proc-like objects have this nifty little method called parameters :</p><pre>-&gt; a, *b, c: 1, **d, &amp;fn {}.parameters<br>=&gt; [[:req, :a], [:rest, :b], [:key, :c], [:keyrest, :d], [:block, :fn]]</pre><p>Each value is an array of type, name . That name? Oh that’s where we can have some fun. First though, we want to only do this with keyword arguments for now:</p><pre>unless method_proc.parameters.all? { |t, _| t == :key }<br>  raise &quot;Only works with keyword arguments&quot;<br>end</pre><p>It unfortunately won’t tell us the default values of said parameters, but I would love it forever if we could do something like this later (name pending):</p><pre>-&gt; a: 1 {}.default_values<br>=&gt; [[:a, 1]]</pre><p>Mostly because I can imagine what one could do with that if nested hashes were a thing, but I digress. What about the arguments? Let’s save them for later:</p><pre>arguments = method_proc.parameters.map(&amp;:last)</pre><p>Now we’ll have an array of all the original method’s argument names as Symbols. Why is that useful? Well what does send take? Oh yes.</p><h3>Ze Wrap</h3><p>Next up we have our new method body, which we define as a lambda which takes in a single object as an argument:</p><pre>destructure_proc = -&gt; object { ... }</pre><p>Why one? Won’t that wreck keyword params? Na, Ruby is clever like that, try this:</p><pre>puts a: 1<br>{:a=&gt;1}</pre><p>With methods Ruby can imply that it’s a hash, and keywords work much the same way, which brings us to the next bit of fun:</p><h3>Hashing things out</h3><p>We’re setting values equal to the result of a conditional:</p><pre>values = if object.is_a?(Hash)<br>  object<br>else<br>  ...<br>end</pre><p>We won’t worry about that second branch quite yet. The first one, however, is saying that if what we got in was a Hash (keywords or a literal hash) we probably are calling the method as Matz intended:</p><pre>adds(a: 1, b: 2)</pre><pre># or<br>adds({a: 1, b: 2})</pre><p>So simply put it requires no destructuring because Ruby will do that automatically for us.</p><p>Well what about the other side? Not so much, we have to explain a bit to Ruby.</p><h3>Mappy Map Map</h3><p>Remember that our arguments for adds were an array, [:a, :b]. If we were to pass something like an OpenStruct to that:</p><pre>data = OpenStruct.new(a: 1, b: 2)</pre><p>we could call a or b on it to get out those values:</p><pre>data.a # =&gt; 1<br>data.b # =&gt; 2</pre><blockquote>Noted that OpenStruct can act like a Hash, but not the point of this segment.</blockquote><p>So if we have an array of methods we want to call on it, we could just use map to pull them out!</p><pre>[:a, :b].map { |method_name| data.public_send(method_name) }</pre><p>But in this case, we need to get our data into a Hash of some sorts so Ruby knows how to parse it as a keywords list, giving us our else branch:</p><pre>values = if object.is_a?(Hash)<br>  ...<br>else<br>  arguments.map { |a| [a, object.public_send(a)] }.to_h<br>end</pre><p>We’re extracting the value, and giving it a label for the keyword, leaving us with:</p><pre>{ a: 1, b: 2 }</pre><h3>Your Call!</h3><p>Now that we have those values extracted, we can call the original method with whatever we pulled out! That means if we gave anything like a Hash, we’re calling it with a Hash, and if not we make it into one.</p><pre>method_proc.call(values)</pre><p>…and that gives us our return value.</p><h3>Housekeeping Items</h3><p>Notedly the first version just used the meta_klass.send at the very end. If we’re being nice we could return the same method name to allow for even more chaining fun.</p><p>If you check out the tweet above you’ll find a thread which references a fully commented Gist of the code as well.</p><h3>Would you use this in actual code?</h3><p>Y’see, that’s always the nit. It’s fun but when would we <em>ever </em>use things like this in actual code?</p><p>When it’s well tested, commented, documented, and becomes an understood idiom of your code base.</p><p>We focus so much on black magic and avoiding it that we rarely have a chance to enjoy any of the benefits. When used responsibly and when necessary, it gives a lot of power and expressiveness.</p><p>When used poorly? Well that can get sketchy right quick.</p><p>Discretion is the name of the game.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h3>Wrapping Up</h3><p>This has been another fun adventure in me doing interesting things to Ruby because it can be done. I hope you’ve enjoyed this fun little dive!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=9e9bd2be0360" width="1" height="1" alt=""><hr><p><a href="https://medium.com/rubyinside/destructuring-in-ruby-9e9bd2be0360">Destructuring in Ruby</a> was originally published in <a href="https://medium.com/rubyinside">Ruby Inside</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[How we halved our memory consumption in Rails with jemalloc]]></title>
            <link>https://medium.com/rubyinside/how-we-halved-our-memory-consumption-in-rails-with-jemalloc-86afa4e54aa3?source=rss----235b73ea0b2e---4</link>
            <guid isPermaLink="false">https://medium.com/p/86afa4e54aa3</guid>
            <category><![CDATA[web-development]]></category>
            <category><![CDATA[ruby-on-rails]]></category>
            <category><![CDATA[rails]]></category>
            <category><![CDATA[jemalloc]]></category>
            <category><![CDATA[software-engineering]]></category>
            <dc:creator><![CDATA[Carmen Chung]]></dc:creator>
            <pubDate>Tue, 16 Oct 2018 12:01:49 GMT</pubDate>
            <atom:updated>2021-01-10T22:09:01.630Z</atom:updated>
            <content:encoded><![CDATA[<figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><p>One of the earliest projects I was involved in at <a href="http://valiant.finance">Valiant</a> was <strong>investigating ways to optimise performance and memory consumption in our Rails web application</strong>. Although I had heard the age-old complaints about Rails applications being slow, bulky and prone to memory bloat, I had yet to come across any practical, easy-to-navigate solutions to these issues.<br> <br>Until we discovered jemalloc.<br> <br>In this blog post, I will be giving <strong>a brief overview of what jemalloc is</strong>; how to check your current Rails app’s performance and memory consumption <em>(including testing to see whether you have a memory leak)</em>; how to install jemalloc locally and in production; and finally, show you what our end-results were after we switched to jemalloc (<em>spoiler alert: we managed to halve our memory consumption in production!</em>).</p><p>(Sidenote: If you are interested in productivity, tech, and product topics, <a href="https://twitter.com/carmenhchung">follow me on Twitter</a> where I post about these things in an easy and fun way. I’ve also just started a bite-sized newsletter talking about all things tech that you can subscribe to <a href="https://carmenchung.substack.com/">here</a>.)</p><h3>What is jemalloc?</h3><p>Ruby traditionally uses the C language function malloc to dynamically allocate, release, and re-allocate memory when storing objects. Jemalloc is a malloc(3) implementation developed by Jason Evans (hence the “je” initials at the start of malloc), which appears to be more effective at allocating memory compared to other allocators due to its focus on fragmentation avoidance and scalable concurrency support.</p><h3>Step 1: Check your app’s memory consumption</h3><p>In order to determine whether switching to jemalloc actually has any positive effects on your Rails app, you first need to know how much memory is being consumed and how quickly the website responds. To check this locally, I added the following gems to the Gemfile (and did a bundle install):</p><pre>gem &quot;memory_profiler&quot;<br>gem &quot;derailed_benchmarks&quot;</pre><p><em>(Note: you can run tests with these gems in the development, testing or production environments. If you want to run them in development / testing environments, make sure you remove the dotenv-rails gem from these environments in the Gemfile.)</em><br> <br>To determine the total memory used by each gem in the Gemfile, run:</p><pre>bundle exec derailed bundle:mem</pre><p>To only show files above a certain memory usage, add CUT_OFF=0.3 (or whatever figure you want as the cut off). Also note that because Ruby only requires files once, if the same file is required by several libraries, the cost is only associated with the first library to require the file (duplicate entries will list all the parents they belong to).<br> <br>For example, a short excerpt of our results looked like this:</p><pre>TOP: 70.2617 MiB<br>  rails/all: 16.4805 MiB<br>    rails: 6.1523 MiB (Also required by: active_record/railtie, active_model/railtie, and 8 others)<br>      rails/application: 4.707 MiB<br>        rails/engine: 3.543 MiB (Also required by: coffee/rails/engine)<br>          rails/railtie: 3.293 MiB (Also required by: global_id/railtie, sprockets/railtie, and 3 others)<br>            rails/configuration: 3.1484 MiB (Also required by: rails/railtie/configuration)<br>              active_support/core_ext/object: 3.0469 MiB (Also required by: paper_trail/has_paper_trail)<br>                active_support/core_ext/object/conversions: 2.5078 MiB<br>                  active_support/core_ext/hash/conversions: 1.8945 MiB (Also required by: active_record/serializers/xml_serializer, active_model/serializers/xml)<br>                    active_support/time: 1.7031 MiB (Also required by: active_record/base)<br>                      active_support/core_ext/time: 1.625 MiB<br>                        active_support/core_ext/time/calculations: 1.5391 MiB (Also required by: active_support/core_ext/numeric/time, active_support/core_ext/string/conversions)<br>                          active_support/core_ext/time/conversions: 1.1094 MiB (Also required by: active_support/core_ext/time, active_support/core_ext/date_time/conversions)<br>                            active_support/values/time_zone: 1.0664 MiB (Also required by: active_support/time_with_zone, active_support/core_ext/date_time/conversions)<br>                              tzinfo: 0.8438 MiB (Also required by: et-orbi)<br>                                tzinfo/timezone: 0.3867 MiB</pre><p><em>(Note: 1 Mebibyte (MiB) = approximately 1.05 Megabytes.)</em><br> <br>Additionally, in your production environment, you can see the number of allocated objects created (by location, as well as by gem) when dependencies are required by running:</p><pre>bundle exec derailed bundle:objects</pre><p>Below is a sample of the number of objects created by our gems:</p><pre>348351  activesupport<br>66931  erubis<br>54842  json<br>23655  addressable<br>15078  bundler<br>14833  heroics<br>13313  ruby<br>13034  haml<br>7186  actionpack<br>6370  sass</pre><p>In order to check to see whether you have a memory leak in a production environment, you can run:</p><pre>bundle exec derailed exec perf:mem_over_time</pre><blockquote><em>❗️</em><strong><em>Tip: </em></strong>To set the number of tests you want to run rather than let it run forever, you can use: TEST_COUNT=20_000 bundle exec derailed exec perf:mem_over_time<em>.</em></blockquote><p>This command sends numerous requests to the app and profiles memory usage over time - if you have a true memory leak, the memory use will continue increasing; if you do not have a memory leak, usually you will see app memory use increasing until it hits a &quot;plateau&quot;, then peters off.<br> <br>Remember that results vary <em>(and seem to vary a bit when running say 2,000 tests compared to 20,000 tests)</em>. By running the tests a number of times, we discovered that on average, our app&#39;s plateau seemed to occur around the 1.7 MiB - 1.8 MiB mark. This seemed to roughly correspond with our Heroku logs, which showed a plateau around the 1.6 MiB mark.</p><h3>Step 2: Check your app’s performance and speed</h3><p>To check the overall efficiency of your application, you can hit an endpoint in the application using benchmark-ips (that is, benchmarking a block of code’s iterations per second) with this command:</p><pre>bundle exec derailed exec perf:ips</pre><p>A higher value is better as it means more iterations of the code block per second. A few of our results are as follows:</p><pre>Warming up --------------------------------------<br>                 ips     1.000  i/100ms<br>Calculating -------------------------------------<br>                 ips      5.070  (± 0.0%) i/s -     26.000  in   5.141956s<br>                 </pre><pre>Warming up --------------------------------------<br>                 ips     1.000  i/100ms<br>Calculating -------------------------------------<br>                 ips      5.162  (± 0.0%) i/s -     26.000  in   5.051505s<br>           </pre><pre>Warming up --------------------------------------<br>                 ips     1.000  i/100ms<br>Calculating -------------------------------------<br>                 ips      4.741  (± 0.0%) i/s -     24.000  in   5.125214s</pre><h3>Step 3: Install Jemalloc (locally and in production)</h3><p>To install jemalloc locally, simply add this to the Gemfile and bundle install:</p><pre>gem &#39;jemalloc&#39;</pre><p>Note: if you use rvm (and have already installed Ruby 2.4.1), run rvm reinstall 2.4.1 -C —with-jemalloc to reinstall Ruby with jemalloc. <br> <br>To check that your version of Ruby uses jemalloc, run:</p><pre>ruby -r rbconfig -e &quot;puts RbConfig::CONFIG[&#39;LIBS&#39;]&quot;.</pre><p>Your response should be something like:</p><pre>-lpthread -ljemalloc -ldl -lobjc</pre><p>(The -ljemalloc means jemalloc is loaded when starting Ruby.)<br> <br>But what about in production? There are a few ways to add jemalloc in Heroku, but we found that the easiest way was to just add the buildpack with this command:</p><pre>heroku buildpacks:add --index 1 <a href="https://github.com/mojodna/heroku-buildpack-jemalloc.git">https://github.com/mojodna/heroku-buildpack-jemalloc.git</a> --app [your app name here]</pre><p>To confirm that it has been installed, run heroku buildpacks --app [your app name here], and you should see the buildpack listed.<br> <br>Alternatively, you can add the buildpack in Settings → Buildpacks → Add buildpack in the Heroku dashboard.</p><h3>Step 4: Check results locally</h3><p>Run the same commands as in Step 1 to check memory consumption and speed post-jemalloc. Our results showed a 8.6953 MiB (9.117 MB) — which is 12.38% — saving of memory over the entire app. For allocated objects by location, we saved 5,064 MiB (5,310 MB) of memory.</p><h3>Step 5: Check results in production</h3><p>We used siege, an http load testing and benchmarking utility, to overload our review applications with requests (stay tuned for our upcoming post on how to do this!). Without jemalloc, we found that we were averaging around 2.5 transactions per second, with an average of around 160 failed transactions during a 20 minute timeframe. With jemalloc, we ended up with an average of 6.6 transactions per second, and only 1.5 failed transactions during a 20 minute timeframe.<br> <br>Most impressively, our Heroku dashboard results showed remarkable, almost immediate improvements. Prior to jemalloc, our memory usage would hit around 2 GB before being automatically force-restarted. After jemalloc, our memory usage dropped down to the 1 GB mark, avoiding the force-restart entirely.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*5_8rjKsA103kQL0yWb49Xw.png" /><figcaption>Heroku memory consumption pre and post-jemalloc.</figcaption></figure><p>Similarly, our response times to requests showed rapid decline — prior to jemalloc, some requests were taking as long as 30 seconds. Afterwards, our response times dropped to around 5–10 seconds.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*PMpIxL_wEhBkGJMUhPShuA.png" /><figcaption>Heroku response times pre and post-jemalloc.</figcaption></figure><figure><img alt="" src="https://cdn-images-1.medium.com/max/800/1*xTdDSCDf1enlPgV2Ap-_Bg.jpeg" /></figure><h3>Conclusion</h3><p>We had incredible, tangible performance and memory consumption benefits after implementing jemalloc; and while this may not be the silver bullet to combat Rails’s reputation in the industry for sub-optimal garbage collection, it certainly helped us optimise our platform.<br> <br>Let me know in the comments if you have had any success with jemalloc or other optimisation strategies — we’re always on the look-out for ways to make our application even better!</p><p>You can find me on Twitter (where I post about all things tech-related) at <a href="https://twitter.com/carmenhchung">@carmenhchung</a>, and at my little home on the interweb <a href="https://www.carmenhchung.com/">here</a>.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=86afa4e54aa3" width="1" height="1" alt=""><hr><p><a href="https://medium.com/rubyinside/how-we-halved-our-memory-consumption-in-rails-with-jemalloc-86afa4e54aa3">How we halved our memory consumption in Rails with jemalloc</a> was originally published in <a href="https://medium.com/rubyinside">Ruby Inside</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>]]></content:encoded>
        </item>
    </channel>
</rss>