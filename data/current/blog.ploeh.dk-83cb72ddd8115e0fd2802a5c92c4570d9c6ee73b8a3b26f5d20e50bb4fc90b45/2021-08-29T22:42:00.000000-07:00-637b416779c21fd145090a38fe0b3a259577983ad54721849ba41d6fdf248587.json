{
  "title":"The Reader functor",
  "date":"2021-08-29T22:42:00.000000-07:00",
  "author":"Mark Seemann",
  "id":"https://blog.ploeh.dk/2021/08/30/the-reader-functor",
  "link":"https://blog.ploeh.dk/2021/08/30/the-reader-functor/",
  "content":"\n\n\n<div id=\"post\">\n\t<p>\n\t\t<em>Normal functions form functors. An article for object-oriented programmers.</em>\n\t</p>\n\t<p>\n\t\tThis article is an instalment in <a href=\"/2018/03/22/functors\">an article series about functors</a>. In a <a href=\"/2018/03/26/the-maybe-functor\">previous article</a> you saw, for example, how to implement the Maybe functor in C#. In this article, you'll see another functor example: <em>Reader</em>.\n\t</p>\n\t<p>\n\t\tThe Reader functor is similar to the <a href=\"/2018/09/03/the-identity-functor\">Identity functor</a> in the sense that it seems practically useless. If that's the case, then why care about it?\n\t</p>\n\t<p>\n\t\tAs I wrote about the Identity functor:\n\t</p>\n\t<blockquote>\n\t\t&quot;The inutility of Identity doesn't mean that it doesn't exist. The Identity functor exists, whether it's useful or not. You can ignore it, but it still exists. In C# or <a href=\"https://fsharp.org\">F#</a> I've never had any use for it (although I've <a href=\"/2017/09/04/builder-as-identity\">described it before</a>), while it turns out to be occasionally useful in <a href=\"https://www.haskell.org\">Haskell</a>, where it's built-in. The value of Identity is language-dependent.&quot;\n\t</blockquote>\n\t<p>\n\t\tThe same holds for Reader. It exists. Furthermore, it teaches us something important about ordinary functions.\n\t</p>\n\t<h3 id=\"1539ecc9bc504aa1a0cc090255777b1d\">\n\t\tReader interface <a href=\"#1539ecc9bc504aa1a0cc090255777b1d\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tImagine the following interface:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>interface</span> <span>IReader</span>&lt;<span>R</span>, <span>A</span>&gt;\n{\n    A <span>Run</span>(R <span>environment</span>);\n}</pre>\n\t</p>\n\t<p>\n\t\tAn <code>IReader</code> object can produce a value of the type <code>A</code> when given a value of the type <code>R</code>. The input is typically called the <code>environment</code>. A Reader reads the environment and produces a value. A possible (although not particularly useful) implementation might be:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>class</span> <span>GuidToStringReader</span> : IReader&lt;Guid, <span>string</span>&gt;\n{\n    <span>private</span> <span>readonly</span> <span>string</span> format;\n \n    <span>public</span> <span>GuidToStringReader</span>(<span>string</span> <span>format</span>)\n    {\n        <span>this</span>.format = format;\n    }\n \n    <span>public</span> <span>string</span> <span>Run</span>(Guid <span>environment</span>)\n    {\n        <span>return</span> environment.ToString(format);\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tThis may be a silly example, but it illustrates that a a simple class can implement a constructed version of the interface: <code>IReader&lt;Guid, string&gt;</code>. It also demonstrates that a class can take further arguments via its constructor.\n\t</p>\n\t<p>\n\t\tWhile the <code>IReader</code> interface only takes a single input argument, <a href=\"/2018/01/29/argument-list-isomorphisms\">we know that an argument list is isomorphic to a parameter object or tuple</a>. Thus, <code>IReader</code> is equivalent to <em>every</em> possible function type - up to isomorphism, assuming that <a href=\"/2018/01/15/unit-isomorphisms\">unit is also a value</a>.\n\t</p>\n\t<p>\n\t\tWhile the practical utility of the Reader functor may not be immediately apparent, it's hard to argue that it isn't ubiquitous. Every method is (with a bit of hand-waving) a Reader.\n\t</p>\n\t<h3 id=\"23b5c83bffef42a0ab0c95919fef0166\">\n\t\tFunctor <a href=\"#23b5c83bffef42a0ab0c95919fef0166\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tYou can turn the <code>IReader</code> interface into a functor by adding an appropriate <code>Select</code> method:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> IReader&lt;R, B&gt; <span>Select</span>&lt;<span>A</span>, <span>B</span>, <span>R</span>&gt;(<span>this</span> IReader&lt;R, A&gt; <span>reader</span>, Func&lt;A, B&gt; <span>selector</span>)\n{\n    <span>return</span> <span>new</span> FuncReader&lt;R, B&gt;(<span>r</span> =&gt; selector(reader.Run(r)));\n}\n \n<span>private</span> <span>sealed</span> <span>class</span> <span>FuncReader</span>&lt;<span>R</span>, <span>A</span>&gt; : IReader&lt;R, A&gt;\n{\n    <span>private</span> <span>readonly</span> Func&lt;R, A&gt; func;\n \n    <span>public</span> <span>FuncReader</span>(Func&lt;R, A&gt; <span>func</span>)\n    {\n        <span>this</span>.func = func;\n    }\n \n    <span>public</span> A <span>Run</span>(R <span>environment</span>)\n    {\n        <span>return</span> func(environment);\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tThe implementation of <code>Select</code> requires a private class to capture the projected function. <code>FuncReader</code> is, however, an implementation detail.\n\t</p>\n\t<p>\n\t\tWhen you <code>Run</code> a Reader, the output is a value of the type <code>A</code>, and since <code>selector</code> is a function that takes an <code>A</code> value as input, you can use the output of <code>Run</code> as input to <code>selector</code>. Thus, the return type of the lambda expression <code>r =&gt; selector(reader.Run(r))</code> is <code>B</code>. Therefore, <code>Select</code> returns an <code>IReader&lt;R, B&gt;</code>.\n\t</p>\n\t<p>\n\t\tHere's an example of using the <code>Select</code> method to project an <code>IReader&lt;Guid, string&gt;</code> to <code>IReader&lt;Guid, int&gt;</code>:\n\t</p>\n\t<p>\n\t\t<pre>[Fact]\n<span>public</span> <span>void</span> <span>WrappedFunctorExample</span>()\n{\n    IReader&lt;Guid, <span>string</span>&gt; <span>r</span> = <span>new</span> GuidToStringReader(<span>&quot;N&quot;</span>);\n \n    IReader&lt;Guid, <span>int</span>&gt; <span>projected</span> = r.Select(<span>s</span> =&gt; s.Count(<span>c</span> =&gt; c.IsDigit()));\n \n    <span>var</span> <span>input</span> = <span>new</span> Guid(<span>&quot;{CAB5397D-3CF9-40BB-8CBD-B3243B7FDC23}&quot;</span>);\n    Assert.Equal(16, projected.Run(input));\n}</pre>\n\t</p>\n\t<p>\n\t\tThe expected result is <code>16</code> because the <code>input</code> <code>Guid</code> contains 16 digits (the numbers from 0 to 9). Count them if you don't believe me.\n\t</p>\n\t<p>\n\t\tAs usual, you can also use query syntax:\n\t</p>\n\t<p>\n\t\t<pre>[Fact]\n<span>public</span> <span>void</span> <span>QuerySyntaxFunctorExample</span>()\n{\n    <span>var</span> <span>projected</span> =\n        <span>from</span> s <span>in</span> <span>new</span> GuidToStringReader(<span>&quot;N&quot;</span>)\n        <span>select</span> TimeSpan.FromMinutes(s.Length);\n \n    <span>var</span> <span>input</span> = <span>new</span> Guid(<span>&quot;{FE2AB9C6-DDB1-466C-8AAA-C70E02F964B9}&quot;</span>);\n \n    Assert.Equal(32, projected.Run(input).TotalMinutes);\n}</pre>\n\t</p>\n\t<p>\n\t\tThe actual computation shown here makes little sense, since the result will always be <code>32</code>, but it illustrates that arbitrary projections are possible.\n\t</p>\n\t<h3 id=\"ad9b3abef16c4ec8a70a1263c17eecd6\">\n\t\tRaw functions <a href=\"#ad9b3abef16c4ec8a70a1263c17eecd6\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tThe <code>IReader&lt;R, A&gt;</code> interface isn't really necessary. It was just meant as an introduction to make things a bit easier for object-oriented programmers. You can write a similar <code>Select</code> extension method for any <code>Func&lt;R, A&gt;</code>:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> Func&lt;R, B&gt; <span>Select</span>&lt;<span>A</span>, <span>B</span>, <span>R</span>&gt;(<span>this</span> Func&lt;R, A&gt; <span>func</span>, Func&lt;A, B&gt; <span>selector</span>)\n{\n    <span>return</span> <span>r</span> =&gt; selector(func(r));\n}</pre>\n\t</p>\n\t<p>\n\t\tCompare this implementation to the one above. It's essentially the same lambda expression, but now <code>Select</code> returns the raw function instead of wrapping it in a class.\n\t</p>\n\t<p>\n\t\tIn the following, I'll use raw functions instead of the <code>IReader</code> interface.\n\t</p>\n\t<h3 id=\"de5e5a6801ab49d4ae993181a05f7bab\">\n\t\tFirst functor law <a href=\"#de5e5a6801ab49d4ae993181a05f7bab\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tThe <code>Select</code> method obeys the first functor law. As usual, it's proper computer-science work to actually prove this, but you can write some tests to demonstrate the first functor law for the <code>IReader&lt;R, A&gt;</code> interface. In this article, you'll see parametrised tests written with <a href=\"https://xunit.net\">xUnit.net</a>. First, the first functor law:\n\t</p>\n\t<p>\n\t\t<pre>[Theory]\n[InlineData(<span>&quot;&quot;</span>)]\n[InlineData(<span>&quot;foo&quot;</span>)]\n[InlineData(<span>&quot;bar&quot;</span>)]\n[InlineData(<span>&quot;corge&quot;</span>)]\n[InlineData(<span>&quot;antidisestablishmentarianism&quot;</span>)]\n<span>public</span> <span>void</span> <span>FirstFunctorLaw</span>(<span>string</span> <span>input</span>)\n{\n    T <span>id</span>&lt;<span>T</span>&gt;(T <span>x</span>) =&gt; x;\n    Func&lt;<span>string</span>, <span>int</span>&gt; <span>f</span> = <span>s</span> =&gt; s.Length;\n \n    Func&lt;<span>string</span>, <span>int</span>&gt; <span>actual</span> = f.Select(id);\n \n    Assert.Equal(f(input), actual(input));\n}</pre>\n\t</p>\n\t<p>\n\t\tThe 'original' Reader <code>f</code> (for <em>function</em>) takes a <code>string</code> as input and returns its length. The <code>id</code> function (which isn't built-in in C#) is implemented as a <a href=\"https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/local-functions\">local function</a>. It returns whichever input it's given.\n\t</p>\n\t<p>\n\t\tSince <code>id</code> returns any input without modifying it, it'll also return any number produced by <code>f</code> without modification.\n\t</p>\n\t<p>\n\t\tTo evaluate whether <code>f</code> is equal to <code>f.Select(id)</code>, the assertion calls both functions with the same input. If the functions have equal behaviour, they ought to return the same output.\n\t</p>\n\t<p>\n\t\tThe above test cases all pass.\n\t</p>\n\t<h3 id=\"1dc17b41888b420d8b8161f9ef9fb84c\">\n\t\tSecond functor law <a href=\"#1dc17b41888b420d8b8161f9ef9fb84c\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tLike the above example, you can also write a parametrised test that demonstrates that a function (Reader) obeys the second functor law:\n\t</p>\n\t<p>\n\t\t<pre>[Theory]\n[InlineData(<span>&quot;&quot;</span>)]\n[InlineData(<span>&quot;foo&quot;</span>)]\n[InlineData(<span>&quot;bar&quot;</span>)]\n[InlineData(<span>&quot;corge&quot;</span>)]\n[InlineData(<span>&quot;antidisestablishmentarianism&quot;</span>)]\n<span>public</span> <span>void</span> <span>SecondFunctorLaw</span>(<span>string</span> <span>input</span>)\n{\n    Func&lt;<span>string</span>, <span>int</span>&gt; <span>h</span> = <span>s</span> =&gt; s.Length;\n    Func&lt;<span>int</span>, <span>bool</span>&gt; <span>g</span> = <span>i</span> =&gt; i % 2 == 0;\n    Func&lt;<span>bool</span>, <span>char</span>&gt; <span>f</span> = <span>b</span> =&gt; b ? <span>'t'</span> : <span>'f'</span>;\n \n    Assert.Equal(\n        h.Select(g).Select(f)(input),\n        h.Select(<span>i</span> =&gt; f(g(i)))(input));\n}</pre>\n\t</p>\n\t<p>\n\t\tYou can't easily compare two different functions for equality, so, like above, this test defines equality as the functions producing the same result when you invoke them.\n\t</p>\n\t<p>\n\t\tAgain, while the test doesn't <em>prove</em> anything, it demonstrates that for the five test cases, it doesn't matter if you project the 'original' Reader <code>h</code> in one or two steps.\n\t</p>\n\t<h3 id=\"76a34d3dfde1438abd080f02499bc344\">\n\t\tHaskell <a href=\"#76a34d3dfde1438abd080f02499bc344\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tIn Haskell, normal functions <code>a -&gt; b</code> are already <code>Functor</code> instances, which means that you can easily replicate the functions from the <code>SecondFunctorLaw</code> test:\n\t</p>\n\t<p>\n\t\t<pre>&gt; h = length\n&gt; g i = i `mod` 2 == 0\n&gt; f b = if b then 't' else 'f'\n&gt; (fmap f $ fmap g $ h) &quot;ploeh&quot;\n'f'</pre>\n\t</p>\n\t<p>\n\t\tHere <code>f</code>, <code>g</code>, and <code>h</code> are equivalent to their above C# namesakes, while the last line composes the functions stepwise and calls the composition with the input string <code>&quot;ploeh&quot;</code>. In Haskell you generally read code from right to left, so this composition corresponds to <code>h.Select(g).Select(f)</code>.\n\t</p>\n\t<h3 id=\"9d3006be0e904994b2285ae791fd287a\">\n\t\tConclusion <a href=\"#9d3006be0e904994b2285ae791fd287a\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tFunctions give rise to functors, usually known collectively as the Reader functor. Even in Haskell where this fact is ingrained into the fabric of the language, I rarely make use of it. It just is. In C#, it's likely to be even less useful for practical programming purposes.\n\t</p>\n\t<p>\n\t\tThat a function <code>a -&gt; b</code> forms a functor, however, is an important insight into just what a function actually is. It describes an essential property of functions. In itself this may still seem underwhelming, but mixed with some other properties (that I'll describe in a future article) it can produce some profound insights. So stay tuned.\n\t</p>\n\t<p>\n\t\t<strong>Next:</strong> <a href=\"/2020/06/22/the-io-functor\">The IO functor</a>.\n\t</p>\n</div><hr>\n   \t\tThis blog is totally free, but if you like it, please consider <a href=\"https://blog.ploeh.dk/support\">supporting it</a>.</hr>"
}