{
  "title":"The Reader monad",
  "date":"2022-11-14T06:50:00.000000Z",
  "author":"Mark Seemann",
  "id":"https://blog.ploeh.dk/2022/11/14/the-reader-monad",
  "link":"https://blog.ploeh.dk/2022/11/14/the-reader-monad/",
  "content":"\n\n\n<div id=\"post\">\n\t<p>\n\t\t<em>Normal functions form monads. An article for object-oriented programmers.</em>\n\t</p>\n\t<p>\n\t\tThis article is an instalment in <a href=\"/2022/03/28/monads\">an article series about monads</a>. A previous article described <a href=\"/2021/08/30/the-reader-functor\">the Reader functor</a>. As is the case with many (but not all) <a href=\"/2018/03/22/functors\">functors</a>, Readers also form monads.\n\t</p>\n\t<p>\n\t\tThis article continues where the Reader functor article stopped. It uses the same code base.\n\t</p>\n\t<h3 id=\"d54d83f22d854e94853271e1a559a1d8\">\n\t\tFlatten <a href=\"#d54d83f22d854e94853271e1a559a1d8\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tA monad must define either a <em>bind</em> or <em>join</em> function, although you can use other names for both of these functions. <code>Flatten</code> is in my opinion a more intuitive name than <code>join</code>, since a monad is really just a functor that you can flatten. Flattening is relevant if you have a nested functor; in this case a Reader within a Reader. You can flatten such a nested Reader with a <code>Flatten</code> function:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> IReader&lt;R, A&gt; <span>Flatten</span>&lt;<span>R</span>, <span>A</span>&gt;(\n    <span>this</span> IReader&lt;R, IReader&lt;R, A&gt;&gt; <span>source</span>)\n{\n    <span>return</span> <span>new</span> FlattenReader&lt;R, A&gt;(source);\n}\n \n<span>private</span> <span>class</span> <span>FlattenReader</span>&lt;<span>R</span>, <span>A</span>&gt; : IReader&lt;R, A&gt;\n{\n    <span>private</span> <span>readonly</span> IReader&lt;R, IReader&lt;R, A&gt;&gt; source;\n \n    <span>public</span> <span>FlattenReader</span>(IReader&lt;R, IReader&lt;R, A&gt;&gt; <span>source</span>)\n    {\n        <span>this</span>.source = source;\n    }\n \n    <span>public</span> A <span>Run</span>(R <span>environment</span>)\n    {\n        IReader&lt;R, A&gt; <span>newReader</span> = source.Run(environment);\n        <span>return</span> newReader.Run(environment);\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tSince the <code>source</code> Reader is nested, calling its <code>Run</code> method once returns a <code>newReader</code>. You can <code>Run</code> that <code>newReader</code> one more time to get an <code>A</code> value to return.\n\t</p>\n\t<p>\n\t\tYou could easily chain the two calls to <code>Run</code> together, one after the other. That would make the code terser, but here I chose to do it in two explicit steps in order to show what's going on.\n\t</p>\n\t<p>\n\t\tLike the previous article about <a href=\"/2022/06/20/the-state-monad\">the State monad</a>, a lot of <a href=\"/2019/12/16/zone-of-ceremony\">ceremony</a> is required because this variation of the Reader monad is defined with an interface. You could also define the Reader monad on a 'raw' function of the type <code>Func&lt;R, A&gt;</code>, in which case <code>Flatten</code> would be simpler:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> Func&lt;R, A&gt; <span>Flatten</span>&lt;<span>R</span>, <span>A</span>&gt;(<span>this</span> Func&lt;R, Func&lt;R, A&gt;&gt; <span>source</span>)\n{\n    <span>return</span> <span>environment</span> =&gt; source(environment)(environment);\n}</pre>\n\t</p>\n\t<p>\n\t\tIn this variation <code>source</code> is a function, so you can call it with <code>environment</code>, which returns another function that you can again call with <code>environment</code>. This produces an <code>A</code> value for the function to return.\n\t</p>\n\t<h3 id=\"e2f72c66681d45949a23a7e574ae5ae7\">\n\t\tSelectMany <a href=\"#e2f72c66681d45949a23a7e574ae5ae7\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tWhen you have <code>Flatten</code> you can always define <code>SelectMany</code> (<em>monadic bind</em>) like this:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> IReader&lt;R, B&gt; <span>SelectMany</span>&lt;<span>R</span>, <span>A</span>, <span>B</span>&gt;(\n    <span>this</span> IReader&lt;R, A&gt; <span>source</span>,\n    Func&lt;A, IReader&lt;R, B&gt;&gt; <span>selector</span>)\n{\n    <span>return</span> source.Select(selector).Flatten();\n}</pre>\n\t</p>\n\t<p>\n\t\tFirst use functor-based mapping. Since the <code>selector</code> returns a Reader, this mapping produces a Reader within a Reader. That's exactly the situation that <code>Flatten</code> addresses.\n\t</p>\n\t<p>\n\t\tThe above <code>SelectMany</code> example works with the <code>IReader&lt;R, A&gt;</code> interface, but the 'raw' function version has the exact same implementation:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> Func&lt;R, B&gt; <span>SelectMany</span>&lt;<span>R</span>, <span>A</span>, <span>B</span>&gt;(\n    <span>this</span> Func&lt;R, A&gt; <span>source</span>,\n    Func&lt;A, Func&lt;R, B&gt;&gt; <span>selector</span>)\n{\n    <span>return</span> source.Select(selector).Flatten();\n}</pre>\n\t</p>\n\t<p>\n\t\tOnly the method declaration differs.\n\t</p>\n\t<h3 id=\"8c5f94f7395040a7bcfdb2561c8e3ed3\">\n\t\tQuery syntax <a href=\"#8c5f94f7395040a7bcfdb2561c8e3ed3\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tMonads also enable query syntax in C# (just like they enable other kinds of syntactic sugar in languages like <a href=\"https://fsharp.org/\">F#</a> and <a href=\"https://www.haskell.org\">Haskell</a>). As outlined in the <a href=\"/2022/03/28/monads\">monad introduction</a>, however, you must add a special <code>SelectMany</code> overload:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> IReader&lt;R, T1&gt; <span>SelectMany</span>&lt;<span>R</span>, <span>T</span>, <span>U</span>, <span>T1</span>&gt;(\n    <span>this</span> IReader&lt;R, T&gt; <span>source</span>,\n    Func&lt;T, IReader&lt;R, U&gt;&gt; <span>k</span>,\n    Func&lt;T, U, T1&gt; <span>s</span>)\n{\n    <span>return</span> source.SelectMany(<span>x</span> =&gt; k(x).Select(<span>y</span> =&gt; s(x, y)));\n}</pre>\n\t</p>\n\t<p>\n\t\tAs already predicted in the monad introduction, this boilerplate overload is always implemented in the same way. Only the signature changes. With it, you could write an expression like this nonsense:\n\t</p>\n\t<p>\n\t\t<pre>IReader&lt;<span>int</span>, <span>bool</span>&gt; <span>r</span> =\n    <span>from</span> dur <span>in</span> <span>new</span> MinutesReader()\n    <span>from</span> b <span>in</span> <span>new</span> Thingy(dur)\n    <span>select</span> b;</pre>\n\t</p>\n\t<p>\n\t\tWhere <code>MinutesReader</code> was already shown in the article <a href=\"/2021/10/04/reader-as-a-contravariant-functor\">Reader as a contravariant functor</a>. I couldn't come up with a good name for another reader, so I went with <a href=\"https://dannorth.net\">Dan North</a>'s naming convention that if you don't yet know what to call a class, method, or function, don't <em>pretend</em> that you know. Be explicit that you don't know.\n\t</p>\n\t<p>\n\t\tHere it is, for the sake of completion:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>sealed</span> <span>class</span> <span>Thingy</span> : IReader&lt;<span>int</span>, <span>bool</span>&gt;\n{\n    <span>private</span> <span>readonly</span> TimeSpan timeSpan;\n \n    <span>public</span> <span>Thingy</span>(TimeSpan <span>timeSpan</span>)\n    {\n        <span>this</span>.timeSpan = timeSpan;\n    }\n \n    <span>public</span> <span>bool</span> <span>Run</span>(<span>int</span> <span>environment</span>)\n    {\n        <span>return</span> <span>new</span> TimeSpan(timeSpan.Ticks * environment).TotalDays &lt; 1;\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tI'm not claiming that this class makes sense. These articles are deliberate kept abstract in order to focus on structure and behaviour, rather than on practical application.\n\t</p>\n\t<h3 id=\"d5d827cf83d242e6baecbda622ca5cb9\">\n\t\tReturn <a href=\"#d5d827cf83d242e6baecbda622ca5cb9\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tApart from flattening or monadic bind, a monad must also define a way to put a normal value into the monad. Conceptually, I call this function <em>return</em> (because that's the name that Haskell uses):\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> IReader&lt;R, A&gt; <span>Return</span>&lt;<span>R</span>, <span>A</span>&gt;(A <span>a</span>)\n{\n    <span>return</span> <span>new</span> ReturnReader&lt;R, A&gt;(a);\n}\n \n<span>private</span> <span>class</span> <span>ReturnReader</span>&lt;<span>R</span>, <span>A</span>&gt; : IReader&lt;R, A&gt;\n{\n    <span>private</span> <span>readonly</span> A a;\n \n    <span>public</span> <span>ReturnReader</span>(A <span>a</span>)\n    {\n        <span>this</span>.a = a;\n    }\n \n    <span>public</span> A <span>Run</span>(R <span>environment</span>)\n    {\n        <span>return</span> a;\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tThis implementation returns the <code>a</code> value and completely ignores the <code>environment</code>. You can do the same with a 'naked' function.\n\t</p>\n\t<h3 id=\"bd79fe3d97644f0f9edb12f08a0b5d01\">\n\t\tLeft identity <a href=\"#bd79fe3d97644f0f9edb12f08a0b5d01\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tWe need to identify the <em>return</em> function in order to examine <a href=\"/2022/04/11/monad-laws\">the monad laws</a>. Now that this is accomplished, let's see what the laws look like for the Reader monad, starting with the left identity law.\n\t</p>\n\t<p>\n\t\t<pre>[Theory]\n[InlineData(UriPartial.Authority, <span>&quot;https://example.com/f?o=o&quot;</span>)]\n[InlineData(UriPartial.Path, <span>&quot;https://example.net/b?a=r&quot;</span>)]\n[InlineData(UriPartial.Query, <span>&quot;https://example.org/b?a=z&quot;</span>)]\n[InlineData(UriPartial.Scheme, <span>&quot;https://example.gov/q?u=x&quot;</span>)]\n<span>public</span> <span>void</span> <span>LeftIdentity</span>(UriPartial <span>a</span>, <span>string</span> <span>u</span>)\n{\n    Func&lt;UriPartial, IReader&lt;Uri, UriPartial&gt;&gt; <span>@return</span> =\n        <span>up</span> =&gt; Reader.Return&lt;Uri, UriPartial&gt;(up);\n    Func&lt;UriPartial, IReader&lt;Uri, <span>string</span>&gt;&gt; <span>h</span> =\n        <span>up</span> =&gt; <span>new</span> UriPartReader(up);\n \n    Assert.Equal(\n        @return(a).SelectMany(h).Run(<span>new</span> Uri(u)),\n        h(a).Run(<span>new</span> Uri(u)));\n}</pre>\n\t</p>\n\t<p>\n\t\tIn order to compare the two Reader values, the test has to <code>Run</code> them and then compare the return values.\n\t</p>\n\t<p>\n\t\tThis test and the next uses a Reader implementation called <code>UriPartReader</code>, which almost makes sense:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>sealed</span> <span>class</span> <span>UriPartReader</span> : IReader&lt;Uri, <span>string</span>&gt;\n{\n    <span>private</span> <span>readonly</span> UriPartial part;\n \n    <span>public</span> <span>UriPartReader</span>(UriPartial <span>part</span>)\n    {\n        <span>this</span>.part = part;\n    }\n \n    <span>public</span> <span>string</span> <span>Run</span>(Uri <span>environment</span>)\n    {\n        <span>return</span> environment.GetLeftPart(part);\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tAlmost.\n\t</p>\n\t<h3 id=\"ad9edb1097be4eeb96170809272851eb\">\n\t\tRight identity <a href=\"#ad9edb1097be4eeb96170809272851eb\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tIn a similar manner, we can showcase the right identity law as a test.\n\t</p>\n\t<p>\n\t\t<pre>[Theory]\n[InlineData(UriPartial.Authority, <span>&quot;https://example.com/q?u=ux&quot;</span>)]\n[InlineData(UriPartial.Path, <span>&quot;https://example.net/q?u=uuz&quot;</span>)]\n[InlineData(UriPartial.Query, <span>&quot;https://example.org/c?o=rge&quot;</span>)]\n[InlineData(UriPartial.Scheme, <span>&quot;https://example.gov/g?a=rply&quot;</span>)]\n<span>public</span> <span>void</span> <span>RightIdentity</span>(UriPartial <span>a</span>, <span>string</span> <span>u</span>)\n{\n    Func&lt;UriPartial, IReader&lt;Uri, <span>string</span>&gt;&gt; <span>f</span> =\n        <span>up</span> =&gt; <span>new</span> UriPartReader(up);\n    Func&lt;<span>string</span>, IReader&lt;Uri, <span>string</span>&gt;&gt; <span>@return</span> =\n        <span>s</span> =&gt; Reader.Return&lt;Uri, <span>string</span>&gt;(s);\n \n    IReader&lt;Uri, <span>string</span>&gt; <span>m</span> = f(a);\n \n    Assert.Equal(\n        m.SelectMany(@return).Run(<span>new</span> Uri(u)),\n        m.Run(<span>new</span> Uri(u)));\n}</pre>\n\t</p>\n\t<p>\n\t\tAs always, even a parametrised test constitutes no <em>proof</em> that the law holds. I show the tests to illustrate what the laws look like in 'real' code.\n\t</p>\n\t<h3 id=\"67a2f225bd8f432dbeed30c2ba2b623a\">\n\t\tAssociativity <a href=\"#67a2f225bd8f432dbeed30c2ba2b623a\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tThe last monad law is the associativity law that describes how (at least) three functions compose. We're going to need three functions. For the purpose of demonstrating the law, any three pure functions will do. While the following functions are silly and not at all 'realistic', they have the virtue of being as simple as they can be (while still providing a bit of variety). They don't 'mean' anything, so don't worry too much about their behaviour. It is, as far as I can tell, nonsensical.\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>sealed</span> <span>class</span> <span>F</span> : IReader&lt;<span>int</span>, <span>string</span>&gt;\n{\n    <span>private</span> <span>readonly</span> <span>char</span> c;\n \n    <span>public</span> <span>F</span>(<span>char</span> <span>c</span>)\n    {\n        <span>this</span>.c = c;\n    }\n \n    <span>public</span> <span>string</span> <span>Run</span>(<span>int</span> <span>environment</span>)\n    {\n        <span>return</span> <span>new</span> <span>string</span>(c, environment);\n    }\n}\n \n<span>public</span> <span>sealed</span> <span>class</span> <span>G</span> : IReader&lt;<span>int</span>, <span>bool</span>&gt;\n{\n    <span>private</span> <span>readonly</span> <span>string</span> s;\n \n    <span>public</span> <span>G</span>(<span>string</span> <span>s</span>)\n    {\n        <span>this</span>.s = s;\n    }\n \n    <span>public</span> <span>bool</span> <span>Run</span>(<span>int</span> <span>environment</span>)\n    {\n        <span>return</span> environment &lt; 42 || s.Contains(<span>&quot;a&quot;</span>);\n    }\n}\n \n<span>public</span> <span>sealed</span> <span>class</span> <span>H</span> : IReader&lt;<span>int</span>, TimeSpan&gt;\n{\n    <span>private</span> <span>readonly</span> <span>bool</span> b;\n \n    <span>public</span> <span>H</span>(<span>bool</span> <span>b</span>)\n    {\n        <span>this</span>.b = b;\n    }\n \n    <span>public</span> TimeSpan <span>Run</span>(<span>int</span> <span>environment</span>)\n    {\n        <span>return</span> b ?\n            TimeSpan.FromMinutes(environment) :\n            TimeSpan.FromSeconds(environment);\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tArmed with these three classes, we can now demonstrate the Associativity law:\n\t</p>\n\t<p>\n\t\t<pre>[Theory]\n[InlineData(<span>'a'</span>, 0)]\n[InlineData(<span>'b'</span>, 1)]\n[InlineData(<span>'c'</span>, 42)]\n[InlineData(<span>'d'</span>, 2112)]\n<span>public</span> <span>void</span> <span>Associativity</span>(<span>char</span> <span>a</span>, <span>int</span> <span>i</span>)\n{\n    Func&lt;<span>char</span>, IReader&lt;<span>int</span>, <span>string</span>&gt;&gt; <span>f</span> = <span>c</span> =&gt; <span>new</span> F(c);\n    Func&lt;<span>string</span>, IReader&lt;<span>int</span>, <span>bool</span>&gt;&gt; <span>g</span> = <span>s</span> =&gt; <span>new</span> G(s);\n    Func&lt;<span>bool</span>, IReader&lt;<span>int</span>, TimeSpan&gt;&gt; <span>h</span> = <span>b</span> =&gt; <span>new</span> H(b);\n \n    IReader&lt;<span>int</span>, <span>string</span>&gt; <span>m</span> = f(a);\n \n    Assert.Equal(\n        m.SelectMany(g).SelectMany(h).Run(i),\n        m.SelectMany(<span>x</span> =&gt; g(x).SelectMany(h)).Run(i));\n}</pre>\n\t</p>\n\t<p>\n\t\tIn case you're wondering, the four test cases produce the outputs <code>00:00:00</code>, <code>00:01:00</code>, <code>00:00:42</code>, and <code>00:35:12</code>. You can see that reproduced below:\n\t</p>\n\t<h3 id=\"a46f77dddd914f0b9c8926dd2c06e9d6\">\n\t\tHaskell <a href=\"#a46f77dddd914f0b9c8926dd2c06e9d6\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tIn Haskell, normal functions <code>a -&gt; b</code> are already <code>Monad</code> instances, which means that you can easily replicate the functions from the <code>Associativity</code> test:\n\t</p>\n\t<p>\n\t\t<pre>&gt; f c = \\env -&gt; replicate env c\n&gt; g s = \\env -&gt; env &lt; 42 || 'a' `elem` s\n&gt; h b = \\env -&gt; if b then secondsToDiffTime (toEnum env * 60) else secondsToDiffTime (toEnum env)</pre>\n\t</p>\n\t<p>\n\t\tI've chosen to write the <code>f</code>, <code>g</code>, and <code>h</code> as functions that return lambda expressions in order to emphasise that each of these functions return Readers. Since Haskell functions are already curried, I could also have written them in the more normal function style with two normal parameters, but that might have obscured the Reader aspect of each.\n\t</p>\n\t<p>\n\t\tHere's the composition in action:\n\t</p>\n\t<p>\n\t\t<pre>&gt; f 'a' &gt;&gt;= g &gt;&gt;= h $ 0\n0s\n&gt; f 'b' &gt;&gt;= g &gt;&gt;= h $ 1\n60s\n&gt; f 'c' &gt;&gt;= g &gt;&gt;= h $ 42\n42s\n&gt; f 'd' &gt;&gt;= g &gt;&gt;= h $ 2112\n2112s</pre>\n\t</p>\n\t<p>\n\t\tIn case you are wondering, 2,112 seconds is 35 minutes and 12 seconds, so all outputs fit with the results reported for the C# example.\n\t</p>\n\t<p>\n\t\tWhat the above Haskell GHCi (<a href=\"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop\">REPL</a>) session demonstrates is that it's possible to compose functions with Haskell's monadic bind operator <code>&gt;&gt;=</code> operator exactly because all functions are (Reader) monads.\n\t</p>\n\t<h3 id=\"fb5e50be9b66464ca61cd4a45eb7e756\">\n\t\tConclusion <a href=\"#fb5e50be9b66464ca61cd4a45eb7e756\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tIn Haskell, it can occasionally be useful that a function can be used when a <code>Monad</code> is required. Some Haskell libraries are defined in very general terms. Their APIs may enable you to call functions with any monadic input value. You can, say, pass a <a href=\"/2022/04/25/the-maybe-monad\">Maybe</a>, a <a href=\"/2022/04/19/the-list-monad\">List</a>, an <a href=\"/2022/05/09/an-either-monad\">Either</a>, a State, but you can also pass a function.\n\t</p>\n\t<p>\n\t\tC# and most other languages (F# included) doesn't come with that level of abstraction, so the fact that a function forms a monad is less useful there. In fact, I can't recall having made explicit use of this knowledge in C#, but one never knows if that day arrives.\n\t</p>\n\t<p>\n\t\tIn a similar vein, knowing that <a href=\"/2018/04/16/endomorphic-composite-as-a-monoid\">endomorphisms form monoids</a> (and thereby also <a href=\"/2017/11/27/semigroups\">semigroups</a>) enabled me to <a href=\"/2020/12/14/validation-a-solved-problem\">quickly identify the correct design for a validation problem</a>.\n\t</p>\n\t<p>\n\t\tWho knows? One day the knowledge that functions are monads may come in handy.\n\t</p>\n\t<p>\n\t\t<strong>Next:</strong> The IO monad.\n\t</p>\n</div><hr>\n   \t\tThis blog is totally free, but if you like it, please consider <a href=\"https://blog.ploeh.dk/support\">supporting it</a>."
}