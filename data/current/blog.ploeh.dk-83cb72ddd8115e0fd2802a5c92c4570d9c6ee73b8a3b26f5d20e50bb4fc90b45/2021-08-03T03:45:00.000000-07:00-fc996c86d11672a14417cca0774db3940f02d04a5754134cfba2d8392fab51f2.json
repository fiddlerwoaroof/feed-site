{
  "title":"The Tennis kata revisited",
  "date":"2021-08-03T03:45:00.000000-07:00",
  "author":"Mark Seemann",
  "id":"https://blog.ploeh.dk/2021/08/03/the-tennis-kata-revisited",
  "link":"https://blog.ploeh.dk/2021/08/03/the-tennis-kata-revisited/",
  "content":"\n\n\n<div id=\"post\">\n\t<p>\n\t\t<em>When you need discriminated unions, but all you have are objects.</em>\n\t</p>\n\t<p>\n\t\tAfter I learned that <a href=\"/2018/06/25/visitor-as-a-sum-type\">the Visitor design pattern is isomorphic to sum types</a> (AKA <a href=\"https://docs.microsoft.com/dotnet/fsharp/language-reference/discriminated-unions\">discriminated unions</a>), I wanted to try how easy it is to carry out a translation in practice. For that reason, I decided to translate my go-to <a href=\"https://fsharp.org\">F#</a> implementation of the <a href=\"https://codingdojo.org/kata/Tennis\">Tennis kata</a> to C#, using the <a href=\"https://en.wikipedia.org/wiki/Visitor_pattern\">Visitor design pattern</a> everywhere I'd use a discriminated union in F#.\n\t</p>\n\t<p>\n\t\tThe resulting C# code shows that it is, indeed, possible to 'mechanically' translate discriminated unions to the Visitor design pattern. Given that the Visitor pattern requires multiple interfaces and classes to model just a single discriminated union, it's no surprise that the resulting code is much more complex. As a solution to the Tennis kata itself, all this complexity is unwarranted. On the other hand, as an exercise in getting by with the available tools, it's quite illustrative. If all you have is C# (or a similar language), but you really need discriminated unions, the solution is ready at hand. It'll be complex, but not complicated.\n\t</p>\n\t<p>\n\t\tThe main insight of this exercise is that translating any discriminated union to a Visitor is, indeed, possible. You can best internalise such insights, however, if you actually do the work yourself. Thus, in this article, I'll only show a few highlights from my own exercise. I highly recommend that you try it yourself.\n\t</p>\n\t<h3 id=\"5667e0a2df95411da703aab3df3ddcb3\">\n\t\tTypical F# solution <a href=\"#5667e0a2df95411da703aab3df3ddcb3\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tYou can see my typical F# solution in great detail in my article series <a href=\"/2016/02/10/types-properties-software\">Types + Properties = Software</a>. To be clear, there are many ways to implement the Tennis kata, even in F#, and the one shown in the articles is neither overly clever nor <a href=\"/2021/03/29/table-driven-tennis-scoring\">too boring</a>. As implementations go, this one is quite pedestrian.\n\t</p>\n\t<p>\n\t\tMy emphasis with that kind of solution to the Tennis kata is on readability, correctness, and testability. Going for <a href=\"/2018/11/19/functional-architecture-a-definition\">a functional architecture</a> automatically <a href=\"/2015/05/07/functional-design-is-intrinsically-testable\">addresses the testability concern</a>. In F#, I endeavour to use the excellent type system to <a href=\"https://blog.janestreet.com/effective-ml-video\">make illegal states unrepresentable</a>. Discriminated unions are essential ingredients in that kind of design.\n\t</p>\n\t<p>\n\t\tIn F#, I'd typically <a href=\"/2016/02/10/types-properties-software-designing-with-types\">model a Tennis game score as a discriminated union</a> like this:\n\t</p>\n\t<p>\n\t\t<pre><span>type</span> <span>Score</span> =\n| <span>Points</span> <span>of</span> <span>PointsData</span>\n| <span>Forty</span> <span>of</span> <span>FortyData</span>\n| <span>Deuce</span>\n| <span>Advantage</span> <span>of</span> <span>Player</span>\n| <span>Game</span> <span>of</span> <span>Player</span></pre>\n\t</p>\n\t<p>\n\t\tThat's not the only discriminated union involved in the implementation. <code>Player</code> is also a discriminated union, and both <code>PointsData</code> and <code>FortyData</code> compose a third discriminated union called <code>Point</code>:\n\t</p>\n\t<p>\n\t\t<pre><span>type</span> <span>Point</span> = <span>Love</span> | <span>Fifteen</span> | <span>Thirty</span></pre>\n\t</p>\n\t<p>\n\t\tPlease refer to <a href=\"/2016/02/10/types-properties-software-designing-with-types\">the older article</a> for full details of the F# 'domain model'.\n\t</p>\n\t<p>\n\t\tThis was the sort of design I wanted to try to translate to C#, using the Visitor design pattern in place of discriminated unions.\n\t</p>\n\t<h3 id=\"90107f78b2a64ad288c62905aca58011\">\n\t\tPlayer <a href=\"#90107f78b2a64ad288c62905aca58011\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tIn F# you must declare all types and functions before you can use them. To newcomers, this often looks like a constraint, but is <a href=\"/2015/04/15/c-will-eventually-get-all-f-features-right\">actually one of F#'s greatest strengths</a>. Since other types transitively use the <code>Player</code> discriminated union, this is the first type you have to define in an F# code file:\n\t</p>\n\t<p>\n\t\t<pre><span>type</span> <span>Player</span> = <span>PlayerOne</span> | <span>PlayerTwo</span></pre>\n\t</p>\n\t<p>\n\t\tThis one is fairly straightforward to translate to C#. You might reach for an <code>enum</code>, but those aren't really type-safe in C#, since they're little more than glorified integers. Using a discriminated union is safer, so define a Visitor:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>interface</span> <span>IPlayerVisitor</span>&lt;<span>T</span>&gt;\n{\n    T <span>VisitPlayerOne</span>();\n \n    T <span>VisitPlayerTwo</span>();\n}</pre>\n\t</p>\n\t<p>\n\t\tA Visitor interface is where you enumerate the cases of the discriminated union - in this example <em>player one</em> and <em>player two</em>. You can <a href=\"/2015/08/03/idiomatic-or-idiosyncratic\">idiomatically</a> prefix each method with <code>Visit</code> as I've done here, but that's optional.\n\t</p>\n\t<p>\n\t\tOnce you've defined the Visitor, you can declare the 'actual' type you're modelling: the player:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>interface</span> <span>IPlayer</span>\n{\n    T <span>Accept</span>&lt;<span>T</span>&gt;(IPlayerVisitor&lt;T&gt; <span>visitor</span>);\n}</pre>\n\t</p>\n\t<p>\n\t\tThose are only the polymorphic types required to model the discriminated union. You also need to add concrete classes for each of the cases. Here's <code>PlayerOne</code>:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>struct</span> <span>PlayerOne</span> : IPlayer\n{\n    <span>public</span> T <span>Accept</span>&lt;<span>T</span>&gt;(IPlayerVisitor&lt;T&gt; <span>visitor</span>)\n    {\n        <span>return</span> visitor.VisitPlayerOne();\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tThis is an example of the Visitor pattern's central <em>double dispatch</em> mechanism. Clients of the <code>IPlayer</code> interface will dispatch execution to the <code>Accept</code> method, which again dispatches execution to the <code>visitor</code>.\n\t</p>\n\t<p>\n\t\tI decided to make <code>PlayerOne</code> a <code>struct</code> because it holds no data. Perhaps I <a href=\"/2021/03/08/pendulum-swing-sealed-by-default\">also ought to have sealed it</a>, or, as <a href=\"http://amzn.to/XBYukB\">Design Patterns</a> likes to suggest, make it a <a href=\"https://en.wikipedia.org/wiki/Singleton_pattern\">Singleton</a>.\n\t</p>\n\t<p>\n\t\tHardly surprising, <code>PlayerTwo</code> looks almost identical to <code>PlayerOne</code>.\n\t</p>\n\t<p>\n\t\tApart from a <a href=\"https://fsharpforfunandprofit.com/posts/designing-with-types-single-case-dus\">single-case discriminated union</a> (which is degenerate), a discriminated union doesn't get any simpler than <code>Player</code>. It has only two cases and carries no data. Even so, it takes <em>four</em> types to translate it to a Visitor: two interfaces and two concrete classes. This highlights how the Visitor pattern adds significant complexity.\n\t</p>\n\t<p>\n\t\tAnd it only gets worse with more complex discriminated unions.\n\t</p>\n\t<h3 id=\"1ce1c4cb87894ae183799a140a9001fe\">\n\t\tScore <a href=\"#1ce1c4cb87894ae183799a140a9001fe\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tI'm going to leave the translation of <code>Point</code> as an exercise. It's similar to the translation of <code>Player</code>, but instead of two cases, it enumerates three cases. Instead, consider how to enumerate the cases of <code>Score</code>. First, add a Visitor:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>interface</span> <span>IScoreVisitor</span>&lt;<span>T</span>&gt;\n{\n    T <span>VisitPoints</span>(IPoint <span>playerOnePoint</span>, IPoint <span>playerTwoPoint</span>);\n \n    T <span>VisitForty</span>(IPlayer <span>player</span>, IPoint <span>otherPlayerPoint</span>);\n \n    T <span>VisitDeuce</span>();\n \n    T <span>VisitAdvantage</span>(IPlayer <span>advantagedPlayer</span>);\n \n    T <span>VisitGame</span>(IPlayer <span>playerWhoWonGame</span>);\n}</pre>\n\t</p>\n\t<p>\n\t\tNotice that these methods take arguments, apart from <code>VisitDeuce</code>. I could have made that member a read-only property instead, but for consistency's sake, I kept it as a method.\n\t</p>\n\t<p>\n\t\tAll the other methods take arguments that are, in their own right, Visitors.\n\t</p>\n\t<p>\n\t\tIn addition to the Visitor interface, you also need an interface to model the score itself:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>interface</span> <span>IScore</span>\n{\n    T <span>Accept</span>&lt;<span>T</span>&gt;(IScoreVisitor&lt;T&gt; <span>visitor</span>);\n}</pre>\n\t</p>\n\t<p>\n\t\tThis one defines, as usual, just a single <code>Accept</code> method.\n\t</p>\n\t<p>\n\t\tSince <code>IScoreVisitor</code> enumerates five distinct cases, you must also add five concrete implementations of <code>IScore</code>. Here's <code>Forty</code>:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>struct</span> <span>Forty</span> : IScore\n{\n    <span>private</span> <span>readonly</span> IPlayer player;\n    <span>private</span> <span>readonly</span> IPoint otherPlayerPoint;\n \n    <span>public</span> <span>Forty</span>(IPlayer <span>player</span>, IPoint <span>otherPlayerPoint</span>)\n    {\n        <span>this</span>.player = player;\n        <span>this</span>.otherPlayerPoint = otherPlayerPoint;\n    }\n \n    <span>public</span> T <span>Accept</span>&lt;<span>T</span>&gt;(IScoreVisitor&lt;T&gt; <span>visitor</span>)\n    {\n        <span>return</span> visitor.VisitForty(player, otherPlayerPoint);\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tI'm leaving other concrete classes as an exercise to the reader. All of them are similar, though, in that they all implement <code>IScore</code> and unconditionally dispatch to 'their' method on <code>IScoreVisitor</code> - <code>Forty</code> calls <code>VisitForty</code>, <code>Points</code> calls <code>VisitPoints</code>, and so on. Each concrete implementation has a distinct constructor, though, since what they need to dispatch to the Visitor differs.\n\t</p>\n\t<p>\n\t\t<code>Deuce</code>, being degenerate, doesn't have to explicitly define a constructor:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>struct</span> <span>Deuce</span> : IScore\n{\n    <span>public</span> T <span>Accept</span>&lt;<span>T</span>&gt;(IScoreVisitor&lt;T&gt; <span>visitor</span>)\n    {\n        <span>return</span> visitor.VisitDeuce();\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tThe C# compiler automatically adds a parameterless constructor when none is defined. An alternative implementation would, again, be to make <code>Deuce</code> a Singleton.\n\t</p>\n\t<p>\n\t\tIn all, it takes seven types (two interfaces and five concrete classes) to model <code>Score</code> - a type that requires only a few lines of code in F# (six lines in my code, but you could format it more densely if you want to compromise readability).\n\t</p>\n\t<h3 id=\"6ac8c03643eb454f9dfcc76365d7ef2e\">\n\t\tKeeping score <a href=\"#6ac8c03643eb454f9dfcc76365d7ef2e\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tIn order to calculate the score of a game, I also translated the <code>score</code> function. I put that in an <a href=\"https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/extension-methods\">extension method</a> so as to not 'pollute' the <code>IScore</code> interface:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> IScore <span>BallTo</span>(<span>this</span> IScore <span>score</span>, IPlayer <span>playerWhoWinsBall</span>)\n{\n    <span>return</span> score.Accept(<span>new</span> ScoreVisitor(playerWhoWinsBall));\n}</pre>\n\t</p>\n\t<p>\n\t\tGiven an <code>IScore</code> value, there's little you can do with it, apart from calling its <code>Accept</code> method. In order to do that, you'll need an <code>IScoreVisitor</code>, which I defined as a private nested class:\n\t</p>\n\t<p>\n\t\t<pre><span>private</span> <span>class</span> <span>ScoreVisitor</span> : IScoreVisitor&lt;IScore&gt;\n{\n    <span>private</span> <span>readonly</span> IPlayer playerWhoWinsBall;\n \n    <span>public</span> <span>ScoreVisitor</span>(IPlayer <span>playerWhoWinsBall</span>)\n    {\n        <span>this</span>.playerWhoWinsBall = playerWhoWinsBall;\n    }\n \n    <span>// Implementation goes here...</span></pre>\n\t</p>\n\t<p>\n\t\tSome of the methods are trivial to implement, like <code>VisitDeuce</code>:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> IScore <span>VisitDeuce</span>()\n{\n    <span>return</span> <span>new</span> Advantage(playerWhoWinsBall);\n}</pre>\n\t</p>\n\t<p>\n\t\tMost others are more complicated. Keep in mind that the method arguments (<code>IPlayer</code>, <code>IPoint</code>) are Visitors in their own right, so in order to do anything useful with them, you'll have to call their <code>Accept</code> methods with a corresponding, specialised Visitor.\n\t</p>\n\t<h3 id=\"054ae9485c294ba2a9b9029271f540fa\">\n\t\tPattern matching <a href=\"#054ae9485c294ba2a9b9029271f540fa\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tI quickly realised that this would become too tedious, even for an exercise, so I leveraged my knowledge that the Visitor pattern is isomorphic to a <a href=\"/2018/05/22/church-encoding\">Church encoding</a>. Instead of defining umpteen specialised Visitors, I just defined a generic <code>Match</code> method for each Visitor-based object. I put those in extension methods as well. Here's the <code>Match</code> method for <code>IPlayer</code>:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> T <span>Match</span>&lt;<span>T</span>&gt;(<span>this</span> IPlayer <span>player</span>, T <span>playerOne</span>, T <span>playerTwo</span>)\n{\n    <span>return</span> player.Accept(<span>new</span> MatchVisitor&lt;T&gt;(playerOne, playerTwo));\n}</pre>\n\t</p>\n\t<p>\n\t\tThe implementation is based on a private nested <code>MatchVisitor</code>:\n\t</p>\n\t<p>\n\t\t<pre><span>private</span> <span>class</span> <span>MatchVisitor</span>&lt;<span>T</span>&gt; : IPlayerVisitor&lt;T&gt;\n{\n    <span>private</span> <span>readonly</span> T playerOneValue;\n    <span>private</span> <span>readonly</span> T playerTwoValue;\n \n    <span>public</span> <span>MatchVisitor</span>(T <span>playerOneValue</span>, T <span>playerTwoValue</span>)\n    {\n        <span>this</span>.playerOneValue = playerOneValue;\n        <span>this</span>.playerTwoValue = playerTwoValue;\n    }\n \n    <span>public</span> T <span>VisitPlayerOne</span>()\n    {\n        <span>return</span> playerOneValue;\n    }\n \n    <span>public</span> T <span>VisitPlayerTwo</span>()\n    {\n        <span>return</span> playerTwoValue;\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tThis enables pattern matching, upon which you can implement other reusable methods, such as <code>Other</code>:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> IPlayer <span>Other</span>(<span>this</span> IPlayer <span>player</span>)\n{\n    <span>return</span> player.Match&lt;IPlayer&gt;(\n        playerOne: <span>new</span> PlayerTwo(),\n        playerTwo: <span>new</span> PlayerOne());\n}</pre>\n\t</p>\n\t<p>\n\t\tIt's also useful to be able to compare two players and return two alternative values depending on the result:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> T <span>Equals</span>&lt;<span>T</span>&gt;(\n    <span>this</span> IPlayer <span>p1</span>,\n    IPlayer <span>p2</span>,\n    T <span>same</span>,\n    T <span>different</span>)\n{\n    <span>return</span> p1.Match(\n        playerOne: p2.Match(\n            playerOne: same,\n            playerTwo: different),\n        playerTwo: p2.Match(\n            playerOne: different,\n            playerTwo: same));\n}</pre>\n\t</p>\n\t<p>\n\t\tYou can add similar <code>Match</code> and <code>Equals</code> extension methods for <code>IPoint</code>, which enables you to implement all the methods of the <code>ScoreVisitor</code> class. Here's <code>VisitForty</code> as an example:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> IScore <span>VisitForty</span>(IPlayer <span>player</span>, IPoint <span>otherPlayerPoint</span>)\n{\n    <span>return</span> playerWhoWinsBall.Equals(player,\n        same: <span>new</span> Game(player),\n        different: otherPlayerPoint.Match&lt;IScore&gt;(\n            love: <span>new</span> Forty(player, <span>new</span> Fifteen()),\n            fifteen: <span>new</span> Forty(player, <span>new</span> Thirty()),\n            thirty: <span>new</span> Deuce()));\n}</pre>\n\t</p>\n\t<p>\n\t\tIf <code>playerWhoWinsBall.Equals(player</code> the implementation matches on <code>same</code>, and returns <code>new Game(player)</code>. Otherwise, it matches on <code>different</code>, in which case it then has to <code>Match</code> on <code>otherPlayerPoint</code> to figure out what to return.\n\t</p>\n\t<p>\n\t\tAgain, I'll leave the remaining code as an exercise to the reader.\n\t</p>\n\t<h3 id=\"f476c043ca9548b58f874fb0b87aaf70\">\n\t\tTests <a href=\"#f476c043ca9548b58f874fb0b87aaf70\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tWhile all this code is written in C#, it's all <a href=\"https://en.wikipedia.org/wiki/Pure_function\">pure functions</a>. Thus, <a href=\"/2015/05/07/functional-design-is-intrinsically-testable\">it's intrinsically testable</a>. Knowing that, I could have added tests after writing the 'production code', but that's so boring, so I still developed this code base using test-driven development. Here's an example of a test:\n\t</p>\n\t<p>\n\t\t<pre>[Theory, MemberData(nameof(Player))]\n<span>public</span> <span>void</span> <span>TransitionFromDeuce</span>(IPlayer <span>player</span>)\n{\n    <span>var</span> <span>sut</span> = <span>new</span> Deuce();\n \n    <span>var</span> <span>actual</span> = sut.BallTo(player);\n \n    <span>var</span> <span>expected</span> = <span>new</span> Advantage(player);\n    Assert.Equal(expected, actual);\n}</pre>\n\t</p>\n\t<p>\n\t\tI wrote all tests as <a href=\"/2020/08/31/properties-for-all\">properties for all</a>. The above test uses <a href=\"https://xunit.net\">xUnit.net</a> 2.4.0. The <code>Player</code> data source is a private <code>MemberData</code> defined as a read-only property:\n\t</p>\n\t<p>\n\t\t<pre><span>public</span> <span>static</span> IEnumerable&lt;<span>object</span>[]&gt; Player\n{\n    <span>get</span>\n    {\n        <span>yield</span> <span>return</span> <span>new</span> <span>object</span>[] { <span>new</span> PlayerOne() };\n        <span>yield</span> <span>return</span> <span>new</span> <span>object</span>[] { <span>new</span> PlayerTwo() };\n    }\n}</pre>\n\t</p>\n\t<p>\n\t\tOther tests are defined in a likewise manner.\n\t</p>\n\t<h3 id=\"720181cad99a4cd79c41435d622a949b\">\n\t\tConclusion <a href=\"#720181cad99a4cd79c41435d622a949b\" title=\"permalink\">#</a>\n\t</h3>\n\t<p>\n\t\tOnce you've tried to solve problems with <a href=\"https://en.wikipedia.org/wiki/Algebraic_data_type\">algebraic data types</a> it can be frustrating to return to languages that don't have <a href=\"https://en.wikipedia.org/wiki/Tagged_union\">sum types</a> (discriminated unions). There's no need to despair, though. Sum types are isomorphic to the Visitor design pattern, so it <em>is</em> possible to solve problems in the same way.\n\t</p>\n\t<p>\n\t\tThe resulting code can easily <em>seem</em> complex because a simple discriminated union translates to multiple C# files. Another option is to use Church encoding, but many developers who consider themselves object-oriented often balk at such constructs. When it comes to policy, the Visitor design pattern offers the advantage that it's described in <a href=\"http://amzn.to/XBYukB\">Design Patterns</a>. While it may be a bit of an underhanded tactic, it effectively deals with some teams' resistance to ideas originating in functional programming.\n\t</p>\n\t<p>\n\t\tThe exercise outlined in this article demonstrates that translating from algebraic data types to patterns-based object-oriented code is not only possible, but (once you get the hang of it) unthinking and routine. It's entirely automatable, so you could even imagine defining a <a href=\"https://en.wikipedia.org/wiki/Domain-specific_language\">DSL</a> for defining sum types and transpiling them to C#.\n\t</p>\n\t<p>\n\t\tBut really, you don't have to, because <a href=\"https://fsharp.org\">such a DSL already exists</a>.\n\t</p>\n</div>\n\n<div id=\"comments\">\n\t<hr>\n\t<h2 id=\"comments-header\">\n\t\tComments\n\t</h2>\n\t\n\t<div class=\"comment\" id=\"efdd9051556447b8be4831a793c1bbbf\">\n\t\t<div class=\"comment-author\"><a href=\"https://github.com/Joker-vD\">Joker_vD</a></div>\n\t\t<div class=\"comment-content\">\n\t\t\t<p>\n\t\t\t\tThe most annoying thing about the visitor pattern is that you can't get around declaring\n\t\t\t\t<code>interface IMyLovelyADT { R Accept&lt;R&gt;(IMyLovelyADTVisitor&lt;R&gt; visitor); }</code>\n\t\t\t\tand a separate class implementing this interface for each data variant. One may think that this interface is isomorphic to\n\t\t\t\t<code>Func&lt;IMyLovelyADTVisitor&lt;R&gt;, R&gt;</code> but it actually is not, look:\n\t\t\t</p>\n\t\t\t\n\t\t\t<p><pre>// type Bool = True | False\ninterface IBoolVisitor&lt;R&gt;\n{\n    R True();\n    R False();\n}\n\nstatic class BoolUtils\n{\n    public static Func&lt;IBoolVisitor&lt;R&gt;, R&gt; True&lt;R&gt;() =&gt; sym =&gt; sym.True();\n    public static Func&lt;IBoolVisitor&lt;R&gt;, R&gt; False&lt;R&gt;() =&gt; sym =&gt; sym.False();\n\n    private class BoolMatcher&lt;R&gt; : IBoolVisitor&lt;R&gt;\n    {\n        Func&lt;R&gt; OnTrue { get; }\n        Func&lt;R&gt; OnFalse { get; }\n\n        public BoolMatcher(Func&lt;R&gt; onTrue, Func&lt;R&gt; onFalse)\n        {\n            OnTrue = onTrue;\n            OnFalse = onFalse;\n        }\n\n        public R True() =&gt; OnTrue();\n        public R False() =&gt; OnFalse();\n    }\n\n    public static R Match&lt;R&gt;(this Func&lt;IBoolVisitor&lt;R&gt;, R&gt; value, Func&lt;R&gt; onTrue, Func&lt;R&gt; onFalse) =&gt; value(new BoolMatcher&lt;R&gt;(onTrue, onFalse));\n}</pre></p>\n\t\t\t<p>\n\t\t\t\tYes, all this typechecks and compiles, and you can even write <code>ShowBool</code> and <code>BoolToInt</code> methods, but!\n\t\t\t\tYou can't combine them:\n\t\t\t</p>\n\t\t\n\t\t\t<p><pre>static class FunctionsAttempt1\n{\n    public static string ShowBool(Func&lt;IBoolVisitor&lt;string&gt;, string&gt; value)\n    {\n        return value.Match(() =&gt; &quot;True&quot;, () =&gt; &quot;False&quot;);\n    }\n\n    public static int BoolToInt(Func&lt;IBoolVisitor&lt;int&gt;, int&gt; value)\n    {\n        return value.Match(() =&gt; 1, () =&gt; 0);\n    }\n\n    public static string CombineBoolFunctions&lt;R&gt;(Func&lt;IBoolVisitor&lt;R&gt;, R&gt; value)\n    {\n        return ShowBool(value) + &quot;: &quot; + BoolToInt(value).ToString();\n    }\n}</pre></p>\n\t\n\t\t\t<p>\n\t\t\t\tThe first two methods are fine, but <code>CombineBoolFunctions</code> doesn't compile, because you can't pass\n\t\t\t\t<code>Func&lt;IBoolVisitor&lt;R&gt;, R&gt;</code> to a method that expects\n\t\t\t\t<code>Func&lt;IBoolVisitor&lt;string&gt;, string&gt;</code>.\n\t\t\t\tWhat if you try to make <code>ShowBool</code> and <code>BoolToInt</code> accept <code>Func&lt;IBoolVisitor&lt;R&gt;, R&gt;</code>?\n\t\t\t</p>\n\t\n\t\t\t<p><pre>static class FunctionsAttempt2\n{\n    public static string ShowBool</pre></p>\n\n\t\t\t<p>\n\t\t\t\tThat also doesn't work, for pretty much the same reason: <code>CombineBoolFunctions</code> compiles now, but not\n\t\t\t\t<code>ShowBool</code> or <code>BoolToInt</code>. That's why you need a <em>non-generic</em> wrapper interface <code>IMyLovelyADT</code>:\n\t\t\t\tit essentially does the same job as Haskell's <code>forall</code>, since generic types are not quite proper types in C#'s type system.\n\t\t\t\tInterestingly enough, upcoming Go 2's generics will <em>not</em> support this scenario: a method inside an interface will be able to use\n\t\t\t\tonly the generic parameters that the interface itself declares.\n\t\t\t</p>\t\t\t\n\t\t</div>\n\t\t<div class=\"comment-date\">2021-08-06 20:47 UTC</div>\n\t</div>\n\n\t<div class=\"comment\" id=\"e9b335c980b649ccb18a015868b55763\">\n\t\t<div class=\"comment-author\"><a href=\"/\">Mark Seemann</a></div>\n\t\t<div class=\"comment-content\">\n\t\t\t<p>\n\t\t\t\tJoker_vD, thank you for writing; you explained that well.\n\t\t\t</p>\n\t\t</div>\n\t\t<div class=\"comment-date\">2021-08-07 20:25 UTC</div>\n\t</div>\n\t\n\t<div class=\"comment\" id=\"d385b2cd13834e19b587a5d80048794e\">\n\t\t<div class=\"comment-author\">Tyrie Vella</div>\n\t\t<div class=\"comment-content\">\n\t\t\t<p>\n\t\t\t\tI've recently been using C# 9's <code>record</code> feature to implement ADTs. For example:\n\t\t\t</p>\n\t\t\t<p><pre>\npublic abstract record Player\n{\n\tprivate Player() {}\n\t\n\tpublic sealed record One : Player;\n\tpublic sealed record Two : Player;\n}\n\npublic abstract record Point\n{\n\tprivate Point() {}\n\t\n\tpublic sealed record Love: Point;\n\tpublic sealed record Fifteen: Point;\n\tpublic sealed record Thirty: Point;\n}\n\npublic abstract record Score\n{\n\tprivate Score() {}\n\t\n\tpublic sealed record Points(Point PlayerOnePoints, Point PlayerTwoPoints);\n\tpublic sealed record Forty(Player Player, Point OtherPlayersPoint);\n\tpublic sealed record Deuce;\n\tpublic sealed record Advantage(Player Player);\n\tpublic sealed record Game(Player Player);\n}\n\t\t\t</pre></p>\n\t\t\t<p>\n\t\t\t\tIt's not as good as F# ADTs, but it's more concise than Visitors, works with <code>switch</code> pattern matching,\n\t\t\t\thas structural equality semantics, and I haven't found the downside yet.\n\t\t\t</p>\n\t\t</div>\n\t\t<div class=\"comment-date\">2021-08-17 00:16 UTC</div>\n\t</div>\n\n\t<div class=\"comment\" id=\"33ae4341e1b44975b0171c0f99bbe263\">\n\t\t<div class=\"comment-author\"><a href=\"/\">Mark Seemann</a></div>\n\t\t<div class=\"comment-content\">\n\t\t\t<p>\n\t\t\t\tTyrie, thank you for writing. I haven't tried that yet, but I agree that if this works, it's simpler.\n\t\t\t</p>\n\t\t\t<p>\n\t\t\t\tDoes <code>switch</code> pattern matching check exhaustiveness? What I means is: With sum types/discriminated unions, as well as with the Visitor pattern, the compiler can tell you if you haven't covered all cases. Does the C# compiler also do that with <code>switch</code> pattern matching?\n\t\t\t</p>\n\t\t\t<p>\n\t\t\t\tAnd do you need to include a <code>default</code> label?\n\t\t\t</p>\n\t\t</div>\n\t\t<div class=\"comment-date\">2021-08-17 5:39 UTC</div>\n\t</div>\n\t\n\t<div class=\"comment\" id=\"9bd1ef73f41243f6bb02f0825ccc245b\">\n\t\t<div class=\"comment-author\">Tyrie Vella</div>\n\t\t<div class=\"comment-content\">\n\t\t\t<p>\n\t\t\t\tLooks like you found the flaw. The C# compiler tries, and it will block invalid cases, but it always wants a default case (either <code>_</code> or both <code>&quot;null&quot;</code> and <code>&quot;not null&quot;</code>)\n\t\t\t\twhen switching on one of these. It can't suggest the actually missing cases.\n\t\t\t</p>\n\t\t\t&lt;p&gt;\n\t\t\t\tIt's also only a warning by default at compile time.\n\t\t\t&lt;p&gt;\n\t\t</div>\n\t\t<div class=\"comment-date\">2021-08-17 15:43 UTC</div>\n\t</div>\n</hr></div>\n<hr>\n   \t\tThis blog is totally free, but if you like it, please consider <a href=\"https://blog.ploeh.dk/support\">supporting it</a>.</hr>"
}