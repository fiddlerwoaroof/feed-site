{
  "title":"data, transformation, and PROOF!",
  "date":"2021-08-30T20:55:38.000000-07:00",
  "author":"/u/stuudente",
  "id":"t3_pey8vk",
  "link":"https://www.reddit.com/r/lisp/comments/pey8vk/data_transformation_and_proof/",
  "content":"<div class=\"md\"><p>Most of programming boils down to data and transformation, at least traditionally. Recently it seems that there are more and more need to include <code>PROOF</code> into the paradigm. What do I mean?</p> <p>Well, data and transformation are nice, but it will be great if we can easily argue if, say, a function is going to act exactly as we expect! The old way is to write some tests, and hopefully no edge cases slip through. However, for some scenario having a strong proof could be useful and eventually save us time!</p> <p>For example, in Haskell or typed Racket, we must attach a type to a function. This way <a href=\"https://www.youtube.com/watch?v=XTl7Jn_kmio\">eliminates</a> a lot of long-term bugs! I hope to bring this to a stronger extreme, and define a paradigm in which functions' behaviors can be argued.</p> <p>Lisp is of course fully extendable, so I wonder how I can achieve that with it. Namely, how to define a new class of functions that are more predicable, in the sense that a rigorous proof can be provided?</p> <p>E.g.</p> <pre><code>(defvar *proof* #|insert-a-mathematical-proof|#) (equalf (lambda (n) (apply #'+ (loop for k from 1 to n collect k)) ;; 1+2+..+n (lambda (n) (/ (* n (+ n 1)) 2))) ;; n(n+1)/2 :proof *proof* :class 'N-&gt;N) ;; =&gt; t (is-pure-function (lambda () 1)) ;; =&gt; t (is-pure-function (lambda () *X*) ;; =&gt; nil </code></pre> </div>   submitted by   <a href=\"https://www.reddit.com/user/stuudente\"> /u/stuudente </a>   to   <a href=\"https://www.reddit.com/r/lisp/\"> r/lisp </a> <br> <span><a href=\"https://www.reddit.com/r/lisp/comments/pey8vk/data_transformation_and_proof/\">[link]</a></span>   <span><a href=\"https://www.reddit.com/r/lisp/comments/pey8vk/data_transformation_and_proof/\">[comments]</a></span>"
}