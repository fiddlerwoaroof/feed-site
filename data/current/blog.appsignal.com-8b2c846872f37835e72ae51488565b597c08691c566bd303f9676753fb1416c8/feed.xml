<?xml version="1.0" encoding="UTF-8"?>
  <feed xmlns="http://www.w3.org/2005/Atom">
    <title>Ruby Magic by AppSignal</title>
    <subtitle>Dive deep into all things Ruby. If you are interested in learning more about concurrency, webservers, memory allocations and garbage collection, you'll love this.</subtitle>
    <id>https://blog.appsignal.com</id>
    <link href="https://blog.appsignal.com">
    <link href="https://blog.appsignal.com/ruby-magic-feed.xml" rel="self">
    <updated>2022-11-17T10:00:00+00:00</updated>
    <author>
      <name>Roy Tomeij</name>
    </author>
    
  <entry>
    <title>How to Scale Ruby on Rails Applications</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/11/09/how-to-scale-ruby-on-rails-applications.html">
    <id>https://blog.appsignal.com/2022/11/09/how-to-scale-ruby-on-rails-applications.html</id>
    <published>2022-11-09T00:00:00+00:00</published>
    <updated>2022-11-09T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Check out some ways to scale your Ruby on Rails applications, including with caching and background workers.</summary>
    <content type="html">&lt;p&gt;Today we will dive into some strategies you can use to scale Ruby on Rails applications to a huge user base.&lt;/p&gt;
&lt;p&gt;One obvious way of scaling applications is to throw more money at them. And it works amazingly well — add a few more servers, upgrade your database server, and voila, a lot of the performance issues just go &lt;em&gt;poof&lt;/em&gt;!&lt;/p&gt;
&lt;p&gt;But it is often also possible to scale applications without adding more servers. That&amp;#39;s what we will discuss today.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s get going!&lt;/p&gt;
&lt;h2 id=&quot;use-appsignal-for-your-rails-application&quot;&gt;Use AppSignal for your Rails Application&lt;/h2&gt;
&lt;p&gt;Before we dive into scaling and performance optimization, you first need to identify &lt;em&gt;if&lt;/em&gt; you need to do this, what the bottlenecks are in your application, and what resources can be scaled.&lt;/p&gt;
&lt;p&gt;One easy way to do this is to use &lt;a href=&quot;https://www.appsignal.com/ruby&quot;&gt;AppSignal&amp;#39;s performance monitoring and metrics for Ruby&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://www.appsignal.com/tour/performance&quot;&gt;performance dashboard&lt;/a&gt; helps you pinpoint the exact controller actions and background jobs that are slow on average.&lt;/p&gt;
&lt;p&gt;For example, here&amp;#39;s how a performance dashboard might look for ActiveRecord:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-11/activerecord.png&quot; alt=&quot;ActiveRecord dashboard&quot;/&gt;&lt;/p&gt;
&lt;p&gt;This gives a good starting point to any scaling journey — whether you decide to add more servers or optimize performance through code.&lt;/p&gt;
&lt;p&gt;Now let&amp;#39;s move on to one of the simplest techniques you can use to scale your Rails app — caching.&lt;/p&gt;
&lt;h2 id=&quot;caching-in-ruby-on-rails&quot;&gt;Caching in Ruby on Rails&lt;/h2&gt;
&lt;p&gt;Caching allows you to stop computing the same things again and again.&lt;/p&gt;
&lt;p&gt;For example, let&amp;#39;s say you run a social media platform and there&amp;#39;s a very popular post. Caching can immediately help you regain all the CPU cycles you spend rendering that post for every user. And that&amp;#39;s only a part of what caching can help you do.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s look at all the possible resources that can be cached.&lt;/p&gt;
&lt;h3 id=&quot;caching-views&quot;&gt;Caching Views&lt;/h3&gt;
&lt;p&gt;Rendering views can sometimes be an expensive operation, especially when that view has a lot of data to be rendered. Even when the operation isn&amp;#39;t expensive, using a pre-rendered view will give you a lot of performance as opposed to rendering that same view a million times.&lt;/p&gt;
&lt;p&gt;Rails supports this out of the box using the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/CacheHelper.html#method-i-cache&quot;&gt;&lt;code&gt;cache&lt;/code&gt;&lt;/a&gt; view helper. For example, this is how it can cache each post when rendering a list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;lt;% @posts.each do |post| %&amp;gt;
  &amp;lt;% cache post do %&amp;gt;
    &amp;lt;%= render post %&amp;gt;
  &amp;lt;% end %&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For this, Rails automatically caches each post under a specific key that depends on the HTML content of the template, post id, and update timestamp.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;To read more about this technique, check out the posts &lt;a href=&quot;https://blog.appsignal.com/2018/03/20/fragment-caching-in-rails&quot;&gt;Fragment caching in Rails&lt;/a&gt; and &lt;a href=&quot;https://blog.appsignal.com/2018/08/14/rails-collection-caching&quot;&gt;Rails collection caching&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;One thing to keep in mind, though, is that the cache keys don’t include nested template content. So if you are nesting the cache calls deeper than one level, there might be stale results. Read more about this in &lt;a href=&quot;https://blog.appsignal.com/2018/04/03/russian-doll-caching-in-rails&quot;&gt;Russian doll caching in Rails&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;caching-responses&quot;&gt;Caching Responses&lt;/h3&gt;
&lt;p&gt;In addition to caching views/fragments, you can also choose to cache the full response of &lt;code&gt;GET&lt;/code&gt; requests. This is supported through the &lt;code&gt;If-None-Match&lt;/code&gt; and &lt;code&gt;If-Modified-Since&lt;/code&gt; headers sent by the browsers.&lt;/p&gt;
&lt;p&gt;When an &lt;code&gt;If-None-Match&lt;/code&gt; header is present on the request, the server can return a &lt;code&gt;304 Not Modified&lt;/code&gt; response with no content if there are no changes to the response. The server-computed &lt;code&gt;Etag&lt;/code&gt; is compared with the value inside that header.&lt;/p&gt;
&lt;p&gt;Similarly, if the &lt;code&gt;If-Modified-Since&lt;/code&gt; header is present without an &lt;code&gt;If-None-Match&lt;/code&gt;, the server can return a &lt;code&gt;304 Not Modified&lt;/code&gt; response with no content (as long as the response hasn’t changed since that date).&lt;/p&gt;
&lt;p&gt;Rails provides easy ways to do this inside controller actions. You can simply write:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class PostsController &amp;lt; ApplicationController
  def show
    @post = Post.find(params[:id])
    fresh_when last_modified: @post.updated_at.utc, etag: @post
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rails will send all the required headers to support caching, handle incoming headers, and respond with 304 when the data hasn’t changed. The server can skip rendering the full views again unless things change. You can read more about advanced configuration for this strategy in &lt;a href=&quot;https://blog.appsignal.com/2018/05/01/client-side-caching-in-rails-conditional-get-requests&quot;&gt;Client-side caching in Rails: conditional GET requests&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;caching-values&quot;&gt;Caching Values&lt;/h3&gt;
&lt;p&gt;Finally, it is also possible to cache raw values (anything that can be serialized to the cache store). This is usually useful to cache the results of resource-intensive or slow operations and avoid performing them again.&lt;/p&gt;
&lt;p&gt;Identifying a value that can benefit from this caching depends greatly on the application, but usually, looking at your slowest events can help point you in the correct direction.&lt;/p&gt;
&lt;p&gt;Finally, when you identify what to cache, the API that Rails provides for this is very simple to use:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Rails.cache.fetch(cache_key_with_version, expires_in: 12.hours) do
  perform_the_slow_computation
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code will &lt;code&gt;perform_the_slow_computation&lt;/code&gt; only once and then cache the value under the &lt;code&gt;cache_key_with_version&lt;/code&gt; key. The next time the same code is called, Rails will first check if we already have a cached value and use that instead of triggering &lt;code&gt;perform_the_slow_computation&lt;/code&gt; again.&lt;/p&gt;
&lt;p&gt;The most important part of this caching strategy is to compute a good cache key that depends on all the inputs used in the value&amp;#39;s computation. This is to ensure we don’t keep using a stale value.&lt;/p&gt;
&lt;h3 id=&quot;cache-stores&quot;&gt;Cache Stores&lt;/h3&gt;
&lt;p&gt;Now that we know what to cache and the techniques Rails provides to store things in the cache, the next logical question is — where do we cache this data? Rails comes with several in-built cache store adapters. The most popular cache stores for production use cases are &lt;a href=&quot;https://redis.io/&quot;&gt;Redis&lt;/a&gt; and &lt;a href=&quot;https://memcached.org/&quot;&gt;Memcached&lt;/a&gt;. There are a couple of other options as well — the &lt;a href=&quot;https://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-filestore&quot;&gt;file store&lt;/a&gt; and  &lt;a href=&quot;https://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-memorystore&quot;&gt;memory store&lt;/a&gt;. A full discussion of these stores can be found in the post &lt;a href=&quot;https://blog.appsignal.com/2018/04/17/rails-built-in-cache-stores&quot;&gt;Rails&amp;#39; built-in cache stores: an overview&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;File and memory stores can be great for development use to get things up and running quickly. However, they are usually unsuitable for production, especially if you&amp;#39;re working in a distributed setup with multiple servers. Redis and memcached are both suited for production use. Which one you use usually depends on the application.&lt;/p&gt;
&lt;h2 id=&quot;background-workers-in-ruby-on-rails&quot;&gt;Background Workers in Ruby on Rails&lt;/h2&gt;
&lt;p&gt;Most applications need background jobs for mailers, regular clean-ups, or any other time-consuming operation that doesn&amp;#39;t require a user to be present. Chances are, you already have a background worker set up already.&lt;/p&gt;
&lt;p&gt;Whenever you find yourself doing anything that takes more than a second to do inside a controller action, see if you can move it to a background worker instead. This could range from a user-facing operation like searching for data inside a large table to an API method that ingests a large amount of data.&lt;/p&gt;
&lt;h3 id=&quot;example-implementation&quot;&gt;Example Implementation&lt;/h3&gt;
&lt;p&gt;To run custom jobs, Rails provides the &lt;a href=&quot;https://edgeguides.rubyonrails.org/active_job_basics.html&quot;&gt;Active Job framework&lt;/a&gt;. Let&amp;#39;s see how we can use it to move a very complex filtering logic to a background job. First, let’s create our background job:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# jobs/filter_huge_dataset_job.rb
class FilterHugeDatasetJob &amp;lt; ApplicationJob
  queue_as :default

  def perform(user, filters)
    # search your data
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can run this job from the controller like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# controllers/huge_datasets_controller.rb
class HugeDatasetsController &amp;lt; ApplicationController
  def index
    FilterHugeDatasetJob.perform_later(@current_user, filters)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We need to render a loading indicator on our template while we wait for our job to compute data and deliver the results.&lt;/p&gt;
&lt;p&gt;But how can we get the results from our job to the view? Turbo makes this really easy. For example, inside the view, we can subscribe to turbo-stream events on a specific notification channel using &lt;code&gt;turbo_stream_from&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Using this, let’s write our templates:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# view/huge_datasets/index.html.erb
&amp;lt;%= render &amp;quot;index&amp;quot;, user: @current_user %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# view/huge_datasets/_index.html.erb
&amp;lt;%= turbo_stream_from user, :huge_datasets %&amp;gt;
&amp;lt;%= render &amp;quot;filters&amp;quot; %&amp;gt;
&amp;lt;div id=&amp;quot;data-container&amp;quot;&amp;gt;
  &amp;lt;% if defined? data %&amp;gt;
    &amp;lt;%= render partial: &amp;quot;item&amp;quot;, collection: data  %&amp;gt;
  &amp;lt;% else %&amp;gt;
    &amp;lt;%= render &amp;quot;loading&amp;quot; %&amp;gt;
  &amp;lt;% end %&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since data is not defined in the initial controller action, we will only render a loading indicator. Let’s now deliver the results from our job:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# jobs/filter_huge_dataset_job.rb
class FilterHugeDatasetJob &amp;lt; ApplicationJob
  queue_as :default

  def perform(user, filters)
    data = search_huge_dataset(filters)
    notify_completed(user, data)
  end

  def search_huge_dataset(filters)
    # search your data
  end

  def notify_completed(user, data)
    Turbo::StreamsChannel.broadcast_replace_to(
      [user, :huge_datasets],
      target: &amp;quot;data-container&amp;quot;,
      partial: &amp;quot;huge_datasets/index&amp;quot;,
      locals: { user: user, data: data }
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important part here is the &lt;code&gt;notify_completed&lt;/code&gt; method. It uses &lt;a href=&quot;https://github.com/hotwired/turbo-rails/blob/main/app/channels/turbo/streams_channel.rb&quot;&gt;Turbo::StreamsChannel&lt;/a&gt;, broadcasting a replace event to the &lt;code&gt;[user, :huge_datasets]&lt;/code&gt; notification stream that we subscribed to from our view.&lt;/p&gt;
&lt;p&gt;That is everything we need to move complex operations from our controller to background jobs. The main advantage of moving tasks to the background is that background workers can be scaled independently of web servers. This frees up resources on the web server side considerably. For the user, such interfaces also feel much more responsive because we can respond quickly and deliver results incrementally.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: &lt;em&gt;If you need help deciding between a background job worker, read &lt;a href=&quot;https://blog.appsignal.com/2022/02/15/delayed-job-vs-sidekiq-which-is-better.html&quot;&gt;Delayed Job vs. Sidekiq: Which Is Better?&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;scaling-a-database-in-your-ruby-on-rails-application&quot;&gt;Scaling a Database in Your Ruby on Rails Application&lt;/h2&gt;
&lt;p&gt;The last scalable resource that we will discuss in this post is the database. Databases form the core of most applications. As data and the number of servers accessing that data grows, databases start to feel the load.&lt;/p&gt;
&lt;p&gt;The easiest way to scale a database is to add more processing power and memory to the database server. As opposed to scaling web servers, doing this with a database is usually a very slow operation, especially if you have high storage.&lt;/p&gt;
&lt;p&gt;The second option to scale databases is to scale horizontally using multiple databases or by sharding your database. Check out &lt;a href=&quot;https://guides.rubyonrails.org/active_record_multiple_databases.html&quot;&gt;Multiple Databases with Active Record&lt;/a&gt; for more details about this.&lt;/p&gt;
&lt;p&gt;Instead, we&amp;#39;ll focus on optimizing your database&amp;#39;s performance by looking at PostgreSQL.&lt;/p&gt;
&lt;h3 id=&quot;find-time-consuming-queries-in-postgresql&quot;&gt;Find Time-Consuming Queries in PostgreSQL&lt;/h3&gt;
&lt;p&gt;First, we need to identify our most time-consuming queries. The way we can do that is to query the &lt;a href=&quot;https://www.postgresql.org/docs/current/pgstatstatements.html&quot;&gt;&lt;code&gt;pg_stat_statements&lt;/code&gt;&lt;/a&gt; table that contains statistics about all SQL statements executed on the server. Let’s see how we can find the top 100 queries with the highest run times:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT query, calls, (total_exec_time/calls)::integer as avg_time_ms
FROM pg_stat_statements
WHERE calls &amp;gt; 1000
ORDER BY avg_time_ms desc
LIMIT 100;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will return the query, the number of calls, and the average run time of these queries. Try to find the ones you think could be faster and analyze why they were slow.&lt;/p&gt;
&lt;p&gt;You can also run &lt;code&gt;EXPLAIN&lt;/code&gt; or &lt;code&gt;EXPLAIN ANALYZE&lt;/code&gt; on the query to see the query plan and actual execution details, respectively.&lt;/p&gt;
&lt;p&gt;One of the most important things to look out for in the results is &lt;code&gt;Seq Scan&lt;/code&gt;, which indicates that Postgres has to go through all the records sequentially to run the query. If this happens, try to bypass that sequential scan by adding an index to the columns that you&amp;#39;ve filtered.&lt;/p&gt;
&lt;h3 id=&quot;tables-with-the-most-sequential-scans&quot;&gt;Tables with the Most Sequential Scans&lt;/h3&gt;
&lt;p&gt;Another useful query that I like to run is to find the total number of sequential scans run against a table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT relname AS name, seq_scan as count
FROM pg_stat_user_tables
ORDER BY seq_scan DESC;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you see a very large table (with a high number of rows) and a high count value from this result, then you have a problem. Try to check all queries against that table, find ones that can run sequential scans, and add indices to boil that down.&lt;/p&gt;
&lt;h3 id=&quot;index-usage&quot;&gt;Index Usage&lt;/h3&gt;
&lt;p&gt;You can also find statistics about index usage by running this query:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT relname,
   CASE idx_scan
     WHEN 0 THEN &amp;#39;Insufficient data&amp;#39;
     ELSE (100 * idx_scan / (seq_scan + idx_scan))::text
   END percent_of_times_index_used,
   n_live_tup rows_in_table
 FROM
   pg_stat_user_tables
 ORDER BY
   n_live_tup DESC;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This returns the percentage of index usage for each table. A low number means that you are missing some indexes on that table.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap Up&lt;/h2&gt;
&lt;p&gt;In this post, we explored several strategies to scale your Ruby on Rails applications, including caching and background workers. We also looked at optimizing your PostgreSQL database&amp;#39;s performance.&lt;/p&gt;
&lt;p&gt;Rails makes it really easy to add several layers of performance optimization to your application.&lt;/p&gt;
&lt;p&gt;The most important consideration with scalability is to identify bottlenecks in an application before we can act on them. A good performance monitoring tool can help. If you need one, check out &lt;a href=&quot;https://www.appsignal.com/ruby&quot;&gt;AppSignal for Ruby&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Build a Table Editor with Trix and Turbo Frames in Rails</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/10/26/build-a-table-editor-with-trix-and-turbo-frames-in-rails.html">
    <id>https://blog.appsignal.com/2022/10/26/build-a-table-editor-with-trix-and-turbo-frames-in-rails.html</id>
    <published>2022-10-26T00:00:00+00:00</published>
    <updated>2022-10-26T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's build a table editor in a Rails application using ActionText's Trix editor, and use Turbo Frames to customize your table.</summary>
    <content type="html">&lt;p&gt;In this post, we will implement a basic ActionText table editor for your Rails application. We&amp;#39;ll learn how:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ActionText and Trix handle attachments&lt;/li&gt;
&lt;li&gt;To implement our own &lt;code&gt;Attachable&lt;/code&gt; type, and leverage this to build a basic table editor&lt;/li&gt;
&lt;li&gt;Turbo Frames can be used to edit the table&lt;/li&gt;
&lt;li&gt;Turbo helps and gets in the way at the same time&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;This article draws inspiration from the excellent &lt;a href=&quot;https://onrails.blog/2020/09/30/adding-tables-to-actiontext-with-stimulus-js/&quot;&gt;&amp;#39;Adding Tables to ActionText With Stimulus.js&amp;#39; blog post&lt;/a&gt; from 2020. That was written before the advent of &lt;a href=&quot;https://turbo.hotwired.dev&quot;&gt;Turbo&lt;/a&gt; though, which we can expect to simplify matters quite a bit.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s get going!&lt;/p&gt;
&lt;h2 id=&quot;actiontext-attachments-in-rails-101&quot;&gt;ActionText Attachments in Rails 101&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;Note&lt;/strong&gt;: This demonstration assumes some understanding of Trix and Turbo Frames. You might find our &lt;a href=&quot;https://blog.appsignal.com/2022/07/06/get-started-with-hotwire-in-your-ruby-on-rails-app.html&quot;&gt;&amp;#39;Get Started with Hotwire in Your Ruby on Rails App&amp;#39; post&lt;/a&gt; helpful in learning the basics of Hotwire and Turbo Frames.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/julianrubisch/trix-tables-turbo-frames&quot;&gt;You can follow along with the code demonstration with this GitHub repo&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;As described in the &lt;a href=&quot;https://guides.rubyonrails.org/action_text_overview.html&quot;&gt;ActionText documentation&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Action Text brings rich text content and editing to Rails. It includes the Trix editor that handles everything from formatting to links to quotes to lists to embedded images and galleries.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;At a high level, attachments are part of ActionText&amp;#39;s document model. They render custom templates for any resource resolvable by a Signed Global ID (SGID). In other words, ActionText stores a reference to a certain SGID as an &lt;code&gt;&amp;lt;action-text-attachment&amp;gt;&lt;/code&gt; element:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;action-text-attachment sgid=&amp;quot;BAh7CEkiCG…&amp;quot;&amp;gt;&amp;lt;/action-text-attachment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Whenever ActionText encounters such an element, it calls the &lt;code&gt;to_attachable_partial_path&lt;/code&gt; method on the respective resource. By default, this method delegates to &lt;code&gt;to_partial_path&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So, as a preview, this is how our &lt;code&gt;Table&lt;/code&gt;&amp;#39;s representation in ActionText is going to look when rendered back to HTML:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;action-text-attachment sgid=&amp;quot;...&amp;quot;&amp;gt;
  &amp;lt;table&amp;gt;
    &amp;lt;tbody&amp;gt;
      &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Cell 1&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;Cell 2&amp;lt;/td&amp;gt;
      &amp;lt;/tr&amp;gt;
      &amp;lt;!-- more rows --&amp;gt;
    &amp;lt;/tbody&amp;gt;
  &amp;lt;/table&amp;gt;
&amp;lt;/action-text-attachment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To conform with the ActionText Attachment API, a class has to do only two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Implement &lt;code&gt;to_sgid&lt;/code&gt; by including &lt;code&gt;GlobalID::Identification&lt;/code&gt;. By default, all &lt;code&gt;ActiveRecord::Base&lt;/code&gt; descendants already do this.&lt;/li&gt;
&lt;li&gt;Include the &lt;code&gt;ActionText::Attachable&lt;/code&gt; module.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://api.rubyonrails.org/classes/ActionText/Attachable.html&quot;&gt;The &lt;code&gt;ActionText::Attachable&lt;/code&gt; module&lt;/a&gt; offers canonical ways to convert any model to and from an SGID via the &lt;code&gt;attachable_sgid&lt;/code&gt; and &lt;code&gt;from_attachable_sgid&lt;/code&gt; methods. We will make use of this later on.&lt;/p&gt;
&lt;p&gt;It also provides convenience accessors for attachment metadata, such as file size and name, as well as content type.&lt;/p&gt;
&lt;p&gt;Finally, it provides the default locations for the partials used to render an attachment in the editor and rich text views.&lt;/p&gt;
&lt;h2 id=&quot;adding-a-table-model&quot;&gt;Adding a Table Model&lt;/h2&gt;
&lt;p&gt;We will capitalize on ActionText&amp;#39;s Attachment API to implement our table solution. For this, we have to create a custom model capturing our tables&amp;#39; data and include &lt;code&gt;Attachable&lt;/code&gt;. We&amp;#39;ll use a simple JSON(B) column to hold a two-dimensional array for the table data.&lt;/p&gt;
&lt;p&gt;To start our exploration, let&amp;#39;s create a new Rails app with ActionText enabled:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ rails new trix-tables-turbo-frames
$ bin/rails action_text:install
$ bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because I&amp;#39;m not feeling creative today, let&amp;#39;s scaffold an &lt;code&gt;Article&lt;/code&gt; model with a title and rich text content:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ bin/rails g scaffold Article title:string content:rich_text
$ bin/rails g model ActionText::Table content:json
# or, if using postgres
$ bin/rails g model ActionText::Table content:jsonb

$ bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Watch out, here&amp;#39;s a surprising gotcha! The above install command created a &lt;code&gt;CreateActionTextTables&lt;/code&gt; migration, so we need to rename it to &lt;code&gt;CreateActionTextTablesTable&lt;/code&gt;. Additionally, we&amp;#39;ll have it default to a 2x2 table using &lt;code&gt;null: false, default: [[&amp;quot;&amp;quot;, &amp;quot;&amp;quot;], [&amp;quot;&amp;quot;, &amp;quot;&amp;quot;]]&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class CreateActionTextTablesTable &amp;lt; ActiveRecord::Migration[7.0]
  def change
    create_table :action_text_tables do |t|
      t.json :content, null: false, default: [[&amp;quot;&amp;quot;, &amp;quot;&amp;quot;], [&amp;quot;&amp;quot;, &amp;quot;&amp;quot;]] # create a 2x2 table by default

      t.timestamps
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;add-a-table-to-a-rails-actiontext-model&quot;&gt;Add a Table to a Rails ActionText Model&lt;/h3&gt;
&lt;p&gt;Before we continue with actually adding a table to rich text, we need to patch Trix&amp;#39;s toolbar:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;  // app/javascript/application.js
  import &amp;quot;@hotwired/turbo-rails&amp;quot;;
  import &amp;quot;controllers&amp;quot;;
- import &amp;quot;trix&amp;quot;;
+ import Trix from &amp;quot;trix&amp;quot;;
  import &amp;quot;@rails/actiontext&amp;quot;;

+ const buttonHTML =
+   &amp;#39;&amp;lt;button type=&amp;quot;button&amp;quot;
+      class=&amp;quot;trix-button trix-button--icon trix-button--icon-table&amp;quot;
+      title=&amp;quot;table&amp;quot; tabindex=&amp;quot;-1&amp;quot;
+      data-action=&amp;quot;trix-table#attachTable&amp;quot;&amp;gt;table&amp;lt;/button&amp;gt;&amp;#39;;
+
+ const buttonGroupElement = document
+   .querySelector(&amp;quot;trix-editor&amp;quot;)
+   .toolbarElement.querySelector(&amp;quot;[data-trix-button-group=file-tools]&amp;quot;);
+
+ buttonGroupElement.insertAdjacentHTML(&amp;quot;beforeend&amp;quot;, buttonHTML);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we manually append a button to Trix&amp;#39;s &lt;code&gt;toolbarElement&lt;/code&gt;. Wiring this up to a &lt;code&gt;trix-table&lt;/code&gt; Stimulus controller (that we&amp;#39;ve yet to build) will insert a table into the document. Let&amp;#39;s give this button a nice SVG as content in CSS and set up some table styles while we&amp;#39;re at it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;/* app/assets/stylesheets/application.css */
/*
 *
 *= require_tree .
 *= require_self
 */

+  .trix-button--icon-table::before {
+    background-image: url(&amp;quot;data:image/svg+xml,%3Csvg xmlns=&amp;#39;http://www.w3.org/2000/svg&amp;#39; class=&amp;#39;h-6 w-6&amp;#39; fill=&amp;#39;none&amp;#39; viewBox=&amp;#39;0 0 24 24&amp;#39; stroke=&amp;#39;currentColor&amp;#39; stroke-width=&amp;#39;2&amp;#39;%3E%3Cpath stroke-linecap=&amp;#39;round&amp;#39; stroke-linejoin=&amp;#39;round&amp;#39; d=&amp;#39;M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z&amp;#39; /%3E%3C/svg%3E&amp;quot;);
+    top: 8%;
+    bottom: 4%;
+  }
+
+ table {
+   border: 1px solid black;
+   border-collapse: collapse;
+ }
+
+ td {
+   padding: 0.5rem!important;
+   border: 1px solid black;
+ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we have successfully added it to the &amp;quot;file-tools&amp;quot; group:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-10/trix-toolbar.png&quot; alt=&quot;Customized Trix Toolbar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Now let&amp;#39;s return to adding and manipulating tables with the help of Turbo. For this, we will first need a controller with a &lt;code&gt;create&lt;/code&gt; action:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ bin/rails g controller Tables create --no-helper --skip-routes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This action can be more or less borrowed from the &lt;a href=&quot;https://onrails.blog/2020/09/30/adding-tables-to-actiontext-with-stimulus-js/&quot;&gt;&amp;#39;On Rails&amp;#39; blog post we cited in the introduction&lt;/a&gt;. It constructs the JSON necessary to insert an attachment on the client side: including an SGID and &lt;code&gt;content&lt;/code&gt; rendered from an &lt;code&gt;editor&lt;/code&gt; partial, as we shall see later.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/tables_controller.rb

class TablesController &amp;lt; ApplicationController
  layout false

  def create
    @table = ActionText::Table.create

    render json: {
      sgid: @table.attachable_sgid,
      content: render_to_string(partial: &amp;quot;tables/editor&amp;quot;, locals: {table: @table}, formats: [:html])
    }
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We add the relevant &lt;strong&gt;resourceful table routes&lt;/strong&gt; to our configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;  # config/routes.rb

  Rails.application.routes.draw do
    resources :articles
+   resources :tables
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now comes the moment to plunge into the deep end: we need to build our table model. First, let&amp;#39;s include &lt;code&gt;ActionText::Attachable&lt;/code&gt; and define the relevant partial paths:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;  # app/models/action_text/table.rb

  class ActionText::Table &amp;lt; ApplicationRecord
+   include ActionText::Attachable
+
+   attribute :content_type, :string, default: &amp;quot;text/html&amp;quot;
+
+   def to_trix_content_attachment_partial_path
+     &amp;quot;tables/editor&amp;quot;
+   end
+
+   def to_partial_path
+     &amp;quot;tables/table&amp;quot;
+   end
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that we haven&amp;#39;t defined how the table&amp;#39;s content is stored yet. Because we declared it as a JSON(B) column in our database, we are free to choose any format. Deviating from the cited blog post a bit, let&amp;#39;s go with a two-dimensional array. Thus, we can simply do a nested loop over the &lt;code&gt;content&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;!-- app/views/tables/_table.html.erb --&amp;gt;
&amp;lt;table&amp;gt;
  &amp;lt;% table.content.each do |row| %&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;% row.each do |column| %&amp;gt;
        &amp;lt;td&amp;gt;
          &amp;lt;%= column %&amp;gt;
        &amp;lt;/td&amp;gt;
      &amp;lt;% end %&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;% end %&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above partial will render whenever it is requested by &lt;code&gt;ActionView&lt;/code&gt;, for example. Next, we also have to devise an &lt;code&gt;editor&lt;/code&gt; partial to be used inline in Trix:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;!-- app/views/tables/_editor.html.erb --&amp;gt;
&amp;lt;%= turbo_frame_tag &amp;quot;table_#{table.attachable_sgid}&amp;quot; do %&amp;gt;
  &amp;lt;table&amp;gt;
    &amp;lt;% table.content.each_with_index do |row, row_index| %&amp;gt;
      &amp;lt;tr&amp;gt;
        &amp;lt;% row.each_with_index do |column, column_index| %&amp;gt;
          &amp;lt;td&amp;gt;
            &amp;lt;div contenteditable&amp;gt;&amp;lt;%= column %&amp;gt;&amp;lt;/div&amp;gt;
          &amp;lt;/td&amp;gt;
        &amp;lt;% end %&amp;gt;
      &amp;lt;/tr&amp;gt;
    &amp;lt;% end %&amp;gt;
  &amp;lt;/table&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only difference, as you have probably noticed, is that we now have wrapped it in a Turbo Frame, using the SGID as a DOM id. Furthermore, we provide row and column indexes to the separator blocks and prepare for inline editing by making the inner DIV &lt;code&gt;contenteditable&lt;/code&gt; — we&amp;#39;ll get to that later.&lt;/p&gt;
&lt;p&gt;We will now connect our toolbar&amp;#39;s table button to the server-side controller action we have just written. To do this, we first need to bring Rails&amp;#39; &lt;a href=&quot;https://github.com/rails/request.js&quot;&gt;request.js&lt;/a&gt; library into the project. This library will help us administer &lt;code&gt;post&lt;/code&gt; requests from the client, including proper CSRF-tokens, etc.:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ bin/importmap pin @rails/request.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;build-a-new-trix-table-stimulus-controller&quot;&gt;Build a New Trix Table Stimulus Controller&lt;/h3&gt;
&lt;p&gt;Now that everything is set up, let&amp;#39;s create a new &lt;strong&gt;trix-table&lt;/strong&gt; Stimulus controller. In it, we will implement the &lt;code&gt;attachTable&lt;/code&gt; action referenced by our toolbar button:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// app/javascript/controllers/trix_table_controller.js

import { Controller } from &amp;quot;@hotwired/stimulus&amp;quot;;
import Trix from &amp;quot;trix&amp;quot;;
import { post } from &amp;quot;@rails/request.js&amp;quot;;

export default class extends Controller {
  static values = {
    url: String,
  };

  async attachTable(event) {
    const response = await post(this.urlValue);

    if (response.ok) {
      const tableAttachment = await response.json;
      this.insertTable(tableAttachment);
    } else {
      // error handling
    }
  }

  insertTable(tableAttachment) {
    this.attachment = new Trix.Attachment(tableAttachment);
    this.element
      .querySelector(&amp;quot;trix-editor&amp;quot;)
      .editor.insertAttachment(this.attachment);
    this.element.focus();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will POST to the table&amp;#39;s &lt;code&gt;create&lt;/code&gt; route, inserting the JSON response as a &lt;strong&gt;Trix attachment&lt;/strong&gt;. This again borrows from the OnRails blog post, exchanging the deprecated &lt;strong&gt;rails-ujs&lt;/strong&gt; calls for the newer &lt;strong&gt;request.js&lt;/strong&gt; library.&lt;/p&gt;
&lt;p&gt;Now we have to actually make use of this controller in our app by adding it to the form&amp;#39;s markup:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;  &amp;lt;!-- app/views/tables/_form.html.erb --&amp;gt;
- &amp;lt;%= form_with(model: article) do |form| %&amp;gt;
+ &amp;lt;%= form_with(model: article, data: {controller: &amp;quot;trix-table&amp;quot;, trix_table_url_value: tables_path}) do |form| %&amp;gt;
    &amp;lt;% if article.errors.any? %&amp;gt;
      &amp;lt;div style=&amp;quot;color: red&amp;quot;&amp;gt;
        &amp;lt;h2&amp;gt;&amp;lt;%= pluralize(article.errors.count, &amp;quot;error&amp;quot;) %&amp;gt; prohibited this article from being saved:&amp;lt;/h2&amp;gt;

        &amp;lt;ul&amp;gt;
          &amp;lt;% article.errors.each do |error| %&amp;gt;
            &amp;lt;li&amp;gt;&amp;lt;%= error.full_message %&amp;gt;&amp;lt;/li&amp;gt;
          &amp;lt;% end %&amp;gt;
        &amp;lt;/ul&amp;gt;
      &amp;lt;/div&amp;gt;
    &amp;lt;% end %&amp;gt;

    &amp;lt;div&amp;gt;
      &amp;lt;%= form.label :title, style: &amp;quot;display: block&amp;quot; %&amp;gt;
      &amp;lt;%= form.text_field :title %&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div&amp;gt;
      &amp;lt;%= form.label :content, style: &amp;quot;display: block&amp;quot; %&amp;gt;
      &amp;lt;%= form.rich_text_area :content %&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;div&amp;gt;
      &amp;lt;%= form.submit %&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The beauty of Stimulus.js is that only adding two data attributes to the &lt;code&gt;form&lt;/code&gt; element achieves the desired result. We are now able to add tables to our article&amp;#39;s content with a single button click:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-10/insert-table.gif&quot; alt=&quot;Inserting a Table Attachment into a Trix Editor&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;manipulating-the-table-via-turbo-frames&quot;&gt;Manipulating the Table via Turbo Frames&lt;/h2&gt;
&lt;p&gt;Now that we can create table attachments, let&amp;#39;s shift our focus to manipulating the content. As it turns out, Turbo Frames are &lt;em&gt;almost&lt;/em&gt; a natural fit here.&lt;/p&gt;
&lt;h3 id=&quot;add-and-delete-table-rows-and-columns&quot;&gt;Add and Delete Table Rows and Columns&lt;/h3&gt;
&lt;p&gt;To add and delete table rows and columns, we create a mini-toolbar consisting of four buttons, one for each operation. Make use of the &lt;code&gt;button_to&lt;/code&gt; helper and set the URL to the &lt;code&gt;update&lt;/code&gt; route for the respective table. Let&amp;#39;s add the respective operation we want to trigger as additional parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;  &amp;lt;!-- app/views/tables/_editor.html.erb --&amp;gt;
  &amp;lt;%= turbo_frame_tag &amp;quot;table_#{table.attachable_sgid}&amp;quot; do %&amp;gt;
+   &amp;lt;div style=&amp;quot;display: flex&amp;quot;&amp;gt;
+     &amp;lt;%= button_to &amp;quot;+ Row&amp;quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &amp;quot;addRow&amp;quot;} %&amp;gt;
+     &amp;lt;%= button_to &amp;quot;- Row&amp;quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &amp;quot;removeRow&amp;quot;} %&amp;gt;
+     &amp;lt;%= button_to &amp;quot;+ Column&amp;quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &amp;quot;addColumn&amp;quot;} %&amp;gt;
+     &amp;lt;%= button_to &amp;quot;- Column&amp;quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &amp;quot;removeColumn&amp;quot;} %&amp;gt;
+   &amp;lt;/div&amp;gt;
    &amp;lt;table&amp;gt;
      &amp;lt;% table.content.each_with_index do |row, row_index| %&amp;gt;
        &amp;lt;tr&amp;gt;
          &amp;lt;% row.each_with_index do |column, column_index| %&amp;gt;
            &amp;lt;td&amp;gt;
              &amp;lt;div contenteditable&amp;gt;&amp;lt;%= column %&amp;gt;&amp;lt;/div&amp;gt;
            &amp;lt;/td&amp;gt;
          &amp;lt;% end %&amp;gt;
        &amp;lt;/tr&amp;gt;
      &amp;lt;% end %&amp;gt;
    &amp;lt;/table&amp;gt;
  &amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In turn, we also need to add the respective controller action(s) to our &lt;code&gt;TablesController&lt;/code&gt;. Observe that the &lt;code&gt;update&lt;/code&gt; action delegates those actions to the model.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;  # app/controllers/tables_controller.rb

  class TablesController &amp;lt; ApplicationController
+   before_action :set_table, only: %i[show edit update destroy]

    layout false

+   def edit
+   end

    def create
      @table = ActionText::Table.create

      render json: {
        sgid: @table.attachable_sgid,
        content: render_to_string(partial: &amp;quot;tables/editor&amp;quot;, locals: {table: @table}, formats: [:html])
      }
    end

+   def update
+     if params[&amp;quot;operation&amp;quot;] == &amp;quot;addRow&amp;quot;
+       @table.add_row
+     elsif params[&amp;quot;operation&amp;quot;] == &amp;quot;removeRow&amp;quot;
+       @table.remove_row
+     elsif params[&amp;quot;operation&amp;quot;] == &amp;quot;addColumn&amp;quot;
+       @table.add_column
+     elsif params[&amp;quot;operation&amp;quot;] == &amp;quot;removeColumn&amp;quot;
+       @table.remove_column
+     else
+       flash.alert = &amp;quot;Unknown table operation: #{params[&amp;quot;operation&amp;quot;]}&amp;quot;
+     end
+
+     if @table.save
+       redirect_to edit_table_path(id: @table.attachable_sgid)
+     else
+       render :edit
+     end
+   end
+
+   private
+
+   def set_table
+     @table = ActionText::Attachable.from_attachable_sgid params[:id]
+   end
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After changes to the table&amp;#39;s structure are saved, we redirect to the table&amp;#39;s edit view. It renders the same &lt;code&gt;editor&lt;/code&gt; partial, which has the side-effect of referring to the same Turbo Frame. Thus Turbo can detect the matching frame and substitute one for the other.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;!-- app/views/tables/edit.html.erb --&amp;gt;
&amp;lt;%= render &amp;quot;tables/editor&amp;quot;, table: @table %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have to implement the missing commands on the &lt;code&gt;Table&lt;/code&gt; model.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;  # app/models/action_text/table.rb

  class ActionText::Table &amp;lt; ApplicationRecord
    include ActionText::Attachable

    attribute :content_type, :string, default: &amp;quot;text/html&amp;quot;

    def to_trix_content_attachment_partial_path
      &amp;quot;tables/editor&amp;quot;
    end

    def to_partial_path
      &amp;quot;tables/table&amp;quot;
    end

+   def rows
+     content.size
+   end
+
+   def columns
+     content.map(&amp;amp;:size).max
+   end
+
+   def add_row(index = rows - 1)
+     content &amp;lt;&amp;lt; Array.new(columns, &amp;quot;&amp;quot;)
+   end
+
+   def remove_row(index = rows - 1)
+     content.delete_at(index)
+   end
+
+   def add_column(index = columns - 1)
+     content.each do |row|
+       row &amp;lt;&amp;lt; &amp;quot;&amp;quot;
+     end
+   end
+
+   def remove_column(index = columns - 1)
+     content.each do |row|
+       row.delete_at(index)
+     end
+   end
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notably, due to our simple data structure of a two-dimensional array, the &lt;code&gt;add/remove&amp;lt;sub&amp;gt;column&amp;lt;/sub&amp;gt;/row&lt;/code&gt; methods are mere proxies to modify the column and row count. Once that is in place, we can change our table&amp;#39;s structure with button clicks:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-10/add-remove-table-rows.gif&quot; alt=&quot;Adding and Removing Table Rows and Columns&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;edit-the-content-of-table-cells&quot;&gt;Edit the Content of Table Cells&lt;/h3&gt;
&lt;p&gt;In addition to changing the number of columns and rows, we also want to edit the cells&amp;#39; content. To achieve this, we will again lean heavily on the cited blog post and create a Stimulus table editor controller.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// app/javascript/controllers/table_editor_controller.js

import { Controller } from &amp;quot;@hotwired/stimulus&amp;quot;;
import { patch } from &amp;quot;@rails/request.js&amp;quot;;

export default class extends Controller {
  static values = {
    url: String,
  };

  async updateCell(event) {
    const response = await patch(this.urlValue, {
      body: { value: event.target.textContent },
      query: {
        operation: &amp;quot;updateCell&amp;quot;,
        row_index: event.target.dataset.rowIndex,
        column_index: event.target.dataset.columnIndex,
      },
      contentType: &amp;quot;application/json&amp;quot;,
      responseKind: &amp;quot;json&amp;quot;,
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;updateCell&lt;/code&gt; method will issue a PATCH request whenever a cell is edited, passing the row and column index as parameters. Now, all we have to do is connect it to our DOM:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;  &amp;lt;!-- app/views/tables/_editor.html.erb --&amp;gt;
- &amp;lt;%= turbo_frame_tag &amp;quot;table_#{table.attachable_sgid}&amp;quot; do %&amp;gt;
+ &amp;lt;%= turbo_frame_tag &amp;quot;table_#{table.attachable_sgid}&amp;quot;,
+    data: {controller: &amp;quot;table-editor&amp;quot;, table_editor_url_value: table_path(id: table.attachable_sgid)} do %&amp;gt;
    &amp;lt;div style=&amp;quot;display: flex&amp;quot;&amp;gt;
      &amp;lt;%= button_to &amp;quot;+ Row&amp;quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &amp;quot;addRow&amp;quot;} %&amp;gt;
      &amp;lt;%= button_to &amp;quot;- Row&amp;quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &amp;quot;removeRow&amp;quot;} %&amp;gt;
      &amp;lt;%= button_to &amp;quot;+ Column&amp;quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &amp;quot;addColumn&amp;quot;} %&amp;gt;
      &amp;lt;%= button_to &amp;quot;- Column&amp;quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &amp;quot;removeColumn&amp;quot;} %&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;table&amp;gt;
      &amp;lt;% table.content.each_with_index do |row, row_index| %&amp;gt;
        &amp;lt;tr&amp;gt;
          &amp;lt;% row.each_with_index do |column, column_index| %&amp;gt;
            &amp;lt;td&amp;gt;
-             &amp;lt;div contenteditable&amp;gt;&amp;lt;%= column %&amp;gt;&amp;lt;/div&amp;gt;
+             &amp;lt;div contenteditable
+                data-action=&amp;quot;input-&amp;gt;table-editor#updateCell&amp;quot;
+                data-row-index=&amp;quot;&amp;lt;%= row_index %&amp;gt;&amp;quot;
+                data-column-index=&amp;quot;&amp;lt;%= column_index %&amp;gt;&amp;quot;&amp;gt;
+               &amp;lt;%= column %&amp;gt;
+             &amp;lt;/div&amp;gt;
            &amp;lt;/td&amp;gt;
          &amp;lt;% end %&amp;gt;
        &amp;lt;/tr&amp;gt;
      &amp;lt;% end %&amp;gt;
    &amp;lt;/table&amp;gt;
  &amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The server-side &lt;code&gt;TablesController&lt;/code&gt;, of course, now needs a way to handle this operation. Luckily, this is easily done in our simplified proof of concept by adding another branch to our condition. We also make sure that the &lt;code&gt;update&lt;/code&gt; action can now handle JSON-type requests, even if it&amp;#39;s merely returning an empty object here.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;  # app/controllers/tables_controller.rb

  class TablesController &amp;lt; ApplicationController
    before_action :set_table, only: %i[show edit update destroy]

    layout false

    def edit
    end

    def create
      @table = ActionText::Table.create

      render json: {
        sgid: @table.attachable_sgid,
        content: render_to_string(partial: &amp;quot;tables/editor&amp;quot;, locals: {table: @table}, formats: [:html])
      }
    end

    def update
      if params[&amp;quot;operation&amp;quot;] == &amp;quot;addRow&amp;quot;
        @table.add_row
      elsif params[&amp;quot;operation&amp;quot;] == &amp;quot;removeRow&amp;quot;
        @table.remove_row
      elsif params[&amp;quot;operation&amp;quot;] == &amp;quot;addColumn&amp;quot;
        @table.add_column
      elsif params[&amp;quot;operation&amp;quot;] == &amp;quot;removeColumn&amp;quot;
        @table.remove_column
+     elsif params[&amp;quot;operation&amp;quot;] == &amp;quot;updateCell&amp;quot;
+       @table.content[params[&amp;quot;row_index&amp;quot;].to_i][params[&amp;quot;column_index&amp;quot;].to_i] = params[&amp;quot;value&amp;quot;]
      end

      if @table.save
-       redirect_to edit_table_path(id: @table.attachable_sgid)
+       respond_to do |format|
+         format.html { redirect_to edit_table_path(id: @table.attachable_sgid) }
+         format.json {}
+       end
      else
        render :edit
      end
    end

    private

    def set_table
      @table = ActionText::Attachable.from_attachable_sgid params[:id]
    end
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that in a production app, I would advise you to choose a different strategy for sanitizing the operation than an &lt;code&gt;if/elsif/else&lt;/code&gt; condition. I would probably reach for a Mediator or Proxy in this case.&lt;/p&gt;
&lt;h2 id=&quot;the-limitations-of-trix-in-ruby&quot;&gt;The Limitations of Trix in Ruby&lt;/h2&gt;
&lt;p&gt;Up to this point, I assume this account has made perfect sense, but I have left out a critical detail. While we are persisting the underlying database model just fine, we are not syncing it to Trix&amp;#39;s internal shadow representation. That&amp;#39;s why the table snaps back to the previously stored representation when we focus out of it:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-10/document-sync-bug.gif&quot; alt=&quot;Bug When Syncing with Trix&amp;#39;s Internal Document Model&quot;/&gt;&lt;/p&gt;
&lt;p&gt;If we were to refresh the page now, the added content would appear, because Trix&amp;#39;s document is freshly initialized.&lt;/p&gt;
&lt;p&gt;I have pinned this problem down to where Trix syncs its internal document when the selection changes. It just unfurls it from the shadow element &lt;a href=&quot;https://github.com/basecamp/trix/blob/v2/src/trix/views/document_view.js#L52&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I tried hooking into the &lt;code&gt;turbo:submit&lt;/code&gt; event and preventing the sync just when blurring a table, but the solutions I came up with all seem very hairy and highly dependent on the internal API.&lt;/p&gt;
&lt;p&gt;The most Turbo-esque way of dealing with this, I guess, would be to wrap the whole form in an eager-loaded Turbo Frame and tell it to reload whenever Trix&amp;#39;s content changes.&lt;/p&gt;
&lt;p&gt;Something like this should do the trick:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// app/javascript/controllers/trix_table_controller.js

// ...

connect() {
  this.element.addEventListener(&amp;quot;turbo:submit-end&amp;quot;, (e) =&amp;gt; {
    this.element.closest(&amp;quot;turbo-frame&amp;quot;).reload();
  });
}

// ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you enclose your form in a Turbo Frame that you load from &lt;code&gt;src&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;!-- app/views/articles/edit.html.erb --&amp;gt;
&amp;lt;h1&amp;gt;Editing article&amp;lt;/h1&amp;gt;

&amp;lt;%= turbo_frame_tag dom_id(@article, :form), src: form_article_path(@article) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This approach only works with already persisted base records, though.&lt;/p&gt;
&lt;h2 id=&quot;final-words-of-warning-on-trix&quot;&gt;Final Words of Warning on Trix&lt;/h2&gt;
&lt;p&gt;The proof of concept we&amp;#39;ve built uses server-rendered HTML to do away with the added complexity of serializing tables to JSON and listening for JavaScript events. It is portable to any ActionText installation and could be easily extracted to a gem.&lt;/p&gt;
&lt;p&gt;There are a couple of drawbacks, though, the most obvious one being the necessary re-syncing with Trix&amp;#39;s document model. There might be situations where the proposed workaround is workable and others where it&amp;#39;s a no-go. Until Trix gains a Turbo-compatible interface, there&amp;#39;s no way around it.&lt;/p&gt;
&lt;p&gt;The second catch is that it does not use Trix&amp;#39;s &lt;code&gt;undo&lt;/code&gt; functionality (but that is true of any Trix attachment). Likewise, it would be wise to wait for upstream changes instead of tweaking the internal API.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap Up&lt;/h2&gt;
&lt;p&gt;In this post, we started by taking a quick look at the basics of ActionText Attachments. We then added a table to an ActionText model before tweaking it using Turbo Frames. Finally, we touched on some limitations of using Trix.&lt;/p&gt;
&lt;p&gt;Given that Trix v2 is underway, featuring a translation from CoffeeScript to plain modern JavaScript, now would be a good time to address its Turbo compatibility. Currently, the scope of what such a wrapper might look like is beyond my capabilities, but it sure looks like a window of opportunity.&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Improve Code in Your Ruby Application with RubyCritic</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html">
    <id>https://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html</id>
    <published>2022-10-19T00:00:00+00:00</published>
    <updated>2022-10-19T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's take a look at RubyCritic and dig into RubyCritic's reports.</summary>
    <content type="html">&lt;p&gt;RubyCritic provides visual reports highlighting code smells, code structure, ease of testing, and test coverage in your Ruby application.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s in active development, with new code analysis tools often being introduced as new features. It&amp;#39;s well worth keeping track of RubyCritic&amp;#39;s releases.&lt;/p&gt;
&lt;p&gt;This article will touch on some of RubyCritic&amp;#39;s benefits, its dependencies, and how to read its code reports.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s get going!&lt;/p&gt;
&lt;h2 id=&quot;why-choose-rubycritic-for-your-ruby-on-rails-application&quot;&gt;Why Choose RubyCritic for Your Ruby on Rails Application?&lt;/h2&gt;
&lt;p&gt;You should consider using &lt;a href=&quot;https://github.com/whitesmith/rubycritic&quot;&gt;RubyCritic&lt;/a&gt; if you want a single place to review code improvements for your project. Including RubyCritic in your development process will certainly reduce the time a development team spends working on technical debts. Most technical debts will be mapped out at development time.&lt;/p&gt;
&lt;p&gt;Some benefits that RubyCritic can provide to your project and development process include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unified information in one place&lt;/li&gt;
&lt;li&gt;Visual reports&lt;/li&gt;
&lt;li&gt;Easy installation&lt;/li&gt;
&lt;li&gt;Zero configuration&lt;/li&gt;
&lt;li&gt;Customization allowed&lt;/li&gt;
&lt;li&gt;Being extensible — you can make your own open-source integration&lt;/li&gt;
&lt;li&gt;A badge generator 🎉&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To understand how RubyCritic works, let&amp;#39;s look at the internal dependencies it uses to make reports.&lt;/p&gt;
&lt;h2 id=&quot;internal-dependencies-in-rubycritic&quot;&gt;Internal Dependencies in RubyCritic&lt;/h2&gt;
&lt;p&gt;When you add RubyCritic to your project, some dependencies will also be included.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s highlight the dependencies that make magic happen: the Reek, Flay, and Flog gems. These dependencies allow RubyCritic to show you valuable information about your code. Understanding how they work also makes RubyCritic easier to use.&lt;/p&gt;
&lt;h3 id=&quot;reek-detect-code-smells-in-ruby&quot;&gt;Reek: Detect Code Smells in Ruby&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/troessner/reek&quot;&gt;Reek&lt;/a&gt; is a gem for detecting code smells in Ruby. A bad smell in code is not about identifying wrong code, it is more about analyzing if the code could be written better.&lt;/p&gt;
&lt;p&gt;Reek&amp;#39;s analysis identifies &lt;em&gt;if&lt;/em&gt; something could be implemented in another way. It does not suggest &lt;em&gt;how&lt;/em&gt;, as most code smells are associated with business logic and a developer&amp;#39;s experience with a language.&lt;/p&gt;
&lt;p&gt;For example, you could easily rewrite an &lt;code&gt;if&lt;/code&gt; statement using metaprogramming techniques. The way to correct it, though, is up to a developer according to a project&amp;#39;s context. In this case, no library will be able to indicate the best solution.&lt;/p&gt;
&lt;p&gt;Reek detects an &lt;a href=&quot;https://github.com/troessner/reek/blob/master/docs/Code-Smells.md&quot;&gt;extensive list of smells&lt;/a&gt;. It examines and identifies possible smells in:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Classes&lt;/li&gt;
&lt;li&gt;Attributes&lt;/li&gt;
&lt;li&gt;Methods&lt;/li&gt;
&lt;li&gt;Parameters&lt;/li&gt;
&lt;li&gt;Modules&lt;/li&gt;
&lt;li&gt;Iterators&lt;/li&gt;
&lt;li&gt;The implementation of polymorphism&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By finding smells, you can take steps to make your code more readable and maintainable.&lt;/p&gt;
&lt;p&gt;Reek allows for custom configuration to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Disable a detector by its type&lt;/li&gt;
&lt;li&gt;Exclude directories from being scanned&lt;/li&gt;
&lt;li&gt;Use filters to silence warnings&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can even define specific code to &lt;a href=&quot;https://github.com/troessner/reek/blob/master/docs/Smell-Suppression.md&quot;&gt;suppress in a scan&lt;/a&gt;, a very useful feature when code is not yet finalized or refactored, or even if it is legacy code.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s see a sample of how Reek works. In this code, the exception is just defined as &lt;code&gt;e&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/erp/orders_controller.rb

def create
  ...

  rescue JSON::Schema::ValidationError =&amp;gt; e
    render status: :unprocessable_entity, json: {
      type: &amp;quot;invalid-schema&amp;quot;,
      title: &amp;quot;Your request does not match the expected schema.&amp;quot;,
      detail: e.message
    }
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is easy to imagine that &lt;code&gt;e&lt;/code&gt; means an exception, but what if we have other exceptions? Identifying them correctly is the best way to maintain good code.&lt;/p&gt;
&lt;p&gt;Reek will identify &lt;code&gt;e&lt;/code&gt; as UncommunicativeVariableName and show a warning.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ reek app/controllers/erp/orders_controller.rb
Inspecting 1 file(s):
S

app/controllers/erp/orders_controller.rb -- 1 warning:

  [91]:UncommunicativeVariableName: Erp::OrdersController#create has the variable name &amp;#39;e&amp;#39; [https://github.com/troessner/reek/blob/v6.1.1/docs/Uncommunicative-Variable-Name.md]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;flay-check-for-ruby-code-duplication&quot;&gt;Flay: Check for Ruby Code Duplication&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://ruby.sadi.st/Flay.html&quot;&gt;Flay&lt;/a&gt; identifies structural Ruby code similarities, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Detecting code duplication within a project&lt;/li&gt;
&lt;li&gt;Checking the difference at any code level&lt;/li&gt;
&lt;li&gt;Generating a score to measure how good your code is (the lower your score, the better the code)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If Flay reports a similarity in your code, it&amp;#39;s a high indicator that refactoring is needed. Don&amp;#39;t ignore this! Duplicate code is a gateway to bugs. If you fix something in one place but forget about another, more bugs appear.&lt;/p&gt;
&lt;p&gt;We can check how Flay works by running it in its own source code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ flay lib/flay.rb
Total score (lower is better) = 36

1) Similar code found in :iter (mass = 36)
  lib/flay.rb:80
  lib/flay.rb:105
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Flay identifies similarities between these two:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# lib/flay.rb:80
opts.on(&amp;quot;-m&amp;quot;, &amp;quot;--mass MASS&amp;quot;, Integer, &amp;quot;Sets mass threshold (default = #{options[:mass]})&amp;quot;) do |m|
  options[:mass] = m.to_i
end

# lib/flay.rb:105
opts.on(&amp;quot;-t&amp;quot;, &amp;quot;--timeout TIME&amp;quot;, Integer, &amp;quot;Set the timeout. (default = #{options[:timeout]})&amp;quot;) do |t|
  options[:timeout] = t.to_i
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that the code&amp;#39;s spelling is not exactly the same, but its functionality is and can be refactored to avoid duplication. That&amp;#39;s the magic of Flay!&lt;/p&gt;
&lt;h3 id=&quot;flog-examine-your-code-complexity-in-ruby&quot;&gt;Flog: Examine Your Code Complexity in Ruby&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://ruby.sadi.st/Flog.html&quot;&gt;Flog&lt;/a&gt; checks how difficult your code is to test. It sets a complexity score for each line of code and sums up the score for each method and class.&lt;/p&gt;
&lt;p&gt;The higher the score, the more your code needs to be refactored because it signifies that you have a highly complex implementation.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s see Flog in action! A small change can cause your score to variate.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def validate_expiration
  return if exp_month.blank? || exp_year.blank?

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ flog app/models/credit_card.rb

5.2: CreditCard#validate_expiration   app/models/credit_card.rb:12-15
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that in the first part of the code, we have an &lt;code&gt;or&lt;/code&gt; check that increases the score by 0.4 points.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def validate_expiration
  return if exp_month.blank?
  return if exp_year.blank?

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ flog app/models/credit_card.rb

4.8: CreditCard#validate_expiration app/models/credit_card.rb:12-15
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;other-rubycritic-dependencies&quot;&gt;Other RubyCritic Dependencies&lt;/h3&gt;
&lt;p&gt;RubyCritic also uses other runtime dependencies, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/deivid-rodriguez/byebug&quot;&gt;&lt;code&gt;byebug&lt;/code&gt;&lt;/a&gt; - this elevates debugging Ruby applications. It allows you to run a program line by line, add breakpoints, and evaluate and track values at runtime. If you still use &lt;code&gt;puts&lt;/code&gt; for debugging, it&amp;#39;s time you get to know Byebug&amp;#39;s features and commands.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rubocop/rubocop&quot;&gt;&lt;code&gt;rubocop&lt;/code&gt;&lt;/a&gt; - a linter for Ruby code that helps you follow a style guide used by the Ruby community, or even apply your own code style. It&amp;#39;s very useful to set standards in your team and avoid silly conflicts about spaces and tabs.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/simplecov-ruby/simplecov&quot;&gt;&lt;code&gt;SimpleCov&lt;/code&gt;&lt;/a&gt; - a tool to check Ruby application code coverage. You can configure it to run alongside your tests. It provides metrics on code coverage so that you can identify what you need to pay attention to and where to invest your time to create better test cases.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/whitesmith/rubycritic/blob/main/rubycritic.gemspec&quot;&gt;Dive into RubyCritic&amp;#39;s list of dependencies&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;using-rubycritic-for-your-ruby-on-rails-app&quot;&gt;Using RubyCritic for Your Ruby on Rails App&lt;/h2&gt;
&lt;p&gt;RubyCritic has good documentation to help you get started without much configuration. Therefore, we will focus on utilizing its resources to help us analyze its reports.&lt;/p&gt;
&lt;p&gt;RubyCritic provides &amp;#39;Code&amp;#39;, &amp;#39;Smells&amp;#39;, and &amp;#39;Coverage&amp;#39; reports. We&amp;#39;ll look at each of these features in turn.&lt;/p&gt;
&lt;h3 id=&quot;the-overview-in-rubycritic&quot;&gt;The Overview in RubyCritic&lt;/h3&gt;
&lt;p&gt;The &amp;#39;Overview&amp;#39; page shows a total score for your project on a donut chart, along with ratings (A being the best rating, F the worst). The &amp;#39;Summary&amp;#39; section shows the details of each rating, including the number of files, churns (commit changes), and smells found.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-10/overview.png&quot; alt=&quot;RubyCritic Overview&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In the &amp;#39;Churn vs Complexity&amp;#39; section here, it is already possible to identify the class with the greatest complexity, which should probably be the first point of attention.&lt;/p&gt;
&lt;p&gt;To better understand this graph, it is worth recapping &lt;a href=&quot;https://www.oreilly.com/library/view/making-software/9780596808310/ch23s03.html&quot;&gt;code churn&lt;/a&gt;. Code that changes frequently can raise an alert that something is wrong — maybe in the logic or the business domain, for example. Either way, looking at &amp;#39;Churn vs Complexity&amp;#39; can help you see where the pain points are across your project.&lt;/p&gt;
&lt;h3 id=&quot;code-report&quot;&gt;Code Report&lt;/h3&gt;
&lt;p&gt;The &amp;#39;Code&amp;#39; report shows a score for each class, including indicators for churn, complexity, duplication, and smells.&lt;/p&gt;
&lt;p&gt;You can sort this list by any column to view the highest ranking factors and address the most critical issues first.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-10/code.png&quot; alt=&quot;RubyCritic Overview&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In addition, this list has a filter that allows you to search by class name quickly.&lt;/p&gt;
&lt;p&gt;Clicking on the class name will open a detailed page with the class code and metrics such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Code line&lt;/li&gt;
&lt;li&gt;Quantity methods&lt;/li&gt;
&lt;li&gt;Calculated churn&lt;/li&gt;
&lt;li&gt;Complexity by method&lt;/li&gt;
&lt;li&gt;Complexity score (total per class)&lt;/li&gt;
&lt;li&gt;Amount of duplicates found&lt;/li&gt;
&lt;li&gt;Number of smells&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The line of code where an issue is found will be highlighted (based on information provided by the Reek gem).&lt;/p&gt;
&lt;p&gt;If Flog identifies any issues, you&amp;#39;ll see a score. You&amp;#39;ll also see if a Flay report has detected any duplicate code.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-10/reports.png&quot; alt=&quot;RubyCritic Overview&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;smells-report&quot;&gt;Smells Report&lt;/h3&gt;
&lt;p&gt;The &amp;#39;Smells&amp;#39; page displays the smell type, the exact location where a smell appears, and the fix status.&lt;/p&gt;
&lt;p&gt;As mentioned earlier, the smells are detected by Reek, and sorting and filtering are also available on this page.&lt;/p&gt;
&lt;p&gt;Clicking on a class name will open a page with your code details. You can also see the classes grouped by smell type (this is missing from the &amp;#39;Code&amp;#39; page, which only displays the number of smells).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-10/smells.png&quot; alt=&quot;RubyCritic Overview&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;coverage-report&quot;&gt;Coverage Report&lt;/h3&gt;
&lt;p&gt;Finally, you can see class classifications and the percentage of coverage for each class in the &amp;#39;Coverage&amp;#39; report. In contrast to the lists on the &amp;#39;Code&amp;#39; and &amp;#39;Smells&amp;#39; reports, the list in &amp;#39;Coverage&amp;#39; does not allow information to be sorted and filtered.&lt;/p&gt;
&lt;p&gt;You can only see the percentage of code coverage — no additional information is available.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-10/coverage.png&quot; alt=&quot;RubyCritic Overview&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Integrating the SimpleCov report could add more value and usefulness to this page. But in any case, the &amp;#39;Coverage&amp;#39; report can help if you need a simple report to examine your project&amp;#39;s test coverage.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap Up&lt;/h2&gt;
&lt;p&gt;In this post, we briefly looked at the benefits of RubyCritic for your Ruby application before diving into its internal dependencies: Reek, Flay, and Flog. We then ran through how to read and analyze RubyCritic&amp;#39;s reports.&lt;/p&gt;
&lt;p&gt;As a next step, figure out how to use RubyCritic in your pipeline.&lt;/p&gt;
&lt;p&gt;Happy code refactoring!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Security Best Practices for Your Rails Application</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/10/05/security-best-practices-for-your-rails-application.html">
    <id>https://blog.appsignal.com/2022/10/05/security-best-practices-for-your-rails-application.html</id>
    <published>2022-10-05T00:00:00+00:00</published>
    <updated>2022-10-05T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Ensure your Rails application stays secure by following some best practices and habits.</summary>
    <content type="html">&lt;p&gt;Alongside performance and usability, you should always focus on security when creating any web application. Keep in mind that hacking techniques are constantly evolving, just as fast as technology is. So you must know how to secure your users and their data.&lt;/p&gt;
&lt;p&gt;This article will show you how to create a secure Rails application. The framework is known to be secure by default, but the default configuration is not enough to let you sleep well at night.&lt;/p&gt;
&lt;p&gt;We will share some best coding practices and a few habits in the development process that can help you create secure code.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s dive in!&lt;/p&gt;
&lt;h2 id=&quot;security-in-your-app-best-coding-practices&quot;&gt;Security in Your App: Best Coding Practices&lt;/h2&gt;
&lt;p&gt;Modern web applications are often complex. They utilize multiple data sources and handle custom authorization rules as well as different methods of authentication. Knowing how to avoid SQL injections or ensuring that users can only read their data is not enough.&lt;/p&gt;
&lt;p&gt;When you build a Rails application, you have to configure it properly, design the application securely, and write code that makes it bulletproof.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ll look at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Application configuration&lt;/strong&gt; - The default configuration is exemplary, but we can make things even better with a few extra steps.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Business logic&lt;/strong&gt; - Applications should be secure by design, not only by code. This principle is essential but is often ignored when an MVP has to be delivered quickly.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Code in controllers&lt;/strong&gt; - These classes are the entry point to our application, so an extra dose of attention is always needed to design a reliable application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Code in models&lt;/strong&gt; - Many issues are related to a database, so it is essential to design and perform secure communication with the primary source of the data.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Code in views&lt;/strong&gt; - The point where we expose data to the browser is also a popular target for hackers, so we have to ensure that we don&amp;#39;t render anything that risks our users&amp;#39; data or privacy.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;application-configuration&quot;&gt;Application Configuration&lt;/h3&gt;
&lt;p&gt;It all starts here, in the configuration files. In most cases, unless you restart the application, the rules will remain the same. Rails&amp;#39; creators made an effort to create secure defaults, but we can still improve them with some extra steps.&lt;/p&gt;
&lt;h3 id=&quot;force-ssl&quot;&gt;Force SSL&lt;/h3&gt;
&lt;p&gt;You can force your Rails application to always use a secure connection with the HTTPS protocol. To do this, open the &lt;code&gt;config/environments/production.rb&lt;/code&gt; file and set the following line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;config.force_ssl = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This setting does a few things to the application:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every time there is a request to the HTTP version of the application, Rails will redirect the request to the HTTPS protocol.&lt;/li&gt;
&lt;li&gt;It sets a secure flag on cookies. Thanks to this, browsers won&amp;#39;t send cookies with HTTP requests.&lt;/li&gt;
&lt;li&gt;It tells the browser to remember your application as TLS-only (TLS is Transport Layer Security, an extension of the HTTPS protocol).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;cors&quot;&gt;CORS&lt;/h3&gt;
&lt;p&gt;Cross-Origin Resource Sharing (CORS) is a security mechanism that defines which website can interact with your application&amp;#39;s API. Of course, if you build a monolith app, you don&amp;#39;t need to care about this protection.&lt;/p&gt;
&lt;p&gt;If you build an API application, you can configure CORS by installing an additional gem called &lt;code&gt;rack-cors&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Once you have done that, create a file called &lt;code&gt;cors.rb&lt;/code&gt; in the initializers directory &lt;code&gt;config/initializers&lt;/code&gt;. Define what endpoints a website can access (including request methods):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Rails.application.config.middleware.insert_before 0, Rack::Cors do
 allow do
   origins &amp;#39;https://your-frontend.com&amp;#39;
   resource &amp;#39;/users&amp;#39;,
     :headers =&amp;gt; :any,
     :methods =&amp;gt; [:post]
   resource &amp;#39;/articles&amp;#39;,
     headers: :any,
     methods: [:get]
 end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above example, we allow the your-frontend.com website to call the &lt;code&gt;/users&lt;/code&gt; endpoint (using only the POST method) and the &lt;code&gt;/articles&lt;/code&gt; endpoint (using only the GET method).&lt;/p&gt;
&lt;h3 id=&quot;secure-environment-variables&quot;&gt;Secure Environment Variables&lt;/h3&gt;
&lt;p&gt;You should never hardcode your API keys, passwords, or other sensitive credentials in the source code. You might accidentally make them public or give someone who&amp;#39;s not authorized access to some sensitive application resources.&lt;/p&gt;
&lt;p&gt;The Rails framework itself provides a way to store credentials securely. However, the implementation varies depending on the framework version:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rails 4&lt;/strong&gt; - The feature is called &amp;#39;secrets&amp;#39;. You store your sensitive information in a &lt;code&gt;config/secrets.yml&lt;/code&gt; file that is not tracked in the git repository.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rails 5&lt;/strong&gt; - The feature is called &amp;#39;credentials&amp;#39;. Your sensitive information is stored encrypted in &lt;code&gt;config/credentials.yml.enc&lt;/code&gt; — you can edit it with the &lt;code&gt;config/master.key&lt;/code&gt; file. So while the YAML configuration file can be stored in the repository because it’s encrypted, you don’t track the &lt;code&gt;master.key&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Rails 6&lt;/strong&gt; - Also called &amp;#39;credentials&amp;#39;, you can store credentials per environment. Because of that, for every environment, you have the encrypted YAML file and key to decrypt it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Alternatively, you can always set the values on the server level, so that they only load in the server environment. Locally, each developer sets them individually.&lt;/p&gt;
&lt;h3 id=&quot;business-logic&quot;&gt;Business Logic&lt;/h3&gt;
&lt;p&gt;You should think about security not only when you write code, but also when you design the processes in your application.&lt;/p&gt;
&lt;p&gt;Business logic is a set of rules that apply in the real world, and your goal is to map them in your code. Unfortunately, mapping them can cause weak points in your application and lead to security issues.&lt;/p&gt;
&lt;h3 id=&quot;strong-authentication-and-authorization-rules&quot;&gt;Strong Authentication and Authorization Rules&lt;/h3&gt;
&lt;p&gt;Let&amp;#39;s first explain the difference between authentication and authorization, as these terms are sometimes misinterpreted:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Authentication&lt;/strong&gt; - You validate a user&amp;#39;s login and password against an application&amp;#39;s database.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Authorization&lt;/strong&gt; - You validate the role of a signed-in user and, based on that, render different information for different users. For example, a user with an admin role can access a list of users in an application, while in most cases, the typical user can&amp;#39;t.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To improve the security level of your authentication, you can set high standards for your end-users:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Strong passwords&lt;/strong&gt; - Set a strict password policy that doesn&amp;#39;t allow for passwords that are too simple or weak. Of course, you can&amp;#39;t control if your users share their passwords, but you can make their passwords hard to guess.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Two-factor authentication&lt;/strong&gt; - Another layer of protection that will secure an account even if someone else knows the password.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Encrypted passwords&lt;/strong&gt; - Never store passwords in your database as plain text. Then, even if your database is exposed, a hacker won&amp;#39;t be able to get your users&amp;#39; passwords.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;authorization-best-practices&quot;&gt;Authorization Best Practices&lt;/h3&gt;
&lt;p&gt;If your application is complex, you probably need different roles for users to manage their data. As business logic grows, it may be hard to control everything without making a mistake that leads to an information leak.&lt;/p&gt;
&lt;p&gt;You can avoid issues by following some well-known good practices:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Keep authorization logic in one place&lt;/strong&gt; - It&amp;#39;s hard to modify business logic correctly if you have to change multiple areas in the code. Storing the rules in one file makes it easy.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set clear rules&lt;/strong&gt; - You won&amp;#39;t be able to tell whether your application is secure if you can&amp;#39;t validate the business logic against well-defined rules.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set roles based on the group, not a single user&lt;/strong&gt; - It is easier to control the authorization process if you have groups of permissions instead of defining rules per user.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Of course, good code reviews and well-written tests are also a must here to avoid introducing bugs to existing business logic.&lt;/p&gt;
&lt;h3 id=&quot;code-in-controllers&quot;&gt;Code in Controllers&lt;/h3&gt;
&lt;p&gt;Controllers are the first layer of MVC architecture and handle requests coming from users. Therefore, it is essential to filter incoming information correctly as it will be propagated on other application layers.&lt;/p&gt;
&lt;h3 id=&quot;filter-incoming-parameters&quot;&gt;Filter Incoming Parameters&lt;/h3&gt;
&lt;p&gt;You should never pass a raw &lt;code&gt;params&lt;/code&gt; value to your application. Thanks to the strong parameters feature, it is easy to control the data that we&amp;#39;d like to pass along.&lt;/p&gt;
&lt;p&gt;Imagine that we have a &lt;code&gt;User&lt;/code&gt; model we want to update:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class UsersController &amp;lt; ApplicationController
  def update
    current_user.update(params[:user])
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Someone can manipulate the params, and it would be possible to update other &lt;code&gt;User&lt;/code&gt; model attributes (for example, the &lt;code&gt;admin&lt;/code&gt; flag if you have one). To avoid such a situation, filter params that you pass to your model:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class UsersController &amp;lt; ApplicationController
  def update
    current_user.update(user_params)
  end

  private

  def user_params
    params.require(:user).permit(:first_name, :last_name)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;use-scopes-to-avoid-data-leaking&quot;&gt;Use Scopes to Avoid Data Leaking&lt;/h3&gt;
&lt;p&gt;Usually, we don&amp;#39;t want to show the user data that does not belong to them. We may inadvertently expose some records for URL address manipulation due to the wrong code design. Let&amp;#39;s consider the following case:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MessagesController
  before_action :authenticate_user!

  def show
    @message = Message.find(params[:id])
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything seems fine; the controller is protected from guests, and we assign the message object. However, a user just needs to change the id in the URL address to get a message that does not belong to them. This is a very dangerous situation.&lt;/p&gt;
&lt;p&gt;We can avoid it by using scopes within the given context. In the mentioned example, the current user is the scope:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MessagesController
  before_action :authenticate_user!

  def show
    @message = current_user.messages.find(params[:id])
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;avoid-insecure-url-redirects&quot;&gt;Avoid Insecure URL Redirects&lt;/h3&gt;
&lt;p&gt;Let&amp;#39;s consider a straightforward example of a redirect based on the user input:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;redirect_to params[:url]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We should never do that, as we expose our user to a redirect that can take them everywhere. The simplest solution to prevent this security issue is to avoid using redirects with user input. If you can&amp;#39;t, you can always redirect to a path without the host:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;path = URI.parse(params[:url]).path.presence || &amp;quot;/&amp;quot;
redirect_to path
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;code-in-models&quot;&gt;Code in Models&lt;/h3&gt;
&lt;p&gt;Once Rails parses code in a controller, you will probably call models to receive the information from the database. Since models are responsible for communicating with your database as well as performing important computations, they are also often targeted by hackers.&lt;/p&gt;
&lt;h3 id=&quot;avoid-sql-injection&quot;&gt;Avoid SQL Injection&lt;/h3&gt;
&lt;p&gt;SQL injection is one of the most popular techniques used to access database information from the outside. The Rails framework tries to protect us from that threat, but we also need to write code that won&amp;#39;t let this happen.&lt;/p&gt;
&lt;p&gt;In general, we should avoid passing user input directly as a part of a query:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.joins(params[:table]).order(&amp;#39;id DESC&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you need to, always validate the user input and assign a default value when the input is invalid:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;valid_tables = %w[articles posts messages]
table = valid_tables.include?(params[:table]) ? params[:table] : &amp;quot;articles&amp;quot;
User.joins(table).order(&amp;#39;id DESC&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://rails-sqli.org/&quot;&gt;Check out this extensive set of examples of what &lt;em&gt;not&lt;/em&gt; to do when it comes to SQL injection&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;prevent-command-injection&quot;&gt;Prevent Command Injection&lt;/h3&gt;
&lt;p&gt;Avoid using methods that allow a program to execute any code. Such methods include &lt;code&gt;exec&lt;/code&gt;, &lt;code&gt;system&lt;/code&gt;, &lt;code&gt;`&lt;/code&gt;, and &lt;code&gt;eval&lt;/code&gt;. You should never pass user input to those functions.&lt;/p&gt;
&lt;p&gt;If your application allows users to execute code, you should run their code in separate Docker containers. In addition, you can remove dangerous methods before executing user input:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Kernel
 remove_method :exec
 remove_method :system
 remove_method :`
 remove_method :eval
 remove_method :open
end

Binding.send :remove_method, :eval
RubyVM::InstructionSequence.send :remove_method, :eval
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;avoid-unsafe-data-serialization&quot;&gt;Avoid Unsafe Data Serialization&lt;/h3&gt;
&lt;p&gt;Insecure deserialization can lead to the execution of arbitrary code in your application. If you plan to serialize JSON:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;data = { &amp;quot;key&amp;quot; =&amp;gt; &amp;quot;value&amp;quot; }.to_json
# =&amp;gt; &amp;quot;{\&amp;quot;key\&amp;quot;:\&amp;quot;value\&amp;quot;}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of using &lt;code&gt;load&lt;/code&gt; or &lt;code&gt;restore&lt;/code&gt; methods, use &lt;code&gt;parse&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# bad
JSON.load(data)
JSON.restore(data)

# good
JSON.parse(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you plan to serialize YAML:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;data = { &amp;quot;key&amp;quot; =&amp;gt; &amp;quot;value&amp;quot; }.to_yaml
# =&amp;gt; &amp;quot;---\nkey: value\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of using &lt;code&gt;load&lt;/code&gt; or &lt;code&gt;restore&lt;/code&gt; methods from the &lt;code&gt;Marshal&lt;/code&gt; module, use the &lt;code&gt;safe_load&lt;/code&gt; method from &lt;code&gt;Psych&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# bad
Marshal.load(data)
Marshal.restore(data)

# good
Psych.safe_load(data)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;code-in-views&quot;&gt;Code in Views&lt;/h3&gt;
&lt;p&gt;Whatever you render in views is visible to the end-user. When malicious code is rendered, it will affect your users directly by exposing them to untrusted websites and data sources.&lt;/p&gt;
&lt;h3 id=&quot;avoid-css-injection&quot;&gt;Avoid CSS Injection&lt;/h3&gt;
&lt;p&gt;It would appear that CSS code is always secure; it only modifies the styles of a website. However, if you allow for user-defined styles in your application, there is always a risk of CSS code injection.&lt;/p&gt;
&lt;p&gt;One of the most popular cases of user-defined CSS is a custom page background:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;body style=&amp;quot;background: &amp;lt;%= profile.background_color %&amp;gt;;&amp;quot;&amp;gt;&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A user with bad intentions can input a URL that an application will automatically load, and do damage to the current user viewing the content. To prevent such situations, provide a predefined set of values instead of allowing users to type any value.&lt;/p&gt;
&lt;h3 id=&quot;sanitize-rendered-output&quot;&gt;Sanitize Rendered Output&lt;/h3&gt;
&lt;p&gt;In the modern versions of Rails, output is sanitized by default. Even if a user inputs HTML or JS code and the application renders it, the HTML or JS code will escape.&lt;/p&gt;
&lt;p&gt;If you want to render HTML defined by users, always predefine which tags should render and which should escape:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;lt;%= sanitize @comment.body, tags: %w(strong em a), attributes: %w(href) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above code, we allow users to render &lt;code&gt;strong&lt;/code&gt;, &lt;code&gt;em&lt;/code&gt;, and &lt;code&gt;a&lt;/code&gt; HTML elements in their comments.&lt;/p&gt;
&lt;h3 id=&quot;dont-include-sensitive-data-in-comments&quot;&gt;Don&amp;#39;t Include Sensitive Data in Comments&lt;/h3&gt;
&lt;p&gt;This is primarily a reminder for junior developers unfamiliar with how web applications work on the front end. Don&amp;#39;t ever put sensitive information in comments (especially in views, as it will be exposed to end-users):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!--- password for the service is 1234 –&amp;gt;
&amp;lt;%= @some_service.result_of_search %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;habits-to-keep-your-rails-application-secure&quot;&gt;Habits to Keep Your Rails Application Secure&lt;/h2&gt;
&lt;p&gt;To make your Rails app secure and reduce technical debt, establish some valuable development habits. Taking small preventative actions frequently is much less painful than refactoring more significant portions of your codebase.&lt;/p&gt;
&lt;h3 id=&quot;upgrade-rails-and-other-libraries-often&quot;&gt;Upgrade Rails and Other Libraries Often&lt;/h3&gt;
&lt;p&gt;An upgrade is often painful and time-consuming, unless you upgrade to minor versions of a library. Develop a habit of upgrading a library each time a new, stable version is published. Your application will then be in good shape (not only regarding security, but also performance).&lt;/p&gt;
&lt;p&gt;If you use GitHub for day-to-day development, an extension like &lt;a href=&quot;https://github.com/marketplace/depfu&quot;&gt;Depfu&lt;/a&gt; is useful as it performs frequent updates for you.&lt;/p&gt;
&lt;h3 id=&quot;perform-security-audits&quot;&gt;Perform Security Audits&lt;/h3&gt;
&lt;p&gt;I don&amp;#39;t mean expensive audits by external companies. Often, it is enough to install a tool like &lt;a href=&quot;https://brakemanscanner.org/&quot;&gt;Brakeman&lt;/a&gt; and scan code with every commit or pull request.&lt;/p&gt;
&lt;p&gt;Also, it is a good idea to scan your Gemfile and find gems that need updating due to security issues discovered by the community. You can use &lt;a href=&quot;https://github.com/rubysec/bundler-audit&quot;&gt;bundler-audit&lt;/a&gt; to automate this process.&lt;/p&gt;
&lt;h3 id=&quot;have-a-proper-logging-strategy&quot;&gt;Have A Proper Logging Strategy&lt;/h3&gt;
&lt;p&gt;Logs, in many cases, are usually just thousands of lines of information you will never view. However, there might be a case where one of your users is attacked or experiences a suspicious action.&lt;/p&gt;
&lt;p&gt;In such a situation, if you have detailed and easily searchable logs, you can collect information that will help you prevent similar problems in the future.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-up-keep-your-rails-app-secure&quot;&gt;Wrapping Up: Keep Your Rails App Secure&lt;/h2&gt;
&lt;p&gt;In this post, we ran through some security best practices for your Rails app that reduce the risk of a data breach.&lt;/p&gt;
&lt;p&gt;Making sure that your Rails application is secure might be challenging. Sticking to the framework&amp;#39;s defaults is not enough; you have to know how to avoid creating security issues. For example, various injections and remote code executions have been well-known issues for the past few years, but still, you can&amp;#39;t be 100% sure that your application won&amp;#39;t be affected.&lt;/p&gt;
&lt;p&gt;Don&amp;#39;t forget the importance of frequent upgrades, security audits, and a culture of good logging. When combined, all of these things will help to make your Rails application more secure.&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Debugging in Ruby with AppSignal</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/09/21/debugging-in-ruby-with-appsignal.html">
    <id>https://blog.appsignal.com/2022/09/21/debugging-in-ruby-with-appsignal.html</id>
    <published>2022-09-21T00:00:00+00:00</published>
    <updated>2022-09-21T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Learn how you can use AppSignal to log and debug your Ruby application.</summary>
    <content type="html">&lt;p&gt;An application monitoring tool (APM) is not just useful for seeing how your application performs through graphs and visuals. We can go deeper and use an APM to understand how your application behaves in a certain environment.&lt;/p&gt;
&lt;p&gt;As developers, we should aim to be less reactive to errors and more predictive, avoiding crashes for end-users.&lt;/p&gt;
&lt;p&gt;One way to accomplish this is by using monitoring tools to debug our application when an error occurs. AppSignal has advanced features that allow us to intelligently debug our logs and thus reflect this precautionary thinking in our applications.&lt;/p&gt;
&lt;p&gt;This article will show you how to better log and debug your Ruby application using AppSignal.&lt;/p&gt;
&lt;h2 id=&quot;integrate-your-ruby-app-with-appsignal&quot;&gt;Integrate Your Ruby App with AppSignal&lt;/h2&gt;
&lt;p&gt;To start debugging with AppSignal, you need to have an AppSignal account.&lt;/p&gt;
&lt;p&gt;Integrate your Ruby application with AppSignal by following the steps in the article &lt;a href=&quot;https://blog.appsignal.com/2021/12/01/ruby-on-rails-application-monitoring-with-appsignal.html&quot;&gt;&amp;#39;Ruby on Rails Application Monitoring with AppSignal&amp;#39;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;log-options&quot;&gt;Log Options&lt;/h2&gt;
&lt;p&gt;Now that you have an application set up to send logs to AppSignal, let&amp;#39;s look at the logging options for your Ruby application.&lt;/p&gt;
&lt;p&gt;AppSignal offers various log levels for your application according to your project&amp;#39;s needs. In this section, we will explore the difference between each log level.&lt;/p&gt;
&lt;p&gt;At first glance, we might think these logs are related to the application logs shown in the &amp;#39;Backtrace&amp;#39; section of AppSignal.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-09/backtrace.png&quot; alt=&quot;Backtrace Section&quot;/&gt;&lt;/p&gt;
&lt;p&gt;However, changes to &lt;code&gt;log_level&lt;/code&gt; won&amp;#39;t reflect the information displayed in the backtrace. It is important to understand that setting the &lt;code&gt;log_level&lt;/code&gt; value relates to AppSignal&amp;#39;s communication logs with your application. It has nothing to do with application logs.&lt;/p&gt;
&lt;p&gt;This means that when we set the logging level in our application, we change the type of information that appears in the application logs about execution and integration with AppSignal.&lt;/p&gt;
&lt;p&gt;In most cases, you can just set the &lt;code&gt;log_level&lt;/code&gt; to error (unless you&amp;#39;ve had an issue with the AppSignal integration and need to send log information to AppSignal&amp;#39;s Support team). The &lt;code&gt;log_level&lt;/code&gt; must be defined in &lt;code&gt;config/appsignal.yml&lt;/code&gt;, as in the example below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/appsignal.yml

production:
  &amp;lt;&amp;lt;: *defaults
  log_level: error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Watch the application logs when we set &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;warning&lt;/code&gt;, or &lt;code&gt;info&lt;/code&gt; to &lt;code&gt;log_level&lt;/code&gt;. We will see pretty much the same information in the logs.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-09/error.png&quot; alt=&quot;error as log_level&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Now, check out the logs when we set &lt;code&gt;log_level&lt;/code&gt; as &lt;code&gt;debug&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-09/debug.png&quot; alt=&quot;debug as log_level&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Finally, let&amp;#39;s see what happens when we set &lt;code&gt;log_level&lt;/code&gt; as &lt;code&gt;trace&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-09/trace.png&quot; alt=&quot;trace as log_level&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;ignore-your-ruby-apps-predicted-errors-in-appsignal&quot;&gt;Ignore Your Ruby App&amp;#39;s Predicted Errors in AppSignal&lt;/h2&gt;
&lt;p&gt;You don&amp;#39;t need to catch and keep all errors in logs. Some common errors can be expected in an application — we don&amp;#39;t need to inflate our logs with 404 errors, for example. Now let&amp;#39;s configure AppSignal to ignore errors that are irrelevant to trace.&lt;/p&gt;
&lt;p&gt;Ignoring an error is useful when a production bug has already been identified, but the fix is still in development. We already know about the problem&amp;#39;s existence, so there&amp;#39;s no need to keep filling the error monitoring tool or be notified about it. We can ignore the error&amp;#39;s appearance until the patch deployment goes into production. This approach can be applied to all known bugs that have already been cataloged in the issues list.&lt;/p&gt;
&lt;p&gt;We can also ignore errors when we know that a service our application communicates with will be down for maintenance. This way, we don&amp;#39;t flood the monitoring tool with errors regarding expected maintenance, alerting our monitoring team unnecessarily.&lt;/p&gt;
&lt;p&gt;AppSignal&amp;#39;s gem provides three ways to handle and ignore predicted errors.&lt;/p&gt;
&lt;h3 id=&quot;ignore_errors&quot;&gt;&lt;code&gt;ignore_errors&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ignore_errors&lt;/code&gt; helps when you need to ignore all errors generated by a class error or when you don&amp;#39;t know the exact error that could happen from there.&lt;/p&gt;
&lt;p&gt;Maybe your application needs to do many math calculations, and AppSignal doesn&amp;#39;t need to track all related errors. &lt;code&gt;ignore_errors&lt;/code&gt; will reduce the errors list and only keep issues that need to be addressed.&lt;/p&gt;
&lt;h3 id=&quot;ignore_actions&quot;&gt;&lt;code&gt;ignore_actions&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;This is useful if you know exactly which method will generate an error you don&amp;#39;t need to trace — for example, a method that will be re-executed until it succeeds. You can also use &lt;code&gt;ignore_actions&lt;/code&gt; for queue processing when another monitoring tool handles logs specific to queue item failures.&lt;/p&gt;
&lt;h3 id=&quot;ignore_namespace&quot;&gt;&lt;code&gt;ignore_namespace&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ignore_namespace&lt;/code&gt; is great if you have an application separated by domain and want to group errors. Maybe you have a specific module to treat payments or to process an order in the background. Grouping it in a namespace for jobs makes sense. Then you can ignore the exceptions that occur inside this namespace.&lt;/p&gt;
&lt;h3 id=&quot;configure-in-your-ruby-app&quot;&gt;Configure in Your Ruby App&lt;/h3&gt;
&lt;p&gt;Include &lt;code&gt;ignore_errors&lt;/code&gt;, &lt;code&gt;ignore_actions&lt;/code&gt;, and &lt;code&gt;ignore_namespace&lt;/code&gt; in your &lt;code&gt;config/appsignal.yml&lt;/code&gt; file, with a list of classes to ignore when this error occurs in your application.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/appsignal.yml

production:
  &amp;lt;&amp;lt;: *defaults
  ignore_errors:
    - Net::HTTPGatewayTimeout
    - NoMethodError
  ignore_actions:
    - HomeController#index
  ignore_namespace:
    - jobs
    - payment
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;debugging-exceptions-in-ruby-with-appsignal&quot;&gt;Debugging Exceptions in Ruby with AppSignal&lt;/h2&gt;
&lt;p&gt;Now that we know how to ignore irrelevant errors, it&amp;#39;s time to deal with the errors that matter. AppSignal provides functions to configure how an error is sent from your application to the AppSignal monitor. Let&amp;#39;s learn about the &lt;code&gt;listen_for_error&lt;/code&gt; feature and extract valuable information from exceptions.&lt;/p&gt;
&lt;p&gt;Sometimes, we have a situation where an exception may or may not be thrown due to some parameters (if a job is not running or even if an external endpoint is unavailable). We still want to send detailed information to AppSignal, not just the exception itself. For this case, we&amp;#39;ll create a custom exception and use it to send helpful information to the monitoring team.&lt;/p&gt;
&lt;p&gt;The first thing we need to do is create a class for our custom exception. Make a new folder called &lt;code&gt;exceptions&lt;/code&gt; inside your application directory. Then create a new class called &lt;code&gt;CustomException&lt;/code&gt; inherited from &lt;code&gt;StandardError&lt;/code&gt;. You can define any information as the content of this exception. By default, an exception already has &lt;code&gt;msg&lt;/code&gt; as an attribute.&lt;/p&gt;
&lt;p&gt;In this example, you need to include an exception &lt;code&gt;name&lt;/code&gt; and the &lt;code&gt;content&lt;/code&gt; field to report all details about the exception. In the exception constructor, all attributes are set and the method to send to AppSignal is called.&lt;/p&gt;
&lt;p&gt;The block inside &lt;code&gt;Appsignal.listen_for_error&lt;/code&gt; is where the magic happens! The raise will send the exception content to AppSignal in hash format to facilitate the separation of the different contents.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/exceptions/custom_exception.rb

class CustomException &amp;lt; StandardError
  attr_accessor :name, :content

  def initialize(name, msg, content)
    @name = name
    @msg = msg
    @content = content

    send_exception_to_appsignal
  end

  def send_exception_to_appsignal
    Appsignal.listen_for_error do
      exception_hash = { name: @name, msg: @msg, content: @content }
      raise &amp;quot;#{exception_hash}&amp;quot;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can call this custom exception from anywhere, to use it in your application. For this example, we will include it in the controller inside the &lt;code&gt;Home#index&lt;/code&gt; method. We need a block to handle the exception, to avoid sending it to AppSignal. The &lt;code&gt;nil.object&lt;/code&gt; code will throw a &lt;code&gt;NoMethodError&lt;/code&gt; exception, but this exception is handled, and only &lt;code&gt;CustomException&lt;/code&gt; will be sent to AppSignal.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/home_controller.rb

class HomeController &amp;lt; ApplicationController
  def index
    begin
      nil.object
    rescue =&amp;gt; e
      raise CustomException.new(&amp;quot;Customized Exception&amp;quot;, &amp;quot;A new exception occurred&amp;quot;, e)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All done! After starting your application and accessing &lt;a href=&quot;http://localhost:3000/home#index&quot;&gt;http://localhost:3000/home#index&lt;/a&gt; in your browser, you will see a page with a &lt;code&gt;RuntimeError&lt;/code&gt; exception. In AppSignal, access the &amp;#39;Errors &amp;gt; Issue list&amp;#39; to see the Customized Exception issue.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;{:name=&amp;gt;&amp;quot;Customized Exception&amp;quot;, :msg=&amp;gt;&amp;quot;A new exception occurred&amp;quot;, :content=&amp;gt;#&amp;lt;NoMethodError: undefined method `object&amp;#39; for nil:NilClass&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-09/custom-exception.png&quot; alt=&quot;Custom Exception&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-and-next-steps&quot;&gt;Wrap Up and Next Steps&lt;/h2&gt;
&lt;p&gt;AppSignal provides a well-documented gem to start truly monitoring your Ruby application. Why not test it? Send data from your local machine without deploying to see if the error configuration is how you want it.&lt;/p&gt;
&lt;p&gt;Many other features in AppSignal make it easier to debug Ruby applications, like &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/exception-handling.html&quot;&gt;exception handling&lt;/a&gt;. &lt;a href=&quot;https://docs.appsignal.com/ruby/&quot;&gt;Check AppSignal&amp;#39;s Ruby documentation&lt;/a&gt; and choose the feature that makes the most sense in your project&amp;#39;s context. Make your app easier to debug by decreasing the time your team needs to spend looking into the root cause of bugs in production.&lt;/p&gt;
&lt;p&gt;Happy debugging!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>JIT Compilers for Ruby and Rails: An Overview</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/09/07/jit-compilers-for-ruby-and-rails-an-overview.html">
    <id>https://blog.appsignal.com/2022/09/07/jit-compilers-for-ruby-and-rails-an-overview.html</id>
    <published>2022-09-07T00:00:00+00:00</published>
    <updated>2022-09-07T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Find out about the different JIT compilers for Ruby — YJIT, MJIT, and TenderJIT — and their benefits.</summary>
    <content type="html">&lt;p&gt;A program is compiled at runtime using a different method from pre-execution compilation. This process is known as just-in-time compilation or dynamic translation.&lt;/p&gt;
&lt;p&gt;In this post, we&amp;#39;ll look at why JIT compilation can be a good choice for your Ruby on Rails app, before looking at some of the options available (YJIT, MJIT, and TenderJIT) and how to install them.&lt;/p&gt;
&lt;p&gt;But first: how does JIT compilation work?&lt;/p&gt;
&lt;h2 id=&quot;how-a-jit-compiler-works&quot;&gt;How a JIT Compiler Works&lt;/h2&gt;
&lt;p&gt;Just-in-time compilation is a method of running computer code that requires compilation while running a program.&lt;/p&gt;
&lt;p&gt;This could entail translating the source code, but it&amp;#39;s most frequently done by converting the bytecode to machine code,
which is then run directly.&lt;/p&gt;
&lt;p&gt;The code being executed is often continuously analyzed by a system using a JIT compiler. This identifies sections of code where the benefit of compilation or recompilation (in terms of speed) outweighs the cost.&lt;/p&gt;
&lt;h2 id=&quot;benefits-of-jit-compilation-for-ruby&quot;&gt;Benefits of JIT Compilation for Ruby&lt;/h2&gt;
&lt;p&gt;JIT compilation combines some of the benefits (and shortcomings) of the two conventional methods for converting programs into machine code:
interpretation and ahead-of-time compilation (AOT).&lt;/p&gt;
&lt;p&gt;Roughly speaking, it combines the flexibility of interpretation with the speed
of generated code, and the additional overhead of compiling and linking (not just interpreting).&lt;/p&gt;
&lt;p&gt;JIT compilation is a type of dynamic
compilation that enables adaptive optimization techniques, including dynamic recompilation and speed-ups tailored to certain microarchitectures. Due to a runtime system&amp;#39;s ability to handle late-bound data types and impose security guarantees, dynamic programming languages like Ruby are particularly
well-suited for interpretation and JIT compilation.&lt;/p&gt;
&lt;p&gt;An optimizing compiler like GCC can more efficiently optimize instructions — a significant advantage of adopting
a register-oriented architecture. Compilers operate on intermediate representation with register-based architecture.&lt;/p&gt;
&lt;p&gt;Once your instructions reach an intermediate representation during compilation, GCC does additional passes to speed up the CPU&amp;#39;s execution of your instructions.&lt;/p&gt;
&lt;h2 id=&quot;jit-compilers-for-ruby-yjit-mjit-and-tenderjit&quot;&gt;JIT Compilers for Ruby: YJIT, MJIT, and TenderJIT&lt;/h2&gt;
&lt;p&gt;Now let&amp;#39;s explore the different JIT compilers available for Ruby — YJIT, MJIT, and TenderJIT — and how you can set them up.&lt;/p&gt;
&lt;h2 id=&quot;mjit-method-based-just-in-time-compiler-for-ruby&quot;&gt;MJIT (Method-based Just-in-time Compiler) for Ruby&lt;/h2&gt;
&lt;p&gt;Vladimir Makarov implemented MJIT, and it was the first compiler methodology implemented in Ruby based on the C language.
It works with Ruby 2.6, uses YARV instructions, and compiles instructions often used in binary code.&lt;/p&gt;
&lt;p&gt;For programs that are not input/output-bound, MJIT enhances performance.&lt;/p&gt;
&lt;p&gt;YJIT is better than this original C-based compiler in terms of performance. Ruby 3&amp;#39;s JIT is the quickest JIT that MRI has ever had, made possible by the excellent work of MJIT.&lt;/p&gt;
&lt;h3 id=&quot;how-to-use-mjit&quot;&gt;How to Use MJIT&lt;/h3&gt;
&lt;p&gt;To use MJIT, you can enable the JIT in Ruby 2.6 and with the &lt;code&gt;--jit&lt;/code&gt; option.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;ruby --jit app.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you skip this part, MJIT will show an error.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;clang: error: cannot specify -o when generating multiple output files
MJIT warning: Making precompiled header failed on compilation. Stopping MJIT worker...
MJIT warning: failed to remove &amp;quot;/var/folders/3d/fk_588wd4g12syc56pjqybjc0000gn/T//_ruby_mjit_hp25992u0.h.gch&amp;quot;: No such file or directory
Successful MJIT finish
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A collection of JIT-specific settings included in Ruby 2.6 helps us understand how it functions. Run &lt;code&gt;ruby --help&lt;/code&gt; to view these options.&lt;/p&gt;
&lt;p&gt;In short, MJIT executes in a different thread and is asynchronous. It will begin just-in-time compilation following the first five runs of a calculation.&lt;/p&gt;
&lt;h2 id=&quot;yjit-for-ruby-on-rails&quot;&gt;YJIT for Ruby on Rails&lt;/h2&gt;
&lt;p&gt;A recent JIT compiler called YJIT was released with Ruby 3.1. It promises a lot of improvements and better performance.
Still a work-in-progress project designed by Shopify with experimental results, it must be used with caution, especially on larger applications.&lt;/p&gt;
&lt;p&gt;With that in mind, YJIT enhances the performance of Ruby on Rails applications. The majority of real-world software benefits
from the fast warm-up and performance enhancements provided by the YJIT basic block versioning JIT compiler.&lt;/p&gt;
&lt;p&gt;A JIT compiler will be gradually built into CRuby as part of the YJIT project, eventually replacing the interpreter for most of the code execution.&lt;/p&gt;
&lt;p&gt;Official benchmarks — see &lt;a href=&quot;https://shopify.engineering/yjit-just-in-time-compiler-cruby&quot;&gt;&amp;#39;YJIT: Building a New JIT Compiler for CRuby&amp;#39;&lt;/a&gt; — show that YJIT improved performance over the default CRuby interpreter by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;20% on railsbench&lt;/li&gt;
&lt;li&gt;39% on liquid template rendering&lt;/li&gt;
&lt;li&gt;37% on activerecord&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Only about 79% of instructions in railsbench are executed by YJIT,
and the rest run in the default interpreter.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://shopify.engineering/yjit-just-in-time-compiler-cruby&quot;&gt;Source: YJIT: Building a New JIT Compiler for CRuby&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;This means that a lot still needs to be done to improve YJIT&amp;#39;s current results.&lt;/p&gt;
&lt;p&gt;Even so, YJIT performs at least as well as the interpreter on every benchmark, even on the hardest
ones, and reaches near-peak performance after just one iteration of every benchmark.&lt;/p&gt;
&lt;h3 id=&quot;how-to-use-yjit&quot;&gt;How to Use YJIT&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: YJIT is currently limited to macOS and Linux on x86-64 platforms. Also, as mentioned, YJIT is not recommended for large applications (yet).&lt;/p&gt;
&lt;p&gt;YJIT is disabled by default. If you want to enable it, first specify the &lt;code&gt;--yjit&lt;/code&gt; command-line option.&lt;/p&gt;
&lt;p&gt;You need to check if it is installed, so run &lt;code&gt;ruby --enable-yjit -v&lt;/code&gt;. If &lt;code&gt;warning: unknown argument for --enable: &lt;/code&gt;yjit&amp;#39;` shows up, you have to install it.&lt;/p&gt;
&lt;p&gt;Then open &lt;code&gt;irb&lt;/code&gt; and set &lt;code&gt;RUBY_YJIT_ENABLE=1&lt;/code&gt;. You can exit and now, you&amp;#39;re ready to use YJIT. The command &lt;code&gt;ruby --enable-yjit -v&lt;/code&gt; must return something like &lt;code&gt;ruby 3.1.0p0 (2021-12-25 revision fb4df44d16) [arm64-darwin21]&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;tenderjit&quot;&gt;TenderJIT&lt;/h2&gt;
&lt;p&gt;With a design largely based off YJIT, TenderJIT is an experimental JIT compiler for Ruby. What&amp;#39;s different about TenderJIT is that it&amp;#39;s written in pure Ruby.&lt;/p&gt;
&lt;p&gt;This is a demo project and the aim is to ship it as a gem. In the meantime, you can experiment with it, but bear in mind it&amp;#39;s still a work in progress. Ruby 3.0.2 or later is required for TenderJIT.&lt;/p&gt;
&lt;h3 id=&quot;how-to-use-tenderjit&quot;&gt;How to Use TenderJIT&lt;/h3&gt;
&lt;p&gt;TenderJIT does not currently do method compilation automatically. To compile a method, you must manually configure TenderJIT.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tenderlove/tenderjit&quot;&gt;Clone the repository&lt;/a&gt; and run the following commands:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ bundle install
$ bundle exec rake test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You must set it manually on your code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;require &amp;quot;tenderjit&amp;quot;

def your_method
  ...
end

jit = TenderJIT.new
jit.compile(method(:your_method))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each YARV instruction in the target method is read by TenderJIT, which then transforms it into machine code.&lt;/p&gt;
&lt;p&gt;For more examples with TenderJIT, check one of these videos:
&lt;a href=&quot;https://www.youtube.com/watch?v=FCjwSOlHqbY&amp;amp;ab_channel=hexdevs&quot;&gt;A JIT compiler for Ruby with Aaron Patterson&lt;/a&gt; and
&lt;a href=&quot;https://www.youtube.com/watch?v=mPtouOS0gxE&amp;amp;ab_channel=Tenderlove%27sCoolStuff&quot;&gt;Hacking on TenderJIT!&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;In this post, we&amp;#39;ve taken a quick look at three JIT compilers for Ruby — MJIT, YJIT, and TenderJIT — and how to set them up. Each of the options is experimental and comes with its own limitations.&lt;/p&gt;
&lt;p&gt;However, YJIT is the most mature at the moment, and it has the biggest potential
to grow and scale. It demonstrates better performance over the other Ruby JITs, was developed with Ruby 3.1.0, and is quickly becoming an important part of CRuby.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://hokstad.com/compiler&quot;&gt;Check out this post if you want to build your own compiler for Ruby&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Monitor Ruby Application Performance with Magic Dashboards</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/08/31/monitor-ruby-application-performance-with-magic-dashboards.html">
    <id>https://blog.appsignal.com/2022/08/31/monitor-ruby-application-performance-with-magic-dashboards.html</id>
    <published>2022-08-31T00:00:00+00:00</published>
    <updated>2022-08-31T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's monitor and fix performance issues within a Ruby on Rails application using magic dashboards.</summary>
    <content type="html">&lt;p&gt;Application teams must understand what their customer experience is like. This is true not only from a general perspective (in terms of usability and responsiveness) but also on a day-to-day, minute-by-minute basis.&lt;/p&gt;
&lt;p&gt;In particular, when you work with distributed systems, errors are inevitable. Site traffic fluctuates throughout the day, and any one of a system’s dependencies could also encounter an issue at any time.&lt;/p&gt;
&lt;p&gt;In this article, we&amp;#39;ll use magic dashboards to help monitor and resolve performance issues within a Ruby on Rails application.&lt;/p&gt;
&lt;p&gt;But before we dive into magic dashboards, let&amp;#39;s see what we should look out for when designing our apps.&lt;/p&gt;
&lt;h2 id=&quot;things-to-consider-when-building-a-ruby-app&quot;&gt;Things to Consider When Building A Ruby App&lt;/h2&gt;
&lt;p&gt;As an application owner or team member, you&amp;#39;ll want to know if there are any problems with your application before the customer does. This enables you to take corrective action immediately and hopefully avoid any disruption to your users.&lt;/p&gt;
&lt;p&gt;There are a few key application questions you need to be able to answer at any point in time:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Is the page response time acceptable? According to Google, these days anything &lt;a href=&quot;https://www.youtube.com/watch?v=OpMfx_Zie2g&quot;&gt;slower than two seconds&lt;/a&gt; will cause customers to leave your site and go elsewhere.&lt;/li&gt;
&lt;li&gt;Are your users experiencing any errors? If so, what types of errors? What is the error rate?&lt;/li&gt;
&lt;li&gt;Are any ongoing operational issues affecting your application? This could be with the network, storage, or security services. As we all know, cloud providers have outages that impact our application’s health as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Observability is key, yet it is often the last thing engineers think about. Besides, there is already time built into the schedule for operational readiness. It&amp;#39;s called the weekend before the product launch!&lt;/p&gt;
&lt;p&gt;Joking aside, you have to build your app first before something exists to be observed. This lends itself to delaying performance testing until close to the end of the development lifecycle. You don’t want to spend too much time performance testing when the product isn’t code-complete, because then you’ll have to do it all over again later.&lt;/p&gt;
&lt;p&gt;The same is true for security testing. If you conduct it too early, a vulnerability could still be introduced after testing, but before a product goes into production.&lt;/p&gt;
&lt;p&gt;So, we know monitoring is critical, but all of these concerns are fair points. Monitoring doesn’t get the attention it deserves until late in the process. That’s why AppSignal created &lt;a href=&quot;https://blog.appsignal.com/2019/03/27/magic-dashboards.html&quot;&gt;magic dashboards&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;magic-dashboards-in-appsignal&quot;&gt;Magic Dashboards in AppSignal&lt;/h2&gt;
&lt;p&gt;AppSignal understands the importance of metrics, dashboards, and your app&amp;#39;s performance — but also that engineers have minimal time to work on these before launch.&lt;/p&gt;
&lt;p&gt;Our magic dashboards are called &amp;quot;magic&amp;quot; because the metrics collection and associated dashboards are created automatically for you, simply when you connect your app and integrated components.&lt;/p&gt;
&lt;h2 id=&quot;magic-dashboards-an-example-ruby-on-rails-app&quot;&gt;Magic Dashboards: An Example Ruby on Rails App&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s find out how we can monitor and resolve performance issues within a Ruby on Rails app using magic dashboards.&lt;/p&gt;
&lt;p&gt;Our application uses a simple machine learning (ML) model for cryptocurrency price prediction. An asynchronous job updates the model daily with the latest price data and improves accuracy over time. This Rails app has both web pages and a REST API, as shown in the architecture diagram below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/magic-dashboard-app-architecture.png&quot; alt=&quot;Architecture diagram for the sample application&quot;/&gt;&lt;/p&gt;
&lt;p&gt;After we deploy our Rails app, magic dashboards are automatically created for the Rails &lt;a href=&quot;https://docs.appsignal.com/ruby/integrations/puma.html#minutely-probe&quot;&gt;Puma&lt;/a&gt; web server and the &lt;a href=&quot;https://docs.appsignal.com/ruby/integrations/sidekiq.html#minutely-probe&quot;&gt;Sidekiq&lt;/a&gt; asynchronous jobs. Other supported integrations for magic dashboards include &lt;a href=&quot;https://docs.appsignal.com/ruby/integrations/mongodb.html&quot;&gt;MongoDB&lt;/a&gt; and the &lt;a href=&quot;https://docs.appsignal.com/elixir/integrations/erlang.html#minutely-probe&quot;&gt;Erlang VM&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can use the Puma magic dashboard to evaluate performance based on threads, pool capacity, and puma workers. The Sidekiq magic dashboard monitors queue length, queue latency, job duration, job status, and memory usage.&lt;/p&gt;
&lt;p&gt;Magic dashboards are detected and created based on the use of event-based metrics such as a Sidekiq job run, as well as &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/minutely-probes.html&quot;&gt;minutely probes&lt;/a&gt;. The minutely probe feature allows you to register a Ruby block or class to send custom metrics to AppSignal. Magic dashboards provide out-of-the-box integration for supported components, but you can leverage this mechanism to send your custom metrics to AppSignal.&lt;/p&gt;
&lt;h2 id=&quot;an-example-of-custom-minutely-probes&quot;&gt;An Example of Custom Minutely Probes&lt;/h2&gt;
&lt;p&gt;Sidekiq integration is already built in, but imagine you want to monitor a proprietary background job mechanism. You can use the following class example. The probe class obtains a connection that is then used on each call to get the desired metrics.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/initializers/appsignal.rb or a file that&amp;#39;s loaded on boot

# Creating a probe using a Ruby class
class BackgroundJobLibraryProbe
  def initialize
    # This is only called when the minutely probe gets initialized
    require &amp;quot;background_job_library&amp;quot;
    @connection = BackgroundJobLibrary.connection
  end

  def call
    stats = @connection.fetch_queue_stats
    Appsignal.set_gauge &amp;quot;background_job_library_queue_length&amp;quot;, stats.queue_length
    Appsignal.set_gauge &amp;quot;background_job_library_processed_jobs&amp;quot;, stats.processed_jobs
  end
end

# Registering a Class probe
Appsignal::Minutely.probes.register(
  :background_job_library_probe, BackgroundJobLibraryProbe
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The call to &lt;code&gt;Appsignal::Minutely.probes.register&lt;/code&gt; takes two parameters — a name for the probe and its implementation, which can be either a lambda or a class that implements the call method.&lt;/p&gt;
&lt;h2 id=&quot;configuration-and-system-requirements-for-appsignal&quot;&gt;Configuration and System Requirements for AppSignal&lt;/h2&gt;
&lt;p&gt;Simply use AppSignal with your Rails application to get magic dashboards. If you haven’t already installed AppSignal, include the appsignal gem in your Gemfile and run a bundle install.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;gem &amp;#39;appsignal&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then run the &lt;code&gt;appsignal install&lt;/code&gt; command to configure your environment. This configuration can be stored in a config file or environment variables, and connects your application to your AppSignal account and dashboards.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bundle exec appsignal install appsignal-license-key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After you install and run your server, you will see a few emails similar to the following.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/email-notification.png&quot; alt=&quot;Informational email that a Sidekiq magic dashboard was created&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The system requirements for this example are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AppSignal gem 2.9.0 or higher, which includes support for the minutely probe.&lt;/li&gt;
&lt;li&gt;Puma integration - requires version 3.11.4 or higher.&lt;/li&gt;
&lt;li&gt;Sidekiq integration - requires the &lt;a href=&quot;https://rubygems.org/gems/redis/&quot;&gt;Redis gem&lt;/a&gt; 3.3.5 or higher. For this integration, the AppSignal gem 2.9.5 or higher is recommended.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;performance-testing-our-price-prediction-api&quot;&gt;Performance Testing our Price Prediction API&lt;/h2&gt;
&lt;p&gt;The above example application uses a simple neural network implemented using the &lt;a href=&quot;https://github.com/tangledpath/ruby-fann&quot;&gt;Ruby FANN gem&lt;/a&gt; to predict the next day&amp;#39;s Bitcoin price. Percentage price changes from the last ten days are used as inputs to the model.&lt;/p&gt;
&lt;p&gt;The REST API doesn&amp;#39;t take any parameters, as it currently only predicts the price for tomorrow. The output is a simple JSON document, as shown below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;http://localhost:3000/crypto/predict_api

{
  &amp;quot;day&amp;quot;:&amp;quot;2022-07-22&amp;quot;,
  &amp;quot;price&amp;quot;:23080.95619
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A Sidekiq job gets the market price at the beginning of each day and updates the ML model. This job is scheduled to run every five minutes, enabling it to catch up to any outages or errors quickly.&lt;/p&gt;
&lt;p&gt;You can find all of the &lt;a href=&quot;https://github.com/dbroemme/btc-price-prediction&quot;&gt;code from this article on GitHub&lt;/a&gt;. &lt;em&gt;Please note that nothing in this article or the software constitutes investment advice. Consult a financial advisor before making any investment decisions regarding cryptocurrency.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;We&amp;#39;ll use JMeter to simulate load on the REST API for performance testing. This allows us to generate traffic and evaluate performance using our magic dashboards. Our first test uses 5 concurrent clients, each making 100 requests.&lt;/p&gt;
&lt;p&gt;The statistics show a fairly high range in response time, with an average of 342ms, but the P99 is 852ms. It seems that we can do better.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/jmeter-report-five-threads.png&quot; alt=&quot;Summary report of test with five Puma threads&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;improving-rails-app-performance-with-the-puma-magic-dashboard&quot;&gt;Improving Rails App Performance with the Puma Magic Dashboard&lt;/h2&gt;
&lt;p&gt;Our Puma magic dashboard includes a graph of the thread pool capacity, and we can see that it touches zero during our test run. This would explain why some requests take longer than others, so we&amp;#39;ll increase the number of puma threads to 10.&lt;/p&gt;
&lt;p&gt;Keep in mind, we did nothing to create the dashboard or this graph. AppSignal automatically created this for us.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/puma-dashboard-pool-capacity-10.png&quot; alt=&quot;Graph of Puma pool availability during multiple test runs&quot;/&gt;&lt;/p&gt;
&lt;p&gt;After running the test with the increased puma thread count, the response times are much more consistent, and the dashboard confirms that pool capacity stays within acceptable levels.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/jmeter-report-ten-threads.png&quot; alt=&quot;Summary report of test with ten Puma threads&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Now it is time to turn up the dial. The number of JMeter concurrent clients is increased to 50, with a ramp-up time of 5 seconds. This test shows a poor response time and a number of API errors. The Puma magic dashboard again shows the available puma threads reaching zero.&lt;/p&gt;
&lt;p&gt;Looking at the API code, we find that the model is being loaded from the database each time. This is not very efficient, so we change the Sidekiq job to not only grab the new daily price, but also run the ML model and save the prediction in the database.&lt;/p&gt;
&lt;p&gt;We deploy this change.&lt;/p&gt;
&lt;h2 id=&quot;better-api-performance-with-sidekiqs-magic-dashboard&quot;&gt;Better API Performance with Sidekiq&amp;#39;s Magic Dashboard&lt;/h2&gt;
&lt;p&gt;Now let&amp;#39;s check our Sidekiq magic dashboard. Unfortunately, there is a bug in the code, but at least we can identify and fix it quickly.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/sidekiq-error-graph.png&quot; alt=&quot;Graph of Sidekiq job status over time&quot;/&gt;&lt;/p&gt;
&lt;p&gt;With the Sidekiq &lt;code&gt;PriceUpdateJob&lt;/code&gt; now working, the API is modified so that it only needs to retrieve the predicted price from the database. This improves the API performance, but we still see some API errors and lengthy response times.&lt;/p&gt;
&lt;h2 id=&quot;back-to-the-puma-magic-dashboard&quot;&gt;Back to the Puma Magic Dashboard&lt;/h2&gt;
&lt;p&gt;A glance at the dashboard highlights that we have not yet configured Puma to use additional workers. A Puma worker is an OS-level process that can run several threads. The total thread count is calculated as the number of workers multiplied by the maximum threads. First, we use 2 workers, but the available threads are still exhausted. So we&amp;#39;ll increase the amount to 4 workers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/puma-four-workers.png&quot; alt=&quot;Graph of Puma workers over time&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Our API performance is now very good. The average response time is 419ms, and there are no API errors.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/puma-capacity-four-workers.png&quot; alt=&quot;Graph of Puma thread capacity over time&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The magic dashboard confirms that there is still available thread capacity.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/jmeter-report-four-workers.png&quot; alt=&quot;JMeter test report with four workers&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AppSignal&amp;#39;s magic dashboards give us instant insights into the capacity of the Puma web server. The Sidekiq and Active Worker dashboards provide similar insights into our application&amp;#39;s asynchronous jobs.&lt;/p&gt;
&lt;h3 id=&quot;what-weve-learned-from-magic-dashboards&quot;&gt;What We&amp;#39;ve Learned from Magic Dashboards&lt;/h3&gt;
&lt;p&gt;During our Rails application performance testing, the Puma magic dashboard helped us easily identify that the number of threads was insufficient for our desired throughput level. It shows the thread pool capacity, number of workers over time, and the total number of threads.&lt;/p&gt;
&lt;p&gt;While the Sidekiq job did not have any performance issues, the magic dashboard helped us quickly identify that there was an error after deployment, which we were able to fix and redeploy rapidly. All of these monitoring capabilities were set up for us automatically by AppSignal.&lt;/p&gt;
&lt;h2 id=&quot;appsignals-dashboard-features-for-ruby-and-rails-apps&quot;&gt;AppSignal&amp;#39;s Dashboard Features for Ruby and Rails Apps&lt;/h2&gt;
&lt;p&gt;Dashboards in AppSignal have namespaces, such as &amp;quot;web&amp;quot; application or &amp;quot;background&amp;quot; jobs, so you can create numerous monitoring views of your application. The built-in summary dashboard shows an overview of your application&amp;#39;s health, including throughput, response time, and the latest errors.&lt;/p&gt;
&lt;p&gt;Note that, as with any dashboard, you can edit what graphs and metrics are shown, as well as change the layout and the configuration of selected graphs.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.appsignal.com/anomaly-detection#main&quot;&gt;Anomaly detection&lt;/a&gt; is a powerful feature. It allows you to define thresholds that send notifications when a metric value goes over or below a given value, such as free memory or the error rate.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-up-monitor-your-ruby-app-today-with-appsignal&quot;&gt;Wrapping Up: Monitor Your Ruby App Today with AppSignal&lt;/h2&gt;
&lt;p&gt;Observability and performance are critical to the success of our applications. However, we often wait until the last minute to deal with these topics.&lt;/p&gt;
&lt;p&gt;AppSignal&amp;#39;s magic dashboards provide extensive out-of-the-box metrics, dashboards, and insights that are set up automatically. This allows you to rapidly tune your application’s performance and reach a state of operational readiness.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.appsignal.com/ruby&quot;&gt;Read more about AppSignal for Ruby&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Until next time, happy coding!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>An Introduction to Ractors in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/08/24/an-introduction-to-ractors-in-ruby.html">
    <id>https://blog.appsignal.com/2022/08/24/an-introduction-to-ractors-in-ruby.html</id>
    <published>2022-08-24T00:00:00+00:00</published>
    <updated>2022-08-24T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Discover when and why you should use ractors, and build a ractor in Ruby.</summary>
    <content type="html">&lt;p&gt;In this post, we&amp;#39;ll dive into ractors in Ruby, exploring how to build a ractor. You&amp;#39;ll send and receive messages in ractors, and learn about shareable and unshareable objects.&lt;/p&gt;
&lt;p&gt;But first, let&amp;#39;s define the actor model and ractors, and consider when you should use ractors.&lt;/p&gt;
&lt;h2 id=&quot;what-is-the-actor-model&quot;&gt;What is the Actor Model?&lt;/h2&gt;
&lt;p&gt;In computer science, the object-oriented model is very popular, and in the Ruby community, many people are used to the term &amp;#39;everything is an object&amp;#39;.&lt;/p&gt;
&lt;p&gt;Similarly, let me introduce you to the actor model, within which &amp;#39;everything is an actor&amp;#39;. The actor model is a mathematical model of concurrent computation in which the universal primitive/fundamental agent of computation is an &lt;strong&gt;actor&lt;/strong&gt;. An actor is capable of the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Receiving messages and responding to the sender&lt;/li&gt;
&lt;li&gt;Sending messages to other actors&lt;/li&gt;
&lt;li&gt;Determining how to respond to the next message received&lt;/li&gt;
&lt;li&gt;Creating several other actors&lt;/li&gt;
&lt;li&gt;Making local decisions&lt;/li&gt;
&lt;li&gt;Performing actions (e.g., mutating data in a database)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Actors communicate via messages, process one message at a time, and maintain their own private state. However, they can modify this state via messages received, eliminating the need for a lock or mutex.&lt;/p&gt;
&lt;p&gt;Received messages are processed one message at a time in the order of FIFO (first in, first out). The message sender is decoupled (isolated) from the sent communication, enabling asynchronous communication.&lt;/p&gt;
&lt;p&gt;A few examples of the actor model implementation are akka, elixir, pulsar, celluloid, and &lt;strong&gt;ractors&lt;/strong&gt;. A few examples of concurrency models include threads, processes, and futures.&lt;/p&gt;
&lt;h2 id=&quot;what-are-ractors-in-ruby&quot;&gt;What Are Ractors in Ruby?&lt;/h2&gt;
&lt;p&gt;Ractor is an actor-model abstraction that provides a parallel execution feature without &lt;a href=&quot;https://hacks.mozilla.org/2019/02/fearless-security-thread-safety/&quot;&gt;thread-safety concerns&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Just like threads, ractors provide true parallelism. However, unlike threads, they do not share everything. Most objects are unshareable, and when they are made shareable, are protected by an interpreter or locking mechanism.&lt;/p&gt;
&lt;p&gt;Ractors are also unable to access any objects through variables not defined within their scope. This means that we can be free of the possibility of &lt;a href=&quot;https://www.techtarget.com/searchstorage/definition/race-condition&quot;&gt;race conditions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In 2020, when Ruby 3.0.0 was released, these were the &lt;a href=&quot;https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/&quot;&gt;words of Matz&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It’s multi-core age today. Concurrency is very important. With Ractor, along with Async Fiber, Ruby will be a real concurrent language.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ractors do not claim to have solved all thread-safety problems. In the &lt;a href=&quot;https://docs.ruby-lang.org/en/3.0/ractor_md.html&quot;&gt;Ractor documentation&lt;/a&gt;, the following is clearly stated:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are several blocking operations (waiting send, waiting yield, and waiting take) so you
can make a program which has dead-lock and live-lock issues.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Some kind of shareable objects can introduce transactions (STM, for example). However,
misusing transactions will generate inconsistent state.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Without ractors, you need to trace all state mutations to debug thread-safety issues. However, the beauty of ractors is that we can concentrate our efforts on suspicious shared code.&lt;/p&gt;
&lt;h2 id=&quot;when-and-why-should-i-use-ractors-in-ruby&quot;&gt;When and Why Should I Use Ractors in Ruby?&lt;/h2&gt;
&lt;p&gt;When you create a ractor for the first time, you&amp;#39;ll get a warning like this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;&amp;lt;internal:ractor&amp;gt;:267: warning: Ractor is experimental, and the behavior may change in future versions of Ruby! Also there are many implementation issues.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, that does not mean that you should avoid using ractors. Due to parallel execution, ractors can complete processes way faster than when processes are carried out synchronously.&lt;/p&gt;
&lt;p&gt;In the Ruby 3.0.0 release notes, you&amp;#39;ll find this benchmark example of the &lt;a href=&quot;https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/&quot;&gt;Tak function&lt;/a&gt;, where it is executed sequentially four times, and four times in parallel with ractors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def tarai(x, y, z) =
  x &amp;lt;= y ? y : tarai(tarai(x-1, y, z),
                     tarai(y-1, z, x),
                     tarai(z-1, x, y))
require &amp;#39;benchmark&amp;#39;
Benchmark.bm do |x|
  # sequential version
  x.report(&amp;#39;seq&amp;#39;){ 4.times{ tarai(14, 7, 0) } }

  # parallel version with ractors
  x.report(&amp;#39;par&amp;#39;){
    4.times.map do
      Ractor.new { tarai(14, 7, 0) }
    end.each(&amp;amp;:take)
  }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The results are as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Benchmark result:
          user     system      total        real
seq  64.560736   0.001101  64.561837 ( 64.562194)
par  66.422010   0.015999  66.438009 ( 16.685797)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&quot;https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/&quot;&gt;Ruby 3.0.0 release notes&lt;/a&gt; state:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The result was measured on Ubuntu 20.04, Intel(R) Core(TM) i7-6700 (4 cores, 8 hardware threads). It shows that the parallel version is 3.87 times faster than the sequential version.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;So if you need a faster process execution time that can run in parallel on machines with multiple cores, ractors are not a bad idea at all.&lt;/p&gt;
&lt;p&gt;Modifying class/module objects on multi-ractor programs can introduce race conditions and should be avoided as much as possible. However, most objects are unshareable, so the need to implement locks to prevent race conditions becomes obsolete. If objects are shareable, they are protected by an interpreter or locking mechanism.&lt;/p&gt;
&lt;h2 id=&quot;creating-your-first-ractor-in-ruby&quot;&gt;Creating Your First Ractor in Ruby&lt;/h2&gt;
&lt;p&gt;Creating a ractor is as easy as creating any class instance. Call &lt;code&gt;Ractor.new&lt;/code&gt; with a block — &lt;code&gt;Ractor.new { block }&lt;/code&gt;. This block is run in parallel with every other ractor.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;It is important to note that every example shown from this point onwards was performed in Ruby 3.1.2.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;r = Ractor.new { puts &amp;quot;This is my first ractor&amp;quot; }
# This is my first ractor

# create a ractor with a name
r = Ractor.new name: &amp;#39;second_ractor&amp;#39; do
  puts &amp;quot;This is my second ractor&amp;quot;
end
# This is my second ractor

r.name
# =&amp;gt; &amp;quot;second_ractor&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Arguments can also be passed to &lt;code&gt;Ractor.new&lt;/code&gt;, and these arguments become parameters for the ractor block.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;my_array = [4,5,6]
Ractor.new my_array do |arr|
  puts arr.each(&amp;amp;:to_s)
end
# 4
# 5
# 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Recall how we talked about ractors being unable to access objects defined outside their scope? Let&amp;#39;s see an example of that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;outer_scope_object = &amp;quot;I am an outer scope object&amp;quot;
Ractor.new do
  puts outer_scope_object
end
# &amp;lt;internal:ractor&amp;gt;:267:in `new&amp;#39;: can not isolate a Proc because it accesses outer variables (outer_scope_object). (ArgumentError)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get an error on the invocation of &lt;code&gt;.new&lt;/code&gt;, related to a &lt;code&gt;Proc&lt;/code&gt; not being isolated. This is because &lt;code&gt;Proc#isolate&lt;/code&gt; is called at a ractor&amp;#39;s creation to prevent sharing unshareable objects. However, objects can be passed to and from ractors via messages.&lt;/p&gt;
&lt;h2 id=&quot;sending-and-receiving-messages-in-ractors&quot;&gt;Sending and Receiving Messages in Ractors&lt;/h2&gt;
&lt;p&gt;Ractors send messages via an &lt;em&gt;outgoing port&lt;/em&gt; and receive messages via an &lt;em&gt;incoming port&lt;/em&gt;. The incoming port can hold an infinite number of messages and runs on the FIFO principle.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;.send&lt;/code&gt; method works the same way a mailman delivers a message in the mail. The mailman takes the message and drops it at the door (incoming port) of the ractor.&lt;/p&gt;
&lt;p&gt;However, dropping a message at a person&amp;#39;s door is not enough to get them to open it. &lt;code&gt;.receive&lt;/code&gt; is then available for the ractor to open the door and receive whatever message has been dropped.&lt;/p&gt;
&lt;p&gt;The ractor might want to do some computation with that message and return a response, so how do we get it? We ask the mailman to &lt;code&gt;.take&lt;/code&gt; the response.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;tripple_number_ractor = Ractor.new do
  puts &amp;quot;I will receive a message soon&amp;quot;
  msg = Ractor.receive
  puts &amp;quot;I will return a tripple of what I receive&amp;quot;
  msg * 3
end
# I will receive a message soon
tripple_number_ractor.send(15) # mailman takes message to the door
# I will return a tripple of what I receive
tripple_number_ractor.take # mailman takes the response
# =&amp;gt; 45
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As seen above, the return value of a ractor is also a sent message and can be received via &lt;code&gt;.take&lt;/code&gt;. Since this is an outgoing message, it goes to the outgoing port.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s a simple example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;r = Ractor.new do
  5**2
end
r.take # =&amp;gt; 25
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Besides returning a message, a ractor can also send a message to its outgoing port via &lt;code&gt;.yield&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;r = Ractor.new do
  squared = 5**2
  Ractor.yield squared*2
  puts &amp;quot;I just sent a message out&amp;quot;
  squared*3
end
r.take
# =&amp;gt; 50
r.take
# =&amp;gt; 75
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first message sent to the outgoing port is &lt;code&gt;squared*2&lt;/code&gt;, and the next message is &lt;code&gt;squared*3&lt;/code&gt;. Therefore, when we call &lt;code&gt;.take&lt;/code&gt;, we get &lt;code&gt;50&lt;/code&gt; first. We have to call &lt;code&gt;.take&lt;/code&gt; a second time to get &lt;code&gt;75&lt;/code&gt; as two messages are sent to the outgoing port.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s put this all together in one example of customers sending their orders to a supermarket and receiving the fulfilled orders:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;supermarket = Ractor.new do
  loop do
    order = Ractor.receive
    puts &amp;quot;The supermarket is preparing #{order}&amp;quot;
    Ractor.yield &amp;quot;This is #{order}&amp;quot;
  end
end

customers = 5.times.map{ |i|
  Ractor.new supermarket, i do |supermarket, i|
    supermarket.send(&amp;quot;a pack of sugar for customer #{i}&amp;quot;)
    fulfilled_order = supermarket.take
    puts &amp;quot;#{fulfilled_order} received by customer #{i}&amp;quot;
  end
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output is as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;The supermarket is preparing a pack of sugar for customer 3
The supermarket is preparing a pack of sugar for customer 2
This is a pack of sugar for customer 3 received by customer 3
The supermarket is preparing a pack of sugar for customer 1
This is a pack of sugar for customer 2 received by customer 2
The supermarket is preparing a pack of sugar for customer 0
This is a pack of sugar for customer 1 received by customer 1
This is a pack of sugar for customer 0 received by customer 0
The supermarket is preparing a pack of sugar for customer 4
This is a pack of sugar for customer 4 received by customer 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running it a second time yields:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;The supermarket is preparing a pack of sugar for customer 0
This is a pack of sugar for customer 0 received by customer 0
The supermarket is preparing a pack of sugar for customer 4
This is a pack of sugar for customer 4 received by customer 4
The supermarket is preparing a pack of sugar for customer 1
This is a pack of sugar for customer 1 received by customer 1
The supermarket is preparing a pack of sugar for customer 3
The supermarket is preparing a pack of sugar for customer 2
This is a pack of sugar for customer 3 received by customer 3
This is a pack of sugar for customer 2 received by customer 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output can most definitely be in a different order every time we run this (because ractors run concurrently, as we have established).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A few things to note about sending and receiving messages:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Messages can also be sent using &lt;code&gt;&amp;lt;&amp;lt; msg&lt;/code&gt;, instead of &lt;code&gt;.send(msg)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;You can add a condition to a &lt;code&gt;.receive&lt;/code&gt; using &lt;code&gt;receive_if&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;When &lt;code&gt;.send&lt;/code&gt; is called on a ractor that is already terminated (not running), you get a &lt;code&gt;Ractor::ClosedError&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;A ractor&amp;#39;s outgoing port closes after &lt;code&gt;.take&lt;/code&gt; is called on it if it runs just once (not in a loop).&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;r = Ractor.new do
  Ractor.receive
end
# =&amp;gt; #&amp;lt;Ractor:#61 (irb):120 running&amp;gt;
r &amp;lt;&amp;lt; 5
# =&amp;gt; #&amp;lt;Ractor:#61 (irb):120 terminated&amp;gt;
r.take
# =&amp;gt; 5
r &amp;lt;&amp;lt; 9
# &amp;lt;internal:ractor&amp;gt;:583:in `send&amp;#39;: The incoming-port is already closed (Ractor::ClosedError)
r.take
# &amp;lt;internal:ractor&amp;gt;:694:in `take&amp;#39;: The outgoing-port is already closed (Ractor::ClosedError)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Objects can be moved to a destination ractor via &lt;code&gt;.send(obj, move: true)&lt;/code&gt; or &lt;code&gt;.yield(obj, move: true)&lt;/code&gt;. These objects become inaccessible at the previous destination, raising a &lt;code&gt;Ractor::MovedError&lt;/code&gt; when you try to call any other methods on the moved objects.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;r = Ractor.new do
  Ractor.receive
end
outer_object = &amp;quot;outer&amp;quot;
r.send(outer_object, move: true)
# =&amp;gt; #&amp;lt;Ractor:#3 (irb):7 terminated&amp;gt;
outer_object + &amp;quot;moved&amp;quot;
# `method_missing&amp;#39;: can not send any methods to a moved object (Ractor::MovedError)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Threads cannot be sent as messages using &lt;code&gt;.send&lt;/code&gt; and &lt;code&gt;.yield&lt;/code&gt;. Doing this results in a &lt;code&gt;TypeError&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;r = Ractor.new do
  Ractor.yield(Thread.new{})
end
# &amp;lt;internal:ractor&amp;gt;:627:in `yield&amp;#39;: allocator undefined for Thread (TypeError)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;shareable-and-unshareable-objects&quot;&gt;Shareable and Unshareable Objects&lt;/h2&gt;
&lt;p&gt;Shareable objects are objects that can be sent to and from a ractor without compromising thread safety. An immutable object is a good example because once created, it cannot be changed — e.g., numbers and booleans.&lt;/p&gt;
&lt;p&gt;You can check the shareability of an object via &lt;code&gt;Ractor.shareable?&lt;/code&gt; and make an object shareable via &lt;code&gt;Ractor.make_shareable&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Ractor.shareable?(5)
# =&amp;gt; true
Ractor.shareable?(true)
# =&amp;gt; true
Ractor.shareable?([4])
# =&amp;gt; false
Ractor.shareable?(&amp;#39;string&amp;#39;)
# =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As seen above, immutable objects are shareable and mutable ones aren&amp;#39;t. In Ruby, we usually call the &lt;code&gt;.freeze&lt;/code&gt; method on a string to make it immutable. This is the same method ractors apply to make an object shareable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;str = &amp;#39;string&amp;#39;
Ractor.shareable?(str)
# =&amp;gt; false
Ractor.shareable?(str.freeze)
# =&amp;gt; true
arr = [4]
arr.frozen?
# =&amp;gt; false
Ractor.make_shareable(arr)
# =&amp;gt; [4]
arr.frozen?
# =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Messages sent via ractors can either be shareable or unshareable. When shareable, the same object is passed around. However, when unshareable, ractors perform a full copy of the object by default and send the full copy instead.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;SHAREABLE = &amp;#39;share&amp;#39;.freeze
# =&amp;gt; &amp;quot;share&amp;quot;
SHAREABLE.object_id
# =&amp;gt; 350840
r = Ractor.new do
  loop do
    msg = Ractor.receive
    puts msg.object_id
  end
end
r.send(SHAREABLE)
# 350840
NON_SHAREABLE = &amp;#39;can not share me&amp;#39;
NON_SHAREABLE.object_id
# =&amp;gt; 572460
r.send(NON_SHAREABLE)
# 610420
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As seen above, the shareable object is the same within and outside the ractor. However, the unshareable one isn&amp;#39;t because the ractor has a different object, just identical to it.&lt;/p&gt;
&lt;p&gt;Another method to send an exact object when it is unshareable is the previously discussed &lt;code&gt;move: true&lt;/code&gt;. This moves an object to a destination without needing to perform a copy.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A few things to note about sharing objects in ractors:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ractor objects are also shareable objects.&lt;/li&gt;
&lt;li&gt;Constants that are shareable, but defined outside the scope of a ractor, can be accessed by a ractor. Recall our &lt;code&gt;outer_scope_object&lt;/code&gt; example? Give it another try, defined as &lt;code&gt;OUTER_SCOPE_OBJECT = &amp;quot;I am an outer scope object&amp;quot;.freeze&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Class and module objects are shareable, but instance variables or constants defined within them are not if assigned to unshareable values.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class C
  CONST = 5
  @share_me = &amp;#39;share me&amp;#39;.freeze
  @keep_me = &amp;#39;unaccessible&amp;#39;
  def bark
   &amp;#39;barked&amp;#39;
  end
end

Ractor.new C do |c|
  puts c::CONST
  puts c.new.bark
  puts c.instance_variable_get(:@share_me)
  puts c.instance_variable_get(:@keep_me)
end
# 5
# barked
# share me
# (irb):161:in `instance_variable_get&amp;#39;: can not get unshareable values from instance variables of classes/modules from non-main Ractors (Ractor::IsolationError)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;An incoming port or outgoing port can be closed using &lt;code&gt;Ractor#close_incoming&lt;/code&gt; and &lt;code&gt;Ractor#close_outgoing&lt;/code&gt;, respectively.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;wrap-up-and-further-reading-on-ractors&quot;&gt;Wrap Up and Further Reading on Ractors&lt;/h2&gt;
&lt;p&gt;In this article, we introduced the concept of ractors, including when and why to use them and how to get started. We also looked at how they communicate with one another, what objects are shareable and unshareable, and how to make objects shareable.&lt;/p&gt;
&lt;p&gt;Ractors go deeper than this. Many other public methods can be called on ractors, like &lt;code&gt;select&lt;/code&gt; to wait for the success of take, yield and receive, &lt;code&gt;count&lt;/code&gt;, &lt;code&gt;current&lt;/code&gt;, etc.&lt;/p&gt;
&lt;p&gt;To expand your knowledge about ractors, check out the &lt;a href=&quot;https://docs.ruby-lang.org/en/3.0/ractor_md.html&quot;&gt;ractor documentation&lt;/a&gt;. &lt;a href=&quot;https://gist.github.com/Kukunin/960ccef0d3c0a2c4b28ff5345911c2a5&quot;&gt;This GitHub gist&lt;/a&gt; might also interest you if you&amp;#39;d like to experimentally compare ractors with threads.&lt;/p&gt;
&lt;p&gt;Ractors are indeed experimental, but they certainly look like they have a bright future in Ruby&amp;#39;s evolution.&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>A Deep Dive into Memory Leaks in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/08/10/a-deep-dive-into-memory-leaks-in-ruby.html">
    <id>https://blog.appsignal.com/2022/08/10/a-deep-dive-into-memory-leaks-in-ruby.html</id>
    <published>2022-08-10T00:00:00+00:00</published>
    <updated>2022-08-10T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In the second and final part of our series on memory leaks in Ruby, let's dive a bit deeper into some tools you can use.</summary>
    <content type="html">&lt;p&gt;In the &lt;a href=&quot;https://blog.appsignal.com/2022/07/27/how-to-track-down-memory-leaks-in-ruby.html&quot;&gt;first part of this two-part series on memory leaks&lt;/a&gt;, we looked at how Ruby manages memory and how
Garbage Collection (GC) works.&lt;/p&gt;
&lt;p&gt;You might be able to afford powerful machines with more memory, and your app might
restart often enough that your users don&amp;#39;t notice, but memory usage matters.&lt;/p&gt;
&lt;p&gt;Allocation and Garbage Collection aren&amp;#39;t free. If you have a leak, you
spend more and more time on Garbage Collection instead of doing
what you built your app to do.&lt;/p&gt;
&lt;p&gt;In this post, we&amp;#39;ll look
deeper into the tools you can use to discover and diagnose a memory leak.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s continue!&lt;/p&gt;
&lt;h2 id=&quot;finding-leaks-in-ruby&quot;&gt;Finding Leaks in Ruby&lt;/h2&gt;
&lt;p&gt;Detecting a leak is simple enough. You can use &lt;code&gt;GC&lt;/code&gt;, &lt;code&gt;ObjectSpace&lt;/code&gt;,
and the RSS graphs in your APM tool to watch your memory usage increase. But
just knowing you have a leak is not enough to fix it. You need to
know where it is coming from. Raw numbers can&amp;#39;t tell you that.&lt;/p&gt;
&lt;p&gt;Fortunately, the Ruby ecosystem has some great tools to attach context to
those numbers. Two are &lt;code&gt;memory-profiler&lt;/code&gt; and &lt;code&gt;derailed_benchmarks&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;memory_profiler-in-ruby&quot;&gt;&lt;code&gt;memory_profiler&lt;/code&gt; in Ruby&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/SamSaffron/memory_profiler&quot;&gt;&lt;code&gt;memory_profiler&lt;/code&gt; gem&lt;/a&gt; offers a very simple API and a detailed (albeit a
little overwhelming) allocated and retained memory report — that includes the
classes of objects that are allocated, their size, and where they were allocated.
It&amp;#39;s straightforward to add to our leaky program.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# leaky.rb
require &amp;quot;memory_profiler&amp;quot;

an_array = []

report = MemoryProfiler.report do
  11.times do

    1000.times { an_array &amp;lt;&amp;lt; &amp;quot;A&amp;quot; + &amp;quot;B&amp;quot; + &amp;quot;C&amp;quot; }
    puts &amp;quot;Array is #{an_array.size} items long&amp;quot;
  end

  GC.start
end

report.pretty_print
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Outputting a report that looks similar to this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Total allocated: 440072 bytes (11001 objects)
Total retained:  440072 bytes (11001 objects)

allocated memory by gem
-----------------------------------
    440072  other

allocated memory by file
-----------------------------------
    440072  ./leaky.rb

allocated memory by location
-----------------------------------
    440000  ./leaky.rb:9
        72  ./leaky.rb:10

allocated memory by class
-----------------------------------
    440000  String
        72  Thread::Mutex

allocated objects by gem
-----------------------------------
     11001  other

allocated objects by file
-----------------------------------
     11001  ./leaky.rb

allocated objects by location
-----------------------------------
     11000  ./leaky.rb:9
         1  ./leaky.rb:10

allocated objects by class
-----------------------------------
     11000  String
         1  Thread::Mutex

retained memory by gem
-----------------------------------
    440072  other

retained memory by file
-----------------------------------
    440072  ./leaky.rb

retained memory by location
-----------------------------------
    440000  ./leaky.rb:9
        72  ./leaky.rb:10

retained memory by class
-----------------------------------
    440000  String
        72  Thread::Mutex

retained objects by gem
-----------------------------------
     11001  other

retained objects by file
-----------------------------------
     11001  ./leaky.rb

retained objects by location
-----------------------------------
     11000  ./leaky.rb:9
         1  ./leaky.rb:10

retained objects by class
-----------------------------------
     11000  String
         1  Thread::Mutex


Allocated String Report
-----------------------------------
     11000  &amp;quot;ABC&amp;quot;
     11000  ./leaky.rb:9


Retained String Report
-----------------------------------
     11000  &amp;quot;ABC&amp;quot;
     11000  ./leaky.rb:9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is a lot of information here, but generally, the
&lt;code&gt;allocated objects by location&lt;/code&gt; and &lt;code&gt;retained objects by location&lt;/code&gt; sections
can be the most useful when looking for leaks. These are the file locations
that allocate objects, ordered by the number of allocated objects.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;allocated&lt;/code&gt;&lt;/strong&gt; objects are all objects allocated (created) within the
&lt;code&gt;report&lt;/code&gt; block.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;retained&lt;/code&gt;&lt;/strong&gt; objects are objects that have not been garbage collected by
the end of the &lt;code&gt;report&lt;/code&gt; block. We forced a GC run before the end of the
block so we could see the leaked objects more clearly.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Be careful about trusting the &lt;code&gt;retained&lt;/code&gt; object counts. They depend heavily
on what portion of the leaking code is within the &lt;code&gt;report&lt;/code&gt; block.&lt;/p&gt;
&lt;p&gt;For example,
if we move the declaration of &lt;code&gt;an_array&lt;/code&gt; into the &lt;code&gt;report&lt;/code&gt; block, we might be
fooled into thinking the code isn&amp;#39;t leaky.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# leaky.rb
require &amp;quot;memory_profiler&amp;quot;

report = MemoryProfiler.report do
  an_array = []

  11.times do

    1000.times { an_array &amp;lt;&amp;lt; &amp;quot;A&amp;quot; + &amp;quot;B&amp;quot; + &amp;quot;C&amp;quot; }
    puts &amp;quot;Array is #{an_array.size} items long&amp;quot;
  end

  GC.start
end

report.pretty_print
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The top of the resulting report won&amp;#39;t report many retained objects
(just the report itself).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Total allocated: 529784 bytes (11002 objects)
Total retained:  72 bytes (1 objects)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;derailed_benchmarks-in-ruby&quot;&gt;&lt;code&gt;derailed_benchmarks&lt;/code&gt; in Ruby&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/zombocom/derailed_benchmarks&quot;&gt;&lt;code&gt;derailed_benchmarks&lt;/code&gt; gem&lt;/a&gt; is a suite of very useful tools for all
kinds of performance work, primarily aimed at Rails apps. For finding
leaks, we want to look at &lt;code&gt;perf:mem_over_time&lt;/code&gt;, &lt;code&gt;perf:objects&lt;/code&gt;, and
&lt;code&gt;perf:heap_diff&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;These tasks work by sending &lt;code&gt;curl&lt;/code&gt; requests to a running app, so we can&amp;#39;t add
them to our little leaky program. Instead, we&amp;#39;ll need to set up a small
Rails app with an endpoint that leaks memory, then install the
&lt;code&gt;derailed_benchmarks&lt;/code&gt; on that app.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# Create a rails app with no database
rails new leaky --skip-active-record --minimal

## Add derailed benchmarks
cd leaky
bundle add derailed_benchmarks
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/routes.rb
Rails.application.routes.draw do
  root &amp;quot;leaks#index&amp;quot;
end

# app/controllers/leaks_controller.rb
class LeaksController &amp;lt; ApplicationController
  def index
    1000.times { $an_array &amp;lt;&amp;lt; &amp;quot;A&amp;quot; + &amp;quot;B&amp;quot; + &amp;quot;C&amp;quot; }

    render plain: &amp;quot;Array is #{$an_array.size} items long&amp;quot;
  end
end

# config/initializers/array.rb
$an_array = []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should now be able to boot the app with &lt;code&gt;bin/rails s&lt;/code&gt;. You&amp;#39;ll be able
to &lt;code&gt;curl&lt;/code&gt; an endpoint that leaks on each request.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ curl http://localhost:3000

Array is 1000 items long

$ curl http://localhost:3000

Array is 2000 items long
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now use &lt;code&gt;derailed_benchmarks&lt;/code&gt; to see our leak in action.&lt;/p&gt;
&lt;h4 id=&quot;perfmem_over_time&quot;&gt;&lt;code&gt;perf:mem_over_time&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;This will show us memory use over time (similarly to how we watched the
memory growth of our leaky script with &lt;code&gt;watch&lt;/code&gt; and &lt;code&gt;ps&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Derailed will boot the app in production mode, repeatedly hit an endpoint
(&lt;code&gt;/&lt;/code&gt; by default), and report the memory usage. If it never stops growing, we
have a leak!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ TEST_COUNT=10000 DERAILED_SKIP_ACTIVE_RECORD=true \
  bundle exec derailed exec perf:mem_over_time

Booting: production
Endpoint: &amp;quot;/&amp;quot;
PID: 4417
104.33984375
300.609375
455.578125
642.69140625
751.6953125
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: Derailed will boot the Rails app in production mode to perform the tests. By default, it will also &lt;code&gt;require rails/all&lt;/code&gt; first. Since we don&amp;#39;t have a database in this app, we need to override this behavior with &lt;code&gt;DERAILED_SKIP_ACTIVE_RECORD=true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can run this benchmark against different endpoints to see which one/s (if
any) leak.&lt;/p&gt;
&lt;h4 id=&quot;perfobjects&quot;&gt;&lt;code&gt;perf:objects&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;perf:objects&lt;/code&gt; task uses &lt;code&gt;memory_profiler&lt;/code&gt; under the hood so the produced
report will look familiar.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ TEST_COUNT=10 DERAILED_SKIP_ACTIVE_RECORD=true \
  bundle exec derailed exec perf:objects

Booting: production
Endpoint: &amp;quot;/&amp;quot;
Running 10 times
Total allocated: 2413560 bytes (55476 objects)
Total retained:  400000 bytes (10000 objects)

# The rest of the report...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This report can help narrow down where your leaked memory is being
allocated. In our example, the report&amp;#39;s last section — the
&lt;code&gt;Retained String Report&lt;/code&gt; — tells us exactly what our problem is.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Retained String Report
-----------------------------------
     10000  &amp;quot;ABC&amp;quot;
     10000  /Users/tonyrowan/playground/leaky/app/controllers/leaks_controller.rb:3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We&amp;#39;ve leaked 10,000 strings containing &amp;quot;ABC&amp;quot; from the &lt;code&gt;LeaksController&lt;/code&gt; on
line 3. In a non-trivial app, this report would be significantly larger and
contain retained strings that you want to retain — query caches, etc. —
but this and the other &amp;#39;by location&amp;#39; sections should help you narrow down your
leak.&lt;/p&gt;
&lt;h4 id=&quot;perfheap_diff&quot;&gt;&lt;code&gt;perf:heap_diff&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;The &lt;code&gt;perf:heap_diff&lt;/code&gt; benchmark can help if the report from &lt;code&gt;perf:objects&lt;/code&gt; is too complex to
see where your leak is coming from.&lt;/p&gt;
&lt;p&gt;As the name suggests, &lt;code&gt;perf:heap_diff&lt;/code&gt; produces three
heap dumps and calculates the difference between them. It creates a report
that includes the types of objects retained between dumps and the
location that allocated them.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ DERAILED_SKIP_ACTIVE_RECORD=true bundle exec derailed exec perf:heap_diff

Booting: production
Endpoint: &amp;quot;/&amp;quot;
Running 1000 times
Heap file generated: &amp;quot;tmp/2022-06-15T11:08:28+01:00-heap-0.ndjson&amp;quot;
Running 1000 times
Heap file generated: &amp;quot;tmp/2022-06-15T11:08:28+01:00-heap-1.ndjson&amp;quot;
Running 1000 times
Heap file generated: &amp;quot;tmp/2022-06-15T11:08:28+01:00-heap-2.ndjson&amp;quot;

Diff
====
Retained STRING 999991 objects of size 39999640/40008500 (in bytes) at: /Users/tonyrowan/playground/leaky/app/controllers/leaks_controller.rb:3
Retained STRING 2 objects of size 148/40008500 (in bytes) at: /Users/tonyrowan/.asdf/installs/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/derailed_benchmarks-2.1.1/lib/derailed_benchmarks/tasks.rb:265
Retained STRING 1 objects of size 88/40008500 (in bytes) at: /Users/tonyrowan/.asdf/installs/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/derailed_benchmarks-2.1.1/lib/derailed_benchmarks/tasks.rb:266
Retained DATA 1 objects of size 72/40008500 (in bytes) at: /Users/tonyrowan/.asdf/installs/ruby/3.1.2/lib/ruby/3.1.0/objspace.rb:87
Retained IMEMO 1 objects of size 40/40008500 (in bytes) at: /Users/tonyrowan/.asdf/installs/ruby/3.1.2/lib/ruby/3.1.0/objspace.rb:88
Retained IMEMO 1 objects of size 40/40008500 (in bytes) at: /Users/tonyrowan/.asdf/installs/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/derailed_benchmarks-2.1.1/lib/derailed_benchmarks/tasks.rb:259
Retained IMEMO 1 objects of size 40/40008500 (in bytes) at: /Users/tonyrowan/.asdf/installs/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/derailed_benchmarks-2.1.1/lib/derailed_benchmarks/tasks.rb:260
Retained FILE 1 objects of size 8432/40008500 (in bytes) at: /Users/tonyrowan/.asdf/installs/ruby/3.1.2/lib/ruby/gems/3.1.0/gems/derailed_benchmarks-2.1.1/lib/derailed_benchmarks/tasks.rb:266

Run `$ heapy --help` for more options
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also read &lt;em&gt;&lt;a href=&quot;https://medium.com/klaxit-techblog/tracking-a-ruby-memory-leak-in-2021-9eb56575f731#875b&quot;&gt;Tracking a Ruby memory leak in 2021&lt;/a&gt;&lt;/em&gt; to understand better what&amp;#39;s going on.&lt;/p&gt;
&lt;p&gt;The report points us exactly where we need to go for our leaky baby app. At the
top of the diff, we see 999991 retained string objects allocated
from the &lt;code&gt;LeaksController&lt;/code&gt; on line 3.&lt;/p&gt;
&lt;h2 id=&quot;leaks-in-real-ruby-and-rails-apps&quot;&gt;Leaks in Real Ruby and Rails Apps&lt;/h2&gt;
&lt;p&gt;Hopefully, the examples we&amp;#39;ve used so far have never been put into real-life
apps — I hope no one intends to leak memory!&lt;/p&gt;
&lt;p&gt;In non-trivial apps, memory
leaks can be much harder to track down. Retained objects are not always bad —
a cache with garbage collected items would not be of much use.&lt;/p&gt;
&lt;p&gt;There is something common between all leaks, though. Somewhere, a root-level
object (a class/global, etc.) holds a reference to an object.&lt;/p&gt;
&lt;p&gt;One common example is a cache without a limit or an eviction policy. By
definition, this will leak memory since every object put into the cache will
remain forever. Over time, this cache will occupy more and more of the memory
of an app, with a smaller and smaller percentage of it actually in use.&lt;/p&gt;
&lt;p&gt;Consider the following code that fetches a high score for a game. It&amp;#39;s
similar to something I&amp;#39;ve seen in the past. This is an expensive request, and
we can easily bust the cache when it changes, so we want to cache it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Score &amp;lt; ApplicationModel
  def self.user_high_score(game, user)
    @scores = {} unless @scores

    if (score = @scores[&amp;quot;#{game.id}:#{user.id}&amp;quot;])
      score
    else
      Score.where(game: game, user: user).order(:score).first.tap do |score|
        @scores[&amp;quot;#{game.id}:#{user.id}&amp;quot;] = score
      end
    end
  end

  def self.save_score(game, user, raw_score)
    score = create!(game: game, user: user, score: raw_score)

    if raw_score &amp;gt; user_high_score(game, user).score
      @scores[&amp;quot;#{game.id}:#{user.id}&amp;quot;] = score
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;@scores&lt;/code&gt; hash is completely unchecked. It will grow to hold
every single high score for every user — not ideal if you have a lot of
either.&lt;/p&gt;
&lt;p&gt;In a Rails app, we would probably want to use &lt;code&gt;Rails.cache&lt;/code&gt;
with a sensible expiry (a memory leak in Redis is still a memory leak!) instead.&lt;/p&gt;
&lt;p&gt;In a non-Rails app, we want to limit the hash size, evicting the oldest
or least recently used items. &lt;a href=&quot;https://github.com/SamSaffron/lru_redux&quot;&gt;&lt;code&gt;LruRedux&lt;/code&gt;&lt;/a&gt; is a nice
implementation.&lt;/p&gt;
&lt;p&gt;A more subtle version of this leak is a cache with a limit, but
whose keys are of arbitrary size. If the keys themselves grow, so too will the
cache. Usually, you won&amp;#39;t hit this. But, if you&amp;#39;re serializing objects as JSON and
using that as a key, double-check that you&amp;#39;re not serializing things that grow
with usage as well — such as a list of a user&amp;#39;s read messages.&lt;/p&gt;
&lt;h2 id=&quot;circular-references&quot;&gt;Circular References&lt;/h2&gt;
&lt;p&gt;Circular references &lt;em&gt;can&lt;/em&gt; be garbage collected. Garbage Collection in Ruby uses
the &amp;quot;Mark and Sweep&amp;quot; algorithm. &lt;a href=&quot;https://rubykaigi.org/2021-takeout/presentations/peterzhu2118.html&quot;&gt;During their
presentation introducing variable
width allocation&lt;/a&gt;, Peter Zhu and Matt Valentine-House gave an excellent
explanation of how this algorithm works.&lt;/p&gt;
&lt;p&gt;Essentially, there are two phases: marking and sweeping.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;In the &lt;strong&gt;marking&lt;/strong&gt; phase, the garbage collector starts at root objects
(classes, globals, etc.), marks them, and then looks at their referenced
objects.&lt;/p&gt;
&lt;p&gt;It then marks all of the referenced objects. Referenced objects that are already
marked are not looked at again. This continues until there are no more
objects to look at — i.e., all referenced objects have been marked.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The garbage collector then moves on to the &lt;strong&gt;sweeping&lt;/strong&gt; phase. Any object not
marked is cleaned up.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Therefore, objects with live references can still be cleaned up. As long as a root object does not eventually reference an object, it will be collected. In
this way, clusters of objects with circular references can still be garbage
collected.&lt;/p&gt;
&lt;h2 id=&quot;application-performance-monitoring-the-event-timeline-and-allocated-objects-graph&quot;&gt;Application Performance Monitoring: The Event Timeline and Allocated Objects Graph&lt;/h2&gt;
&lt;p&gt;As mentioned in the &lt;a href=&quot;https://blog.appsignal.com/2022/07/27/how-to-track-down-memory-leaks-in-ruby.html&quot;&gt;first part of this series&lt;/a&gt;, any production-level app should use some form of Application Performance
Monitoring (APM).&lt;/p&gt;
&lt;p&gt;Many options are available, including rolling your
own (only recommended for larger teams). One key feature you should get from an APM is the ability
to see the number of allocations an action (or background job) makes. Good APM
tools will break this down, giving insight into where allocations come from — the controller, the view, etc.&lt;/p&gt;
&lt;p&gt;This is often called something like an &amp;#39;event timeline.&amp;#39; Bonus points if your
APM allows you to &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/instrumentation.html&quot;&gt;write custom code that further breaks down the timeline&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Consider the following code for a Rails controller.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class LeaksController &amp;lt; ApplicationController
  before_action :leak

  def index
    @leaks = $leak.sample(100)
  end


  private

  def leak
    1000.times { $leak &amp;lt;&amp;lt; Leak.new }
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When reported by an APM, the &amp;#39;event timeline&amp;#39; might look something like the
following screenshot from AppSignal.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/event-timeline-bare.png&quot; alt=&quot;Bare Event Timeline&quot;/&gt;&lt;/p&gt;
&lt;p&gt;This can be instrumented so we can see which part of the
code makes the allocations in the timeline. In real apps, it is probably going to be less obvious
from the code 😅&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class LeaksController &amp;lt; ApplicationController
  before_action :leak

  def index
    Appsignal.instrument(&amp;#39;leak.fetch_leaks&amp;#39;) do
      @leaks = $leak.sample(100)
    end
  end


  private

  def leak
    return unless params[:leak]

    Appsignal.instrument(&amp;#39;leak.create_leaks&amp;#39;) do
      1000.times { $leak &amp;lt;&amp;lt; Leak.new }
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here&amp;#39;s an example of an instrumented event timeline, again from AppSignal:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/event-timeline-instrumented.png&quot; alt=&quot;Instrumented Event Timeline&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Knowing where to instrument can often be difficult to grasp. There&amp;#39;s no substitute for really understanding your application&amp;#39;s code, but there are some signals that can serve as &amp;#39;smells&amp;#39;.&lt;/p&gt;
&lt;p&gt;If your APM surfaces GC runs or allocations over time, you can look for spikes to see if they match up with certain endpoints being hit or certain running background jobs. Here&amp;#39;s another example from &lt;a href=&quot;https://blog.appsignal.com/2022/07/28/appsignal-for-ruby-gem-3-1-mri-vm-magic-dashboard.html&quot;&gt;AppSignal&amp;#39;s Ruby VM magic dashboard&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/allocated-objects.png&quot; alt=&quot;Allocations&quot;/&gt;&lt;/p&gt;
&lt;p&gt;By looking at allocations in this way, we can narrow down our search when
looking into memory problems. This makes it much easier to use tools like
&lt;code&gt;memory_profiler&lt;/code&gt; and &lt;code&gt;derailed_benchmarks&lt;/code&gt; efficiently.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.appsignal.com/2022/07/28/appsignal-for-ruby-gem-3-1-mri-vm-magic-dashboard.html&quot;&gt;Read about the latest additions to AppSignal&amp;#39;s Ruby gem, like allocation and GC stats tracking&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;In this post, we dived into some tools that can help find and fix memory leaks, including &lt;code&gt;memory_profiler&lt;/code&gt;, &lt;code&gt;derailed_benchmarks&lt;/code&gt;, &lt;code&gt;perf:mem_over_time&lt;/code&gt;, &lt;code&gt;perf:objects&lt;/code&gt;, &lt;code&gt;perf:heap_diff&lt;/code&gt;, the event timeline and allocated objects graph in AppSignal.&lt;/p&gt;
&lt;p&gt;I hope you&amp;#39;ve found this post, alongside &lt;a href=&quot;https://blog.appsignal.com/2022/07/27/how-to-track-down-memory-leaks-in-ruby.html&quot;&gt;part one&lt;/a&gt;, useful in diagnosing and sorting out memory leaks in your Ruby app.&lt;/p&gt;
&lt;p&gt;Read more about the tools we used:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/SamSaffron/memory_profiler&quot;&gt;&lt;code&gt;memory_profiler&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/zombocom/derailed_benchmarks&quot;&gt;&lt;code&gt;derailed_benchmarks&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/tony-rowan/leaky-rails-app&quot;&gt;The leaky Rails app&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additional detailed reading:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ruby-doc.org/core-3.1.2/GC.html&quot;&gt;&lt;code&gt;GC&lt;/code&gt; module documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ruby-doc.org/core-3.1.2/ObjectSpace.html&quot;&gt;&lt;code&gt;ObjectSpace&lt;/code&gt; module documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jemma.dev/blog/ruby-garbage-collection-deep-dive/&quot;&gt;Garbage Collection Deep Dive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rubykaigi.org/2021-takeout/presentations/peterzhu2118.html&quot;&gt;Variable Width Allocation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Connect a Ruby on Rails App with React in a Monolith</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/08/03/connect-a-ruby-on-rails-app-with-react-in-a-monolith.html">
    <id>https://blog.appsignal.com/2022/08/03/connect-a-ruby-on-rails-app-with-react-in-a-monolith.html</id>
    <published>2022-08-03T00:00:00+00:00</published>
    <updated>2022-08-03T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Learn about the three main types of app architecture, then connect React with your monolith Ruby on Rails app.</summary>
    <content type="html">&lt;p&gt;More and more people are using Ruby on Rails to create a back-end API application for a front-end app.&lt;/p&gt;
&lt;p&gt;But what if you want to create a rich and functional interface with JavaScript and use Rails for the back-end, without having them in separate repositories? You can create a monolithic Rails application.&lt;/p&gt;
&lt;p&gt;This article will show you how to connect a Rails application with a front-end developed in React (without splitting the code into two separate applications). We&amp;#39;ll also give some alternatives if React is not your framework of choice, but you like the idea of a monolithic app with a rich front-end.&lt;/p&gt;
&lt;p&gt;But first, let’s start with an architecture overview to see why linking Rails and React is an option worth considering.&lt;/p&gt;
&lt;h2 id=&quot;app-architecture-an-overview&quot;&gt;App Architecture: An Overview&lt;/h2&gt;
&lt;p&gt;A while back, when a developer started to build a web application, they didn’t have a list of possible architectures they could use. For the most part, web apps were monoliths without a very interactive user interface.&lt;/p&gt;
&lt;p&gt;In modern software development, we have much more to choose from. We can:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use the old monolith architecture&lt;/li&gt;
&lt;li&gt;Go for a separated back-end and front-end&lt;/li&gt;
&lt;li&gt;Use service-oriented architecture&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let’s take a closer look at the most common types of architecture.&lt;/p&gt;
&lt;h3 id=&quot;headless-architecture&quot;&gt;Headless Architecture&lt;/h3&gt;
&lt;p&gt;In headless architecture, the head of an application is detached from its body. In other words, you create a back-end application using Ruby, Python, Node.js, or another programming language. This application manages a connection with a database and provides computing power.&lt;/p&gt;
&lt;p&gt;The body is a front-end application created with a framework like React, Vue, or Angular.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/headless.png&quot; alt=&quot;alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CDN stands for content delivery network, a service designed to deliver assets faster for visitors worldwide. We can build the architecture in the cloud environment, or each setup piece can be a separate server.&lt;/p&gt;
&lt;p&gt;Choose headless architecture when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;You aim for a large codebase.&lt;/strong&gt; If your application is going to be very large, the separate back-end and front-end layers will make it more maintainable.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You expect different workloads for different system elements.&lt;/strong&gt; With a more modular approach, you can scale modules separately.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You foresee that you&amp;#39;ll change the technology in the future.&lt;/strong&gt; It is easier to adopt new technology with a headless architecture, as the communication, in most cases, will be the same between the back-end and front-end, regardless of the stack.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Avoid a headless approach when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;You want to develop an MVP version of an app very quickly.&lt;/strong&gt; You will likely start over again in the future and consider a different angle.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You have a very small team.&lt;/strong&gt; Finding the right person to do the back-end, front-end, and DevOps stuff simultaneously might be hard.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You want to build a straightforward application.&lt;/strong&gt; Unfortunately, the headless approach increases your app&amp;#39;s complexity.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;monolith-architecture&quot;&gt;Monolith Architecture&lt;/h3&gt;
&lt;p&gt;One application handles the presentation layer (front) and computation layer (back) in a monolith architecture. Such an approach speeds up the application creation process and simplifies the server setup.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/monolith.png&quot; alt=&quot;alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;As you&amp;#39;ll notice, in a monolith, we eliminate a part of the communication that&amp;#39;s in the headless approach. Such architecture improves the performance and security of an application.&lt;/p&gt;
&lt;p&gt;Choose this architecture when:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;You develop an MVP version of your app.&lt;/strong&gt; Frameworks like Ruby on Rails or Django make it easy and fast to build robust monolith applications.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You start with a small team.&lt;/strong&gt; Back-end developers can easily handle the front-end in such an architecture, and the deployment process is straightforward.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Your application doesn’t have to depend on a very interactive front-end, and you don’t want to build a single-page application.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Avoid the monolith approach if:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;You know that the front-end of the application will be huge.&lt;/strong&gt; It is harder to maintain this part as it&amp;#39;s connected directly with the back-end codebase.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You know the front-end will have a completely different workload than the back-end.&lt;/strong&gt; As a result, you won’t scale certain elements of the monolith easily.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You may change the front-end or back-end tech stack in the future.&lt;/strong&gt; Such a transition would be pretty complicated with this architecture.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;hybrid-architecture&quot;&gt;Hybrid Architecture&lt;/h3&gt;
&lt;p&gt;An alternative approach to the monolith and headless architectures is a hybrid. You create a monolith application, but instead of using the front-end produced by the back-end framework, use the technology of headless applications.&lt;/p&gt;
&lt;p&gt;Yet this comes with a few disadvantages which you should consider:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The codebase is shared.&lt;/strong&gt; So as the application grows, it is harder to navigate through all the files and build a structure that is easy to understand.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scaling only the back-end or front-end is very difficult&lt;/strong&gt; as both parts connect in one application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Being agile is not easy.&lt;/strong&gt; With every change, you deploy the whole application, even if it’s just a change in the front-end style.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, you also get some benefits that you wouldn’t get with a standard monolith architecture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;You can work separately on the back-end and front-end and update libraries independently.&lt;/strong&gt; Changing the stack of the front-end is easier.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You can build a very interactive, single-page application&lt;/strong&gt; based on the monolith with a reasonably simple deployment process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You can be flexible.&lt;/strong&gt; It&amp;#39;s possible to use the front-end served by the JavaScript framework for some parts of your application.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With these pros and cons of hybrid architecture in mind, we will now go through the design process of a monolith application (created with Rails and a front-end React framework).&lt;/p&gt;
&lt;h2 id=&quot;designing-a-monolith-with-react&quot;&gt;Designing a Monolith with React&lt;/h2&gt;
&lt;p&gt;There are three main things to keep in mind before you build a monolith application with a React front-end:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Front-end framework installation process&lt;/strong&gt; - there are a few ways of adding React to a Rails application. However, each has some limitations, so choosing the right one for your project is essential.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Communication inside the application&lt;/strong&gt; - The back-end needs to expose data to the front-end, and the front needs to present this data. This element of the system needs to be designed carefully to make information exchange as smooth and fast as possible. As always, your choice should depend on the type of application you would like to build.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Alternatives&lt;/strong&gt; - You can still go for the hybrid approach but not use React. We will show you other solutions that you can quickly adapt to build a more interactive monolith.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;install-react-in-your-ruby-on-rails-app&quot;&gt;Install React in Your Ruby on Rails App&lt;/h2&gt;
&lt;p&gt;There are three main ways to install React in your Rails application.&lt;/p&gt;
&lt;h3 id=&quot;install-react-using-ruby-gems&quot;&gt;Install React Using Ruby Gems&lt;/h3&gt;
&lt;p&gt;We can extend the functionality of our app by installing external libraries called Ruby gems. If you are unfamiliar with JavaScript, this is the fastest way to add React to Rails.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/reactjs/react-rails&quot;&gt;react-rails library&lt;/a&gt; is one of the most popular Ruby gems to integrate React with Rails. It provides generators for components, testing helpers, and view helpers to render JavaScript code inside the views.&lt;/p&gt;
&lt;p&gt;If you accept another layer of logic for your front-end, using this Ruby gem is the best way to get started with React quickly. However, remember that besides the JS framework updates, you also have to depend on the gem updates. The more gems you use, the more problematic the Rails upgrade process can become.&lt;/p&gt;
&lt;h3 id=&quot;install-react-using-import-maps&quot;&gt;Install React Using Import Maps&lt;/h3&gt;
&lt;p&gt;Import maps were first presented in Rails 7. The lib lets you build modern JS applications using libraries made for ES modules without transpiling or bundling.&lt;/p&gt;
&lt;p&gt;Installing React with import maps is as easy as calling this command from the terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ./bin/importmap pin react react-dom
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You don’t even need to host source files on your server, as they are served from JavaScript’s CDN by default. By applying the &lt;code&gt;--download&lt;/code&gt; flag, you can download the files to the vendor directory inside your application.&lt;/p&gt;
&lt;p&gt;However, you cannot use JSX (the most popular rendering extension in the React community) with import maps. HTM library is an alternative solution.&lt;/p&gt;
&lt;h3 id=&quot;install-react-using-package-manager&quot;&gt;Install React Using Package Manager&lt;/h3&gt;
&lt;p&gt;This option seems to be the most flexible and optimal way to add React to a Rails project. You don’t create another level of abstraction for the front-end as you fetch the library directly. Updating React is also simpler.&lt;/p&gt;
&lt;p&gt;The most popular package managers in the Rails community are NPM and Yarn. You can add React libraries by invoking this command in the terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;yarn add react react-dom # or npm install react react-dom
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this installation method, you won’t get any Rails helpers to render JavaScript code. However, we&amp;#39;ll show you how to install and run React components using this approach shortly.&lt;/p&gt;
&lt;h2 id=&quot;communication-between-your-ruby-on-rails-app-and-react&quot;&gt;Communication Between Your Ruby on Rails App and React&lt;/h2&gt;
&lt;p&gt;Choosing the right way to exchange information between your Rails application and React components is essential. Selecting the wrong method can harm your application&amp;#39;s performance and make your code less maintainable.&lt;/p&gt;
&lt;p&gt;There are two common, standardized ways of exposing information from the back-end — REST and GraphQL. Let&amp;#39;s take a look at both options.&lt;/p&gt;
&lt;h3 id=&quot;rest-communication&quot;&gt;REST Communication&lt;/h3&gt;
&lt;p&gt;The REST API is a pretty simple way of exchanging information. We have different request types at our disposal to perform CRUD (create, retrieve, update, delete) operations. If you are familiar with the concept of resources in Rails, the REST API works the same way.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/rest.png&quot; alt=&quot;REST&quot;/&gt;&lt;/p&gt;
&lt;p&gt;You call the &lt;code&gt;/authors&lt;/code&gt; endpoint if you want to pull information about authors or a single author. You call the &lt;code&gt;/posts&lt;/code&gt; endpoint to do the same, but for posts. If a single page in your application requires a lot of different data, you will perform multiple HTTP requests.&lt;/p&gt;
&lt;p&gt;You should consider using REST in your application if:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Your front-end application doesn’t need to render data from different sources on a single page.&lt;/strong&gt; On the other hand, this doesn’t have to mean that the application is very simple.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You don’t want to implement the cache mechanism on the application level.&lt;/strong&gt; Using REST API, you can benefit from the HTTP cache provided by browsers.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You care about error reporting.&lt;/strong&gt; Implementing an error report with REST is easy as you work on different HTTP responses. With GraphQL, it’s not, as your application always returns a 200 response status.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;graphql-communication&quot;&gt;GraphQL Communication&lt;/h3&gt;
&lt;p&gt;GraphQL represents an entirely different approach to data fetching. Using this technology, you perform one request and get only the data you need. You can hit multiple endpoints at once and pull only one attribute per endpoint.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-08/graphql.png&quot; alt=&quot;GraphQL&quot;/&gt;&lt;/p&gt;
&lt;p&gt;With GraphQL implemented on the back-end, you always call the same endpoint and modify the query parameter.&lt;/p&gt;
&lt;p&gt;You should consider using GraphQL in your application if:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;You are building a very interactive application&lt;/strong&gt; requiring the front-end to pull a lot of different data at once.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You want to build your application very quickly.&lt;/strong&gt; Building an API with REST is slower. With GraphQL, you get maximum flexibility, and all you need to care about in every step is the content of the query.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You are building an application where the API is used by multiple different applications&lt;/strong&gt; like mobile, front-end, or services.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;front-end-alternatives-to-react-for-your-ruby-on-rails-app&quot;&gt;Front-end Alternatives to React for Your Ruby on Rails App&lt;/h2&gt;
&lt;p&gt;If you don’t want to use React but like the idea of having a front-end application inside the Rails monolith, there are some alternative solutions available.&lt;/p&gt;
&lt;h3 id=&quot;rails-turbo&quot;&gt;Rails Turbo&lt;/h3&gt;
&lt;p&gt;Turbo allows you to write single-page applications without the need for any JavaScript code. You design the page from independent frames. They behave like components and can also be lazy-loaded if needed.&lt;/p&gt;
&lt;p&gt;With Rails Turbo, you don’t spend time building the JSON responses from an API. You can simply reuse Rails views and render HTML — it’s automatically transferred and rendered in your components. This reduces the amount of code in your application.&lt;/p&gt;
&lt;p&gt;You should consider using Rails Turbo if:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;You don’t like writing JavaScript.&lt;/strong&gt; It is possible to design rich and interactive web applications without the need for a single line of JavaScript.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You like the Rails framework.&lt;/strong&gt; The Turbo library provides helper methods to quickly build interactive pages or transform existing ones into more dynamic forms.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;You want to move fast.&lt;/strong&gt; As mentioned before, you don’t have to care about the JSON responses from an API. You can simply serve HTML views and the Turbo library will automatically pull them.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;stimulus-js&quot;&gt;Stimulus JS&lt;/h3&gt;
&lt;p&gt;Stimulus is a JavaScript framework created by the Rails team. It was designed to extend the HTML that you already have. The main concept of this framework is the controller — one controller per view.&lt;/p&gt;
&lt;p&gt;Your Rails application will automatically load the JavaScript controller for the given view and map the HTML elements. You can respond to events or modify the view when you need to.&lt;/p&gt;
&lt;p&gt;You should consider using Stimulus if:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You are already using Rails Turbo, but want more control over a page&amp;#39;s granular elements.&lt;/li&gt;
&lt;li&gt;You don’t want to build a single-page application but still want to make some page elements interactive or dynamic.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;other-javascript-frameworks&quot;&gt;Other JavaScript Frameworks&lt;/h3&gt;
&lt;p&gt;Besides React, other interesting JavaScript frameworks on the market right now include Vue, Svelte, and Ember.js. So if you like writing JavaScript components, you can choose one of these.&lt;/p&gt;
&lt;p&gt;Rails Turbo and/or Stimulus JS are the perfect choice if you&amp;#39;re a Rails developer who&amp;#39;s familiar with JavaScript but doesn’t want to write much of it. Both libraries heavily follow the principles of the Rails framework, so if you already work in this ecosystem, it will be easier for you to use these extensions.&lt;/p&gt;
&lt;h2 id=&quot;build-a-monolith-with-react&quot;&gt;Build a Monolith with React&lt;/h2&gt;
&lt;p&gt;It’s time to build a simple Rails application to manage a list of books we want to read. Let&amp;#39;s start with generating the Rails skeleton.&lt;/p&gt;
&lt;h3 id=&quot;ruby-on-rails-project-bootstrap&quot;&gt;Ruby on Rails Project Bootstrap&lt;/h3&gt;
&lt;p&gt;Ensure you have the latest version of Ruby on Rails installed locally on your operating system. Then generate the skeleton using the &lt;code&gt;rails new&lt;/code&gt; command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails new booklist -d postgresql -j esbuild
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above command will generate a new Rails project in the &lt;code&gt;booklist&lt;/code&gt; directory, with support for a PostgreSQL database. We can now enter the project’s directory, create the database, and run the server:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd booklist/
./bin/rails db:create
rails s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Visit the localhost:3000 address in your browser to see the default Rails welcome screen.&lt;/p&gt;
&lt;p&gt;Now generate a home controller for a single endpoint in the application so we can attach the React application to the layout. Run this command in the terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./bin/rails g controller Home index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last step is to update &lt;code&gt;config/routes.rb&lt;/code&gt; file to set the root path:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Rails.application.routes.draw do
  root &amp;quot;home#index&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now focus on the front-end part with React.&lt;/p&gt;
&lt;h3 id=&quot;react-installation&quot;&gt;React Installation&lt;/h3&gt;
&lt;p&gt;We will install the &lt;code&gt;react&lt;/code&gt;, &lt;code&gt;react-dom&lt;/code&gt;, and &lt;code&gt;node-uuid&lt;/code&gt; libraries using yarn in our terminal:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;yarn add react react-dom node-uuid
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To properly handle JSX, we also have to update our build script. First, open the &lt;code&gt;package.json&lt;/code&gt; file, and in the &lt;code&gt;scripts&lt;/code&gt; section, ensure that the &lt;code&gt;build&lt;/code&gt; command is the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;esbuild app/javascript/*.* --bundle --sourcemap --outdir=app/assets/builds --public-path=assets --loader:.js=jsx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can now run &lt;code&gt;./bin/dev&lt;/code&gt; to kickstart both &lt;code&gt;yarn build&lt;/code&gt; and the rails server or run them separately. For example, if you want processes in separate terminal tabs, run &lt;code&gt;rails s&lt;/code&gt; in one and &lt;code&gt;yarn build –watch&lt;/code&gt; in the second.&lt;/p&gt;
&lt;h3 id=&quot;render-a-react-application-in-a-rails-layout&quot;&gt;Render a React Application in a Rails Layout&lt;/h3&gt;
&lt;p&gt;We want to run the React application when a user enters the main root in our Rails application. To do this, update the &lt;code&gt;app/views/layout.html.erb&lt;/code&gt; file, so that the &lt;code&gt;body&lt;/code&gt; section looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;body&amp;gt;
  &amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The React application will render the component with JavaScript logic inside the &lt;code&gt;app&lt;/code&gt; div.&lt;/p&gt;
&lt;p&gt;Let’s now create the entry point for the React application. Open the &lt;code&gt;app/javascript/application.js&lt;/code&gt; file and write the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React from &amp;quot;react&amp;quot;;
import { createRoot } from &amp;quot;react-dom/client&amp;quot;;
import App from &amp;quot;./App&amp;quot;;

const container = document.getElementById(&amp;quot;app&amp;quot;);
const root = createRoot(container);
root.render(&amp;lt;App /&amp;gt;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have the container element, but we are missing the &lt;code&gt;App&lt;/code&gt; component so the application will throw an error. Let’s create the &lt;code&gt;App&lt;/code&gt; component then.&lt;/p&gt;
&lt;h2 id=&quot;writing-a-react-component&quot;&gt;Writing a React Component&lt;/h2&gt;
&lt;p&gt;We won’t create a separate directory for components. Let&amp;#39;s place our tiny application in one component for demonstration purposes.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: When writing a production app, always design the React app using multiple components and follow the best design principles.&lt;/p&gt;
&lt;p&gt;Create a file &lt;code&gt;App.js&lt;/code&gt; in the &lt;code&gt;app/javascript&lt;/code&gt; directory and place the application skeleton there, with the header as a placeholder:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import React, { useState } from &amp;quot;react&amp;quot;;

export default function App() {
  const [books, setBooks] = useState([]);

  return (
    &amp;lt;&amp;gt;
      &amp;lt;h1&amp;gt;Books {books.length}&amp;lt;/h1&amp;gt;
    &amp;lt;/&amp;gt;
  );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;rendering-a-book-list&quot;&gt;Rendering a Book List&lt;/h3&gt;
&lt;p&gt;Now it’s time to render a simple list of books. To do this, we have to update the &lt;code&gt;render&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;return (
  &amp;lt;&amp;gt;
    &amp;lt;h1&amp;gt;Books {books.length}&amp;lt;/h1&amp;gt;
    &amp;lt;div&amp;gt;
      &amp;lt;table&amp;gt;
        &amp;lt;thead&amp;gt;
          &amp;lt;tr&amp;gt;
            &amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;
            &amp;lt;th&amp;gt;Author&amp;lt;/th&amp;gt;
          &amp;lt;/tr&amp;gt;
        &amp;lt;/thead&amp;gt;
        &amp;lt;tbody&amp;gt;
          {books &amp;amp;&amp;amp;
            books.map(({ id, title, author }, i) =&amp;gt; (
              &amp;lt;tr key={id}&amp;gt;
                &amp;lt;td&amp;gt;{title}&amp;lt;/td&amp;gt;
                &amp;lt;td&amp;gt;{author}&amp;lt;/td&amp;gt;
              &amp;lt;/tr&amp;gt;
            ))}
        &amp;lt;/tbody&amp;gt;
      &amp;lt;/table&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;create-a-new-book&quot;&gt;Create a New Book&lt;/h3&gt;
&lt;p&gt;We don’t have anything we can render. Let’s add the form to create a new book so we can fill our list with some data that we can later edit and delete if needed.&lt;/p&gt;
&lt;p&gt;However, before we do this, we have to update our component to store some more information:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import { default as UUID } from &amp;quot;node-uuid&amp;quot;;

const [action, setAction] = useState(&amp;quot;list&amp;quot;);
const [formData, setFormData] = useState({ title: &amp;quot;&amp;quot;, author: &amp;quot;&amp;quot; });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I’m not going to create a separate component for the form, so I have to use a conditional in the render function. Thanks to the &lt;code&gt;action&lt;/code&gt;, I can tell when to render the list or form.&lt;/p&gt;
&lt;p&gt;Our &lt;code&gt;render&lt;/code&gt; function is the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;return (
  &amp;lt;&amp;gt;
    &amp;lt;h1&amp;gt;Books {books.length}&amp;lt;/h1&amp;gt;
    {action == &amp;quot;list&amp;quot; ? (
      &amp;lt;div&amp;gt;
        &amp;lt;button onClick={() =&amp;gt; setAction(&amp;quot;form&amp;quot;)}&amp;gt;New book&amp;lt;/button&amp;gt;
        &amp;lt;table&amp;gt;
          &amp;lt;thead&amp;gt;
            &amp;lt;tr&amp;gt;
              &amp;lt;th&amp;gt;Title&amp;lt;/th&amp;gt;
              &amp;lt;th&amp;gt;Author&amp;lt;/th&amp;gt;
              &amp;lt;th&amp;gt;&amp;lt;/th&amp;gt;
            &amp;lt;/tr&amp;gt;
          &amp;lt;/thead&amp;gt;
          &amp;lt;tbody&amp;gt;
            {books &amp;amp;&amp;amp;
              books.map(({ id, title, author }, i) =&amp;gt; (
                &amp;lt;tr key={id}&amp;gt;
                  &amp;lt;td&amp;gt;{title}&amp;lt;/td&amp;gt;
                  &amp;lt;td&amp;gt;{author}&amp;lt;/td&amp;gt;
                  &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;
                &amp;lt;/tr&amp;gt;
              ))}
          &amp;lt;/tbody&amp;gt;
        &amp;lt;/table&amp;gt;
      &amp;lt;/div&amp;gt;
    ) : (
      &amp;lt;div&amp;gt;
        &amp;lt;form&amp;gt;
          &amp;lt;label&amp;gt;Title:&amp;lt;/label&amp;gt;
          &amp;lt;input
            onChange={(e) =&amp;gt;
              setFormData({ ...formData, title: e.target.value })
            }
            name=&amp;quot;title&amp;quot;
            value={formData.title}
          /&amp;gt;
          &amp;lt;label&amp;gt;Author:&amp;lt;/label&amp;gt;
          &amp;lt;input
            onChange={(e) =&amp;gt;
              setFormData({ ...formData, author: e.target.value })
            }
            name=&amp;quot;author&amp;quot;
            value={formData.author}
          /&amp;gt;
          &amp;lt;button onClick={(e) =&amp;gt; saveBook(e)}&amp;gt;Submit&amp;lt;/button&amp;gt;
          &amp;lt;button onClick={() =&amp;gt; setAction(&amp;quot;list&amp;quot;)}&amp;gt;Back&amp;lt;/button&amp;gt;
        &amp;lt;/form&amp;gt;
      &amp;lt;/div&amp;gt;
    )}
  &amp;lt;/&amp;gt;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each time you type something into the title or author input, &lt;code&gt;formData&lt;/code&gt; will update with values from the form. The last missing piece is the &lt;code&gt;saveBook&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const saveBook = (e) =&amp;gt; {
  e.preventDefault();

  setBooks([...books, { ...formData, id: UUID.v4() }]);
  setFormData({ title: &amp;quot;&amp;quot;, author: &amp;quot;&amp;quot;, id: &amp;quot;&amp;quot; });
  setAction(&amp;quot;list&amp;quot;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first step is to prevent a form submission — we don’t want to reload the page. Then we update the books collection and reset the form data. The last step is to render back the list view.&lt;/p&gt;
&lt;h3 id=&quot;update-an-existing-book&quot;&gt;Update an Existing Book&lt;/h3&gt;
&lt;p&gt;Let&amp;#39;s reuse the form we created in the previous step. We also have to store the id of the book we are currently editing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const [currentBookId, setCurrentBookId] = useState(null);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;editBook&lt;/code&gt; function will set the id of the book we want to edit. Fill the form with values and render the form view:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const editBook = (id) =&amp;gt; {
  const currentBook = books.find((book) =&amp;gt; book.id == id);
  setCurrentBookId(id);
  setFormData({
    ...formData,
    title: currentBook.title,
    author: currentBook.author,
  });
  setAction(&amp;quot;form&amp;quot;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we are going to use the &lt;code&gt;saveBook&lt;/code&gt; function for a creation and update action, we have to modify it accordingly:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const saveBook = async (e) =&amp;gt; {
  e.preventDefault();

  if (currentBookId) {
    bookIndex = books.findIndex((book) =&amp;gt; book.id == currentBookId);
    updatedBooks = [...books];
    updatedBooks[bookIndex] = formData;
    setBooks(updatedBooks);
    setCurrentBookId(null);
  } else {
    setBooks([...books, { ...formData, id: UUID.v4() }]);
  }

  setFormData({ title: &amp;quot;&amp;quot;, author: &amp;quot;&amp;quot;, id: &amp;quot;&amp;quot; });
  setAction(&amp;quot;list&amp;quot;);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;delete-a-single-book&quot;&gt;Delete a Single Book&lt;/h3&gt;
&lt;p&gt;Let’s start with building the simple code for destroying the book:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;const deleteBook = (id) =&amp;gt; {
  setBooks(books.filter((book) =&amp;gt; book.id != id));
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get the array of books that aren&amp;#39;t deleted and update the &lt;code&gt;books&lt;/code&gt; collection. React will update our component automatically.&lt;/p&gt;
&lt;h3 id=&quot;the-complete-component&quot;&gt;The Complete Component&lt;/h3&gt;
&lt;p&gt;We implemented all the actions needed to create, update, list, and destroy a book. &lt;a href=&quot;https://gist.github.com/pdabrowski6/ac2c04a71f8c98e6ee386d2a3c3807cd&quot;&gt;View the code for the complete component in this Gist&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;recap&quot;&gt;Recap&lt;/h2&gt;
&lt;p&gt;Congratulations, you created a React application inside a Rails monolith! Let’s summarize what we have learned and done during this article.&lt;/p&gt;
&lt;h3 id=&quot;different-types-of-architecture-for-web-apps&quot;&gt;Different Types of Architecture for Web Apps&lt;/h3&gt;
&lt;p&gt;When you build a web application, it has a front and back part. So you need to decide how you want to connect these two sides. Here&amp;#39;s a reminder of the most common types of architecture:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Headless architecture&lt;/strong&gt; - The front-end application is separate from the back-end. Choose it if you expect to write a lot of code, want to change technologies in the future, or expect a different workload for the front-end and back-end. However, keep in mind that such architecture increases the complexity of an application, takes more time to build, and the development process might be complex for a small development team.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Monolith architecture&lt;/strong&gt; - One application that handles both front-end and back-end. You can build one with popular frameworks like Ruby on Rails or Django. With this architecture, you can build fast with a small team. However, you can run into trouble in the future if you want to change the technology or scale only part of the application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hybrid architecture&lt;/strong&gt; - A compromise between a monolith and headless architecture. You build one codebase, but the front-end is served by a different technology from the back-end. The codebase might be hard to navigate, and it will be challenging to scale only one piece of the system. However, it is more flexible than a monolith. If you don’t like monoliths, but don’t want to fully detach the front from the back-end, this solution is for you.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;the-design-process-to-build-hybrid-architecture&quot;&gt;The Design Process to Build Hybrid Architecture&lt;/h3&gt;
&lt;p&gt;Don’t jump into coding straight away. Think about the specifications of your application. When building a Rails application that uses a React framework for the front-end, you have to consider the following things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Installation process&lt;/strong&gt; - You can install React using import maps if you don’t need to use JSX templates. Otherwise, you can select package managers like Yarn or NPM, or install React using a Ruby gem.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Communication between Rails and React&lt;/strong&gt; - Both applications are inside the same codebase, but need a bridge to exchange information. Use REST API for simpler applications and GraphQL for more complex interfaces where a lot of different data is necessary for the view layer.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;alternatives-to-react-for-a-rails-app&quot;&gt;Alternatives to React for a Rails App&lt;/h3&gt;
&lt;p&gt;If you decide that you don’t want to use React, but you like the idea of hybrid architecture, you can consider the following alternative solutions for the front-end:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Rails Turbo&lt;/strong&gt; - With this library, you can split the page into independent frames and update them when needed. Go for this option if you like the Rails framework, and don’t want to write a lot of JavaScript code.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stimulus JS&lt;/strong&gt; - A small library for the HTML you already have in your views. Choose it when you are happy with your Rails monolith, but you want to make some views more interactive.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Other JavaScript frameworks&lt;/strong&gt; - If you want to write more JavaScript, you can use Vue.js, Svelte, or Ember.js, instead of React. You can easily incorporate these solutions into your Rails application.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;summing-up&quot;&gt;Summing Up&lt;/h2&gt;
&lt;p&gt;In this post, we explored the three main types of architecture — headless, monolith, and hybrid — and looked at their pros and cons. We then created a React application inside a Rails monolith.&lt;/p&gt;
&lt;p&gt;Now it should hopefully be easier for you to choose the right architecture and tools for your next project.&lt;/p&gt;
&lt;p&gt;Until next time, happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>How to Track Down Memory Leaks in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/07/27/how-to-track-down-memory-leaks-in-ruby.html">
    <id>https://blog.appsignal.com/2022/07/27/how-to-track-down-memory-leaks-in-ruby.html</id>
    <published>2022-07-27T00:00:00+00:00</published>
    <updated>2022-07-27T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's explore how Ruby manages memory, garbage collection, and how to uncover a leak, in the first of this two-part series on memory leaks in Ruby.</summary>
    <content type="html">&lt;p&gt;A memory leak is an unintentional, uncontrolled, and unending increase in
memory usage. No matter how small, eventually, a leak will cause your process
to run out of memory and crash. Even if you periodically restart your app to
avoid this crash (no judgment, I&amp;#39;ve done that!), you still suffer the
performance implications of a memory leak.&lt;/p&gt;
&lt;p&gt;In this post, the first of a two-part series on memory leaks, we&amp;#39;ll start by looking at how Ruby manages memory, how Garbage Collection (GC) works, and how to find a leak.&lt;/p&gt;
&lt;p&gt;In the second part, we&amp;#39;ll take a deeper dive into tracking down leaks.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s get started!&lt;/p&gt;
&lt;h2 id=&quot;ruby-memory-management&quot;&gt;Ruby Memory Management&lt;/h2&gt;
&lt;p&gt;Ruby objects are stored on the heap, and each object fills one slot on the
heap.&lt;/p&gt;
&lt;p&gt;Prior to Ruby 3.1, all slots on the heap were the same size — 40 bytes,
to be exact. Objects too large to fit in a slot were stored outside
the heap. Each slot included a reference to where objects were moved.&lt;/p&gt;
&lt;p&gt;In Ruby 3.1,
&lt;a href=&quot;https://bugs.ruby-lang.org/issues/17816&quot;&gt;variable width allocation&lt;/a&gt; for &lt;code&gt;String&lt;/code&gt;
objects was merged. Soon, variable width allocation will be the norm for all
object types.&lt;/p&gt;
&lt;p&gt;Variable width allocation aims to improve performance by improving cache
locality — all the information of an object will be stored in one place
rather than across two memory locations.&lt;/p&gt;
&lt;p&gt;It should also simplify (some parts) of memory management. At the moment,
there are two &amp;#39;heaps&amp;#39;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Ruby heap (or GC heap) that stores smaller Ruby objects.&lt;/li&gt;
&lt;li&gt;The C heap (or malloc/transient heap) that stores larger objects.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once variable width allocation is the norm, there should be no need
for the latter heap.&lt;/p&gt;
&lt;p&gt;The heap starts at a given size (10,000 slots by default) and objects are
assigned to free slots as they are created. When Ruby tries to create an object
and there are no free slots available, Garbage Collection (GC) occurs to make
some free slots available.&lt;/p&gt;
&lt;p&gt;If there are too few free slots after GC, the
heap will be expanded (more on this a little later).&lt;/p&gt;
&lt;p&gt;Here are the factors you can control, alongside their &lt;a href=&quot;https://docs.ruby-lang.org/ja/latest/class/GC.html&quot;&gt;environment variables&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Initial size of the heap - &lt;code&gt;RUBY_GC_HEAP_INIT_SLOTS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Number of free slots that should be available after GC occurs - &lt;code&gt;RUBY_GC_HEAP_FREE_SLOTS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Amount the heap is expanded by - &lt;code&gt;RUBY_GC_HEAP_GROWTH_FACTOR&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;garbage-collection-in-ruby&quot;&gt;Garbage Collection in Ruby&lt;/h2&gt;
&lt;p&gt;Garbage Collection in Ruby &amp;#39;stops the world&amp;#39; — no other
process occurs when GC occurs. Garbage Collection in Ruby
(since 2.1) is also &lt;em&gt;generational&lt;/em&gt;, meaning that the garbage collector has two
modes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Minor GC&lt;/strong&gt; - inspects &amp;#39;young&amp;#39; objects (objects created recently)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Major GC&lt;/strong&gt; - inspects &amp;#39;old&amp;#39; objects as well as &amp;#39;young&amp;#39; objects (&lt;em&gt;all&lt;/em&gt; the
objects)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: An &amp;#39;old&amp;#39; object has survived &lt;code&gt;3&lt;/code&gt; GC runs, major or minor.&lt;/p&gt;
&lt;p&gt;When the heap is full, minor GC is invoked first. If it can&amp;#39;t free up enough
slots to be below the limit, major GC will be invoked. Only then, if there are
still not enough free slots, will the heap be expanded.&lt;/p&gt;
&lt;p&gt;Major GC is more expensive than minor GC because it looks at more objects.&lt;/p&gt;
&lt;p&gt;The theory behind why generational GC is more performant is that objects
usually fall into two categories:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Objects that are allocated and then quickly go out of scope.&lt;/strong&gt; In a Rails app,
models fetched from the DB to render a page will go out of scope when the
request ends.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Objects that are allocated and kept around for a long time.&lt;/strong&gt; Classes and
caches are likely to still be in use throughout the lifetime of an app.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Major GC will also run after minor GC if the number of old objects is above a
certain threshold, even if there are sufficient free slots. This limit
increases as the size of the heap grows and can be controlled by the
&lt;code&gt;RUBY_GC_HEAP_OLDOBJECT_LIMIT_FACTOR&lt;/code&gt; environment variable.&lt;/p&gt;
&lt;p&gt;When you have a leak, you create objects that can&amp;#39;t be cleaned up — more and more &lt;code&gt;old&lt;/code&gt; objects. This means that major (expensive) GC
will run much more often than it should. Since nothing else runs when GC is running, this is time that you waste.&lt;/p&gt;
&lt;p&gt;I&amp;#39;ve left some links at the end of this article for further reading on memory
layout and the garbage collector in Ruby.&lt;/p&gt;
&lt;h2 id=&quot;what-does-a-memory-leak-look-like-in-ruby&quot;&gt;What Does A Memory Leak Look Like in Ruby?&lt;/h2&gt;
&lt;p&gt;You can see a memory leak using simple tools available on any
Unix system. Take the following code as an example.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# leaky.rb

an_array = []

loop do
  1000.times { an_array &amp;lt;&amp;lt; &amp;quot;A&amp;quot; + &amp;quot;B&amp;quot; + &amp;quot;C&amp;quot; }
  puts an_array.size
  sleep 1
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To say this code &amp;#39;leaks&amp;#39; is a little unfair — all it does is leak! —
but it serves our purposes.&lt;/p&gt;
&lt;p&gt;We can observe the leak quite simply from the command line by running this
program in one terminal and &lt;code&gt;watch&lt;/code&gt;-ing the memory increase over time with
&lt;code&gt;ps&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# In terminal one
$ ruby ./leaky.rb

# In terminal two
$ watch ps -p `pgrep -f &amp;quot;ruby ./leaky.rb&amp;quot;` -o pmem,pcpu,rss,args
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;pgrep -f &amp;quot;ruby ./leaky.rb&amp;quot;&lt;/code&gt; finds the process ID for us, so that we can restrict the
&lt;code&gt;ps&lt;/code&gt; output to only the process we&amp;#39;re interested in. As you may be able to
guess, it&amp;#39;s like &lt;code&gt;grep&lt;/code&gt; for processes.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;watch&lt;/code&gt; tool allows us to poll the
output of a given command and update it in place, giving us a live dashboard
within our terminal.&lt;/p&gt;
&lt;p&gt;You&amp;#39;ll get output like this, which updates every couple of seconds.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Every 2.0s: ps -p 50866 -o pmem,pcpu,rss,args

%MEM  %CPU    RSS ARGS
 0.2   4.1 163408 /Users/tonyrowan/.asdf/installs/ruby/3.1.1/bin/ruby ./leaky.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You should see the &lt;code&gt;%MEM&lt;/code&gt; and &lt;code&gt;RSS&lt;/code&gt; increasing. They are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;%MEM&lt;/code&gt;&lt;/strong&gt; - The amount of memory the process uses as a percentage of
memory on the host machine.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;RSS&lt;/code&gt;&lt;/strong&gt; (resident set size) - The amount of RAM the process uses in bytes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This basic OS-only information is enough to spot if you have a leak — if
the memory keeps going up, it means you do!&lt;/p&gt;
&lt;h2 id=&quot;find-ruby-leaks-with-the-garbage-collector-module&quot;&gt;Find Ruby Leaks with the Garbage Collector Module&lt;/h2&gt;
&lt;p&gt;We can also detect leaks within Ruby code itself with the &lt;code&gt;GC&lt;/code&gt; module.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# leaky.rb

GC.disable # Only run GC when manually called

an_array = []

loop do
  1000.times { an_array &amp;lt;&amp;lt; &amp;quot;A&amp;quot; + &amp;quot;B&amp;quot; + &amp;quot;C&amp;quot; }
  puts &amp;quot;Array is #{an_array.size} items long&amp;quot;

  GC.start # Run a major GC - use full_mark: false for minor GC
  puts &amp;quot;There are #{GC.stat(:heap_live_slots)} live objects&amp;quot;

  sleep 1
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;GC.stat&lt;/code&gt; method will return a hash with a lot of useful information. Here,
we&amp;#39;re interested in &lt;code&gt;:heap_live_slots&lt;/code&gt;, which is the number of slots on the
heap that are in use. That&amp;#39;s the opposite of &lt;code&gt;:heap_free_slots&lt;/code&gt;.
At the end of the loop, we force a major GC and print out the number of used
slots, i.e., the number of objects that remain after GC.&lt;/p&gt;
&lt;p&gt;When we run our little program, we see this increase ad infinitum.
We have a leak! We could also have used &lt;code&gt;GC.stat(:old_objects)&lt;/code&gt; to the same
effect.&lt;/p&gt;
&lt;p&gt;While the &lt;code&gt;GC&lt;/code&gt; module can be used to see &lt;em&gt;if&lt;/em&gt; we have a leak and (if you&amp;#39;re
smart with your &lt;code&gt;puts&lt;/code&gt; statements) where the leak might be occurring, we can see
the type of objects that might be leaking with the &lt;code&gt;ObjectSpace&lt;/code&gt; module.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# leaky.rb

GC.disable # Only run GC when manually called

an_array = []

loop do
  1000.times { an_array &amp;lt;&amp;lt; &amp;quot;A&amp;quot; + &amp;quot;B&amp;quot; + &amp;quot;C&amp;quot; }
  puts &amp;quot;Array is #{an_array.size} items long&amp;quot;

  GC.start # Run a major GC - use full_mark: false for minor GC
  pp ObjectSpace.count_objects

  sleep 1
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;ObjectSpace.count_objects&lt;/code&gt; method returns a hash with the counts of
live objects. &lt;code&gt;T_STRING&lt;/code&gt;, for instance, is the number of strings live in
memory. For our rather leaky program, this value increases with each loop,
even after GC. We can see that we are leaking string objects.&lt;/p&gt;
&lt;h2 id=&quot;application-performance-monitoring-in-production-with-appsignal&quot;&gt;Application Performance Monitoring in Production with AppSignal&lt;/h2&gt;
&lt;p&gt;While playing with &lt;code&gt;ps&lt;/code&gt; and &lt;code&gt;GC&lt;/code&gt; can be a sensible route for toy projects —
they&amp;#39;re also fun and informative to use! — I would &lt;em&gt;not&lt;/em&gt; recommend them as your
memory leak detection solution in production apps.&lt;/p&gt;
&lt;p&gt;This is where you would
use an Application Performance Monitoring (APM) tool. If you&amp;#39;re a very large company,
you can build these yourself. For smaller outfits, though, picking an APM off-the-shelf is the way to go. You do need to pay a monthly subscription, but the information they provide
more than makes up for it.&lt;/p&gt;
&lt;p&gt;For detecting memory leaks, you want to find server or process memory use
(sometimes called RSS) graphs over time. Here&amp;#39;s an example screenshot from
AppSignal&amp;#39;s &amp;#39;process memory usage&amp;#39; dashboard of a healthy app shortly after being deployed:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-07/healthy-app-rss-appsignal.png&quot; alt=&quot;Healthy App RSS&quot;/&gt;&lt;/p&gt;
&lt;p&gt;And here&amp;#39;s an unhealthy app after deployment:
&lt;img src=&quot;/images/blog/2022-07/unhealthy-app-rss-appsignal.png&quot; alt=&quot;Unhealthy App RSS&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AppSignal will even surface Ruby VM stats like GC and heap slots, which can
give you an even clearer signal for a memory leak. If the number of live slots
keeps growing, you have a leak!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-07/heap-slots.png&quot; alt=&quot;Heap Slots showing leak&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.appsignal.com/ruby&quot;&gt;Read more about AppSignal for Ruby&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-and-further-reading&quot;&gt;Wrap Up and Further Reading&lt;/h2&gt;
&lt;p&gt;In this post, we took a quick tour of Ruby&amp;#39;s memory management and garbage collector. We then diagnosed how to discover a memory leak using Unix tools and Ruby&amp;#39;s GC module.&lt;/p&gt;
&lt;p&gt;Next time, we&amp;#39;ll see how to use &lt;code&gt;memory_profiler&lt;/code&gt; and &lt;code&gt;derailed_benchmarks&lt;/code&gt; to find and fix leaks.&lt;/p&gt;
&lt;p&gt;In the meantime, you can read more about the tools we used:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://linux.die.net/man/1/watch&quot;&gt;&lt;code&gt;watch&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://linux.die.net/man/1/ps&quot;&gt;&lt;code&gt;ps&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://linux.die.net/man/1/pgrep&quot;&gt;&lt;code&gt;pgrep&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Additional further reading:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ruby-doc.org/core-3.1.2/GC.html&quot;&gt;&lt;code&gt;GC&lt;/code&gt; module documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ruby-doc.org/core-3.1.2/ObjectSpace.html&quot;&gt;&lt;code&gt;ObjectSpace&lt;/code&gt; module documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jemma.dev/blog/ruby-garbage-collection-deep-dive/&quot;&gt;Garbage Collection Deep Dive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rubykaigi.org/2021-takeout/presentations/peterzhu2118.html&quot;&gt;Variable Width Allocation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Happy coding, and see you next time!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Deploy Your Ruby on Rails App Using Capistrano</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/07/13/deploy-your-ruby-on-rails-app-using-capistrano.html">
    <id>https://blog.appsignal.com/2022/07/13/deploy-your-ruby-on-rails-app-using-capistrano.html</id>
    <published>2022-07-13T00:00:00+00:00</published>
    <updated>2022-07-13T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Find out how to configure Capistrano in your Rails app, then deploy the app.</summary>
    <content type="html">&lt;p&gt;In this article, we will configure Capistrano in a Ruby on Rails application. We will then deploy the app to a cloud instance that runs Ubuntu as an operating system, independent of your hosting provider. You can use any cloud service, or even an on-premises server, to test or replicate the steps we&amp;#39;ll take.&lt;/p&gt;
&lt;p&gt;Once we&amp;#39;ve deployed the app, we&amp;#39;ll look briefly at how you can monitor your app&amp;#39;s deployments using AppSignal.&lt;/p&gt;
&lt;p&gt;But first, you might ask: why should I use Capistrano in the first place?&lt;/p&gt;
&lt;h2 id=&quot;why-choose-capistrano-for-your-ruby-on-rails-app&quot;&gt;Why Choose Capistrano for Your Ruby on Rails App?&lt;/h2&gt;
&lt;p&gt;You might be wondering if it still makes sense to continue using Capistrano for deployment these days. We now have many tools and services available for deployments and continuous integration.&lt;/p&gt;
&lt;p&gt;But to answer that, we need to revisit the origin of Capistrano and its evolution to the present day. The first tag created in the Capistrano repository was in 2006. Its objective was to allow the execution of commands remotely via SSH in parallel on several machines, all using DSL. Since then, Capistrano has evolved, by adding several features to each version.&lt;/p&gt;
&lt;p&gt;Currently at version 3 after 16 years, Capistrano continues to be actively developed and is now known as a framework for building automated deployment scripts.&lt;/p&gt;
&lt;p&gt;So it&amp;#39;s no longer just a tool to run commands on remote machines. In addition to &lt;a href=&quot;https://capistranorb.com/documentation/plugins&quot;&gt;Capistrano&amp;#39;s features&lt;/a&gt;, many &lt;a href=&quot;https://capistranorb.com/documentation/third-party-plugins&quot;&gt;plugins&lt;/a&gt; and other gems specifically run with Capistrano.&lt;/p&gt;
&lt;p&gt;Because of this and the fact that a large community still uses Capistrano, it remains a great tool for automated deployment.&lt;/p&gt;
&lt;h2 id=&quot;adding-capistrano-to-your-ruby-on-rails-app&quot;&gt;Adding Capistrano to Your Ruby on Rails App&lt;/h2&gt;
&lt;p&gt;First, you&amp;#39;ll need to configure a Ruby on Rails application to integrate it with Capistrano. You can follow &lt;a href=&quot;https://capistranorb.com/documentation/getting-started/installation&quot;&gt;Capistrano&amp;#39;s documentation&lt;/a&gt;. However, it has more information than you&amp;#39;ll need for the scope of this post. So for simplicity&amp;#39;s sake, this article only includes the necessary steps and configuration that you will need.&lt;/p&gt;
&lt;p&gt;To start the configuration, add the Capistrano gem in the development section of your Gemfile:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;group :development do
  # Deployment
  gem &amp;quot;capistrano&amp;quot;, &amp;quot;~&amp;gt; 3.10&amp;quot;, require: false
  gem &amp;quot;capistrano-rails&amp;quot;, &amp;quot;~&amp;gt; 1.3&amp;quot;, require: false
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You need the capistrano-rails gem to run a migration on your database and handle the assets that we will see in the next sections.&lt;/p&gt;
&lt;p&gt;Now run &lt;code&gt;bundle install&lt;/code&gt; to add Capistrano to your application:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bundle install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then you can install Capistrano:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bundle exec cap install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command will create a file called &lt;code&gt;Capfile&lt;/code&gt; that imports and configures the required libraries. Furthermore, a file called &lt;code&gt;deploy.rb&lt;/code&gt; (created inside the &lt;code&gt;config&lt;/code&gt; folder) will contain all the configurations that should be included in a deployment with Capistrano.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; Capistrano creates a file to override the &lt;code&gt;deploy.rb&lt;/code&gt; configuration for both the staging and production environments, but that will not be covered in this article.&lt;/p&gt;
&lt;p&gt;With that, you&amp;#39;re ready to start configuring and communicating between your Ruby on Rails application and the server.&lt;/p&gt;
&lt;h2 id=&quot;server-configuration-with-capistrano-for-your-rails-app&quot;&gt;Server Configuration with Capistrano for Your Rails App&lt;/h2&gt;
&lt;p&gt;In this step, we&amp;#39;ll add instructions to the Capistrano configuration file. The instructions will communicate to your server on where your app will be deployed. This is where we&amp;#39;ll define access information and the security configuration.&lt;/p&gt;
&lt;p&gt;To ensure that your production environment runs the same version of Ruby as the version you use in development, use a Ruby version manager, such as &lt;em&gt;RVM&lt;/em&gt; or &lt;em&gt;rbenv&lt;/em&gt; (Capistrano supports both).&lt;/p&gt;
&lt;p&gt;In this article, we&amp;#39;ll use RVM. Make sure you have RVM installed on your development machine and production server. Also, check if your version of Ruby is the same in your environments and project.&lt;/p&gt;
&lt;h3 id=&quot;adding-capistrano-rvm-gem&quot;&gt;Adding &lt;code&gt;capistrano-rvm&lt;/code&gt; Gem&lt;/h3&gt;
&lt;p&gt;The Capistrano project provides a gem called &lt;em&gt;capistrano-gem&lt;/em&gt; that lets you easily configure RVM. To include it in your project, add it to your Gemfile within your development group, and run &lt;code&gt;bundle install&lt;/code&gt; again.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;gem &amp;quot;capistrano-rvm&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Update your Capfile with the capistrano-rvm import:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Capfile
require &amp;#39;capistrano/rvm&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the deploy file, add a configuration to set the Ruby version and the path to RVM (especially if you used a different path to install RVM).&lt;/p&gt;
&lt;p&gt;If no version of Ruby is defined, Capistrano chooses the latest version that you have installed on the server where your application will be deployed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/deploy.rb
set :rvm_ruby_version, &amp;quot;ruby-2.6.3&amp;quot;
set :default_env, { rvm_bin_path: &amp;quot;~/.rvm/bin&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/capistrano/rvm&quot;&gt;Capistrano::RVM&lt;/a&gt; has other settings for RVM, but the ones shown here are what you&amp;#39;ll need to get started.&lt;/p&gt;
&lt;h3 id=&quot;set-up-your-server-configuration&quot;&gt;Set Up Your Server Configuration&lt;/h3&gt;
&lt;p&gt;It is good practice to define a user for the deployment. Don&amp;#39;t forget to follow these steps on your server before you start a deployment:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Add the public key generated on your local machine to the &lt;code&gt;~/home/YOUR_USER/.ssh/authorized_keys&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;Create a key and include the public key in the code repository. This gives you access to clone your project within the production server. If you are using GitHub, you can &lt;a href=&quot;https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent&quot;&gt;follow this documentation&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Set permissions to write to the &lt;code&gt;/var/www/&lt;/code&gt; directory.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You can configure Capistrano for any environment you need. You just need to create a new configuration file inside &lt;code&gt;config/deploy/&amp;lt;environment_name&amp;gt;.rb&lt;/code&gt;, then configure the IP or DNS, and username, to connect to your server.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/deploy/production.rb

server &amp;quot;11.22.333.444&amp;quot;, user: &amp;quot;ubuntu&amp;quot;, roles: %w{app db web}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To complete the deployment setup, include information about your application, such as the application name and code repository URL. Any information which is the same for all environments must be added to &lt;code&gt;config/deploy.rb&lt;/code&gt;. Keep specific environment configurations in &lt;code&gt;config/deploy/&amp;lt;environment_name&amp;gt;.rb&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/deploy.rb

set :application, &amp;quot;ruby_rails_app&amp;quot;
set :repo_url, &amp;quot;git@github.com:username/ruby_rails_app.git&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;set-up-capistrano-secrets-yml-gem-for-your-rails-app&quot;&gt;Set Up &lt;code&gt;capistrano-secrets-yml&lt;/code&gt; Gem for Your Rails App&lt;/h3&gt;
&lt;p&gt;You should also set up the &lt;a href=&quot;https://github.com/capistrano-plugins/capistrano-secrets-yml&quot;&gt;capistrano-secrets-yml&lt;/a&gt; gem.&lt;/p&gt;
&lt;p&gt;Add the gem to your Gemfile and run the bundle to install:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Gemfile
gem &amp;quot;capistrano-secrets-yml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Import it into Capfile:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Capfile
require &amp;quot;capistrano/secrets_yml&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then create &lt;code&gt;config/secret.yml&lt;/code&gt; in your application and include the secret key base as an environment variable. This variable will be created on your production server. Remember &lt;em&gt;not&lt;/em&gt; to commit this file to your repository.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/secrets.yml
production:
  secret_key_base: &amp;lt;%= ENV[&amp;quot;SECRET_KEY_BASE&amp;quot;] %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inside your application folder in the terminal, run this command to generate the secret key base:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ rails secret
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Copy the generated key and use it to set your SECRET_KEY_BASE on the production server. Access your production server and export the SECRET_KEY_BASE variable in the final &lt;code&gt;~/.bashrc&lt;/code&gt; file, so it is always available:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# ~/.bashrc
export SECRET_KEY_BASE=&amp;quot;YOUR_SECRET_KEY_BASE&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run the source to make it instantly available in your environment:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, back on your machine, access the application folder in the terminal and run the Capistrano command below to create &lt;code&gt;config/secrets.yml&lt;/code&gt; on the production server:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ cap production setup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All done! Now it&amp;#39;s time to configure Capistrano to run a migration.&lt;/p&gt;
&lt;h2 id=&quot;configure-capistrano-to-perform-a-database-migration&quot;&gt;Configure Capistrano to Perform a Database Migration&lt;/h2&gt;
&lt;p&gt;Now it&amp;#39;s time to configure Capistrano to run database-related commands.&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;capistrano-rails&lt;/em&gt; gem already included in your Gemfile can be configured to perform a migration on each deployment. We just need to import it into Capfile:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Capfile
require &amp;quot;capistrano/rails/migrations&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But if you want to run the seeds on deployment, you need to create a new task to run after the migration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/deploy.rb

namespace :deploy do
  desc &amp;quot;Run seed&amp;quot;
  task :seed do
    on roles(:all) do
      within current_path do
        execute :bundle, :exec, &amp;#39;rails&amp;#39;, &amp;#39;db:seed&amp;#39;, &amp;#39;RAILS_ENV=production&amp;#39;
      end
    end
  end

  after :migrating, :seed
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that, your app is finally ready to be deployed!&lt;/p&gt;
&lt;h2 id=&quot;start-deployment-of-your-ruby-on-rails-app&quot;&gt;Start Deployment of Your Ruby on Rails App&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s see how to perform a deployment from our local machine by directly updating our server to the new version of our application.&lt;/p&gt;
&lt;p&gt;When you execute a deployment command, Capistrano will connect to your server. From there, Capistrano will try to clone the code from the repository defined in the configuration file (&lt;code&gt;config/deploy.rb&lt;/code&gt;). Then other tasks will be performed, following the deployment flow.&lt;/p&gt;
&lt;p&gt;Capistrano&amp;#39;s &lt;code&gt;deploy:check&lt;/code&gt; command validates that the Git configuration is alright and that Capistrano has correct access to the directories that will be used in the deployment.&lt;/p&gt;
&lt;p&gt;To use it, pass the environment. In this case, we are using production:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ cap production deploy:check
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If everything is ok with the configuration, you can start your deployment to production:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ cap production deploy
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition, you can check all available tasks in Capistrano with the command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ cap --tasks
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, in our final step, let&amp;#39;s integrate our Ruby on Rails application with AppSignal and start monitoring it.&lt;/p&gt;
&lt;h2 id=&quot;how-to-integrate-appsignal-with-capistrano-and-your-rails-app&quot;&gt;How to Integrate AppSignal with Capistrano and Your Rails App&lt;/h2&gt;
&lt;p&gt;AppSignal is a monitoring tool, so you might wonder why it&amp;#39;s included in this article. That is a valid question, as monitoring is not directly related to deployments.&lt;/p&gt;
&lt;p&gt;That said, AppSignal is a valuable tool when it comes to monitoring your Ruby on Rails application and keeping track of deployments in each environment. So let&amp;#39;s see how we can set up AppSignal for your app.&lt;/p&gt;
&lt;p&gt;You will need an AppSignal account, which you can create on &lt;a href=&quot;https://appsignal.com/users/sign_up&quot;&gt;AppSignal&amp;#39;s sign-up page&lt;/a&gt;. Pick Ruby as your language and follow the steps to install AppSignal in your application.&lt;/p&gt;
&lt;p&gt;Once installed, a file will be created to configure AppSignal. What&amp;#39;s important here is to define the &lt;em&gt;revision&lt;/em&gt; — information that will be checked after deployment to see if a new version of an application has been deployed. In this case, we will use the Git log as revision information to ensure that each new code deployment will notify AppSignal.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/appsignal.yml

production:
  &amp;lt;&amp;lt;: *defaults
  active: true
  revision: &amp;quot;&amp;lt;%= `git log --pretty=format:&amp;#39;%h&amp;#39; -n 1` %&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is also good practice to export AppSignal environment variables to your production server (especially the API key, so as not to keep it in the AppSignal configuration file).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;export APPSIGNAL_PUSH_API_KEY=XXX
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And now we can rerun the deployment. If everything is set up correctly, you will see a message like this at the end of the deployment:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;Notifying AppSignal of deploy with: revision: ee5e626fd31613ef068873f9cddb5f8c91538396, user: monteirobrena
AppSignal has been notified of this deploy!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will now be able to see your application in AppSignal! 🎉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-07/applications-list.png&quot; alt=&quot;Applications list&quot;/&gt;&lt;/p&gt;
&lt;p&gt;And information about any deployments:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-07/deployments-list.png&quot; alt=&quot;Deployments list&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.appsignal.com/application/markers/deploy-markers.html&quot;&gt;Visit AppSignal&amp;#39;s deployment documentation page&lt;/a&gt; to learn more about deployment integration and other features available for Ruby on Rails applications.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-and-next-steps&quot;&gt;Wrap Up and Next Steps&lt;/h2&gt;
&lt;p&gt;In this post, we explored how to use Capistrano to deploy your Ruby on Rails app. We first added Capistrano to an app, then configured and deployed it, before finally setting up monitoring with AppSignal.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;d like to explore further, you can configure Capistrano to run from an integration connected to your repository&amp;#39;s pipeline. Tools like Bitbucket, GitHub, and GitLab provide settings to manage this process and can be used in conjunction with Capistrano.&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Get Started with Hotwire in Your Ruby on Rails App</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/07/06/get-started-with-hotwire-in-your-ruby-on-rails-app.html">
    <id>https://blog.appsignal.com/2022/07/06/get-started-with-hotwire-in-your-ruby-on-rails-app.html</id>
    <published>2022-07-06T00:00:00+00:00</published>
    <updated>2022-07-06T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Learn the basics of Hotwire and how to use it in your Rails app.</summary>
    <content type="html">&lt;p&gt;Hotwire is a hot topic at the moment for every Rails developer.
If you work with Rails, there is a good chance you have already heard a lot about it.&lt;/p&gt;
&lt;p&gt;Hotwire is a completely new way of adding interactivity to your app with very few lines of code, and it works blazing fast by transmitting HTML over the wire.
That means you can keep your hands clean from most Single Page Applications (SPA) frameworks. You can also keep your rendering logic centralized on the server, while still maintaining quick page load times and interactivity.&lt;/p&gt;
&lt;p&gt;In this post, we&amp;#39;ll look at the main components of Hotwire and how to use it in your Rails app. But first: what is Hotwire and why should you use it?&lt;/p&gt;
&lt;h2 id=&quot;what-is-hotwire&quot;&gt;What Is Hotwire?&lt;/h2&gt;
&lt;p&gt;Hotwire is not a single library, but a new approach to building web and mobile applications by sending HTML over the wire.
It includes Turbo, Stimulus, and Strada (coming later this year).
We will discuss each of these in detail in the next section.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Side note&lt;/em&gt;: While Hotwire is highly linked with Rails, it is completely language-agnostic, so it can work just as well with other applications.
I have been using Stimulus in production on several non-Rails apps and some static websites. You can use
Turbo without Rails as well.&lt;/p&gt;
&lt;p&gt;But let us come back to the Rails world for now.&lt;/p&gt;
&lt;h2 id=&quot;why-use-hotwire-in-your-rails-app&quot;&gt;Why Use Hotwire in Your Rails App?&lt;/h2&gt;
&lt;p&gt;So when should you use Hotwire? The answer is anywhere you want to add interactivity to your application. For example, if you want:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Some content to be displayed/hidden conditionally based on a user&amp;#39;s interaction (e.g., an address form where the list of states automatically changes based on the selected country).&lt;/li&gt;
&lt;li&gt;To update some content in real-time (e.g., a feed like Twitter where new Tweets automatically get added to the page).&lt;/li&gt;
&lt;li&gt;To lazy-load some parts of your pages (e.g., inside an accordion, you can load the titles and mark the details to be lazy-loaded to speed up load times).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;hotwire-components&quot;&gt;Hotwire Components&lt;/h2&gt;
&lt;p&gt;As mentioned before, Hotwire is a collection of new (and some old) techniques for building web apps.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s discuss each of these in the next few sections.&lt;/p&gt;
&lt;h3 id=&quot;turbo&quot;&gt;Turbo&lt;/h3&gt;
&lt;p&gt;HTML drives Turbo at its core.
Turbo provides several techniques to handle HTML data coming over the wire and display it on your application without performing a full page reload.
It is composed of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Turbo Drive&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;If you have used &lt;a href=&quot;https://github.com/turbolinks/turbolinks&quot;&gt;Turbolinks&lt;/a&gt; in the past, you will feel right at home with Turbo Drive.
At its core, some JS code intercepts JavaScript events on your application, loads HTML asynchronously, and replaces parts of your HTML markup.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Turbo Frames&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Turbo Frames decouple parts of your markup into different sections that can be loaded independently.&lt;/p&gt;
&lt;p&gt;For example, if you have a blog application, the content of your post and the comments are two related but independent parts of the page.
You can decouple them so navigation works independently or even load them asynchronously with turbo frames.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Turbo Streams&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Turbo Streams offers utilities to easily bring in real-time data to your application.
For example, let&amp;#39;s say you are building a news feed like Twitter. You want to pull new tweets into a user&amp;#39;s feed as soon as they are posted without reloading the page.
Turbo Streams allow you to do this without writing a single line of JS.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Turbo Native&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Turbo Native lets you build a native wrapper around your web application. Navigations and interactions will feel native without you having to redo all the screens natively.&lt;/p&gt;
&lt;p&gt;You&amp;#39;ll keep delivering the rest of the application through the web. That way, you can focus on the really interactive parts of your application and get them right.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;stimulus&quot;&gt;Stimulus&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://stimulus.hotwired.dev/&quot;&gt;Stimulus&lt;/a&gt; is a JavaScript framework for writing controllers that interact with your HTML.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s say we need to add some JavaScript attributes like &lt;code&gt;data-controller&lt;/code&gt;, &lt;code&gt;data-action&lt;/code&gt;, and &lt;code&gt;data-target&lt;/code&gt; to elements on a page. We&amp;#39;ll write a stimulus controller with access to elements that receives events based on those attributes.
Here&amp;#39;s an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;div data-controller=&amp;quot;clipboard&amp;quot;&amp;gt;
  PIN:
  &amp;lt;input data-clipboard-target=&amp;quot;source&amp;quot; type=&amp;quot;text&amp;quot; value=&amp;quot;1234&amp;quot; readonly /&amp;gt;
  &amp;lt;button data-action=&amp;quot;clipboard#copy&amp;quot;&amp;gt;Copy to Clipboard&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is very easy to get an idea about what this does without even reading the associated Stimulus controller.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s a controller that goes with the HTML:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// src/controllers/clipboard_controller.js
import { Controller } from &amp;quot;@hotwired/stimulus&amp;quot;;

export default class extends Controller {
  static targets = [&amp;quot;source&amp;quot;];

  copy() {
    navigator.clipboard.writeText(this.sourceTarget.value);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That is at the core of Stimulus: keeping things simple and reusable.&lt;/p&gt;
&lt;p&gt;Now, if you ever need a copy-to-the-clipboard button on another page, you can just re-use that controller. Add the &lt;code&gt;data-*&lt;/code&gt; attributes on the markup to get everything working.&lt;/p&gt;
&lt;h3 id=&quot;strada&quot;&gt;Strada&lt;/h3&gt;
&lt;p&gt;Unfortunately, we don&amp;#39;t know much about Strada yet.
But it will allow a web application to communicate (and possibly perform actions) with a native app using HTML bridge attributes.&lt;/p&gt;
&lt;h2 id=&quot;how-to-use-hotwire-in-your-ruby-on-rails-application&quot;&gt;How to Use Hotwire in Your Ruby on Rails Application&lt;/h2&gt;
&lt;p&gt;I don&amp;#39;t want to spend too much time discussing Hotwire installation or a basic use case.
The Hotwire team has already done an excellent job of it in their &lt;a href=&quot;https://hotwired.dev/&quot;&gt;Hotwire screencast&lt;/a&gt;. For full instructions, see &lt;a href=&quot;https://github.com/hotwired/turbo-rails#installation&quot;&gt;&lt;code&gt;turbo-rails&lt;/code&gt; installation&lt;/a&gt; and &lt;a href=&quot;https://stimulus.hotwired.dev/handbook/installing&quot;&gt;Stimulus installation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s jump straight into some common Hotwire use cases.&lt;/p&gt;
&lt;h3 id=&quot;endless-scroll&quot;&gt;Endless Scroll&lt;/h3&gt;
&lt;p&gt;Using Turbo Frames, we can easily make a page with automatic pagination as the user scrolls. For this, we need to do two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Render each &amp;quot;page&amp;quot; inside its own frame by appending the page number to the frame id (e.g., &lt;code&gt;turbo_frame_tag &amp;quot;posts_#{@posts.current_page}&amp;quot;&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;Use a &lt;a href=&quot;https://turbo.hotwired.dev/handbook/frames#lazy-loading-frames&quot;&gt;&lt;code&gt;lazy&lt;/code&gt; frame&lt;/a&gt; for the next page so that it doesn&amp;#39;t load automatically unless it comes into view.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;%= turbo_frame_tag &amp;quot;posts_#{@posts.current_page}&amp;quot; do %&amp;gt;
  &amp;lt;%= render @posts %&amp;gt;
  &amp;lt;% unless @posts.last_page? %&amp;gt;
    &amp;lt;%= turbo_frame_tag &amp;quot;posts_#{@posts.next_page}&amp;quot;, :src =&amp;gt; path_to_next_page(@posts), :loading =&amp;gt; &amp;quot;lazy&amp;quot; do %&amp;gt;
      &amp;lt;%= render &amp;quot;loading&amp;quot; %&amp;gt;
    &amp;lt;% end  %&amp;gt;
  &amp;lt;% end  %&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that this example uses methods from &lt;a href=&quot;https://github.com/kaminari/kaminari&quot;&gt;Kaminari&lt;/a&gt;, but you can adapt it to any other pagination method.&lt;/p&gt;
&lt;p&gt;We don&amp;#39;t need anything special in the controller. A standard &lt;code&gt;index&lt;/code&gt; method works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class PostsController &amp;lt; ApplicationController
  def index
    @posts = Post.page(params[:page]).per(params[:per_page])
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The trick here is that we use nested frames, with the frame for the next page nested inside the frame for the previous page.
That way, when the first page loads, the frame for the next page is placed at the end.
When the user scrolls to that frame, it is replaced with the content of the second page.
The lazy frame for the third page renders at the end.&lt;/p&gt;
&lt;h3 id=&quot;dynamic-forms&quot;&gt;Dynamic Forms&lt;/h3&gt;
&lt;p&gt;You can easily implement dynamic forms with Hotwire without custom logic for toggling fields on the front end.
This is a bit more involved than the endless scroll use case, as it includes the use of both Turbo Stream and Stimulus.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s start with our form first.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;!-- app/views/posts/new.html.erb --&amp;gt;
&amp;lt;div data-controller=&amp;quot;refresh-form&amp;quot; data-refresh-form-url=&amp;quot;&amp;lt;%= refresh_form_posts_url(:target =&amp;gt; &amp;quot;new_post&amp;quot;) %&amp;gt;&amp;quot;&amp;gt;
  &amp;lt;%= render &amp;quot;form&amp;quot; %&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;!-- app/views/posts/_form.html.erb --&amp;gt;
&amp;lt;%= form_for(@post, :data =&amp;gt; { :target =&amp;gt; &amp;quot;refresh-form.form&amp;quot; }) do |f| %&amp;gt;
  &amp;lt;%= f.select :kind, options_for_select([[&amp;quot;News&amp;quot;, :news], [&amp;quot;Blog&amp;quot;, :blog]], @post.kind), {}, data: { action: &amp;quot;change-&amp;gt;refresh-form#refreshForm&amp;quot; } %&amp;gt;

  &amp;lt;%= f.select :category, options_for_select(categories_for_kind(@post.kind), @post.category) %&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The form is simple enough — we display a &lt;code&gt;kind&lt;/code&gt; select with &lt;code&gt;News&lt;/code&gt; and &lt;code&gt;Blog&lt;/code&gt; options.
We want to change the available categories&amp;#39; values based on the kind that is selected (assuming that &lt;code&gt;categories_for_kind(@post.kind)&lt;/code&gt; returns the list of categories for the given kind).&lt;/p&gt;
&lt;p&gt;If you look closer, you&amp;#39;ll see that we&amp;#39;ve added some data attributes to the form.
The &lt;code&gt;data-target&lt;/code&gt; will link the form element to the &lt;code&gt;RefreshFormController&lt;/code&gt; Stimulus Controller&amp;#39;s &lt;code&gt;form&lt;/code&gt; target.
And the &lt;code&gt;data-action&lt;/code&gt; with the value of &lt;code&gt;change-&amp;gt;refresh-form#refreshForm&lt;/code&gt; will call the &lt;code&gt;refreshForm&lt;/code&gt; method on the linked Stimulus Controller every time the &lt;code&gt;kind&lt;/code&gt; select is changed.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s look at our Stimulus Controller:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// app/javascript/controllers/refresh_form_controller.js
import { Controller } from &amp;quot;stimulus&amp;quot;;
import { put } from &amp;quot;@rails/request.js&amp;quot;;

export default class extends Controller {
  static targets = [&amp;quot;form&amp;quot;];

  refreshForm() {
    put(this.data.get(&amp;quot;url&amp;quot;), {
      body: new FormData(this.formTarget),
      responseKind: &amp;quot;turbo-stream&amp;quot;,
    });
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On all &lt;code&gt;refreshForm&lt;/code&gt; calls, we just make a new &lt;code&gt;PUT&lt;/code&gt; request to the controller&amp;#39;s URL (set using the &lt;code&gt;data-refresh-form-url&lt;/code&gt; on the same element with a &lt;code&gt;data-controller=&amp;quot;refresh-form&amp;quot;&lt;/code&gt;).
The important part here is that the &lt;code&gt;responseKind&lt;/code&gt; is set to &lt;code&gt;turbo-stream&lt;/code&gt;.
The &lt;code&gt;@rails/request&lt;/code&gt; library understands this response and performs instructions based on the response stream.&lt;/p&gt;
&lt;p&gt;Now all that&amp;#39;s left is to return the correct stream from our &lt;code&gt;refresh_form&lt;/code&gt; call for Turbo to understand and update our form.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class PostsController &amp;lt; ApplicationController
  def refresh_form
    @post = Post.new
    @post.attributes = post_params
    @post.valid?
    respond_to do |format|
      format.turbo_stream
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just update the attributes on the post and mark that you want to respond in a &lt;code&gt;turbo_stream&lt;/code&gt; format (so that it looks up &lt;code&gt;refresh_form.turbo_stream.erb&lt;/code&gt;).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;!-- app/views/posts/refresh_form.turbo_stream.erb --&amp;gt;
&amp;lt;%= turbo_stream.replace params[:target] do %&amp;gt;
  &amp;lt;%= render &amp;quot;form&amp;quot; %&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this step, we are reusing our &lt;code&gt;form&lt;/code&gt; partial, wrapping it inside a &lt;code&gt;turbo_stream&lt;/code&gt; with a &lt;code&gt;replace&lt;/code&gt; action.&lt;/p&gt;
&lt;p&gt;And that&amp;#39;s all you need to get a dynamic form working.
I know this looks a bit advanced, but the &lt;code&gt;refresh&lt;/code&gt; stimulus controller is a shared part you can now use for all your dynamic forms by adding the correct &lt;code&gt;data-*&lt;/code&gt; attributes.
So essentially, you now get server-side dynamic form refresh without writing any new JS for other forms.
Pretty awesome, right?&lt;/p&gt;
&lt;h3 id=&quot;append-content-to-pages-without-reloading&quot;&gt;Append Content to Pages Without Reloading&lt;/h3&gt;
&lt;p&gt;The next use case that Hotwire makes easy is streaming HTML over a WebSocket connection and updating a page with new content as it comes in.
A good example of this is the GitHub comments section.
You can implement this very easily using Turbo Streams.&lt;/p&gt;
&lt;p&gt;There are two parts to this.&lt;/p&gt;
&lt;p&gt;First, we embed a turbo stream listener on the listing page that opens a WebSocket connection to the server and listens for events.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;!-- app/views/comments/index.html.erb --&amp;gt;
&amp;lt;div id=&amp;quot;comments&amp;quot;&amp;gt;
  &amp;lt;%= turbo_stream_from @post, :comments %&amp;gt;

  &amp;lt;% @comments.each do |comment| %&amp;gt;
    &amp;lt;%= render comment %&amp;gt;
  &amp;lt;% end %&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we update the model to broadcast new comments to the stream.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/models/coment.rb
class Comment &amp;lt; ApplicationRecord
  belongs_to :post

  after_create_commit :stream

  private

  def stream
    broadcast_prepend_later_to(post, :comments, target: :comments)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You don&amp;#39;t need anything else. Turbo will automatically render the &lt;code&gt;app/views/comments/_comment.html.erb&lt;/code&gt; partial for each new comment and send it over a WebSocket connection. It will be picked up by Turbo&amp;#39;s JS and prepended to the target with id &lt;code&gt;comments&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s go one step ahead and add an indication to all newly added comments with a small Stimulus Controller.&lt;/p&gt;
&lt;p&gt;First, modify the broadcast and &lt;code&gt;comment&lt;/code&gt; partial to include the controller conditionally.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/models/coment.rb
# ...
def stream
  broadcast_prepend_later_to(post, :comments,
                             target: :comments,
                             locals: { highlight: true })
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;!-- app/views/comments/_comment.html.erb --&amp;gt;
&amp;lt;div &amp;lt;%= %s(data-controller=&amp;quot;highlight&amp;quot;) if local_assigns[:highlight] %&amp;gt;
  &amp;lt;%= comment.body %&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This small Stimulus controller adds a special highlight class on connection for 3 seconds and then removes it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;export default class extends Controller {
  connect() {
    this.element.classList.add(&amp;quot;highlight&amp;quot;);
    this.timeout = setTimeout(
      () =&amp;gt; this.element.classList.remove(&amp;quot;highlight&amp;quot;),
      3000
    );
  }

  disconnect() {
    clearTimeout(this.timeout);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: You also need to update the CSS highlighting based on the presence of that class.&lt;/p&gt;
&lt;p&gt;Once this controller is done, you can re-use it on anything that requires a highlight class.
You could even modify it to get the duration and class name from data attributes if you need that flexibility.&lt;/p&gt;
&lt;p&gt;That&amp;#39;s the great thing about Hotwire — it takes you a long way, and you don&amp;#39;t have to dip your hands in JS.
When you do need to write some JS, Stimulus gives you the tools to build small generic controllers that can be re-used.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-and-further-reading&quot;&gt;Wrap Up and Further Reading&lt;/h2&gt;
&lt;p&gt;The Rails community has been really excited with the introduction of Hotwire, and rightly so.&lt;/p&gt;
&lt;p&gt;In this post, we looked at the key components of Hotwire and how to use Hotwire in your Rails app. We touched on how you can bring your application to life using Turbo and Stimulus.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://hotwired.dev/#screencast&quot;&gt;official Hotwire screencast introduction&lt;/a&gt; and the &lt;a href=&quot;https://turbo.hotwired.dev/handbook/introduction&quot;&gt;Turbo documentation&lt;/a&gt; are great places to see what Hotwire and Turbo can do for you.&lt;/p&gt;
&lt;p&gt;For advanced usage, I suggest heading over to the &lt;a href=&quot;https://github.com/hotwired/turbo-rails&quot;&gt;turbo-rails GitHub repo&lt;/a&gt;.
Sadly, the documentation is a bit sparse, but if you are not afraid to get your hands dirty, read the code and inline comments in:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hotwired/turbo-rails/blob/main/app/helpers/turbo/frames_helper.rb&quot;&gt;&lt;code&gt;Turbo::FramesHelper&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;Turbo Frames&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hotwired/turbo-rails/blob/main/app/models/concerns/turbo/broadcastable.rb&quot;&gt;&lt;code&gt;Turbo::Broadcastable&lt;/code&gt;&lt;/a&gt; for broadcasting to &lt;em&gt;Turbo Streams&lt;/em&gt; from the code.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hotwired/turbo-rails/blob/main/app/models/turbo/streams/tag_builder.rb&quot;&gt;&lt;code&gt;Turbo::Streams::TagBuilder&lt;/code&gt;&lt;/a&gt; for broadcasting to &lt;em&gt;Turbo Streams&lt;/em&gt; as part of inline controller actions.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>State Machines in Ruby: An Introduction</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/06/22/state-machines-in-ruby-an-introduction.html">
    <id>https://blog.appsignal.com/2022/06/22/state-machines-in-ruby-an-introduction.html</id>
    <published>2022-06-22T00:00:00+00:00</published>
    <updated>2022-06-22T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's build a simple state machine in Ruby and use the state machines gem.</summary>
    <content type="html">&lt;p&gt;A state machine can hold all possible states of &lt;em&gt;something&lt;/em&gt; and the allowed transitions between these states.
For example, the state machine for a door would have only two states (&lt;code&gt;open&lt;/code&gt; and &lt;code&gt;closed&lt;/code&gt;) and only two transitions (&lt;code&gt;opening&lt;/code&gt; and &lt;code&gt;closing&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;On the other hand, complex state machines can have several different states with hundreds of transitions between them.
In fact, if you look around, you will notice finite state machines surrounding you — when you buy from a website, get a pack of crisps from the vending machine, or even just withdraw money from an ATM.&lt;/p&gt;
&lt;p&gt;In this post, we&amp;#39;ll look at how to set up a state machine in Ruby and use the state machines gem.&lt;/p&gt;
&lt;h2 id=&quot;state-machines-in-development&quot;&gt;State Machines in Development&lt;/h2&gt;
&lt;p&gt;When do we need a state machine in development? The simple answer is whenever you want to model multiple rules for state transitions or perform side-effects on some transitions.
The key here is to identify parts of your application that would benefit from a state machine.
A good example that always works for me is an &lt;code&gt;Order&lt;/code&gt; in the context of an e-commerce application.&lt;/p&gt;
&lt;p&gt;For a simple application selling products online, an &lt;code&gt;Order&lt;/code&gt; can be in one of several states:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;created&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;processing&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ready&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;shipped&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delivered&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can see the allowed transitions in the following diagram.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-06/order-state-machine.png&quot; alt=&quot;State machine diagram&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Visualizing the order in the form of a state machine immediately allows us to clearly understand the full flow, from ordering the product to delivery.
And for us developers, it enables clear, set steps on what can and cannot be done at particular points in that flow.&lt;/p&gt;
&lt;p&gt;That being said, it is easy to jump down a rabbit hole by picking this up for a very wide problem and then end up with hundreds of states that are difficult to reason about and follow through.
So always have a top-level idea and a state chart for your proposed state machine before implementing it.&lt;/p&gt;
&lt;h2 id=&quot;our-first-state-machine-in-ruby&quot;&gt;Our First State Machine in Ruby&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s try to implement our &lt;code&gt;OrderStateMachine&lt;/code&gt; with Ruby.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class OrderStateMachine
  def initialize(order)
    @order = order
    @order.state = :created if @order.state.blank?
  end

  def mark_as_paid!
    raise &amp;quot;Invalid state #{@order.state}&amp;quot; unless @order.created?

    @order.state = :processing
  end

  def packed!
    raise &amp;quot;Invalid state #{@order.state}&amp;quot; unless @order.processing?

    @order.state = :ready
  end

  def shipped!
    raise &amp;quot;Invalid state #{@order.state}&amp;quot; unless @order.ready?

    @order.state = :shipped
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That&amp;#39;s a simple enough implementation.
For each possible transition in the state machine, we define a new method that does some sanity checks and performs the transition.&lt;/p&gt;
&lt;p&gt;The great thing about the above implementation is that everything is explicit: any new developer can very quickly understand the full extent of the state machine.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s see how we can add some side-effects to the transitions.
We&amp;#39;ll automatically ship orders that are packed and deliverable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class OrderStateMachine
  # ...

  def packed!
    raise &amp;quot;Invalid state #{@order.state}&amp;quot; unless @order.processing?

    @order.state = :ready
    ship_order if @order.deliverable?
  end

  # ...

  private

  def ship_order
    DeliveryService.create_consigment!(@order)
    shipped!
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While a naïve implementation works great, it is overly verbose, especially when we have a lot of transitions and conditions.&lt;/p&gt;
&lt;p&gt;A quick check on &lt;a href=&quot;https://www.ruby-toolbox.com/categories/state_machines&quot;&gt;Ruby Toolbox&lt;/a&gt; brings up several gems for state machines.
&lt;a href=&quot;https://github.com/state-machines/state_machines&quot;&gt;&lt;code&gt;state_machines&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/aasm/aasm&quot;&gt;&lt;code&gt;aasm&lt;/code&gt;&lt;/a&gt; are the most popular ones, and both come with an ActiveRecord adapter if you want to use them with Rails.
Both are thoroughly tested and production-ready, so do check them out if you need to implement a state machine.&lt;/p&gt;
&lt;h2 id=&quot;using-the-state-machines-gem-in-ruby&quot;&gt;Using the State Machines Gem in Ruby&lt;/h2&gt;
&lt;p&gt;For this post, I will describe how we can model the state machine for our &lt;code&gt;Order&lt;/code&gt; using the &lt;code&gt;state_machines&lt;/code&gt; gem.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Order
  state_machine :state, initial: :created do
    event :confirm_payment do
      transition created: :processing
    end
    event :pack do
      transition processing: :ready
    end
    event :cancel do
      transition %i[created processing ready] =&amp;gt; :void
    end
    event :return do
      transition delivered: :void
    end
    event :ship do
      transition ready: :shipped
    end
    event :fail_delivery do
      transition shipped: :processing
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above class defines our simple state machine and all of its possible transitions.
On top of this, it also automatically exposes a lot of utility methods on an order:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;order.state           # =&amp;gt; &amp;quot;created&amp;quot;
order.state_name      # =&amp;gt; :created
order.created?        # =&amp;gt; true
order.can_pack?       # =&amp;gt; false (since payment has not been confirmed yet)
order.confirm_payment # =&amp;gt; true (and transitions to `processing`)
order.can_pack?       # =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;execute-side-effects-with-the-state-machines-gem-in-ruby&quot;&gt;Execute Side-Effects with the State Machines Gem in Ruby&lt;/h2&gt;
&lt;p&gt;As is usual for any real-world system, many transitions in a state machine will come with side-effects.
The &lt;code&gt;state_machines&lt;/code&gt; gem makes it easy to define and execute them.
Let&amp;#39;s add two side-effects:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;On all transitions to &lt;code&gt;ready&lt;/code&gt;, create a delivery consignment if the order is &lt;code&gt;deliverable&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;On all &lt;code&gt;fail_delivery&lt;/code&gt; events, send an email to the user notifying them of the event.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Order
  attr_accessor :deliverable

  state_machine :state, initial: :created do
    # ...

    after_transition to: :ready, do: :create_delivery_consignment, if: :deliverable
    after_transition on: :fail_delivery, do: :notify_delivery_failure
  end

  private

  def create_delivery_consignment
    DeliveryService.create_consigment!(self)
    ship
  end

  def notify_delivery_failure
    UserMailer.delivery_failure_email(self).deliver_later
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can perform transitions as usual in the order:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;order.deliverable = true
order.pack            # =&amp;gt; true
order.state           # =&amp;gt; &amp;quot;shipped&amp;quot; (through side-effect)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I would suggest checking out the &lt;a href=&quot;https://github.com/state-machines/state_machines&quot;&gt;Github page for the &lt;code&gt;state_machines&lt;/code&gt; gem&lt;/a&gt; to learn about all the possible options the gem offers.&lt;/p&gt;
&lt;h2 id=&quot;use-the-state-machines-gem-with-activerecord-in-ruby-on-rails&quot;&gt;Use the State Machines Gem with ActiveRecord in Ruby on Rails&lt;/h2&gt;
&lt;p&gt;As discussed before, both &lt;code&gt;state_machines&lt;/code&gt; and &lt;code&gt;aasm&lt;/code&gt; support ActiveRecord.
When you use the &lt;code&gt;state_machines&lt;/code&gt; gem with ActiveRecord, not a lot of things change with the implementation. You can continue using most of what we&amp;#39;ve already discussed in the previous sections of this post.&lt;/p&gt;
&lt;p&gt;Here are some additional features that you get:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Side-effects happen inside a transaction.
This means that if you do some database operations inside transition hooks and the transaction fails, the state change won&amp;#39;t be committed.
&lt;a href=&quot;https://www.rubydoc.info/github/state-machines/state_machines-activerecord/StateMachines/Integrations/ActiveRecord#label-Transactions&quot;&gt;See &lt;code&gt;use_transactions&lt;/code&gt;&lt;/a&gt; if you want to disable this behavior.&lt;/li&gt;
&lt;li&gt;Like all other ActiveRecord callbacks, if you want to update the attributes of the current model from a transition, you must do this inside a &lt;code&gt;before_transition&lt;/code&gt; callback.
To update attributes inside &lt;code&gt;after_transition&lt;/code&gt;, you need to save the model again.
Check out the following example:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Order &amp;lt; ActiveRecord::Base
  state_machine initial: :created do

    before_transition any =&amp;gt; :processing do |order|
      # You can just update the attribute here and it will be saved.
      order.processing_start_at = Time.zone.now
    end

    after_transition any =&amp;gt; :shipped do |order|
      # Call update! to update the order.
      # Just setting the attribute like above would not work here.
      order.update!(shipped_at: Time.zone.now)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;The gem automatically provides scopes to filter models by their state.
For example, you can do &lt;code&gt;Order.with_state(:processing)&lt;/code&gt; to find all the processing orders or &lt;code&gt;Order.without_state(:processing)&lt;/code&gt; to find all orders that are not under processing.&lt;/li&gt;
&lt;li&gt;If a state change is attempted without a matching transition (for example, from &lt;code&gt;processing&lt;/code&gt; to &lt;code&gt;delivered&lt;/code&gt;), the record will fail to save, and an error will be added to the validation errors.
To internationalize the generated error messages, just add some keys to provide translations for states and events inside the config files (for example, &lt;code&gt;en.yml&lt;/code&gt;):&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;en:
  activerecord:
    state_machines:
      order:
        states:
          created: Created
          processing: Under Processing
          # ...
        events:
          return: Return Order
          # ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Side note&lt;/em&gt;: &lt;a href=&quot;https://blog.appsignal.com/2021/02/24/troubleshooting-activerecord-performance.html&quot;&gt;Check out this post to troubleshoot ActiveRecord performance issues&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-build-state-machines-in-ruby&quot;&gt;Wrap Up: Build State Machines in Ruby&lt;/h2&gt;
&lt;p&gt;In this post, we explored why we&amp;#39;d use a state machine in development, before building a simple state machine. Finally, we looked at using the state machines gem in Ruby and Ruby on Rails.&lt;/p&gt;
&lt;p&gt;Now that you have a basic understanding of a state machine, I am sure you will recognize several scenarios around you that already use a state machine or will benefit greatly from one.&lt;/p&gt;
&lt;p&gt;Until next time, I wish you luck building state machines!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Add Feature Flags in Ruby on Rails with Flipper</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/06/08/add-feature-flags-in-ruby-on-rails-with-flipper.html">
    <id>https://blog.appsignal.com/2022/06/08/add-feature-flags-in-ruby-on-rails-with-flipper.html</id>
    <published>2022-06-08T00:00:00+00:00</published>
    <updated>2022-06-08T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Find out how feature flags function in principle and get started with feature flags using the Flipper gem.</summary>
    <content type="html">&lt;p&gt;Picture this scenario: you are a Rails developer and have spent the last couple of days developing that awesome feature that everyone
is waiting for. It&amp;#39;s big and complex, but it went through rigorous testing, so you are confident everything works as it
should. There are deadlines to meet, so you deploy. Immediately, all hell breaks loose.&lt;/p&gt;
&lt;p&gt;Your feature straight up breaks the entire app for some of your users. It&amp;#39;s hard to say why. No bugs showed up
during testing. You revert your change, but the damage has been done. Your customers aren&amp;#39;t happy, and you will spend
the foreseeable future doing damage control and investigating what went wrong.&lt;/p&gt;
&lt;p&gt;The problem is that releasing complex changes is inherently risky, no matter how much testing you do. It would have
been nice if you had rolled this feature out gradually, maybe only to a handful of users first. It would have
been even better if you could have switched the feature off as soon as the first problem showed up.&lt;/p&gt;
&lt;p&gt;This is precisely where feature flags come in. In this post, we&amp;#39;ll dive into the ins and outs of feature flags in Rails, including how to set them up using the Flipper gem. But first: what are they?&lt;/p&gt;
&lt;h2 id=&quot;what-are-feature-flags-in-ruby-on-rails&quot;&gt;What Are Feature Flags in Ruby on Rails?&lt;/h2&gt;
&lt;p&gt;Feature flags are a way to enable or disable a feature in your application while it is running. If a flag is enabled,
the feature is used. Otherwise, it is not. Imagine something like this in pseudocode.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;if feature_enabled?(:my_awesome_feature)
  # Run awesome feature code
else
  # Not so awesome code
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The name &amp;#39;feature flag&amp;#39; is somewhat misleading. Controlling application behavior at runtime is not limited to features,
but applies to any function within your program. You can use feature flags to try out performance tweaks and run A/B tests, for example.
A significant difference between a feature flag and any other old conditional is you can modify feature flags at runtime.&lt;/p&gt;
&lt;p&gt;For illustration purposes, let&amp;#39;s imagine a simple feature flagging mechanism using environment variables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def feature_enabled(feature_name)
  ENV[feature_name.to_s.upcase]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By modifying the value of the environment variable, we can switch
parts of our application on or off at will. Which part of an application? Anything you want!&lt;/p&gt;
&lt;p&gt;You could hide parts of the UI if a feature is disabled. You could switch out parts of your code, which is very useful
if you aren&amp;#39;t confident in your latest refactor. One of my favorite uses of feature flags is to hide entire routes
using &lt;a href=&quot;https://guides.rubyonrails.org/routing.html#advanced-constraints&quot;&gt;routing constraints&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# lib/constraint/feature_constraint.rb
class FeatureConstraint
  def initialize(feature)
    @feature = feature
  end

  def matches?(_request)
    feature_enabled?(@feature)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/routes.rb
Rails.application.routes.draw do
  get &amp;#39;statistics&amp;#39;, to: &amp;#39;statistics#index&amp;#39;, constraints: FeatureConstraint.new(:statistics)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can already see that there are lots of applications for feature flags.
Our naive implementation has one significant weakness, though. A feature is either on or off for every user.&lt;/p&gt;
&lt;p&gt;What if we want the ability to enable features only for specific users or groups of users, or only for some of the time?
Let&amp;#39;s take a look at Flipper.&lt;/p&gt;
&lt;h2 id=&quot;using-the-flipper-gem-for-feature-flags&quot;&gt;Using the Flipper Gem for Feature Flags&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jnunemaker/flipper&quot;&gt;Flipper&lt;/a&gt; is a gem that makes feature flags and different ways to toggle them
available in Rails. It is highly modular. Apart from the main gem, you&amp;#39;ll also have to pick a storage adapter — but
more on that later. Let&amp;#39;s use the ActiveRecord adapter for now.&lt;/p&gt;
&lt;p&gt;Add the following lines to your Gemfile and run &lt;code&gt;bundle install&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;gem &amp;#39;flipper&amp;#39;
gem &amp;#39;flipper-active_record&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we use the ActiveRecord adapter, Flipper will store your feature flag in the database and thus requires setting
up new database tables. Flipper comes with a handy generator that will create the necessary migrations.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails g flipper:active_record
rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can use Flipper in the same way as the naive implementation we used previously.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;if Flipper.enabled?(:my_awesome_feature)
  # Run awesome feature code but with Flipper!
else
  # Not so awesome code
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The big difference is that instead of modifying environment variables, you now get to toggle features using Flipper&amp;#39;s user
interface. Add the Flipper UI gem and install it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;gem &amp;#39;flipper-ui&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Modify your routes file to mount Flipper UI.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Rails.application.routes.draw do
  mount Flipper::UI.app(Flipper) =&amp;gt; &amp;#39;/flipper&amp;#39;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you start your application and navigate to the Flipper UI, you will see an overview of all available features and
their status. Go ahead and create a &lt;code&gt;my_awesome_feature&lt;/code&gt; feature.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-06/flipper-ui.png&quot; alt=&quot;The Flipper UI overview&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;feature-toggles-in-flipper&quot;&gt;Feature Toggles in Flipper&lt;/h2&gt;
&lt;p&gt;You&amp;#39;ve probably noticed that you can do much more than simply enable or disable a feature in Flipper UI.
Flipper allows us to enable features for a subset of users or even for a percentage of the time. You can configure your
feature flags using one of five different mechanisms.&lt;/p&gt;
&lt;p&gt;One of them is the boolean toggle, a global on-off switch. The other four are a lot more interesting than that: groups, actors, percentage of actors, and percentage of time.&lt;/p&gt;
&lt;h3 id=&quot;groups&quot;&gt;Groups&lt;/h3&gt;
&lt;p&gt;To enable a feature only for a particular group of users, use the group toggle. If it doesn&amp;#39;t exist, create the
file &lt;code&gt;config/initializers/flipper.rb&lt;/code&gt; and add the following code to register a new group — for example, paid users.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/initializers/flipper.rb
Flipper.register(:paid_users) do |actor, _context|
  actor.respond_to?(:paid_users?) &amp;amp;&amp;amp; actor.paid?
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To use this new toggle, modify the Flipper invocation to pass the user — or actor, as the documentation likes to
call them — and the feature name.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;if Flipper.enabled?(:my_awesome_feature, user)
  # Run awesome feature only if the user is paid
else
  # Not so awesome code
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Flipper will use the block you defined in the initializer to decide if the feature is enabled for this user. In this case,
it will invoke the &lt;code&gt;paid?&lt;/code&gt; method. You can now use this group in Flipper UI. Click the &amp;#39;Add a Group&amp;#39; button and select
your group.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-06/flipper-ui-groups.png&quot; alt=&quot;Adding a Flipper UI group feature&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Your group doesn&amp;#39;t have to be paid users. It could be members of your team or users who have signed up for a beta
program. Using the group toggle is helpful if you want to release something to a subset of users. Imagine beta
releases or internal releases.&lt;/p&gt;
&lt;h3 id=&quot;actors&quot;&gt;Actors&lt;/h3&gt;
&lt;p&gt;Sometimes, you might want to release something to a single individual. In this case, the actor toggle is something to consider.&lt;/p&gt;
&lt;p&gt;You don&amp;#39;t have to change anything in your initializer to use this mechanism. However, you&amp;#39;ll need to ensure that your
actor model — which will be your user model most of the time — implements &lt;code&gt;flipper_id&lt;/code&gt;. Including &lt;code&gt;Flipper::Identifier&lt;/code&gt; takes care of that.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# models/user.rb
class User &amp;lt; ApplicationModel
  include Flipper::Identifier
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.create.flipper_id # User;1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can then use this ID to enable a feature for individual users.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-06/flipper-ui-actor.png&quot; alt=&quot;Adding a Flipper UI actor feature&quot;/&gt;&lt;/p&gt;
&lt;p&gt;This feature toggle is handy if you want to preview functionality for particular individuals. Think about enabling
specific test accounts for partners who need access to a feature before it&amp;#39;s released to a broader audience.&lt;/p&gt;
&lt;h3 id=&quot;percentage-of-actors&quot;&gt;Percentage of Actors&lt;/h3&gt;
&lt;p&gt;If you want to ramp up feature usage slowly, the percentage of actors toggle is for you. Imagine you&amp;#39;ve implemented some
performance optimization, and you&amp;#39;re not quite sure how it will behave in production. You would roll this out to a
small percentage of users first and then slowly ramp up the usage while monitoring your application.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-06/flipper-ui-percentage-of-actors.png&quot; alt=&quot;Adding a Flipper UI percentage of actors feature&quot;/&gt;&lt;/p&gt;
&lt;p&gt;If things go sideways, you can always reset the percentage to zero.&lt;/p&gt;
&lt;h3 id=&quot;percentage-of-time&quot;&gt;Percentage of Time&lt;/h3&gt;
&lt;p&gt;Last but not least, you may enable a feature for a percentage of requests. You do not need to provide an actor when using this toggle.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;if Flipper.enabled?(:my_awesome_feature)
  # Run awesome feature code only for a percentage of requests
else
  # Not so awesome code
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I like to use this to compare the performance of two different implementations. Note that this feature toggle is random.
The same user will experience different behavior on each request.&lt;/p&gt;
&lt;h2 id=&quot;advanced-configuration-in-flipper&quot;&gt;Advanced Configuration in Flipper&lt;/h2&gt;
&lt;p&gt;We&amp;#39;ve already seen that we can use the ActiveRecord adapter to store feature flag information in our database. But depending
on your specific needs, you might want to use &lt;a href=&quot;https://www.flippercloud.io/docs/adapters&quot;&gt;a different adapter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For the most part, all you need to do when swapping out storage adapters is to install the respective gem and configure
Flipper accordingly. For example, if you want to use the Redis adapter, you add the &lt;code&gt;flipper-redis&lt;/code&gt; gem to your
Gemfile and update the Flipper initializer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;gem &amp;#39;flipper-redis&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/initializers/flipper.rb
Flipper.configure do |config|
  config.adapter { Flipper::Adapters::Redis.new(Redis.new) }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Apart from configuring storage adapters, there are a lot of other aspects of Flipper that you can tweak.&lt;/p&gt;
&lt;p&gt;Adding feature flags incurs a slight performance penalty, so you usually want to add memoization and caching. You&amp;#39;ll
likely also want to restrict access to the Flipper UI to authorized users. These topics are out of scope for this post,
but I recommend you check out the &lt;a href=&quot;https://www.flippercloud.io/docs/optimization&quot;&gt;Flipper documentation&lt;/a&gt; if you want to dive
deeper.&lt;/p&gt;
&lt;h2 id=&quot;caveats-to-feature-flags-in-rails&quot;&gt;Caveats to Feature Flags in Rails&lt;/h2&gt;
&lt;p&gt;Feature flags are great. But as with so many things, there are tradeoffs to consider.&lt;/p&gt;
&lt;p&gt;Adding feature flags and maintaining them adds organizational overhead. Releasing and rolling out hidden features using
flags is not as simple as deploying &amp;#39;regular&amp;#39; code — you&amp;#39;ll have to remember to turn it on, of course! That usually
isn&amp;#39;t too hard, but cleaning up feature flags that you don&amp;#39;t need anymore might be.&lt;/p&gt;
&lt;p&gt;Every time you add a feature flag to your code, you add a conditional, and if you don&amp;#39;t watch out, your code quickly
becomes littered with them. Keeping track of when and why you created certain feature flags could be challenging.
Sadly, Flipper UI itself does not offer much to manage feature flags.&lt;/p&gt;
&lt;p&gt;You should also be aware that using feature flags will incur a minor performance penalty. There are ways to mitigate
this, but it can have a noticeable impact if you misconfigure or misuse Flipper.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-get-started-with-feature-flags-in-ruby-on-rails&quot;&gt;Wrap Up: Get Started with Feature Flags in Ruby on Rails&lt;/h2&gt;
&lt;p&gt;We looked at how feature flags can help you release with more confidence, learned how they function in principle, and
saw how you can get started with feature flags using the Flipper gem.&lt;/p&gt;
&lt;p&gt;There are many situations where feature flags are handy. Depending on your use case, you might reach for one of the
five different toggles — boolean, group, actor, percentage of actors, or percentage of requests.&lt;/p&gt;
&lt;p&gt;Although working with feature flags has its caveats and might take some getting used to, they are nevertheless a great
tool to have at your disposal.&lt;/p&gt;
&lt;p&gt;Until next time, happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>An Introduction to Polymorphism in Ruby on Rails</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/05/25/an-introduction-to-polymorphism-in-ruby-on-rails.html">
    <id>https://blog.appsignal.com/2022/05/25/an-introduction-to-polymorphism-in-ruby-on-rails.html</id>
    <published>2022-05-25T00:00:00+00:00</published>
    <updated>2022-05-25T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Learn how you can implement polymorphism in your Rails application for cleaner code.</summary>
    <content type="html">&lt;p&gt;If you have ever spent time building an Object-Oriented Program (OOP), you have likely used polymorphism in your application or, at the very least, heard the term.&lt;/p&gt;
&lt;p&gt;It’s the kind of word you’d expect to see in a science or computer science textbook. You may have spent time researching polymorphism and even implemented it in your application without clearly understanding the concept.&lt;/p&gt;
&lt;p&gt;This article will give you a greater understanding of polymorphism, specifically in Ruby on Rails. To accomplish this, we’ll dive into:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The use of polymorphism in the real world&lt;/li&gt;
&lt;li&gt;Polymorphism in programming by way of OOP&lt;/li&gt;
&lt;li&gt;How you can incorporate it into your Rails application to help maintain high-quality code&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;#39;s get going!&lt;/p&gt;
&lt;h2 id=&quot;polymorphism-in-the-real-world&quot;&gt;Polymorphism in the Real World&lt;/h2&gt;
&lt;p&gt;There are several ways to define polymorphism in different contexts. A useful definition, regardless of context, is &lt;em&gt;&amp;#39;an object&amp;#39;s ability to display more than one form&amp;#39;&lt;/em&gt;. In fact, if we break down the word itself, poly means ‘many’ and morph means ‘form’.&lt;/p&gt;
&lt;p&gt;In the real world, a basic example of this definition could be a woman who is also a police officer, sister, someone’s child, someone’s mother, etc. Each role determines her behavior and contributes to the person she is.&lt;/p&gt;
&lt;h3 id=&quot;polymorphism-and-genetics&quot;&gt;Polymorphism and Genetics&lt;/h3&gt;
&lt;p&gt;Outside computer programming, polymorphism is a term commonly associated with biology and genetics. In this context, polymorphism is more specifically defined as genetic variations that result in several distinct forms or types of individuals within a species.&lt;/p&gt;
&lt;p&gt;Think of jaguars. Jaguars can have multiple gene variations, which can affect their fur coloring. Most jaguars have tawny coloring with black circles. However, they can have lighter or darker circles due to an altered gene, and some can have black fur coloring.&lt;/p&gt;
&lt;p&gt;Different pigmentation within the same species of birds is another example of polymorphism. Consider the Gouldian finch, which has obvious distinctions in its coloring between individuals.&lt;/p&gt;
&lt;h3 id=&quot;monomorphism-vs-polymorphism&quot;&gt;Monomorphism vs. Polymorphism&lt;/h3&gt;
&lt;p&gt;If we turn our attention to monomorphism, we can further understand polymorphism. Sticking with biology, monomorphism can be defined as &lt;em&gt;&amp;#39;a species with just one form&amp;#39;&lt;/em&gt;, that maintains that same form during the various phases of its development.&lt;/p&gt;
&lt;p&gt;Penguins are monomorphic. It is difficult, even for experts, to distinguish between the sexes. Gene differences in a penguin are minimal. Therefore, the physical attributes of penguins are almost indistinguishable, especially in terms of their size and black and white coloring.&lt;/p&gt;
&lt;p&gt;Behavioral cues are often the easiest way to discern between the sexes in monomorphic species.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s turn our attention to polymorphism in programming, specifically.&lt;/p&gt;
&lt;h2 id=&quot;polymorphism-in-oop&quot;&gt;Polymorphism in OOP&lt;/h2&gt;
&lt;p&gt;If we consider our initial definition of polymorphism — &lt;em&gt;the ability of an object to display more than one form&lt;/em&gt; — we can seamlessly relate it to OOP.&lt;/p&gt;
&lt;p&gt;In OOP, we can use the same method to produce different results by passing in separate objects. We could use conditionals to achieve this. However, this can create chunky code and may veer us away from DRY principles. Polymorphism is essential in creating clean and logical OOP applications.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s look at two examples of how polymorphism can be implemented in an OOP language like Ruby: through inheritance and duck-typing.&lt;/p&gt;
&lt;h3 id=&quot;polymorphism-and-inheritance-in-ruby&quot;&gt;Polymorphism and Inheritance in Ruby&lt;/h3&gt;
&lt;p&gt;Inheritance is where a child class inherits the properties of a parent class.&lt;/p&gt;
&lt;p&gt;Below is an example of how we can implement polymorphism with inheritance:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Instrument
  def instrument_example
    puts &amp;quot;Saxophone&amp;quot;
  end
end

class Stringed &amp;lt; Instrument
  def instrument_example
    puts &amp;quot;Guitar&amp;quot;
  end
end

class Percussion &amp;lt; Instrument
  def instrument_example
    puts &amp;quot;Drums&amp;quot;
  end
end

all_instruments = [Instrument.new, Stringed.new, Percussion.new]

all_instruments.each do |instrument|
  instrument.instrument_example
end

# Output

# Saxophone
# Guitar
# Drums
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above code has two child classes — &lt;code&gt;Stringed&lt;/code&gt; and &lt;code&gt;Percussion&lt;/code&gt; — inherited from the parent class &lt;code&gt;Instrument&lt;/code&gt;. This example is polymorphic, as we are calling a method: &lt;code&gt;instrument_example&lt;/code&gt; — and it outputs multiple forms: &lt;code&gt;Saxophone&lt;/code&gt;, &lt;code&gt;Guitar&lt;/code&gt;, and &lt;code&gt;Drums&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This example of achieving polymorphism through inheritance is essentially overriding a method, but helps provide a clearer understanding of polymorphism in an OOP language.&lt;/p&gt;
&lt;h3 id=&quot;duck-typing-and-polymorphism-in-ruby&quot;&gt;Duck-Typing and Polymorphism in Ruby&lt;/h3&gt;
&lt;p&gt;A more practical example of polymorphism in OOP is through duck-typing, as referenced below.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Guitar
  def brand
    &amp;#39;Gibson&amp;#39;
  end
end

  class Drums
    def brand
      &amp;#39;Pearl&amp;#39;
    end
  end

  class Bass
    def brand
      &amp;#39;Fender&amp;#39;
    end
  end

  class Keyboard
    def brand
      &amp;#39;Casio&amp;#39;
    end
  end

  all_instruments = [Guitar.new, Drums.new, Bass.new, Keyboard.new]

  all_instruments.each do |instrument|
    puts instrument.brand
  end
  # Output

  # Gibson
  # Pearl
  # Fender
  # Casio
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Though each class method is named &lt;code&gt;brand&lt;/code&gt;, we don&amp;#39;t override the method (unlike in polymorphic inheritance). Instead of inheriting from a parent class, here we have four independent classes, each with its own method. Duck-typing is useful, as we can just iterate through the classes to get each method&amp;#39;s output (as opposed to calling each method separately).&lt;/p&gt;
&lt;p&gt;Again, duck-typing is polymorphic as we call a method — &lt;code&gt;brand&lt;/code&gt; — and generate an output that takes multiple forms: &lt;code&gt;Gibson&lt;/code&gt;, &lt;code&gt;Pearl&lt;/code&gt;, &lt;code&gt;Fender&lt;/code&gt;, and &lt;code&gt;Casio&lt;/code&gt;. Of course, duck-typing and polymorphism aren’t essential in producing this outcome. However, it’s very useful to implement clean and logical code.&lt;/p&gt;
&lt;h2 id=&quot;polymorphism-in-ruby-on-rails&quot;&gt;Polymorphism in Ruby on Rails&lt;/h2&gt;
&lt;p&gt;Polymorphism works well in Ruby on Rails as an Active Record association. If models essentially do the same thing, we can turn them into one single model to create a polymorphic relationship.&lt;/p&gt;
&lt;p&gt;Sticking with the instrument theme, let&amp;#39;s consider an application where users can post, comment, and review instruments. Examine the Entity-Relationship Diagram (ERD) below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-05/erd-1.png&quot; alt=&quot;first erd - no Polymorphic association&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In this example, we have an ERD for an application where a user can post an instrument with its details. A user can also provide a comment about that posted instrument.&lt;/p&gt;
&lt;p&gt;Other users can then provide a rating of the instrument and rate comments to determine their usefulness or validity. These Active Record associations work just fine and serve the purpose of our application.&lt;/p&gt;
&lt;p&gt;What if we wanted to add other associations to our application? We would need to add and repeat duplicate associations.&lt;/p&gt;
&lt;p&gt;For example, if we wanted to add a &lt;code&gt;user_rating&lt;/code&gt; model to rate the trustworthiness of a user, we would need to create a separate table with its own associations. This would mean adding a new relationship between the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;user_rating&lt;/code&gt; models. The ERD would then look something like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-05/erd-2.png&quot; alt=&quot;second erd - example of adding another model with no Polymorphic association&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Now we have three models essentially doing the same thing: rating an object, but in different contexts. These associations are ripe for a polymorphic association.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s take a look at the ERD with the rating models as polymorphic:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-05/erd-3.png&quot; alt=&quot;third erd - example of a Polymorphic association&quot;/&gt;&lt;/p&gt;
&lt;p&gt;As we have a &lt;code&gt;rating&lt;/code&gt; column, I named the model &lt;code&gt;reviews&lt;/code&gt; as opposed to &lt;code&gt;ratings&lt;/code&gt; to avoid confusion. Here, the non-review models still have associations with the other models, but the separate rating models have been merged into a single review model.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;reviewable_type&lt;/code&gt; and &lt;code&gt;reviewable_id&lt;/code&gt; now take on the same role as the separate rating models by representing which model the review is associated with.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;reviewable_type&lt;/code&gt; column stores the model class name (&lt;code&gt;user&lt;/code&gt;, &lt;code&gt;instrument_post&lt;/code&gt;, or &lt;code&gt;comment&lt;/code&gt;), and the &lt;code&gt;reviewable_id&lt;/code&gt; stores the corresponding ID of that model.&lt;/p&gt;
&lt;p&gt;We can now use these two columns to link the rating integer with a specific user, post, or comment via Active Record queries and/or conditional statements. The foreign key &lt;code&gt;user_id&lt;/code&gt; remains in the review model, as this allows us to track which user left a review.&lt;/p&gt;
&lt;p&gt;Right now, the term ‘-able’ in our polymorphic model may seem strange, but its purpose will soon be made clear when we do some Rails magic.&lt;/p&gt;
&lt;p&gt;The review model is considered polymorphic as we have one model or object that can represent and take on multiple forms: user, comment, and instrument post reviews.&lt;/p&gt;
&lt;h2 id=&quot;implementing-polymorphism-in-ruby-on-rails&quot;&gt;Implementing Polymorphism in Ruby on Rails&lt;/h2&gt;
&lt;p&gt;Time to implement polymorphism in a Rails application! If we act as though we have already created our &lt;code&gt;user&lt;/code&gt;, &lt;code&gt;instrument_post&lt;/code&gt;, and &lt;code&gt;comment&lt;/code&gt; models, we can get started on incorporating our polymorphic model: &lt;code&gt;reviews&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Firstly, create a table and generate the model from the terminal, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails g model Review user:belongs_to reviewable:references{polymorphic}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This builds the migration file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class CreateReviews &amp;lt; ActiveRecord::Migration[7.0]
  def change
    create_table :reviews do |t|
      t.belongs_to :user, null: false, foreign_key: true
      t.references :reviewable, polymorphic: true, null: false
      t.integer :rating

      t.timestamps
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;schema.rb&lt;/code&gt; file updates after the migration is run. The polymorphic option transforms the &lt;code&gt;reviewable&lt;/code&gt; column into the &lt;code&gt;reviewable_type&lt;/code&gt; and &lt;code&gt;reviewable_id&lt;/code&gt; columns:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  create_table &amp;quot;reviews&amp;quot;, force: :cascade do |t|
    t.integer &amp;quot;user_id&amp;quot;, null: false
    t.string &amp;quot;reviewable_type&amp;quot;, null: false
    t.integer &amp;quot;reviewable_id&amp;quot;, null: false
    t.integer &amp;quot;rating&amp;quot;
    t.datetime &amp;quot;created_at&amp;quot;, null: false
    t.datetime &amp;quot;updated_at&amp;quot;, null: false
    t.index [&amp;quot;reviewable_type&amp;quot;, &amp;quot;reviewable_id&amp;quot;], name: &amp;quot;index_reviews_on_reviewable&amp;quot;
    t.index [&amp;quot;user_id&amp;quot;], name: &amp;quot;index_reviews_on_user_id&amp;quot;
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/review.rb

class Review &amp;lt; ApplicationRecord
  belongs_to :user
  belongs_to :reviewable, polymorphic: true
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Remember when we mentioned the term ‘-able’ above? It is a Rails naming convention for designating our polymorphic association, giving us the ability to make a user, instrument post, and comment &amp;#39;reviewable&amp;#39;.&lt;/p&gt;
&lt;p&gt;For this Rails magic to work, we need to ensure that our other models are associated correctly with our polymorphic model.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/user.rb

class User &amp;lt; ApplicationRecord
  has_many :instrument_posts
  has_many :comments
  # alias association for user who submitted the review
  has_many :submitted_reviews, class_name: &amp;quot;Review&amp;quot;, foreign_key: :user_id
  # association for user, instrument_post and comment that has the review
  has_many :reviews, as: :reviewable
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/instrument_post.rb

class InstrumentPost &amp;lt; ApplicationRecord
  belongs_to :user
  has_many :reviews, as: :reviewable
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/comment.rb

class Comment &amp;lt; ApplicationRecord
  belongs_to :user
  has_many :reviews, as: :reviewable
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;user&lt;/code&gt;, &lt;code&gt;instrument_post&lt;/code&gt;, and &lt;code&gt;comment&lt;/code&gt; models can now be reviewed and given ratings.&lt;/p&gt;
&lt;p&gt;If we have already created at least two users, a comment, and an instrument post, we can then create and access the reviews through various ways with Active Record Queries, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# A user (User 2) leaving a review for another user (User 1)
# The reviewable_id is the id of the user to which the review is given
# The user_id is the id of the user who created the user review
user_1 = User.first
user_1.reviews.create(user_id: 2, rating: 2)
Review.where(reviewable_type: &amp;quot;User&amp;quot;).first # id: 1, user_id: 2, reviewable_type: &amp;quot;User&amp;quot;, reviewable_id: 1, rating: 2
# or
user_1.reviews.first # id: 1, user_id: 2, reviewable_type: &amp;quot;User&amp;quot;, reviewable_id: 1, rating: 2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# User 2 reviewing a instrument posted by User 1
# The reviewable_id is the id of the instrument_post
# The user_id is the id of the user who created the instrument_post review
post = InstrumentPost.first
post.reviews.create(user_id: 2, rating: 4)
post.reviews.first # id: 2, user_id: 2, reviewable_type: &amp;quot;InstrumentPost&amp;quot;, reviewable_id: 1, rating: 4
post.reviews.first.reviewable_type # &amp;quot;InstrumentPost&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# User 2 reviewing a comment created by User 1
# The reviewable_id is the id of the comment
# The user_id is the id of the user who created the comment review
comment = Comment.first
comment.reviews.create(user_id: 2, rating: 5)
comment.reviews.first # id: 3, user_id: 2, reviewable_type: &amp;quot;Comment&amp;quot;, reviewable_id: 1, rating: 5
comment.reviews.first.rating # 5

# We can then find the user that created the reviewed comment by associating the value of the reviewable_id to the comment id
Comment.where(id: 1) # id: 1, user_id: 1, content: &amp;quot;Comment created by user id 1&amp;quot;
# In this scenario the comment id and user_id just happen to be the same
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;user_1 = User.first
user_2 = User.last

# Reviews User 1 has given (none)
user_1.submitted_reviews # []

# Reviews User 2 has given
user_2.submitted_reviews
# id: 1, user_id: 2, reviewable_type: &amp;quot;User&amp;quot;, reviewable_id: 1, rating: 2
# id: 2, user_id: 2, reviewable_type: &amp;quot;InstrumentPost&amp;quot;, reviewable_id: 1, rating: 4
# id: 3, user_id: 2, reviewable_type: &amp;quot;Comment&amp;quot;, reviewable_id: 1, rating: 5

# Counting the total amount of reviews User 2 has given
user_2.submitted_reviews.count # 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are many other ways to interact with the &lt;code&gt;reviews&lt;/code&gt; model, depending on what data you need to render. It is important to share how the parent models can create a review. As long as the review is associated with a user and a reviewable model, Active Record automatically links the &lt;code&gt;reviewable_id&lt;/code&gt; and &lt;code&gt;reviewable_type&lt;/code&gt; with the associated model.&lt;/p&gt;
&lt;p&gt;Without polymorphism in our Rails examples, there would be many more tables, unnecessary duplicate columns, &lt;code&gt;belongs_to&lt;/code&gt;, and &lt;code&gt;has_many&lt;/code&gt; associations in our models. Polymorphism has lessened the need to join tables, permitting easier and quicker Active Record queries and associations.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-use-polymorphism-for-clean-and-logical-ruby-code&quot;&gt;Wrap Up: Use Polymorphism for Clean and Logical Ruby Code&lt;/h2&gt;
&lt;p&gt;In this post, we explored polymorphism in two distinct environments: biology and Ruby programming. In both cases, polymorphism is the ability of an object to display more than one form.&lt;/p&gt;
&lt;p&gt;We looked at how to implement polymorphism in Ruby through inheritance and duck-typing before diving into the uses of polymorphism in Ruby on Rails specifically.&lt;/p&gt;
&lt;p&gt;Polymorphism can help you write clean and logical code. My goal is to help you add this essential OOP concept to your toolbelt for your current, future, and maybe even past applications.&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Using Scientist to Refactor Critical Ruby on Rails Code</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/05/18/using-scientist-to-refactor-critical-ruby-on-rails-code.html">
    <id>https://blog.appsignal.com/2022/05/18/using-scientist-to-refactor-critical-ruby-on-rails-code.html</id>
    <published>2022-05-18T00:00:00+00:00</published>
    <updated>2022-05-18T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Migrate, refactor, and change critical Ruby production code with confidence using the Scientist gem.</summary>
    <content type="html">&lt;p&gt;Ask any software engineer to review key portions of production code, and inevitably, they will point out three things that need to be refactored. So why does so much bad, brittle, or misunderstood code remain running in production?&lt;/p&gt;
&lt;p&gt;The answer is simple: engineers are afraid to touch it. Refactoring tasks get identified and added to the backlog, but rarely make it into the current sprint.&lt;/p&gt;
&lt;p&gt;There are numerous reasons for this. The code may have been written by an engineer who left the team years ago, and no one completely understands it. In other cases, the capability is critical to the business. No one wants to be responsible for a potential outage or loss of revenue.&lt;/p&gt;
&lt;p&gt;In this post, we&amp;#39;ll examine how you can use Scientist to migrate, refactor, and change critical Ruby production code with confidence.&lt;/p&gt;
&lt;p&gt;But first, you might ask — can&amp;#39;t we use tests to dig up code issues?&lt;/p&gt;
&lt;h2 id=&quot;this-is-what-rails-testing-is-for-right&quot;&gt;This Is What Rails Testing Is For, Right?&lt;/h2&gt;
&lt;p&gt;Yes, and no. It is often difficult to gain complete confidence in code changes before deployment. The unit and system tests pass. It&amp;#39;s good to go, right?&lt;/p&gt;
&lt;p&gt;The reality is that there is no substitute for the real world, i.e. production. What if the data quality is bad or tests are missing? How can you know if the new software will perform well enough to handle production throughput?&lt;/p&gt;
&lt;p&gt;Teams with public services sometimes find that they need to deal with “bugwards compatibility” issues. When a bug has existed in production for a while, clients may code in a way that depends on consistent incorrect behavior. Customers often use software in unexpected ways.&lt;/p&gt;
&lt;h2 id=&quot;observe-production-changes-in-ruby-and-rails-with-scientist&quot;&gt;Observe Production Changes in Ruby and Rails with Scientist&lt;/h2&gt;
&lt;p&gt;If production is the best place to gain confidence in a change, then consider observing how code behaves there. This may sound scary at first, as the idea of “testing in production” contradicts classic software engineering practices.&lt;/p&gt;
&lt;p&gt;However, the good news is that it’s easy and safe to do so in Ruby and Rails using the &lt;a href=&quot;https://github.com/github/scientist&quot;&gt;Scientist gem&lt;/a&gt;. Scientist&amp;#39;s name is based on the scientific method of conducting experiments to verify a given hypothesis. In this case, our hypothesis is that the new code does the job.&lt;/p&gt;
&lt;p&gt;The reason we can safely take this approach stems from the fact that experiments still use the result of the existing code. New code is only evaluated for observation and comparison purposes, both for accuracy and performance. We mitigate the test coverage concerns discussed earlier by evaluating performance using real-world data and parameters. Experiments typically evaluate a chosen sample rate of requests to minimize the impact on production. However, you can evaluate every request if desired.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s now take a quick look at how Scientist works in a branch by abstraction way.&lt;/p&gt;
&lt;h2 id=&quot;the-branch-by-abstraction-pattern-in-rubys-scientist&quot;&gt;The Branch by Abstraction Pattern in Ruby&amp;#39;s Scientist&lt;/h2&gt;
&lt;p&gt;Scientist&amp;#39;s approach begins with the &lt;a href=&quot;https://martinfowler.com/bliki/BranchByAbstraction.html&quot;&gt;Branch by Abstraction&lt;/a&gt; pattern described by Martin Fowler as making “a large-scale change to a software system in a gradual way.”&lt;/p&gt;
&lt;p&gt;We introduce an abstraction layer to isolate the code being updated. This layer decides which implementation to use so that the experiment is transparent to the rest of the system. The technique is related to using a feature flag that determines the code path.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.blog/2016-02-03-scientist/&quot;&gt;Scientist gem, which originated from Github&lt;/a&gt;, implements this pattern using an experiment. The existing code is referred to as the control, and the new implementation is the candidate. Both code paths are run in randomized order, but only the control result is returned to the client.&lt;/p&gt;
&lt;h2 id=&quot;using-scientist-to-refactor-a-ruby-service&quot;&gt;Using Scientist to Refactor a Ruby Service&lt;/h2&gt;
&lt;p&gt;Consider a &lt;a href=&quot;https://github.com/dbroemme/scientist-labtech-example/blob/master/app/helpers/prime_factor_helper.rb#L20&quot;&gt;Ruby service&lt;/a&gt; that returns the largest prime factor for a given number. Assume that we&amp;#39;ve identified optimizations to prune the required set of candidates, speeding up the service.&lt;/p&gt;
&lt;p&gt;However, service owners want to be sure no bugs were introduced. They also want to observe any performance improvements. Introduce the &lt;a href=&quot;https://github.com/dbroemme/scientist-labtech-example/blob/master/app/helpers/prime_factor_helper.rb#L3&quot;&gt;following code&lt;/a&gt;, modifying clients to call this method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;scientist&amp;#39;

def largest_prime_factor(number)
  science &amp;quot;prime-factors&amp;quot; do |experiment|
    experiment.use { find_largest_prime_factor(number) }     # old way
    experiment.try { improved_largest_prime_factor(number) } # new way
  end  # returns the control value
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point, only the &lt;code&gt;use&lt;/code&gt; (control) expression is invoked. To make the experiment worthwhile, define a custom &lt;code&gt;Experiment&lt;/code&gt; class to enable it (100% of the time below) and publish the results (in this case, just logging). Scientist generates fantastic data but it doesn’t do anything with it by default. That part is left up to you.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;scientist/experiment&amp;#39;
require &amp;#39;pp&amp;#39;

class MyExperiment
  include Scientist::Experiment

  attr_accessor :name

  def initialize(name)
    @name = name
  end

  def enabled?
    true
  end

  def raised(operation, error)
    p &amp;quot;Operation &amp;#39;#{operation}&amp;#39; failed with error &amp;#39;#{error.inspect}&amp;#39;&amp;quot;
    super # will re-raise
  end

  def publish(result)
    pp result
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The results of the experiment will be logged, and we can make improvements over time based on the feedback. Once the new code meets the requirements and confidence is high, accomplish cutover to the new implementation by simply replacing the science code with a delegation to the new implementation.&lt;/p&gt;
&lt;h2 id=&quot;labtech-simplifies-scientist-experiments-in-ruby-on-rails&quot;&gt;LabTech Simplifies Scientist Experiments in Ruby on Rails&lt;/h2&gt;
&lt;p&gt;You can use the &lt;a href=&quot;https://github.com/RealGeeks/lab_tech&quot;&gt;LabTech gem&lt;/a&gt; in your Rails application to easily configure Scientist and handle the results.&lt;/p&gt;
&lt;p&gt;Applications that use AppSignal can use the &lt;code&gt;Appsignal.instrument&lt;/code&gt; &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/instrumentation.html&quot;&gt;custom instrumentation helper&lt;/a&gt; to track how long Scientist events take to complete. Wrap it around the different experiment code blocks to see events appear in the performance timeline.&lt;/p&gt;
&lt;p&gt;Now, going back to LabTech — the web page below simply accepts a number to factor.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-05/prime-factor-screenshot.png&quot; alt=&quot;Image of web form to enter a number and see prime factor&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Getting started is easy provided you have access to the console. First, add the LabTech gem to your Gemfile and run a &lt;code&gt;bundle install&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;gem &amp;#39;lab_tech&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Tables store results and experiment configuration, so run a database migration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails lab_tech:install:migrations db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The abstraction layer is the same, except the LabTech module is used. The full code is available on GitHub.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def largest_prime_factor(number)
    LabTech.science &amp;quot;prime-factors&amp;quot; do |experiment|
      ...
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At this point, the experiment is disabled, so use the console to enable it in all cases or for a percentage of the time.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/rails console
LabTech.enable &amp;quot;prime-factors&amp;quot;
LabTech.enable &amp;quot;prime-factors&amp;quot;, percent: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now run tests and the experiment will be evaluated. For a textual view of results, use either of the following commands from the Rails console.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;LabTech.summarize_results &amp;quot;prime-factors&amp;quot;
LabTech.summarize_errors &amp;quot;prime-factors&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After a few successful runs and one manufactured error, here is an example of what the results summary looks like. There is an overview of successes and failures, as well as an ASCII chart showing performance differences.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;--------------------------------------------------------------------------------
Experiment: prime-factors
--------------------------------------------------------------------------------
Earliest results: 2022-04-27T02:42:45Z
Latest result:    2022-05-01T17:27:39Z (5 days)

3 of 4 (75.00%) correct
1 of 4 (25.00%) mismatched

Median time delta: +0.000s  (90% of observations between +0.000s and +0.000s)

Speedups (by percentiles):
      0%  [                         ·         █               ]    +2.4x faster
      5%  [                         ·         █               ]    +2.4x faster
     10%  [                         ·         █               ]    +2.4x faster
     15%  [                         ·         █               ]    +2.4x faster
     20%  [                         ·         █               ]    +2.4x faster
     25%  [                         ·         █               ]    +2.4x faster
     30%  [                         ·         █               ]    +2.4x faster
     35%  [                         ·         █               ]    +2.4x faster
     40%  [                         ·         █               ]    +2.4x faster
     45%  [                         ·         █               ]    +2.4x faster
     50%  [ · · · · · · · · · · · · · · · · · █ · · · · · · · ]    +2.4x faster
     55%  [                         ·         █               ]    +2.4x faster
     60%  [                         ·         █               ]    +2.4x faster
     65%  [                         ·         █               ]    +2.4x faster
     70%  [                         ·                        █]    +6.9x faster
     75%  [                         ·                        █]    +6.9x faster
     80%  [                         ·                        █]    +6.9x faster
     85%  [                         ·                        █]    +6.9x faster
     90%  [                         ·                        █]    +6.9x faster
     95%  [                         ·                        █]    +6.9x faster
    100%  [                         ·                        █]    +6.9x faster
--------------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/ankane/blazer&quot;&gt;Blazer gem&lt;/a&gt; provides a nice way to analyze the results easily. It is simple to install and allows SQL queries to run against tables. The query here shows that the candidate implementation is significantly faster than the original.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-05/blazer-query.png&quot; alt=&quot;Image of experiment observations using Blazer&quot;/&gt;&lt;/p&gt;
&lt;p&gt;In the example prime factoring service, the speedup in the improved implementation comes from a heuristic that eliminates some possible factors to consider. As we consider higher numbers and find a prime factor, we can stop searching after we get to our target number divided by that factor. The new code path only adds &lt;a href=&quot;https://github.com/dbroemme/scientist-labtech-example/blob/master/app/helpers/prime_factor_helper.rb#L38&quot;&gt;one statement&lt;/a&gt; to accomplish this.&lt;/p&gt;
&lt;p&gt;We can also see the reduction in execution time using a Blazer query against the LabTech tables.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-05/speedup.png&quot; alt=&quot;Image of bar graph showing speedup of new code&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;use-cases-and-limitations-of-scientist&quot;&gt;Use Cases and Limitations of Scientist&lt;/h2&gt;
&lt;p&gt;Optimal use cases for Scientist include searches, calculations, and code that has no side effects. Code that includes transactional updates or external integrations such as email does not fit cleanly into the model because the capability is run twice (both the old and new implementations).&lt;/p&gt;
&lt;p&gt;This is not a trivial limitation, as it does eliminate several use cases. However, there are some workarounds if the experiment is critical to your success. Consider whether the side effects are relevant or if duplication is an issue. For example, it may not matter in some cases whether two emails are sent during the evaluation. Another option is to have the new code determine the result but not persist it. This would prevent any meaningful performance comparisons. However, it would allow you to verify accuracy.&lt;/p&gt;
&lt;p&gt;Other limitations stem from Scientist’s focus on return values. In some cases, valid results may exhibit differences over time, whether they simply include timestamps in the response or certain factors vary. In many cases, we can write custom comparison logic in the experiment to verify accuracy beyond basic string comparisons.&lt;/p&gt;
&lt;p&gt;Finally, a limitation of LabTech is that it has not been ported to Rails 7 as of the time of writing.&lt;/p&gt;
&lt;h2 id=&quot;best-practices-for-effective-scientist-experiments-in-rails&quot;&gt;Best Practices for Effective Scientist Experiments in Rails&lt;/h2&gt;
&lt;p&gt;Consider these items when implementing your experiments:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;In Rails projects, Scientist can either be configured in an initializer or a wrapper like the Rails LabTech gem. Most Rails applications already have a database, so LabTech leverages ActiveRecord to store results.&lt;/li&gt;
&lt;li&gt;To avoid slowing down development and testing, enable your experiment only in staging and production environments.&lt;/li&gt;
&lt;li&gt;To minimize any potential impact on production, only run the experiment on a percentage of requests. LabTech supports this out of the box as an optional parameter when you enable the experiment (it is initially disabled by default). Using pure Scientist, this logic is easy to code in the experiment’s &lt;code&gt;enabled?&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Some logic is resource-intensive, so a low sampling rate may be a good place to start. As you gain confidence with the results, ramp up the percentage of requests being evaluated.&lt;/li&gt;
&lt;li&gt;You can add context attributes to get the most from your results. The experiment context can be set to a Symbol-keyed Hash of data that is then made available in published results, e.g.:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;experiment.context :user =&amp;gt; user
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;wrap-up-observe-and-monitor-your-ruby-app-with-scientist&quot;&gt;Wrap-Up: Observe and Monitor Your Ruby App with Scientist&lt;/h2&gt;
&lt;p&gt;In this post, we explored how to use the Scientist gem to change, migrate, and refactor Ruby code in production.&lt;/p&gt;
&lt;p&gt;We examined Scientist&amp;#39;s origins in the Branch by Abstraction pattern, then dived into refactoring. Next, we saw how LabTech could help with gathering results and your Scientist configuration.&lt;/p&gt;
&lt;p&gt;We then touched on some limitations of Scientist before finally outlining a few best practices.&lt;/p&gt;
&lt;p&gt;You must observe and monitor what is happening in your system. Integrate Scientist into your development process to make critical changes in your Ruby code with greater confidence.&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Bootstrapping with Ruby on Rails Generators and Templates</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/05/04/bootstrapping-with-ruby-on-rails-generators-and-templates.html">
    <id>https://blog.appsignal.com/2022/05/04/bootstrapping-with-ruby-on-rails-generators-and-templates.html</id>
    <published>2022-05-04T00:00:00+00:00</published>
    <updated>2022-05-04T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's explore the basics of Rails generators and templates, then examine how to customize your Rails app with templates.</summary>
    <content type="html">&lt;p&gt;Rails&amp;#39; batteries-included approach is one of its greatest assets. No other framework makes it so
effortless to get your application off the ground quickly, at least partially due to Rails&amp;#39; generators.&lt;/p&gt;
&lt;p&gt;If
you&amp;#39;ve used Rails for any amount of time, you have come across generators. Need to create a new application? Run &lt;code&gt;rails new&lt;/code&gt;. Need to scaffold a bunch of new models and views?
Run &lt;code&gt;rails generate scaffold&lt;/code&gt;. There are dozens more available to help you get
started rapidly or streamline your workflow.&lt;/p&gt;
&lt;p&gt;But sometimes, using generators is just not enough. You might want to customize the
behavior of these commands or even create your own. In this article, we&amp;#39;ll take a closer look at generators -
in particular, how to create your own custom Rails application using templates.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s get started!&lt;/p&gt;
&lt;h2 id=&quot;what-are-rails-generators&quot;&gt;What Are Rails Generators?&lt;/h2&gt;
&lt;p&gt;Not to be confused with generator functions (which you might be familiar with from Python or Javascript), Rails
generators are custom &lt;a href=&quot;https://github.com/rails/thor&quot;&gt;Thor&lt;/a&gt; commands that focus on, well, generating things.&lt;/p&gt;
&lt;p&gt;There are lots of examples. You&amp;#39;ll likely be familiar with the model generator (&lt;code&gt;rails generate model&lt;/code&gt;) for creating
new ActiveRecord models or the migration generator (&lt;code&gt;rails generate migration&lt;/code&gt;) for generating new migrations. There is
also &lt;code&gt;rails generate generator&lt;/code&gt; which — you guessed it — creates a new generator!&lt;/p&gt;
&lt;p&gt;Generators can call each other — for example, &lt;code&gt;rails scaffold&lt;/code&gt; will call numerous other generators — and provide
methods to create or modify files, install gems, run specific rake tasks, and much more. Let&amp;#39;s create a
simple model spec generator to understand how this works.&lt;/p&gt;
&lt;h3 id=&quot;creating-your-own-generator-in-ruby-on-rails&quot;&gt;Creating Your Own Generator in Ruby on Rails&lt;/h3&gt;
&lt;p&gt;Run the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;rails generate generator model_spec
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will create several new files in &lt;code&gt;/lib/generators/model_spec&lt;/code&gt;. We can modify &lt;code&gt;model_spec_generator.rb&lt;/code&gt; in folder &lt;code&gt;lib/generators/model_spec/&lt;/code&gt;
to create a model spec file in the correct directory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ModelSpecGenerator &amp;lt; Rails::Generators::NamedBase
  source_root File.expand_path(&amp;#39;templates&amp;#39;, __dir__)

  def create_model_spec
    template_file = File.join(&amp;#39;spec/models&amp;#39;, class_path, &amp;quot;#{file_name}_spec.rb&amp;quot;)
    template &amp;#39;model_spec.rb.erb&amp;#39;, template_file
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;template&lt;/code&gt; command will look for a template file in the &lt;code&gt;lib/generators/model_spec/templates&lt;/code&gt; directory and render
it to the specified location — the &lt;code&gt;spec/models&lt;/code&gt; directory. The command will replace ERB-style variables
found in the template file.&lt;/p&gt;
&lt;p&gt;By setting the &lt;code&gt;source_root&lt;/code&gt;, we let our generator know where it can find referenced template files. Template
&lt;code&gt;model_spec.rb&lt;/code&gt; in folder &lt;code&gt;lib/generators/model_spec/templates/&lt;/code&gt; could look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;rails_helper&amp;#39;

RSpec.describe &amp;lt;%= class_name %&amp;gt;, :model
  pending &amp;quot;add some examples to (or delete) #{__FILE__}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you have created that file, you can run the generator to create a new spec file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails generate model_spec mymodel
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Many gems ship with generators such as this one. In fact, we created a simplified version of the generator &lt;a href=&quot;https://relishapp.com/rspec/rspec-rails/docs/generators&quot;&gt;Rspec ships with&lt;/a&gt;. &lt;a href=&quot;https://github.com/thoughtbot/factory_bot_rails#generators&quot;&gt;FactoryBot has a generator&lt;/a&gt; for factories.
There are many more examples.&lt;/p&gt;
&lt;p&gt;The generators in various gems are more sophisticated than the one we created. We could
make our generator take arguments or even hook it into existing generators such as &lt;code&gt;rails scaffold&lt;/code&gt;. Refer to the &lt;a href=&quot;https://guides.rubyonrails.org/generators.html#customizing-your-workflow&quot;&gt;Rails generators documentation&lt;/a&gt; if you want to learn more.&lt;/p&gt;
&lt;p&gt;So generators have the potential to simplify your workflow in an existing application. But can we also use generators to customize setting up a new application?&lt;/p&gt;
&lt;p&gt;Enter templates!&lt;/p&gt;
&lt;h2 id=&quot;templates-in-ruby-on-rails&quot;&gt;Templates in Ruby on Rails&lt;/h2&gt;
&lt;p&gt;As the name suggests, templates are files for customizing your application setup. Don&amp;#39;t confuse these with the template files that we previously discussed!
Under the hood, they are just generators with a specific purpose, as evidenced by the &lt;a href=&quot;https://guides.rubyonrails.org/rails_application_templates.html#template-api&quot;&gt;template API&lt;/a&gt;. While not exactly identical to generators, they are very similar.&lt;/p&gt;
&lt;p&gt;If you have an existing template file, you can use it like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails new myapp -m mytemplate.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rather than specifying a local file, you may also specify a URL. This is especially useful as it allows you to share
application templates.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails new myapp -m https://gist.github.com/appsignal/12345/raw/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You are not limited to using templates when running &lt;code&gt;rails new&lt;/code&gt; either. If you&amp;#39;ve already set up an app, you can apply
templates afterward by executing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails app:template LOCATION=http://example.com/template.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Templates can be extremely useful. Who doesn&amp;#39;t want to automate adding the same couple of gems and making the same
configuration changes every time they create a new app? Creating your own application template is great fun — even if
it doesn&amp;#39;t save a lot of time in the long run.&lt;/p&gt;
&lt;h2 id=&quot;creating-your-own-template-in-rails&quot;&gt;Creating Your Own Template in Rails&lt;/h2&gt;
&lt;p&gt;We now know about generators and how to use templates. Let&amp;#39;s create a simple application template to automate some setup
steps.&lt;/p&gt;
&lt;p&gt;How you set up your Rails app is very much down to personal preference, but here&amp;#39;s an example:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Install the &lt;a href=&quot;https://github.com/bkeepers/dotenv&quot;&gt;dotenv&lt;/a&gt; gem.&lt;/li&gt;
&lt;li&gt;Create a &lt;code&gt;.env.development&lt;/code&gt; file for the development environment.&lt;/li&gt;
&lt;li&gt;Adapt the database configuration file to use environment variables.&lt;/li&gt;
&lt;li&gt;Optionally &lt;a href=&quot;https://github.com/rspec/rspec-rails&quot;&gt;install and set up Rspec&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let&amp;#39;s create a local file — &lt;code&gt;mytemplate.rb&lt;/code&gt; — and add &lt;code&gt;dotenv&lt;/code&gt; using the &lt;code&gt;gem&lt;/code&gt; command.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;gem &amp;#39;dotenv-rails&amp;#39;, groups: [:development, :test]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we&amp;#39;ve just added the dotenv gem, let&amp;#39;s also create a &lt;code&gt;.env.development&lt;/code&gt; file to contain our database
configuration.&lt;/p&gt;
&lt;p&gt;You can create a new file with specific content by using &lt;code&gt;create_file&lt;/code&gt;. You won&amp;#39;t find this in the template or generator
documentation, as the method is supplied by Thor. You might also come across the alias &lt;code&gt;file&lt;/code&gt;. Application templates are
evaluated in the context of &lt;code&gt;Rails::Generators::AppGenerator&lt;/code&gt;, and that&amp;#39;s exactly &lt;a href=&quot;https://github.com/rails/rails/blob/8f39fbe18a57ae74513edc8561c00a369fe10f08/railties/lib/rails/generators/rails/app/app_generator.rb#L522&quot;&gt;where the &lt;code&gt;file&lt;/code&gt; alias is defined&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;create_file &amp;#39;.env.development&amp;#39;, &amp;lt;&amp;lt;~TXT
  DATABASE_HOST=localhost
  DATABASE_USERNAME=#{app_name}
  DATABASE_PASSWORD=#{app_name}
TXT
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;app_name&lt;/code&gt; variable contains the first argument of &lt;code&gt;rails new&lt;/code&gt;. Using this variable, we can ensure our config file
matches the generated application.&lt;/p&gt;
&lt;p&gt;Next, let&amp;#39;s use our environment variables to connect to the database. We could overwrite the entire &lt;code&gt;config/database.yml&lt;/code&gt;
using the &lt;code&gt;create_file&lt;/code&gt; command, but let&amp;#39;s modify it instead using &lt;a href=&quot;https://guides.rubyonrails.org/generators.html#inject-into-file&quot;&gt;&lt;code&gt;inject_into_file&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;inject_into_file &amp;#39;config/database.yml&amp;#39;, after: /database: #{app_name}_development\n/ do &amp;lt;&amp;lt;-RUBY
  host: &amp;lt;%= ENV[&amp;#39;DATABASE_HOST&amp;#39;] %&amp;gt;
  username: &amp;lt;%= ENV[&amp;#39;DATABASE_USERNAME&amp;#39;] %&amp;gt;
  password: &amp;lt;%= ENV[&amp;#39;DATABASE_PASSWORD&amp;#39;] %&amp;gt;
  RUBY
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use both strings or regex with the &lt;code&gt;after&lt;/code&gt; argument to specify where to inject content.&lt;/p&gt;
&lt;p&gt;Of course, using this kind of configuration only makes sense if a user isn&amp;#39;t creating an application with SQLite.
You can check for the presence of certain arguments by using the &lt;code&gt;options&lt;/code&gt; variable. It&amp;#39;s best you read the &lt;a href=&quot;https://github.com/rails/rails/blob/8f39fbe18a57ae74513edc8561c00a369fe10f08/railties/lib/rails/generators/database.rb#L14&quot;&gt;source code of Rails&amp;#39; app generator&lt;/a&gt; to see which options are available.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;if options[:database] != &amp;#39;sqlite3&amp;#39;
  # Set up env vars and db configuration
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Last but not least, let&amp;#39;s also allow users to install Rspec if they want to. There are various
methods for taking user input and creating interactive templates. The &lt;code&gt;yes?&lt;/code&gt; method asks a user for
confirmation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;if yes?(&amp;#39;Would you like to install Rspec?&amp;#39;)
  gem &amp;#39;rspec-rails&amp;#39;, group: :test
  after_bundle { generate &amp;#39;rspec:install&amp;#39; }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We already know the &lt;code&gt;gem&lt;/code&gt; method, but &lt;code&gt;generate&lt;/code&gt; and &lt;code&gt;after_bundle&lt;/code&gt; are new.&lt;/p&gt;
&lt;p&gt;As mentioned before, Rspec adds its own generators, and you can call these generators (or any other ones, for that
matter) directly from your template. But there is a catch — gems specified with the &lt;code&gt;gem&lt;/code&gt; method are only installed at
the end of the template. Calling &lt;code&gt;generate&lt;/code&gt; with a generator supplied by such a gem would fail — which is why you should register
the command as a callback with &lt;code&gt;after_bundle&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: Before we wrap up, a quick word about creating or modifying files. We used &lt;code&gt;create_file&lt;/code&gt; and &lt;code&gt;inject_into_file&lt;/code&gt;,
but there are many other options. You may come across &lt;code&gt;copy_file&lt;/code&gt; or &lt;code&gt;template&lt;/code&gt; when reading different templates. I did not
mention them here to keep things simple. If you want to create more advanced templates, you
should know that these other methods for dealing with files exist.&lt;/p&gt;
&lt;h2 id=&quot;the-result-the-final-template-in-rails&quot;&gt;The Result: The Final Template in Rails&lt;/h2&gt;
&lt;p&gt;The final template should look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Install dotenv
gem &amp;#39;dotenv-rails&amp;#39;, groups: [:development, :test]

if options[:database] != &amp;#39;sqlite3&amp;#39;
  # Set up .env.development
  create_file &amp;#39;.env.development&amp;#39;, &amp;lt;&amp;lt;~TXT
    DATABASE_HOST=localhost
    DATABASE_USERNAME=#{app_name}
    DATABASE_PASSWORD=#{app_name}
  TXT

  # Modify database.yml
  inject_into_file &amp;#39;config/database.yml&amp;#39;, after: /database: #{app_name}_development\n/ do &amp;lt;&amp;lt;-RUBY
  host: &amp;lt;%= ENV[&amp;#39;DATABASE_HOST&amp;#39;] %&amp;gt;
  username: &amp;lt;%= ENV[&amp;#39;DATABASE_USERNAME&amp;#39;] %&amp;gt;
  password: &amp;lt;%= ENV[&amp;#39;DATABASE_PASSWORD&amp;#39;] %&amp;gt;
  RUBY
  end
end

# Optionally install Rspec
if yes?(&amp;#39;Would you like to install Rspec?&amp;#39;)
  gem &amp;#39;rspec-rails&amp;#39;, group: :test
  after_bundle { generate &amp;#39;rspec:install&amp;#39; }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can test this particular template by running:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails new myapp -m mytemplate.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Or:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails new myapp --database=postgresql mytemplate.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To take advantage of the custom database configuration.&lt;/p&gt;
&lt;p&gt;As mentioned, this file is perfectly suited to share as a GitHub gist. Adapt it to suit your needs,
upload it, and then share it with your colleagues, friends, and anyone else interested in your custom
app template 😉.&lt;/p&gt;
&lt;h3 id=&quot;learn-more-about-rails-generators-and-templates&quot;&gt;Learn More About Rails Generators and Templates&lt;/h3&gt;
&lt;p&gt;Needless to say, we&amp;#39;ve just scratched the surface here.&lt;/p&gt;
&lt;p&gt;Everyone has different preferences for writing and developing Rails apps, so there are numerous
generators and application templates out there. You can learn a lot about doing specific customizations by reading about them. I recommend &lt;a href=&quot;https://github.com/excid3/jumpstart&quot;&gt;Chris
Oliver&amp;#39;s Jumpstart&lt;/a&gt; and &lt;a href=&quot;https://railsbytes.com/&quot;&gt;RailsBytes&lt;/a&gt;, the latter
of which is a community-curated collection of templates.&lt;/p&gt;
&lt;p&gt;There is also &lt;a href=&quot;https://github.com/thoughtbot/suspenders&quot;&gt;Thoughtbot&amp;#39;s Suspenders&lt;/a&gt;, which inspired me to dig deeper into
Rails generators and templates. I even wrote my own application template — &lt;a href=&quot;https://github.com/hschne/schienenzeppelin&quot;&gt;Schienenzeppelin&lt;/a&gt; —
which, while not up-to-date, might still provide some inspiration.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-get-started-with-ruby-on-rails-generators-and-templates&quot;&gt;Wrap Up: Get Started with Ruby on Rails Generators and Templates&lt;/h2&gt;
&lt;p&gt;In this post, we looked into the basics of Rails generators and how they are used. We created our own generators
to simplify writing new model specs.&lt;/p&gt;
&lt;p&gt;We then delved into templates and learned how you could create a simple template to customize your application
setup. This can be a bit of work, but also quite rewarding. If writing your own templates is not for you, there are
many existing ones online to choose from!&lt;/p&gt;
&lt;p&gt;Happy templating!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>5 Tips to Design Ruby on Rails Transactions the Right Way</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/03/30/5-tips-to-design-ruby-on-rails-transactions-the-right-way.html">
    <id>https://blog.appsignal.com/2022/03/30/5-tips-to-design-ruby-on-rails-transactions-the-right-way.html</id>
    <published>2022-03-30T00:00:00+00:00</published>
    <updated>2022-03-30T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Check out these 5 tips to ensure your transactions are readable and well-designed in your Ruby on Rails app.</summary>
    <content type="html">&lt;p&gt;Data integrity problems are among the most common database issues Rails developers face. Besides allowing for proper validation, correctly designed transaction blocks ensure that your data isn&amp;#39;t partially created or updated.&lt;/p&gt;
&lt;p&gt;However, transactions can also harm your application — or even take down your whole database — when not properly designed.&lt;/p&gt;
&lt;p&gt;This article offers a set of good practices for working with transactions. The tips are pretty simple, but they will help make your transactions bulletproof, readable, and relatively safe.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s dive in!&lt;/p&gt;
&lt;h2 id=&quot;1-use-bang-methods-in-rails-when-possible&quot;&gt;1. Use Bang Methods in Rails When Possible&lt;/h2&gt;
&lt;p&gt;In Rails, method versions with &lt;code&gt;!&lt;/code&gt; can give you confidence that an error will be raised when something goes wrong.&lt;/p&gt;
&lt;p&gt;For example, the &lt;code&gt;#save&lt;/code&gt; method also exists in the &lt;code&gt;save!&lt;/code&gt; version. You might want to use this version in the controller if you don&amp;#39;t want to raise any errors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def create
  user = User.new(user_params)

  if user.save
    # redirect
  else
    render :new
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above approach won&amp;#39;t work well in transactions. By using &lt;code&gt;save&lt;/code&gt;, we can&amp;#39;t roll back the process when the error is raised. That&amp;#39;s why it is so important to use the &lt;code&gt;!&lt;/code&gt; version of the methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ActiveRecord::Base.transaction do
  user = User.create(user_attributes)
  user.memberships.create(membership_attributes)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above, the transaction succeeds even if the membership record isn&amp;#39;t created, and we end up with a messed-up data structure in the database.&lt;/p&gt;
&lt;p&gt;If you use the following version, the transaction reverts due to an &lt;code&gt;ActiveRecord::RecordNotSaved&lt;/code&gt; error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ActiveRecord::Base.transaction do
  user = User.create!(user_attributes)
  user.memberships.create!(membership_attributes)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;2-handle-errors-in-rails-transactions-properly&quot;&gt;2. Handle Errors in Rails Transactions Properly&lt;/h2&gt;
&lt;p&gt;When it comes to errors in transactions, there are a few rules that you should respect. By following these rules, you&amp;#39;ll have readable and well-working code that will not create confusion among other developers or weird behavior that is hard to debug.&lt;/p&gt;
&lt;h3 id=&quot;do-not-rescue-from-activerecordstatementinvalid&quot;&gt;Do Not Rescue from &lt;code&gt;ActiveRecord::StatementInvalid&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ActiveRecord::StatementInvalid&lt;/code&gt; is a special error raised when something on the database level goes wrong. Never rescue from this error. You should always be explicitly notified when something goes wrong with the database query.&lt;/p&gt;
&lt;p&gt;Avoid the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def perform_action(...)
  User.transaction do
    # perform transaction
  end
rescue ActiveRecord::StatementInvalid
  # do something
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;use-the-rescue-on-the-right-level&quot;&gt;Use the Rescue on the Right Level&lt;/h3&gt;
&lt;p&gt;If you use rescue on the following level, you&amp;#39;ll catch the error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.transaction do
  user.perform_action!
  user.perform_another_action!
rescue SomeError
  # rescue
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The transaction does not roll back because you caught the error. Let the error be raised and catch it outside the transaction block:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def some_method
  User.transaction do
    user.perform_action!
    user.perform_another_action!
  end
rescue SomeError
  # rescue
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above approach, the transaction rolls back in case of an error, and you catch the error. This is the right approach to catch errors raised inside transactions without overwriting transaction behavior.&lt;/p&gt;
&lt;h3 id=&quot;do-not-catch-generic-errors&quot;&gt;Do Not Catch Generic Errors&lt;/h3&gt;
&lt;p&gt;You should avoid catching generic errors like &lt;code&gt;StandardError&lt;/code&gt; or &lt;code&gt;ArgumentError&lt;/code&gt;. This is more like a general rule for readable and easily testable code, but it&amp;#39;s worth mentioning.&lt;/p&gt;
&lt;p&gt;Catching these errors can make debugging harder, as other places in the code may raise the errors. This could silence some serious issues in your app that are not necessarily related to the place you rescue them.&lt;/p&gt;
&lt;h3 id=&quot;use-activerecords-default-rollback-error-wisely&quot;&gt;Use ActiveRecord&amp;#39;s Default Rollback Error Wisely&lt;/h3&gt;
&lt;p&gt;ActiveRecord provides a particular error class that you can use inside a transaction to make a silent rollback. You roll back the transaction by raising the &lt;code&gt;ActiveRecord::Rollback&lt;/code&gt; error, but the error isn&amp;#39;t raised outside, as happens with other errors. Keep this behavior in mind and use it wisely.&lt;/p&gt;
&lt;h2 id=&quot;3-know-when-to-avoid-using-transactions-in-rails&quot;&gt;3. Know When to Avoid Using Transactions in Rails&lt;/h2&gt;
&lt;p&gt;As with anything, you should not overuse transactions in your code. For example, a common mistake is to wrap only one query into your transaction. This does not make sense because, if the query doesn&amp;#39;t succeed, there is no need to roll back anything.&lt;/p&gt;
&lt;p&gt;Another common mistake is to wrap code unrelated to your database call into a transaction. You should avoid such an approach, as the transaction will hold the connection unless the code inside the block executes. Limit the code inside the block to call only your database, if possible.&lt;/p&gt;
&lt;h2 id=&quot;4-understand-the-disadvantages-of-transactions&quot;&gt;4. Understand the Disadvantages of Transactions&lt;/h2&gt;
&lt;p&gt;Transactions help maintain data integrity inside a database, but you should also be aware of their disadvantages. For example, queries wrapped in a transaction block take more DB resources than single queries.&lt;/p&gt;
&lt;p&gt;Another drawback of using transactions is that it leads to more complex code. Transactions can make your code less readable when used incorrectly.&lt;/p&gt;
&lt;h2 id=&quot;5-use-the-transaction-block-in-the-right-context&quot;&gt;5. Use the Transaction Block in the Right Context&lt;/h2&gt;
&lt;p&gt;You can use the transaction method when a class inherits from the &lt;code&gt;ActiveRecord&lt;/code&gt; class. This does not mean that the version you use does not matter. Although it might not matter from a functional perspective, it matters in terms of ensuring your code is readable.&lt;/p&gt;
&lt;p&gt;Three common versions use the transaction method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ActiveRecord::Base.transaction
Model.transaction
Model.new.transaction
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you use many models and mix instance method invocations with classes inside a block, you should use &lt;code&gt;ActiveRecord::Base.transaction&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ActiveRecord::Base.transaction do
  attributes = user.prepare_attributes(account)
  membership = Membership.create(attributes)
  LogService.log_creation(user, membership)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you deal mostly with code that belongs to a given model, invoke the transaction method on a class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.transaction do
  user = User.create!(attributes)
  user.log_activity(‘creation’)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you operate on a model instance, it makes sense to invoke the transaction method on the instance level:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;user.transaction do
  user.make_transaction(attributes)
  user.log_activity(‘transaction’)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, these rules are not official. They are just suggestions to make code more readable.&lt;/p&gt;
&lt;h2 id=&quot;next-steps-review-transactions-in-your-ruby-on-rails-project&quot;&gt;Next Steps: Review Transactions in Your Ruby on Rails Project&lt;/h2&gt;
&lt;p&gt;I hope you&amp;#39;ve found these tips for working with transactions in Ruby on Rails useful.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ve covered the importance of designing Rails transactions properly to improve data integrity and ensure that your processes perform without surprising side effects.&lt;/p&gt;
&lt;p&gt;However, a proper error handling policy isn&amp;#39;t only beneficial when using transactions — it will also improve your whole codebase. Keep that in mind the next time you expect your code to throw some errors.&lt;/p&gt;
&lt;p&gt;Now is an excellent time to review transactions in your Ruby on Rails project design to avoid errors. Design for efficient and reliable communication with your database to make your application more stable.&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>The Perils of Parallel Testing in Ruby on Rails</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/03/16/the-perils-of-parallel-testing-in-ruby-on-rails.html">
    <id>https://blog.appsignal.com/2022/03/16/the-perils-of-parallel-testing-in-ruby-on-rails.html</id>
    <published>2022-03-16T00:00:00+00:00</published>
    <updated>2022-03-16T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Parallel tests can help speed up your tests in Rails, but be aware of the possible pitfalls.</summary>
    <content type="html">&lt;p&gt;Have you ever heard someone complain about their tests being too fast? Me neither.&lt;/p&gt;
&lt;p&gt;Fast tests mean fast feedback. Whether you run them locally or in a continuous integration pipeline,
the earlier your tests finish, the earlier you can react to failures and improve your code. Besides the productivity
gains, it is well known that slow tests make developers grumpy. Nobody likes their developers grumpy.&lt;/p&gt;
&lt;p&gt;With all that said, creating a lightning-fast test suite isn&amp;#39;t always as easy as you&amp;#39;d hope. Luckily, Rails 6 introduced
an exciting feature called &lt;strong&gt;parallel testing&lt;/strong&gt;. It is effortless to get started with and can speed up your tests by a
lot. However, there are some pitfalls to watch out for.&lt;/p&gt;
&lt;h2 id=&quot;what-is-parallel-testing&quot;&gt;What Is Parallel Testing?&lt;/h2&gt;
&lt;p&gt;What does parallel testing even mean?&lt;/p&gt;
&lt;p&gt;When you run a test suite, your test runner will typically spawn a single process to execute your tests one
after the other — or &lt;em&gt;serially&lt;/em&gt;. A single test process uses a single CPU core.
As you can probably imagine, this approach doesn&amp;#39;t take full advantage of modern hardware, which often sports dozens
of CPU cores.&lt;/p&gt;
&lt;p&gt;You may have a fancy MacBook with 10 CPU cores, but sadly, that won&amp;#39;t make your tests go any faster!&lt;/p&gt;
&lt;p&gt;We can change this by distributing individual tests to multiple worker processes. Tests will no longer run after
each other, but next to each other — in &lt;em&gt;parallel&lt;/em&gt;. Running your test suite on two workers is twice as fast
as running the same test suite on a single worker.&lt;/p&gt;
&lt;p&gt;The more cores your machine has, the more worker processes are feasible, and thus, the faster your test suite will
finish. Say your tests usually take eight minutes to run. Running those same tests using four worker processes will
take the runtime down to around two minutes!&lt;/p&gt;
&lt;p&gt;Imagine doing the same on a nice, fat 16 core machine, where we can spawn sixteen workers. Very nice indeed!&lt;/p&gt;
&lt;h2 id=&quot;configuring-parallel-testing-in-rails&quot;&gt;Configuring Parallel Testing in Rails&lt;/h2&gt;
&lt;p&gt;So how do we get there? Until recently, you could use third-party gems to parallelize your test suite, but starting from
Rails 6, parallel tests come standard. It&amp;#39;s as easy as adding &lt;code&gt;parallelize&lt;/code&gt; to your tests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ActiveSupport::TestCase
  parallelize(workers: :number_of_processors)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this configuration, Rails will automatically spawn worker processes based on the number of processors in your
machine. Rails will also create namespaced databases (e.g. &lt;code&gt;database-test-0&lt;/code&gt;, &lt;code&gt;database-test-1&lt;/code&gt;, etc.)
to run your tests against.&lt;/p&gt;
&lt;p&gt;That&amp;#39;s all it takes to get started! Of course, there are some additional configuration options if you need them.&lt;/p&gt;
&lt;p&gt;Sometimes, you may have to perform a specific setup or cleanup for parallel tests. Rails provides two hooks for you
to use — &lt;code&gt;parallelize_setup&lt;/code&gt; and &lt;code&gt;parallelize_teardown&lt;/code&gt;. These are called before and after new worker processes spawn:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ActiveSupport::TestCase
  parallelize_setup do |worker|
    # setup
  end

  parallelize_teardown do |worker|
    # cleanup
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also manually set the number of workers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ActiveSupport::TestCase
  parallelize(workers: 4) # Use 4 worker processes
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, use the &lt;code&gt;PARALLEL_WORKERS&lt;/code&gt; environment variable to override an existing configuration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;PARALLEL_WORKERS=4 rails test
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There is also the option to use threads instead of workers to parallelize your test suite.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ActiveSupport::TestCase
  parallelize(workers: :number_of_processors, with: :threads)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;with: :threads&lt;/code&gt; is the default option when using JRuby or TruffleRuby. Using threads, in theory, provides slightly better
performance. Threads require less overhead than processes, after all. In practice, however, I never found using threads
all too useful, and you should be fine just sticking to process-based parallelization for the most part.&lt;/p&gt;
&lt;h2 id=&quot;beware-the-pitfalls&quot;&gt;Beware the Pitfalls&lt;/h2&gt;
&lt;p&gt;So all you need to do is add &lt;code&gt;parallelize&lt;/code&gt; to your existing tests to experience incredible speedup? It&amp;#39;s that easy!&lt;/p&gt;
&lt;p&gt;If you are lucky, that really is true. It&amp;#39;s more likely that you will hit some unexpected snags when first adding parallelization to your existing test suite. This certainly was the case for me!&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s get one thing out of the way. If you use RSpec rather than Minitest, you are out of luck. RSpec does not
support Rails 6 built-in parallel testing. There is an &lt;a href=&quot;https://github.com/rspec/rspec-rails/issues/2104&quot;&gt;ongoing discussion&lt;/a&gt;
about changing that, but there hasn&amp;#39;t been any significant progress for a while. If you want parallel tests with RSpec,
your best bet is still using third-party gems such as &lt;a href=&quot;https://github.com/grosser/parallel_tests&quot;&gt;grosser/parallel_tests&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Another unexpected issue that you might face is that running a small number of tests in parallel ends up being &lt;em&gt;slower&lt;/em&gt;
then running them serially. Setting up parallel tests comes with a significant overhead — such as creating multiple
databases — which can eliminate any gains you might get from parallelization.&lt;/p&gt;
&lt;p&gt;You might be better off disabling parallel tests for a small number of tests. You can do so by using the
&lt;code&gt;PARALLEL_WORKERS&lt;/code&gt; environment variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;PARALLEL_WORKERS=0 rails test test/controllers/my_controller_test.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rails 7 addressed this by enabling parallel execution only when you execute many tests. So if you&amp;#39;ve already
upgraded, you won&amp;#39;t experience this problem. Per default, the parallelization threshold is set to 50, but you can override
it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;config.active_support.test_parallelization_threshold = 123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last problem I want to highlight is the one you are most likely to face, and it is also the most insidious and hardest
to deal with. You may start seeing random failures when enabling parallel tests for your test suite. To understand how
parallelization can cause this, let&amp;#39;s look at a simple test case:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class FileTest
  def teardown
    File.delete(&amp;#39;test.txt&amp;#39;)
  end

  test &amp;#39;create file&amp;#39; do
    file = File.write(&amp;#39;test.txt&amp;#39;, &amp;#39;created&amp;#39;)

    assert_path_exists(&amp;#39;test.txt&amp;#39;)
  end

  test &amp;#39;delete file&amp;#39; do
    file = File.write(&amp;#39;test.txt&amp;#39;, &amp;#39;deleted&amp;#39;)

    File.delete(&amp;#39;test.txt&amp;#39;)

    assert_not(File.exist?(&amp;#39;test.txt&amp;#39;))
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Besides being a bit useless, this test is perfectly fine. It will pass 100% of the time as long as it&amp;#39;s run serially.
Each test is isolated, and executing these tests in random order does not cause them to fail. That changes when you
add multiple processes or threads to the mix.&lt;/p&gt;
&lt;p&gt;When running tests in parallel, the execution order of individual statements in your tests can get changed up due to
CPU scheduling. Looking at the example, you&amp;#39;ll sometimes see execution orders such as this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Worker 1 executes
file = File.write(&amp;#39;test.txt&amp;#39;, &amp;#39;created&amp;#39;)

# Worker 2 executes
file = File.write(&amp;#39;test.txt&amp;#39;, &amp;#39;deleted&amp;#39;)
File.delete(&amp;#39;test.txt&amp;#39;)
assert_not(File.exist?(&amp;#39;test.txt&amp;#39;))

# Worker 1 executes
assert_path_exists(&amp;#39;test.txt&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since Worker 2 deleted the file before Worker 1&amp;#39;s assertion was executed, the first test will fail — sometimes. To add
insult to injury, a different execution order would sometimes make the second test fail and the first one pass.&lt;/p&gt;
&lt;p&gt;This simple example illustrates an issue that extends not only to files but to any singleton resource that your tests
access in a non-thread-safe way. Suppose you write to a Redis database or an Elasticsearch index. In that case, you&amp;#39;ll likely experience
similar complications. What&amp;#39;s worse, it may take you a while to uncover all tests that cause random failures — and
even more time to fix all of them.&lt;/p&gt;
&lt;p&gt;There is no silver bullet to address flaky parallel tests. In general, you will need to ensure that multiple test processes
do not share resources. For files, use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.5.3/libdoc/tempfile/rdoc/Tempfile.html&quot;&gt;Tempfiles&lt;/a&gt;.
Use &lt;code&gt;parallelize_setup&lt;/code&gt; to create namespaced resources (e.g. Redis databases). And so on.&lt;/p&gt;
&lt;h2 id=&quot;adding-parallel-testing-to-existing-rails-tests&quot;&gt;Adding Parallel Testing to Existing Rails Tests&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s say you struggle with random test failures due to parallelization and don&amp;#39;t have the time to fix them. However, you still
want to reap the benefits of parallel testing. You may prefer to enable it only for a subset of your tests.&lt;/p&gt;
&lt;p&gt;Only tests
that call &lt;code&gt;parallelize&lt;/code&gt; will be parallelized after all, and by using concerns or parent classes, you can add parallel
testing to your test suite one test class at a time. You could create a module like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Parallelize
  def self.included(base)
   base.class_eval do
      parallelize(workers: :number_of_processors)

      # ...
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Any test class that includes this module will now run in parallel:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MyTest &amp;lt; ActiveSupport::TestCase
  include Parallelize
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, you could create a new test class like &lt;code&gt;ParallelTest&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ParallelTest &amp;lt; ActiveSupport::TestCase
  parallelize(workers: :number_of_processors)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, inherit from that for tests that should run in parallel — and leave out those that prove problematic.&lt;/p&gt;
&lt;h2 id=&quot;parallel-testing-as-a-bandaid&quot;&gt;Parallel Testing as a Bandaid&lt;/h2&gt;
&lt;p&gt;Parallel testing provides impressive speed gains for little effort. Don&amp;#39;t be fooled, though: it is no substitute for other
approaches to improve your test suites&amp;#39; speed, but rather an addition.&lt;/p&gt;
&lt;p&gt;If you find your test suite is slow and can spare the effort, spend some time profiling it and addressing
the root cause/s for the slowness. A slow test suite with parallel testing added to it will get faster, but never as fast as an already
fast test suite that also runs in parallel!&lt;/p&gt;
&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap Up&lt;/h2&gt;
&lt;p&gt;In this post, we looked at what
parallel testing is, how you can set it up and how to configure it. If you need a way to make your tests go faster, parallel testing provides just that.&lt;/p&gt;
&lt;p&gt;You might face some obstacles when adding parallel testing to your test suite. Don&amp;#39;t be surprised when tests that ran
stable for years suddenly start failing. You can work around them by parallelizing only a subset of your test suite.&lt;/p&gt;
&lt;p&gt;No matter which approach you choose, parallel testing is a fantastic tool to speed up your tests!&lt;/p&gt;
&lt;p&gt;Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Import Maps Under the Hood in Rails 7</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/03/02/import-maps-under-the-hood-in-rails-7.html">
    <id>https://blog.appsignal.com/2022/03/02/import-maps-under-the-hood-in-rails-7.html</id>
    <published>2022-03-02T00:00:00+00:00</published>
    <updated>2022-03-02T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Learn how to install JavaScript libraries with import maps and how import maps work under the hood in Rails 7.</summary>
    <content type="html">&lt;p&gt;Import maps is the new feature in Rails 7 that allows us to say goodbye to Node.js and tools like Webpack. There&amp;#39;s no need for bundling anymore. With this new mechanism, you can still manage your JavaScript libraries with a specific version. Instead of one big file, though, your application serves many small JavaScript files.&lt;/p&gt;
&lt;p&gt;It’s essential you know how import maps work to benefit from the newest version of Rails (but don’t worry, you can still use tools like Webpack instead). However, it’s also worth discovering what is happening under the hood. This way, you can better understand the journey from installing a JavaScript library in your project to serving its content to your users.&lt;/p&gt;
&lt;p&gt;This article will show you how to install, serve, and uninstall JavaScript libraries with import maps and what happens under the hood during each phase.&lt;/p&gt;
&lt;h2 id=&quot;the-core-of-import-maps&quot;&gt;The Core of Import Maps&lt;/h2&gt;
&lt;p&gt;The feature itself is not complicated. However, before I show you what happens inside the library, I would like to introduce the JSPM tool. JSPM is a shortcut for JavaScript Package Management. Thanks to this tool, you can load any NPM package inside the browser without extra tooling, and it will be fully optimized.&lt;/p&gt;
&lt;p&gt;Rails uses JSPM to serve JavaScript libraries in your application. You can either download the source files to the vendor directory or serve the code directly from the URL.&lt;/p&gt;
&lt;p&gt;For example, to access the jQuery library, you can call &lt;a href=&quot;https://api.jspm.io/generate?install=jquery&quot;&gt;https://api.jspm.io/generate?install=jquery&lt;/a&gt; URL in your browser, and you will receive the URL to the minified source code in the JSON response. Of course, the service provides some more options for requests, but this knowledge is enough to understand how Rails cooperates with JSPM in the import maps library.&lt;/p&gt;
&lt;h2 id=&quot;install-import-maps-in-your-rails-project&quot;&gt;Install Import Maps in Your Rails Project&lt;/h2&gt;
&lt;p&gt;The import maps feature is available in Rails as a Ruby gem. If you generate a new project with Rails 7, it’s included in the Gemfile by default. You can add it to existing projects by executing the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bundle add importmap-rails
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once you have the gem installed, you have to generate the required files by using the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./bin/rails importmap:install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What does this command do, exactly? First, it calls the install rake task included in the importmap namespace. The gem delivers the rake task. Inside the task, the standard rails rake task is executed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;system &amp;quot;#{RbConfig.ruby} ./bin/rails app:template LOCATION=#{File.expand_path(&amp;quot;../install/install.rb&amp;quot;,  __dir__)}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;install.rb&lt;/code&gt; file does a few things in the following order:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Adds helper to the layout in the head section&lt;/strong&gt; - if the &lt;code&gt;application.html.erb&lt;/code&gt; layout exists in your project, it adds the &lt;code&gt;javascript_importmap_tags&lt;/code&gt; line before the closing &lt;code&gt;&amp;lt;/head&amp;gt;&lt;/code&gt; tag. This helper includes JavaScript libraries pinned by import maps. If your project does not include the standard layout file, it will render the information about the helper so you can add it by yourself.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Creates app/javascript/application.js file&lt;/strong&gt; - it adds the comment about import maps to let you know that there is a new place where you should define dependencies.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Creates vendor/javascript directory&lt;/strong&gt; - this is where JavaScript libraries will be stored if they are not served directly via a URL.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Updates sprockets manifest, if it exists&lt;/strong&gt; - sprockets needs to know about the JavaScript files placed inside the &lt;code&gt;vendor/javascript&lt;/code&gt; directory.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Creates config/importmap.rb file&lt;/strong&gt; - this will contain the list of libraries used by Rails (something like package.json file).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Copies bin/importmap file and sets the correct permission to execute it&lt;/strong&gt; - this file is used to pin and unpin specific libraries.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;As soon as this process finishes, you are ready to install JavaScript libraries using the &lt;code&gt;./bin/importmap&lt;/code&gt; file, and Rails is prepared to serve those files to your visitors.&lt;/p&gt;
&lt;h2 id=&quot;adding-libraries-to-your-rails-project&quot;&gt;Adding Libraries to Your Rails Project&lt;/h2&gt;
&lt;p&gt;When installing a library with import maps, you have two options: you can either use the code directly from the CDN URL or download the file and serve it directly from your server.&lt;/p&gt;
&lt;p&gt;Let’s explore the CDN option first.&lt;/p&gt;
&lt;h3 id=&quot;using-npm-packages-via-javascript-cdns&quot;&gt;Using NPM Packages via JavaScript CDN’s&lt;/h3&gt;
&lt;p&gt;It all starts with the pin command and the library name:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./bin/importmap pin jquery
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You pass two arguments to the program located inside the &lt;code&gt;./bin/importmap&lt;/code&gt; file. &lt;code&gt;importmap&lt;/code&gt; is an executable file that loads a &lt;code&gt;config/application.rb&lt;/code&gt; file from your project and the import maps commands file.&lt;/p&gt;
&lt;p&gt;Import maps use the Thor gem to handle command line programs gently. The first argument, pin, is the command name. When you invoke it, the following things happen under the hood:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Request to JSPM API is executed&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As I mentioned before, the gem uses JSPM to get the contents of the package into our application. Therefore, the very first step is the request URL formation. Without any extra parameters passed to the pin command, the request URL is &lt;a href=&quot;https://api.jspm.io/generate&quot;&gt;https://api.jspm.io/generate&lt;/a&gt; with the following parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;install&lt;/code&gt; - [&amp;quot;jquery&amp;quot;] - the param is an array because you can install multiple packages simultaneously.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flattenScope&lt;/code&gt; - true - with this param set to &lt;code&gt;true&lt;/code&gt;, the returned import map format will be more straightforward without scopes, if possible.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;env&lt;/code&gt; - [&amp;quot;browser&amp;quot;, &amp;quot;module&amp;quot;, &amp;quot;production&amp;quot;] - this is the list of environment condition strings.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;provider&lt;/code&gt; - &amp;quot;jspm&amp;quot; - besides JSPM, Skypack, JSdelivr, and Unpkg providers are available to use as well.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Try accessing &lt;a href=&quot;https://api.jspm.io/generate?install=jquery&amp;amp;flattenScope=true&quot;&gt;https://api.jspm.io/generate?install=jquery&amp;amp;flattenScope=true&lt;/a&gt; in your browser, and you will get a simple JSON response with some simple attributes.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Response from JSPM is parsed&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Parsing is a very straightforward phase. As you saw, the response is simple, and all we need is the library name and CDN URL. The &lt;code&gt;Packager&lt;/code&gt; class is responsible for parsing the response in the import map library. Instead of returning the attributes, it returns a complete line that you can use directly in the config:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;%(pin &amp;quot;#{package}&amp;quot;, to: &amp;quot;#{url}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are not yet familiar with &lt;code&gt;%()&lt;/code&gt;, don’t worry, as it works almost the same as the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;quot;pin \&amp;quot;#{package}\&amp;quot;, to: \&amp;quot;#{url}\&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The only difference is that the &lt;code&gt;%()&lt;/code&gt; notation escapes the double quotes automatically. The generated config line passes to another function that handles the config file update process.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Import map config is updated&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The last step is to update the config file with the pin definition. Because the previous pin definition can be present, the gem first verifies the config file and searches for the existing library definition. It’s simple to do with the regex:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;/^pin &amp;quot;#{package}&amp;quot;.*$/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the pin definition for the given package is present, the gem replaces the line with the new definition. If the previous definition is not present, the gem adds a new line at the end of the &lt;code&gt;config/importmap.rb&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: When you use this method, keep in mind that this option is free, but one person supported by the community manages the JSPM servers. This situation could change in the future, so I advise you to store libraries locally if you plan to use import maps with production-ready applications.&lt;/p&gt;
&lt;h3 id=&quot;downloading-npm-packages&quot;&gt;Downloading NPM Packages&lt;/h3&gt;
&lt;p&gt;If you don’t want to use source code from a CDN URL, you can download the library to the &lt;code&gt;vendor&lt;/code&gt; directory inside your application. In this case, the process is very similar to the case with CDN URLs. What&amp;#39;s different is that the code is downloaded into a .js file before the config line is returned for an update.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;The download process&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The download process consists of a few small steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The gem calls &lt;code&gt;FileUtils.mkdir_p&lt;/code&gt;, which creates the &lt;code&gt;vendor&lt;/code&gt; directory if it does not already exist.&lt;/li&gt;
&lt;li&gt;The gem calls &lt;code&gt;FileUtils.rm_rf&lt;/code&gt; to remove the previous package file if it exists.&lt;/li&gt;
&lt;li&gt;The gem saves JS code located under the JSPM-provided URL into the .js file and places it into the &lt;code&gt;vendor&lt;/code&gt; directory.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If the gem cannot download the package’s contents, you will be notified by a proper error raised in your command line.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Config line generation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If the package is named the same as the file with the package source, the config line is straightforward:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;%(pin &amp;quot;#{package}&amp;quot; # #{version})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Otherwise, the import map needs to map the package name to the file directly:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;%(pin &amp;quot;#{package}&amp;quot;, to: &amp;quot;#{filename}&amp;quot; # #{version})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When the config line is formatted and returned, the config is updated with the package definition (as described in the CDN URL version above).&lt;/p&gt;
&lt;h2 id=&quot;using-pinned-packages-in-your-rails-app&quot;&gt;Using Pinned Packages in Your Rails App&lt;/h2&gt;
&lt;p&gt;The gem extensively uses the Rails engine mechanism to deliver features. The &lt;code&gt;Importmap::Engine&lt;/code&gt; defines a bunch of initializers that perform the configuration.&lt;/p&gt;
&lt;h3 id=&quot;import-pinned-packages-from-configimportmaprb&quot;&gt;Import Pinned Packages from config/importmap.rb&lt;/h3&gt;
&lt;p&gt;The configuration lines inside the config/importmap.rb file are replaced with references inside the application. First, the gem collects all definitions into a hash where the &lt;code&gt;Struct&lt;/code&gt; object represents each definition to make it easier to access specific attributes.&lt;/p&gt;
&lt;p&gt;You can call &lt;code&gt;Rails.application.importmap.packages&lt;/code&gt; to access the hash with all definitions inside the application.&lt;/p&gt;
&lt;h3 id=&quot;including-references-to-packages-inside-views&quot;&gt;Including References to Packages inside Views&lt;/h3&gt;
&lt;p&gt;When pinned packages are imported, you can include them in your views to provide the code. The gem provides a &lt;code&gt;javascript_importmap_tags&lt;/code&gt; helper, which you can simply render in your layout. It uses &lt;code&gt;Rails.application.importmap&lt;/code&gt; to generate JSON output for all pinned libraries, and with the usage of &lt;code&gt;asset_helper&lt;/code&gt; in Rails, it provides the correct paths to the libraries.&lt;/p&gt;
&lt;p&gt;After adding the following line to your &lt;code&gt;head&lt;/code&gt; section of the layout:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;%= javascript_importmap_tags %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will get the following output (assuming that you are only using jQuery):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script type=&amp;quot;importmap&amp;quot; data-turbo-track=&amp;quot;reload&amp;quot;&amp;gt;
  {
    &amp;quot;imports&amp;quot;: {
      &amp;quot;application&amp;quot;: &amp;quot;/assets/application-37f365cbecf1fa2810a8303f4b6571676fa1f9c56c248528bc14ddb857531b95.js&amp;quot;,
      &amp;quot;jquery&amp;quot;: &amp;quot;https://ga.jspm.io/npm:jquery@3.6.0/dist/jquery.js&amp;quot;
    }
  }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;handling-import-maps-by-browser&quot;&gt;Handling Import Maps by Browser&lt;/h3&gt;
&lt;p&gt;From that moment on, the browser handles the rest. If you are not familiar with the &lt;code&gt;importmap&lt;/code&gt; script type, let me explain it quickly.&lt;/p&gt;
&lt;p&gt;Import map simply controls what is fetched when you use the following statement inside your JavaScript code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import &amp;quot;jquery&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;removing-pinned-packages&quot;&gt;Removing Pinned Packages&lt;/h2&gt;
&lt;p&gt;To remove a pinned package, you have to execute the unpin command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;./bin/importmap unpin react
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You don’t have to pass the &lt;code&gt;--download&lt;/code&gt; parameter because the gem will automatically delete any files related to the package. The removal process consists of three steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Request to the JSPM API&lt;/strong&gt; - the same request is executed when the package is added. The gem does this to get up-to-date package information.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Removal of the existing package files&lt;/strong&gt; - the gem uses &lt;code&gt;FileUtils.rm_rf&lt;/code&gt; to remove all related files even if they are placed in directories.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Remove the config lines related to the package&lt;/strong&gt; - with the usage of &lt;code&gt;File.readlines&lt;/code&gt;, the gem loads all lines from the config file, selects those that do not contain anything related to the removed package and saves them again in the config file. Simple as that.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also unpin multiple packages at once; just add their names after the &lt;code&gt;unpin&lt;/code&gt; argument.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up&quot;&gt;Wrap Up&lt;/h2&gt;
&lt;p&gt;We&amp;#39;ve reached the end of this short, yet valuable, journey. You now know that import maps is just a different way of loading JavaScript libraries in your web application. Instead of one big bundled file, you serve multiple smaller files that are easy to cache and control.&lt;/p&gt;
&lt;p&gt;With the &lt;code&gt;importmap-rails&lt;/code&gt; gem, it’s easy to adapt import maps in your project. The gem ships with a simple configuration file and command-line interface to install and remove packages using the JSPM.&lt;/p&gt;
&lt;p&gt;Should you use import maps in your next Rails project? As always, it depends. The good thing is that you are not limited to import maps — you can always switch between it, Webpack, and similar, more complex tools.&lt;/p&gt;
&lt;p&gt;Thanks for reading and happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Delayed Job vs. Sidekiq: Which Is Better?</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/02/15/delayed-job-vs-sidekiq-which-is-better.html">
    <id>https://blog.appsignal.com/2022/02/15/delayed-job-vs-sidekiq-which-is-better.html</id>
    <published>2022-02-15T00:00:00+00:00</published>
    <updated>2022-02-15T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's take a look at the pros and cons of Delayed Job and Sidekiq, two major job processing systems for Rails apps.</summary>
    <content type="html">&lt;p&gt;Most applications need background jobs for mailers, regular clean-ups, or any other time-consuming operation that doesn&amp;#39;t require a user to be present.&lt;/p&gt;
&lt;p&gt;Several gems support job queues and background processing in the Rails world — &lt;a href=&quot;https://github.com/collectiveidea/delayed_job&quot;&gt;Delayed Job&lt;/a&gt; and &lt;a href=&quot;https://github.com/mperham/sidekiq&quot;&gt;Sidekiq&lt;/a&gt; being the two most popular ones.&lt;/p&gt;
&lt;p&gt;In this post, we will take a detailed look at Delayed Job and Sidekiq, including how they fare against each other.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s go!&lt;/p&gt;
&lt;h2 id=&quot;a-quick-introduction-to-delayed-job&quot;&gt;A Quick Introduction to Delayed Job&lt;/h2&gt;
&lt;p&gt;Delayed Job is a direct extraction from Shopify and uses a table to maintain all background jobs.
It follows a very simple pattern. Any Ruby object that responds to a &lt;code&gt;perform&lt;/code&gt; method can be enqueued in the jobs table.&lt;/p&gt;
&lt;p&gt;In addition, if you don&amp;#39;t need to maintain special job objects (although this is highly recommended for testability and clear separation of long-running operations), it also allows you to call &lt;code&gt;.delay.method(params)&lt;/code&gt; on any Ruby object. It will process the method in the background.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/collectiveidea/delayed_job#queuing-jobs&quot;&gt;Delayed Job README&lt;/a&gt; does a great job of explaining all common usage patterns.&lt;/p&gt;
&lt;p&gt;Many teams choose Delayed Job because it is simple and uses their already existing database. They don&amp;#39;t need to spend/maintain other resources.&lt;/p&gt;
&lt;p&gt;However, it will still take up space in your database table. If you have too many jobs queued at the same time, you might need more disk space to accommodate them all.&lt;/p&gt;
&lt;h2 id=&quot;a-quick-introduction-to-sidekiq&quot;&gt;A Quick Introduction to Sidekiq&lt;/h2&gt;
&lt;p&gt;Sidekiq, on the other hand, uses Redis as its data store to maintain all job metadata.
This comes with the obvious benefit of being much faster than the regular database systems Delayed Jobs uses.
In addition to this, each Sidekiq process spawns multiple threads to process the jobs even faster.&lt;/p&gt;
&lt;p&gt;For each background job in Sidekiq, we need a specialized class that includes the &lt;code&gt;Sidekiq::Worker&lt;/code&gt; concern and responds to the &lt;code&gt;perform&lt;/code&gt; method.
To enqueue the job, we need to call &lt;code&gt;perform_async(arg1, arg2)&lt;/code&gt; on the worker with the arguments.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/mperham/sidekiq/wiki/Getting-Started&quot;&gt;Sidekiq &amp;#39;Getting Started&amp;#39; guide&lt;/a&gt; explains this and other usage patterns in good detail.&lt;/p&gt;
&lt;h2 id=&quot;using-active-job-with-delayed-job-or-sidekiq&quot;&gt;Using Active Job with Delayed Job or Sidekiq&lt;/h2&gt;
&lt;p&gt;Rails already provides a mature job framework for top-level declaration and handling of jobs.
Both Delayed Job and Sidekiq support running jobs through ActiveJob&amp;#39;s unified API.
Just inherit from &lt;code&gt;ApplicationJob&lt;/code&gt; and call &lt;code&gt;perform_later&lt;/code&gt; on your job class to enqueue the job to the configured queuing backend.&lt;/p&gt;
&lt;p&gt;The advantage of running jobs with Active Job is that your application code becomes framework agnostic, and switching from Delayed Job to Sidekiq (or vice versa) becomes pretty easy. The &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveJob/TestHelper.html&quot;&gt;&lt;code&gt;ActiveJob::TestHelper&lt;/code&gt;&lt;/a&gt; also makes testing enqueued jobs a breeze.&lt;/p&gt;
&lt;p&gt;But the abstraction provided by Active Job also comes with a performance overhead, as job data has to be wrapped before it&amp;#39;s pushed to the store.
Sidekiq claims that ActiveJob is about 2-20x slower when pushing to Redis, with ~3x the processing overhead.&lt;/p&gt;
&lt;h2 id=&quot;delayed-jobs-vs-sidekiq&quot;&gt;Delayed Jobs vs. Sidekiq&lt;/h2&gt;
&lt;p&gt;Now that we know the basics of Delayed Jobs and Sidekiq, let&amp;#39;s dive deeper into their differences and what each brings to the table.&lt;/p&gt;
&lt;h3 id=&quot;the-features&quot;&gt;The Features&lt;/h3&gt;
&lt;p&gt;For basic applications, both Sidekiq and Delayed Job provide a good set of features out of the box.
These include assigning job priorities, named queues, and auto-retry on failures.&lt;/p&gt;
&lt;p&gt;Delayed Job also provides a way to configure max run time out of the box (Sidekiq does not).&lt;/p&gt;
&lt;p&gt;Sidekiq, on the other hand, provides support for &lt;a href=&quot;https://github.com/mperham/sidekiq/wiki/Middleware&quot;&gt;Middleware&lt;/a&gt; to update job metadata, skip queuing a job, or execute a job.
Sidekiq supports more callbacks, though &lt;a href=&quot;https://github.com/collectiveidea/delayed_job/#hooks&quot;&gt;some hooks are available for Delayed Job apps&lt;/a&gt;. Instead of callbacks, you can use Delayed Job with Active Job (namely, the &lt;code&gt;before_enqueue&lt;/code&gt; and &lt;code&gt;around_perform&lt;/code&gt; callbacks inbuilt into Rails).&lt;/p&gt;
&lt;p&gt;Web UI is another feature that comes out of the box with Sidekiq.
This provides historical statistics about jobs and information about workers, currently enqueued and dead jobs.
You can perform operations like deleting or running jobs immediately without going through the console.&lt;/p&gt;
&lt;p&gt;Delayed Job does not have an inbuilt Web UI, but &lt;a href=&quot;https://github.com/ejschmitt/delayed_job_web&quot;&gt;&lt;code&gt;delayed_job_web&lt;/code&gt;&lt;/a&gt; gives access to a basic Web UI with similar features to Sidekiq&amp;#39;s.&lt;/p&gt;
&lt;h3 id=&quot;sidekiq-wins-at-performance&quot;&gt;Sidekiq Wins at Performance&lt;/h3&gt;
&lt;p&gt;Performance-wise, Sidekiq beats Delayed Job quite convincingly.
According to &lt;a href=&quot;https://github.com/mperham/sidekiq#performance&quot;&gt;Sidekiq&amp;#39;s open-source benchmark&lt;/a&gt;, it is approximately 30x faster than Delayed Job.
There are two major reasons for this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Redis is much faster at querying data than traditional databases like Postgres because it stores data in memory as opposed to the disk.&lt;/li&gt;
&lt;li&gt;Delayed Job runs a single thread to process jobs, compared to Sidekiq, which uses multiple threads.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;While all of this looks great on paper, the differences do not matter much unless you work on a big scale (something like 10k jobs per minute).
The exact number also depends on the average run time of a job. The longer the run time, the less the performance overhead of Delayed Job matters.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;re worried about the performance of Delayed Job, you can make some performance optimizations.
The exact indexes to use will depend on the statistics of your job system.
For example, if you use multiple queues and only one gets a major chunk of jobs, a simple index on the queue column (&lt;code&gt;add_index :delayed_jobs, :queue&lt;/code&gt;) can significantly improve performance.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In AppSignal, &lt;a href=&quot;https://www.appsignal.com/ruby/sidekiq-monitoring&quot;&gt;Sidekiq magic dashboard&lt;/a&gt; gets automatically generated and it enables you to monitor queue length, queue latency, job duration, job statuses, memory usage, etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-02/sidekiq-dashboard.png&quot; alt=&quot;Sidekiq&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;deployment&quot;&gt;Deployment&lt;/h3&gt;
&lt;p&gt;Both Delayed Job and Sidekiq have a similar deployment strategy for workers.
Using Heroku, you just need to add entries inside your &lt;code&gt;Procfile&lt;/code&gt; to start the job processor and run the workers.&lt;/p&gt;
&lt;p&gt;For Sidekiq:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;worker: bundle exec sidekiq -t 25 -c ${SIDEKIQ_CONCURRENCY:-5} [-q name,priority [-q another_queue,another_priority]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For Delayed Job:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;worker: [QUEUE=x,y,z] bundle exec rails jobs:work
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;memory&quot;&gt;Memory&lt;/h3&gt;
&lt;p&gt;Here&amp;#39;s where things start to get a bit more interesting. Sidekiq has a concurrency option to control how many threads it runs.
Most of the Sidekiq vs. Delayed Job benchmarks mention Sidekiq&amp;#39;s very high concurrency of up to 25 threads, which contributes to its super-fast performance.&lt;/p&gt;
&lt;p&gt;But in a real setting, you have to limit the threads to something more conservative.
The actual number depends on how heavy your application is and what kinds of jobs you perform.
What I have seen in practice is that if you run a worker on 512MB memory (equivalent to &lt;code&gt;standard-1x&lt;/code&gt; on Heroku), the number of threads is somewhere between 2 and 5 instead of 25.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.mikeperham.com/2018/04/25/taming-rails-memory-bloat/&quot;&gt;&amp;#39;Taming Rails memory bloat&amp;#39; by Mike Perham&lt;/a&gt;, the creator of Sidekiq, discusses memory issues in more detail and is well worth a read.
I won&amp;#39;t jump into the full discussion, but he recommends that you set &lt;code&gt;MALLOC_ARENA_MAX=2&lt;/code&gt; on all workers that run Sidekiq.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;jemalloc&lt;/code&gt; instead of regular &lt;code&gt;malloc&lt;/code&gt; helps too. The exact way to do this depends on the platform you use, but it is pretty simple on Heroku. Just set &lt;a href=&quot;https://github.com/gaffneyc/heroku-buildpack-jemalloc.git&quot;&gt;heroku-buildpack-jemalloc&lt;/a&gt; as the first buildpack (ahead of the &lt;code&gt;heroku/ruby&lt;/code&gt; buildpack).&lt;/p&gt;
&lt;h3 id=&quot;delayed-job-uses-simpler-resources&quot;&gt;Delayed Job Uses Simpler Resources&lt;/h3&gt;
&lt;p&gt;As we discussed, Delayed Job runs on your existing database instance.
You might need to increase:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the available memory&lt;/li&gt;
&lt;li&gt;disk space&lt;/li&gt;
&lt;li&gt;max connections&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;depending on the job load or the number of workers you run. But the only resource you need is the job processor.&lt;/p&gt;
&lt;p&gt;On the other hand, Sidekiq requires a Redis instance to handle jobs.
If you also use Redis as a cache store, it is recommended that you use a separate instance configured as a &amp;quot;persistent store&amp;quot; for Sidekiq jobs.&lt;/p&gt;
&lt;p&gt;Since Redis works best when everything fits in memory, if you have too many jobs (for example, if Sidekiq stops processing them for some time due to an issue in the app), it might take some downtime to clear everything up.
This is especially troublesome if you have Redis on the same server as your app.
They will start competing for memory, leading to swapping and eventually destroying your app&amp;#39;s performance.&lt;/p&gt;
&lt;p&gt;One important point to note about Redis is that it has to be configured with &lt;code&gt;maxmemory-policy noeviction&lt;/code&gt; to avoid silent drops of Sidekiq&amp;#39;s data.
Otherwise, you will find yourself missing jobs that need to be performed, without any trace.&lt;/p&gt;
&lt;h4 id=&quot;a-side-note-paid-upgrades-in-sidekiq&quot;&gt;A Side-Note: Paid Upgrades in Sidekiq&lt;/h4&gt;
&lt;p&gt;If you need extra features, Sidekiq comes with &lt;code&gt;Pro&lt;/code&gt; and &lt;code&gt;Enterprise&lt;/code&gt; versions.&lt;/p&gt;
&lt;p&gt;The most notable addition to Pro is &lt;code&gt;Batch Jobs&lt;/code&gt; that can run in parallel, be monitored, and interact as a group, invoking a callback when all jobs are done. Pro also has improved reliability features to ensure that no jobs are dropped silently, even during network problems.&lt;/p&gt;
&lt;p&gt;The Enterprise version comes with yet more features. If you are looking for something that a regular Sidekiq installation can&amp;#39;t solve, &lt;a href=&quot;https://sidekiq.org/&quot;&gt;explore the paid Sidekiq features&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In practice, the free version of Sidekiq still works great.
But it is good to know that there are paid options you can upgrade to as needed, instead of switching to a different solution.&lt;/p&gt;
&lt;h3 id=&quot;community-and-development-status-sidekiq-has-the-edge&quot;&gt;Community and Development Status: Sidekiq Has the Edge&lt;/h3&gt;
&lt;p&gt;There is a huge community behind both Sidekiq and Delayed Job. However, it is not always easy to find quick answers to your questions in StackOverflow or the official documentation.&lt;/p&gt;
&lt;p&gt;On the development side, things are not looking very bright for Delayed Job.
There was some minor work done on Delayed Job in December 2021 and January 2022, but it doesn&amp;#39;t seem like it is getting any major developments going forward. It appears to be in maintenance-only mode, and there are a lot of open issues on Github.&lt;/p&gt;
&lt;p&gt;In contrast, Sidekiq is still under active development, and its creator is working full time on it.
There are very few open issues, and they get addressed regularly.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-sidekiq-or-delayed-job-it-depends-on-your-needs&quot;&gt;Wrap-up: Sidekiq or Delayed Job? It Depends on Your Needs&lt;/h2&gt;
&lt;p&gt;In this post, we covered two major job processing systems for Rails applications — Sidekiq and Delayed Job — taking a look at some of their pros and cons.&lt;/p&gt;
&lt;p&gt;There are different use cases for each. It all depends on the budget and scale of your operation.&lt;/p&gt;
&lt;p&gt;If performance and long-term maintainability are of importance, Sidekiq is a no-brainer.
On the other hand, if running costs are a concern, Delayed Job can help you there.&lt;/p&gt;
&lt;p&gt;Whether you choose Delayed Job or Sidekiq, good luck with your project and happy coding!&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;👋 If you liked this article, take a look at other Ruby (on Rails) performance articles in our &lt;a href=&quot;https://www.appsignal.com/ruby#ruby-monitoring-checklist&quot;&gt;Ruby performance monitoring checklist&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Test and Optimize Your Ruby on Rails Database Performance</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/01/26/test-and-optimize-your-ruby-on-rails-database-performance.html">
    <id>https://blog.appsignal.com/2022/01/26/test-and-optimize-your-ruby-on-rails-database-performance.html</id>
    <published>2022-01-26T00:00:00+00:00</published>
    <updated>2022-01-26T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Explore three common ways to discover and test database performance problems in Rails, and seven ways to optimize performance.</summary>
    <content type="html">&lt;p&gt;In this article, you will learn how to test database performance in Rails and solve some of the most common database performance issues.&lt;/p&gt;
&lt;p&gt;When you develop a Rails application, ActiveRecord is the default tool that manages your database. ActiveRecord provides an easy and fast interface to query and insert data using commands like &lt;code&gt;.where&lt;/code&gt;, &lt;code&gt;.save&lt;/code&gt;, &lt;code&gt;.create&lt;/code&gt;, and &lt;code&gt;.update&lt;/code&gt;. Rails does the work of converting these commands to SQL queries, which is a good thing, but sometimes can cause performance issues. It is important that you understand some of the common issues and how to optimize performance.&lt;/p&gt;
&lt;h2 id=&quot;a-quick-note-on-activerecord-in-ruby-on-rails&quot;&gt;A Quick Note on ActiveRecord in Ruby on Rails&lt;/h2&gt;
&lt;p&gt;Rails ActiveRecord is a layer in Model-View-Controller (MVC) that manages your database by representing it as a business object. The ActiveRecord pattern uses the ORM technique to connect objects of an application to the relational database table management system.&lt;/p&gt;
&lt;p&gt;Now, let&amp;#39;s get going!&lt;/p&gt;
&lt;h2 id=&quot;3-ways-to-identify-and-test-database-performance-issues-in-rails&quot;&gt;3 Ways to Identify and Test Database Performance Issues in Rails&lt;/h2&gt;
&lt;h3 id=&quot;1-run-explain-on-activerecord-queries&quot;&gt;1. Run Explain on ActiveRecord Queries&lt;/h3&gt;
&lt;p&gt;An explain statement displays information about the execution plan of an SQL query - how a query will be executed, including how many rows will be scanned, what index will be used, and how tables are joined.&lt;/p&gt;
&lt;p&gt;The execution plan helps us figure out what slows down query execution by looking at:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What index you should add to improve the performance of a query.&lt;/li&gt;
&lt;li&gt;If tables are joined in an optimal order. You can use &lt;code&gt;STRAIGHT_JOIN&lt;/code&gt; to force table order in a join statement for better performance.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Explain works on SELECT, DELETE, INSERT, REPLACE and UPDATE statements as well.&lt;/p&gt;
&lt;p&gt;Using explain with ActiveRecord is very straightforward. Enter the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;2.4.2 :004 &amp;gt; User.where(id: 1).explain

 =&amp;gt; EXPLAIN for: SELECT &amp;quot;users&amp;quot;.* FROM &amp;quot;users&amp;quot; WHERE &amp;quot;users&amp;quot;.&amp;quot;id&amp;quot; = $1 [[&amp;quot;id&amp;quot;, 1]]
                                QUERY PLAN
--------------------------------------------------------------------------
 Index Scan using users_pkey on users  (cost=0.14..8.16 rows=1 width=792)
   Index Cond: (id = 1)
(2 rows)

2.4.2 :005 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Adding &lt;code&gt;.explain&lt;/code&gt; at the end of the command provides the query plan for the ActiveRecord commands. The above example is a very simple query that uses the &lt;code&gt;id&lt;/code&gt; (primary key) to query the table. The output of the &lt;code&gt;explain&lt;/code&gt; statement shows that it is using the &lt;code&gt;pkey&lt;/code&gt;. From this, you can be sure that the statement is optimal and fast.&lt;/p&gt;
&lt;p&gt;You can try adding an &lt;code&gt;.explain&lt;/code&gt; command to your slow queries to uncover the order of execution, along with the index used. If the query plan shows &lt;code&gt;Seq Scan&lt;/code&gt;, the index is not being used and requires a query change or a new index to be added.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s another example with join:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;2.4.2 :062 &amp;gt; User.where(id: 1).joins(:collaborations).explain

 =&amp;gt; EXPLAIN for: SELECT &amp;quot;users&amp;quot;.* FROM &amp;quot;users&amp;quot; INNER JOIN &amp;quot;collaborations&amp;quot; ON &amp;quot;collaborations&amp;quot;.&amp;quot;user_id&amp;quot; = &amp;quot;users&amp;quot;.&amp;quot;uid&amp;quot; WHERE &amp;quot;users&amp;quot;.&amp;quot;id&amp;quot; = $1 [[&amp;quot;id&amp;quot;, 1]]
                                      QUERY PLAN
--------------------------------------------------------------------------------------
 Hash Join  (cost=8.17..27.31 rows=4 width=792)
   Hash Cond: ((collaborations.user_id)::text = (users.uid)::text)
   -&amp;gt;  Seq Scan on collaborations  (cost=0.00..17.20 rows=720 width=32)
   -&amp;gt;  Hash  (cost=8.16..8.16 rows=1 width=792)
         -&amp;gt;  Index Scan using users_pkey on users  (cost=0.14..8.16 rows=1 width=792)
               Index Cond: (id = 1)
(6 rows)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, the user table is joined with the collaborations table. When you look into the query plan, the collaboration table is using &lt;code&gt;seq scan&lt;/code&gt; and is executing first — whereas the user table is using the &lt;code&gt;pkey&lt;/code&gt; index and is executing later. You can add an index on the &lt;code&gt;user_id&lt;/code&gt; column in the collaborations table to optimize this query. Explain helps in breaking down the query, so you can figure out where optimization is needed.&lt;/p&gt;
&lt;h3 id=&quot;2-measure-key-database-metrics&quot;&gt;2. Measure Key Database Metrics&lt;/h3&gt;
&lt;p&gt;Query time is not the only metric to measure to see if a query is performant — look at several other database metrics, including:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU usage&lt;/li&gt;
&lt;li&gt;Memory usage&lt;/li&gt;
&lt;li&gt;Disk queue for waiting IO&lt;/li&gt;
&lt;li&gt;Network bandwidth for inbound and outbound traffic&lt;/li&gt;
&lt;li&gt;Available disk space&lt;/li&gt;
&lt;li&gt;Throughput&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The query may slow down when these metrics go over a certain threshold. You must look at a data point across a time range to understand performance issues.&lt;/p&gt;
&lt;p&gt;The data point that needs to be measured depends on lots of factors, like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The database type:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Relational&lt;/li&gt;
&lt;li&gt;In-memory&lt;/li&gt;
&lt;li&gt;No-SQL&lt;/li&gt;
&lt;li&gt;Data-Warehouse&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;How the server is hosted:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;On-premises&lt;/li&gt;
&lt;li&gt;On the cloud&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There is no single way to monitor database metrics — it depends on different factors.&lt;/p&gt;
&lt;h3 id=&quot;3-measure-rails-app-performance-using-appsignal&quot;&gt;3. Measure Rails App Performance using AppSignal&lt;/h3&gt;
&lt;p&gt;It can get difficult to manage all your performance metrics without a central place that gives you visibility over all queries. Adding performance code to every code block can be cumbersome and unmanageable.&lt;/p&gt;
&lt;p&gt;With tools like AppSignal, you can easily integrate performance measurement into your application. AppSignal supports Rails out of the box. Learn about the simple AppSignal installation process from the &lt;a href=&quot;https://docs.appsignal.com/ruby/&quot;&gt;&amp;#39;AppSignal for Ruby&amp;#39; documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Some of the critical metrics to keep an eye on are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Slow queries&lt;/li&gt;
&lt;li&gt;Database performance based on throughput&lt;/li&gt;
&lt;li&gt;N+1 queries&lt;/li&gt;
&lt;li&gt;Database latency&lt;/li&gt;
&lt;li&gt;Number of active connections&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Here&amp;#39;s how an AppSignal dashboard might look:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-01/dashboard-demo.png&quot; alt=&quot;demo&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;7-ways-to-optimize-ruby-on-rails-database-performance&quot;&gt;7 Ways to Optimize Ruby on Rails Database Performance&lt;/h2&gt;
&lt;h3 id=&quot;1-eager-loading-for-n1-queries&quot;&gt;1. Eager Loading for N+1 Queries&lt;/h3&gt;
&lt;p&gt;N+1 queries are the most common database performance problem. Let us see an example of an &lt;code&gt;N+1&lt;/code&gt; query where you have two models — user and project:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User &amp;lt; ActiveRecord::Base
  has_many :projects
end

class Project &amp;lt; ActiveRecord::Base
  belongs_to :user
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, if you want to find the user and project names, run the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;users = User.where(country: &amp;quot;Germany&amp;quot;)

users.each do |user|
  puts &amp;quot;#{user.name} | #{user.project.name}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The code above will query the database with each loop and cause performance issues. The total number of queries executed will be the number of users + 1.&lt;/p&gt;
&lt;p&gt;Eliminating this issue is very simple: eager load the association. Simply add &lt;code&gt;.includes(:projects)&lt;/code&gt; at the end of the query:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;users = User.where(country: &amp;quot;Germany&amp;quot;).includes(:projects)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, executing the loop will not query the database, as the query above eager loads the projects:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;users.each do |user|
  puts &amp;quot;#{user.name} | #{user.project.name}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rails 6.1 provides &lt;a href=&quot;https://github.com/rails/rails/pull/37400&quot;&gt;strict loading&lt;/a&gt; to ensure that the association is eager loaded before it is accessed. To enable strict loading, add the following line in the model:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User &amp;lt; ApplicationRecord
  has_many :projects, strict_loading: true
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, when you try to access the projects without eager loading, Rails will throw an &lt;code&gt;ActiveRecord::StrictLoadingViolationError&lt;/code&gt; exception.&lt;/p&gt;
&lt;p&gt;If you don&amp;#39;t have Rails 6.1, you can use gems like &lt;a href=&quot;https://github.com/flyerhzm/bullet&quot;&gt;Bullet&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;2-use-a-database-index&quot;&gt;2. Use a Database Index&lt;/h3&gt;
&lt;p&gt;Databases provide indexes to help retrieve data faster. Using the explain command that we covered earlier, you will be able to figure out if a query is using a proper index.&lt;/p&gt;
&lt;p&gt;You can change a slow query to use an already existing index or an added index that helps improve performance.&lt;/p&gt;
&lt;p&gt;There are four different types of indexes in MySQL:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Primary key - Index is automatically added to the primary key, which also ensures that it is unique&lt;/li&gt;
&lt;li&gt;Unique - Unique key index ensures that the items added in an attribute are always unique&lt;/li&gt;
&lt;li&gt;Index - Added to attributes other than the primary key&lt;/li&gt;
&lt;li&gt;Full text - Helps to query against character-based data&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;An index is stored in a &lt;a href=&quot;https://www.geeksforgeeks.org/introduction-of-b-tree-2/&quot;&gt;B-Tree&lt;/a&gt; or a Hash format.&lt;/p&gt;
&lt;p&gt;Indexes can be added to a single field or created as a composition of multiple fields. A composite index is useful to optimize queries that include multiple fields. When only one index is used, it requires a large dataset scan.&lt;/p&gt;
&lt;p&gt;For example, in the following query, there are two fields:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.where(project: &amp;quot;abc&amp;quot;, country: &amp;quot;Germany&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There could be a lot of users in the project &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; and the country field will be scanned. This can be a slow process because of the large result dataset. In this case, you can add a composite index to both the project and country fields to improve performance.&lt;/p&gt;
&lt;p&gt;You can add the index to Rails with the following ActiveRecord migration commands:&lt;/p&gt;
&lt;p&gt;Single index:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class AddIndexOnProjectToUsers &amp;lt; ActiveRecord::Migration[6.0]
  def change
    add_index :users, :project
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Composite index:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class AddIndexOnProjectAndCountryToUsers &amp;lt; ActiveRecord::Migration[6.0]
  def change
    add_index :users, [:project, :country]
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;3-use-limits&quot;&gt;3. Use Limits&lt;/h3&gt;
&lt;p&gt;The more records that are returned, the slower performance can get. It is better to do multiple queries than a single query that returns a large data set.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.where(country: &amp;quot;Germany&amp;quot;).limit(100)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fetch the next 100 batches, you can use the offset:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.where(country: &amp;quot;Germany&amp;quot;).limit(100).offset(100)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will significantly improve performance. One thing to keep in mind is that with a higher offset, a query gets slower. Add a limit to the offset.&lt;/p&gt;
&lt;h3 id=&quot;4-use-find_each-to-load-a-large-number-of-items&quot;&gt;4. Use &lt;code&gt;find_each&lt;/code&gt; To Load a Large Number of Items&lt;/h3&gt;
&lt;p&gt;When iterating over records, batch them in Rails for better performance:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.where(country: &amp;quot;Germany&amp;quot;).each do |user|
  puts user
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will query all the records in the database once and cause memory and database performance issues.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;find_each&lt;/code&gt; or &lt;code&gt;find_in_batches&lt;/code&gt; will help improve performance by doing the same operation in a batch:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.where(country: &amp;quot;Germany&amp;quot;).find_each do |user|
  puts user
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, &lt;code&gt;find_each&lt;/code&gt; queries result in a batch of 1,000. You can change the batch size by defining it as an argument:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.where(country: &amp;quot;Germany&amp;quot;).find_each(:batch_size: 5000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also use &lt;code&gt;find_in_batches&lt;/code&gt; based on the operation you need to perform. The difference between &lt;code&gt;find_in_batches&lt;/code&gt; and &lt;code&gt;find_each&lt;/code&gt; is that &lt;code&gt;find_in_batches&lt;/code&gt; yields the result as an array of models instead of individual records.&lt;/p&gt;
&lt;h3 id=&quot;5-select-your-required-field-using-pluck&quot;&gt;5. Select Your Required Field Using Pluck&lt;/h3&gt;
&lt;p&gt;The Pluck command directly converts a query&amp;#39;s result to an array instead of an ActiveRecord object.&lt;/p&gt;
&lt;p&gt;If a query returns large results, using Pluck will improve code performance. Pluck will only select a required field from a database:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.pluck(:id)
# SELECT &amp;quot;users&amp;quot;.&amp;quot;id&amp;quot; FROM &amp;quot;users&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result is fetched from an index, not the main table, and is more effective with queries involving sorts.&lt;/p&gt;
&lt;h3 id=&quot;6-use-bulk-operations&quot;&gt;6. Use Bulk Operations&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Bulk Delete&lt;/strong&gt;
A delete operation looping over the ActiveRecord object will delete records one at a time:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;users = User.where(country: &amp;quot;Germany&amp;quot;)

users.each do |user|
  user.delete
end

# &amp;gt;
# DELETE FROM users WHERE id = 1;
# DELETE FROM users WHERE id = 5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Deleting each record requires many queries to be made to the database. Instead, it&amp;#39;s optimal to use a single bulk &lt;code&gt;delete_all&lt;/code&gt; query:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;users = User.where(country: &amp;quot;Germany&amp;quot;)

users.delete_all

# &amp;gt;
# DELETE FROM users WHERE users.country = &amp;#39;Germany&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Bulk Create&lt;/strong&gt;
Some people don&amp;#39;t realize that similar to bulk delete, you can also perform a bulk insert with ActiveRecord. This can reduce the &lt;code&gt;n&lt;/code&gt; number of queries to only one. The &lt;code&gt;ActiveRecord::Base&lt;/code&gt; &lt;code&gt;create&lt;/code&gt; method accepts an array of hashes as input:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;users = [
  {name: &amp;quot;Milap&amp;quot;, email: &amp;quot;milap@country.com&amp;quot;, country: &amp;quot;Germany&amp;quot;},
  {name: &amp;quot;Aastha&amp;quot;, email: &amp;quot;aastha@country.com&amp;quot;, country: &amp;quot;Germany&amp;quot;}
]

User.create(users)

# INSERT INTO users (name, email)
# VALUES
#   (&amp;#39;Milap&amp;#39;, &amp;#39;milap@country.com&amp;#39;, &amp;#39;Germany&amp;#39;),
#   (&amp;#39;Aastha&amp;#39;, &amp;#39;aastha@country.com&amp;#39;, &amp;#39;Germany&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;7-use-in-memory-calculation-if-needed&quot;&gt;7. Use In-Memory Calculation if Needed&lt;/h3&gt;
&lt;p&gt;In some instances, an in-memory calculation is preferable to querying. Suppose we want to find countries in our database that do not have a record of users:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;countries = [
  &amp;quot;Germany&amp;quot;,
  &amp;quot;UK&amp;quot;,
  &amp;quot;Norway&amp;quot;,
  &amp;quot;Netherlands&amp;quot;
]

countries.each do |country|
  unless User.where(country: country).exists?
    puts country
  end
end
# SELECT 1 AS one FROM `users` WHERE users`.`country` = &amp;#39;Germany&amp;#39; LIMIT 1
# SELECT 1 AS one FROM `users` WHERE users`.`country` = &amp;#39;UK&amp;#39; LIMIT 1
# SELECT 1 AS one FROM `users` WHERE users`.`country` = &amp;#39;Norway&amp;#39; LIMIT 1
# SELECT 1 AS one FROM `users` WHERE users`.`country` = &amp;#39;Netherlands&amp;#39; LIMIT 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above query required N queries to get the result. Instead of this, we can write a single query to find the users in the given countries and do the other calculation in memory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;existing_countries = User.distinct.pluck(:countries)
puts countries - existing_countries

# SELECT DISTINCT `users`.`countries` FROM `users`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can cache to reuse the request-response cycle and reduce database load in some cases. Rails provides three types of &lt;a href=&quot;https://guides.rubyonrails.org/caching_with_rails.html&quot;&gt;caching&lt;/a&gt; techniques: page, action, and fragment caching (&lt;a href=&quot;https://blog.appsignal.com/2018/03/20/fragment-caching-in-rails.html&quot;&gt;fragment caching&lt;/a&gt; is offered by default).&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-optimize-your-ruby-on-rails-performance-with-activerecord-and-appsignal&quot;&gt;Wrap Up: Optimize Your Ruby on Rails Performance with ActiveRecord and AppSignal&lt;/h2&gt;
&lt;p&gt;Okay, time to recap! In this post, we covered three ways to identify and test database performance issues in Rails by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Running Explain on ActiveRecord queries&lt;/li&gt;
&lt;li&gt;Measuring key database metrics&lt;/li&gt;
&lt;li&gt;Measuring Rails app performance using AppSignal&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And seven ways to optimize your database performance, including the use of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Eager loading for N+1 queries&lt;/li&gt;
&lt;li&gt;A database index&lt;/li&gt;
&lt;li&gt;limits&lt;/li&gt;
&lt;li&gt;&lt;code&gt;find_each&lt;/code&gt; to load a large number of items&lt;/li&gt;
&lt;li&gt;Pluck to select a required field&lt;/li&gt;
&lt;li&gt;Bulk operations&lt;/li&gt;
&lt;li&gt;In-memory calculation&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Rails makes it super easy and fast to develop an application. ActiveRecord helps with the productivity, reusability, and maintainability of database code. Understanding how ActiveRecord queries translate to SQL queries and execute is important.&lt;/p&gt;
&lt;p&gt;However, the most crucial thing you need to optimize your Rails database performance is visibility over performance data. Performance issues are common, but you can resolve them once you have this visibility. You need a proper monitoring tool that provides database metrics. We like AppSignal ;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Next Level Ruby on Rails Application Monitoring with AppSignal</title>
    <link rel="alternate" href="https://blog.appsignal.com/2022/01/05/next-level-ruby-on-rails-application-monitoring-with-appsignal.html">
    <id>https://blog.appsignal.com/2022/01/05/next-level-ruby-on-rails-application-monitoring-with-appsignal.html</id>
    <published>2022-01-05T00:00:00+00:00</published>
    <updated>2022-01-05T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's run through adding custom instrumentation and monitoring to a Ruby on Rails application.</summary>
    <content type="html">&lt;p&gt;In the &lt;a href=&quot;https://blog.appsignal.com/2021/12/01/ruby-on-rails-application-monitoring-with-appsignal.html&quot;&gt;first of this two-part series&lt;/a&gt;, we covered how to
set up AppSignal in a Ruby on Rails application for many great
insights out of the box. AppSignal can automatically track errors,
monitor performance, and report metrics about some dependencies.&lt;/p&gt;
&lt;p&gt;But, in many cases, each of our applications behaves in different ways, so we&amp;#39;ll want more than just generic monitoring.&lt;/p&gt;
&lt;p&gt;In this post, we will run through adding custom instrumentation and
monitoring to a Ruby on Rails application. This will give you deeper insights into how
your application is behaving.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prerequisites if you want to follow along with the code:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An account on &lt;a href=&quot;https://www.appsignal.com/&quot;&gt;www.appsignal.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.docker.com/products/docker-desktop&quot;&gt;Docker&lt;/a&gt; installed and running (to use &lt;code&gt;docker-compose&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To follow along with this post, you will need to &lt;a href=&quot;https://blog.appsignal.com/2021/12/01/ruby-on-rails-application-monitoring-with-appsignal.html&quot;&gt;set up AppSignal in
the sample application with your own AppSignal account&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;custom-instrumentation-and-monitoring&quot;&gt;Custom Instrumentation and Monitoring&lt;/h2&gt;
&lt;p&gt;When you need more than what AppSignal instruments out of the box, the AppSignal
gem allows you to add custom instrumentation to your Rails application.&lt;/p&gt;
&lt;h3 id=&quot;instrumenting-parts-of-the-code&quot;&gt;Instrumenting Parts of the Code&lt;/h3&gt;
&lt;p&gt;Let&amp;#39;s say you want to add a new feature to an application. When a user visits
&lt;code&gt;/posts&lt;/code&gt; to view all posts, they should be able to filter for posts where
the title begins with a specific letter (or something a lot more complex 🪄).&lt;/p&gt;
&lt;p&gt;This new search functionality has already been implemented in the &lt;code&gt;Post&lt;/code&gt; model
with the method &lt;code&gt;Post.where_title_starts_with&lt;/code&gt;. Let&amp;#39;s update
the &lt;code&gt;PostsController#index&lt;/code&gt; to use the new method if a specific query parameter
is present:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/posts_controller.rb
  def index
    starts_with = params[:starts_with]
    @posts = if starts_with.present?
               Post.where_title_starts_with(starts_with)
             else
               Post.all
             end
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is such a core part of your application that you&amp;#39;ll want to know how it
performs and when that performance changes. AppSignal provides a few ways to do
this.&lt;/p&gt;
&lt;p&gt;First, we will instrument the contents of the &lt;code&gt;Post.where_title_starts_with&lt;/code&gt;
method. If you want to receive insights about any code blocks, you can use &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/instrumentation.html&quot;&gt;instrumentation blocks&lt;/a&gt; to
wrap the code blocks. Update the method
like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/post.rb
def self.where_title_starts_with(letter)
  Appsignal.instrument(&amp;#39;Post.where_title_starts_with&amp;#39;, &amp;quot;Fetch posts that start with letter&amp;quot;) do
    Analytics.track_post_title_search(letter.downcase)
    select(&amp;#39;*, pg_sleep(0.01)&amp;#39;).where(&amp;quot;title ILIKE :letter&amp;quot;, letter: &amp;quot;#{letter.downcase}%&amp;quot;).load
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Secondly, we also want to instrument the &lt;code&gt;Analytics.track_post_title_search&lt;/code&gt;
method being called because
&lt;code&gt;app/services/analytics.rb&lt;/code&gt; is doing some heavy processing. In this case, we
will use &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/method-instrumentation.html&quot;&gt;method instrumentation&lt;/a&gt;
to instrument the entire method more accurately:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/services/analytics.rb
require &amp;#39;appsignal/integrations/object&amp;#39;

class Analytics
  def self.track_post_title_search(letter, sleep = sleep(1))
    # Some heavy processing
    sleep 1
  end
  appsignal_instrument_class_method :track_post_title_search
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;insights&quot;&gt;Insights&lt;/h4&gt;
&lt;p&gt;A few minutes after saving the above to the application, take a
look at whatever new information is available on your AppSignal dashboard (if you
don&amp;#39;t see the information, you may need to restart the
docker containers again). You can verify that the new feature works by visiting
the posts index page with a search param:
&lt;a href=&quot;http://localhost:3000/posts?starts_with=f&quot;&gt;http://localhost:3000/posts?starts_with=f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Depending on the number of posts created in the database, the
&lt;code&gt;/posts&lt;/code&gt; endpoint will have become a lot slower.&lt;/p&gt;
&lt;p&gt;If you open up performance issues on AppSignal (&amp;#39;Performance&amp;#39; -&amp;gt; &amp;#39;Issue
list&amp;#39;) and view the &lt;code&gt;PostsController#index&lt;/code&gt; action, lower down on the page, you
should be able to see an &amp;#39;Event Timeline&amp;#39;. This gives you a breakdown of how
much time is spent running specific code:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-01/event-timeline.png&quot; alt=&quot;Performance issue event timeline&quot;/&gt;&lt;/p&gt;
&lt;p&gt;This timeline exists for all performance events, but
here, we can also see the custom instrumentation
events. It shows us that calling &lt;code&gt;Post.where_title_starts_with&lt;/code&gt; took
8.84 seconds to run, with 2.01 seconds used up by the
&lt;code&gt;Analytics.track_post_title_search&lt;/code&gt; method, and the remaining time used up by an
active record query. You can also click into
individual events for further investigation and see more information about their performance — e.g. the &lt;code&gt;sql.active_record&lt;/code&gt; event.&lt;/p&gt;
&lt;p&gt;AppSignal&amp;#39;s instrumentation helpers give you a more detailed
breakdown of the application code, so it&amp;#39;s easier to gain insights into
particular pieces of code that you think could impact an application&amp;#39;s
performance. You can learn more about this in &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/instrumentation.html&quot;&gt;AppSignal&amp;#39;s instrumentation guide&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;exception-handling&quot;&gt;Exception Handling&lt;/h3&gt;
&lt;p&gt;Besides monitoring the performance of your code, you also need to know when the
application doesn&amp;#39;t behave as expected and where things go wrong. We&amp;#39;ve
already seen how AppSignal reports exceptions that have not been handled by our
code. But there&amp;#39;s always a bit more than what comes out of the box.&lt;/p&gt;
&lt;p&gt;You can start by removing existing code that causes an intermittent error. We
see where this error occurs in the backtrace when viewing the error on
the dashboard. Inside of &lt;code&gt;app/controllers/pages_controller.rb&lt;/code&gt; remove the &lt;code&gt;if&lt;/code&gt;
statement:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class PagesController &amp;lt; ApplicationController
  def home
    CreateRandomPostsJob.perform_later
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, in the overview dashboard, the application&amp;#39;s error rate will drop significantly.&lt;/p&gt;
&lt;p&gt;Currently, when a user tries to view a post that doesn&amp;#39;t exist, the application
crashes — e.g.,
&lt;a href=&quot;http://localhost:3000/posts/doesnotexist&quot;&gt;http://localhost:3000/posts/doesnotexist&lt;/a&gt;.
Instead, you might want to show them a message. Add a
rescue to where this could happen inside the &lt;code&gt;PostsController&lt;/code&gt;. Update the
&lt;code&gt;#set_post&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/posts_controller.rb
class PostsController &amp;lt; ApplicationController
    .
    .
    .
    private
    def set_post
      @post = Post.find(params[:id])
    rescue ActiveRecord::RecordNotFound =&amp;gt; e
      render json: { error: &amp;quot;Oops. That post isn&amp;#39;t here&amp;quot; } , status: :not_found
    end
    .
    .
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because we are manually handling the exception, it
won&amp;#39;t automatically be reported to AppSignal. You can still track errors
manually by using &lt;code&gt;Appsignal.set_error&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The easiest way to track an error is to simply add it as the function&amp;#39;s only argument like &lt;code&gt;Appsignal.set_error(e)&lt;/code&gt;. We also want to take advantage
of the ability to add more context to the request. AppSignal allows you to tag
events with your own arbitrary information using &lt;code&gt;Appsignal.tag_request&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def set_post
  Appsignal.tag_request(user_id: &amp;#39;user-from-params&amp;#39;, post_id: params[:id])
  @post = Post.find(params[:id])
rescue ActiveRecord::RecordNotFound =&amp;gt; e
  Appsignal.set_error(e)
  render json: { error: &amp;quot;Oops. That post isn&amp;#39;t here&amp;quot; }, status: :not_found
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now visit
&lt;a href=&quot;http://localhost:3000/posts/doesnotexist&quot;&gt;http://localhost:3000/posts/doesnotexist&lt;/a&gt;
to verify that you get back the JSON response as expected, instead of having the
application crash.&lt;/p&gt;
&lt;h4 id=&quot;insights-1&quot;&gt;Insights&lt;/h4&gt;
&lt;p&gt;After you try to view a post that does not exist, the added updates ensure that the errors are reported to AppSignal.
On the AppSignal dashboard, in &lt;em&gt;&amp;#39;Errors -&amp;gt; Issue
list&amp;#39;&lt;/em&gt;, find and view the new reported error
(&lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;The error detail page gives us useful context about the error, which by default,
includes information about the request such as the HTTP method, parameters, and
session data. You can see that the custom tags are also included, which
gives you the ability to filter for all of the errors with a matching tag.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2022-01/tags.png&quot; alt=&quot;Error tags&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Because we tagged the request, it adds this information to errors and other instrumented events. If you view an individual post a few
times, e.g., &lt;a href=&quot;http://localhost:3000/posts/posts/1&quot;&gt;http://localhost:3000/posts/1&lt;/a&gt;,
you will notice that the tags are also included when you look at the performance
measurement (&amp;#39;Performance&amp;#39; -&amp;gt; &amp;#39;Issue list&amp;#39; -&amp;gt; &amp;#39;PostsController#show&amp;#39;). You can
&lt;a href=&quot;https://docs.appsignal.com/guides/custom-data/tagging-request.html&quot;&gt;read more about tagging transactions in the guides&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This ability to add custom metadata to the transaction opens up many
opportunities to help diagnose issues in production. A great example of this
is &lt;a href=&quot;https://blog.appsignal.com/2021/06/23/adding-kubernetes-metadata-to-your-appsignal-errors.html&quot;&gt;adding Kubernetes metadata to your errors&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;metrics&quot;&gt;Metrics&lt;/h3&gt;
&lt;p&gt;Now that there is some custom instrumentation and error monitoring in place, you might
realize that sometimes, there are large spikes in posts searches. Whenever a
user searches, &lt;code&gt;Analytics#track_post_title_search&lt;/code&gt; is called, which does some calculations and makes an API call to a third-party service.
This third party has rate limits on the API. We want to track how often it is
called to keep an eye on how close the application is to its
limits.&lt;/p&gt;
&lt;p&gt;AppSignal allows you to track custom metrics throughout the application as you
wish.&lt;/p&gt;
&lt;p&gt;First, we will track how often we&amp;#39;re calling our analytics service and with
what data, using a counter and tags:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;#app/services/analytics.rb
require &amp;#39;appsignal/integrations/object&amp;#39;

class Analytics
  def self.track_post_title_search(letter, sleep = sleep(1))
    Appsignal.increment_counter(&amp;quot;track_post_search&amp;quot;, 1, { letter: letter })
    # Some heavy processing
    sleep 1
  end
  appsignal_instrument_class_method :track_post_title_search
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Secondly, we will also track the number of posts being returned in the
&lt;code&gt;PostsController#index&lt;/code&gt;, because this is a core part of the application&amp;#39;s
behavior, and we know it keeps growing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;#app/controllers/posts_controller.rb
class PostsController &amp;lt; ApplicationController
    .
    .
  def index
    .
        .
    Appsignal.set_gauge(&amp;quot;posts_index&amp;quot;, @posts.size, starts_with: params[:starts_with])
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The fake traffic script still running on the application will generate some
data, but to add more variety, let&amp;#39;s also search for posts starting with
&lt;a href=&quot;http://localhost:3000/posts?starts_with=f&quot;&gt;f&lt;/a&gt;,
&lt;a href=&quot;http://localhost:3000/posts?starts_with=l&quot;&gt;l&lt;/a&gt;, and
&lt;a href=&quot;http://localhost:3000/posts?starts_with=v&quot;&gt;v&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&quot;insights-2&quot;&gt;Insights&lt;/h4&gt;
&lt;p&gt;To view the custom metrics, you will need to create a dashboard with custom
graphs on AppSignal. This can be done through the UI, but we
will just import one for this example. Under the &amp;#39;Dashboard&amp;#39; section, click on &amp;#39;Add dashboard&amp;#39;
and import a dashboard with the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
  &amp;quot;title&amp;quot;: &amp;quot;Post Search&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Sample dashboard about posts search activity&amp;quot;,
  &amp;quot;visuals&amp;quot;: [
    {
      &amp;quot;title&amp;quot;: &amp;quot;Analytics&amp;quot;,
      &amp;quot;line_label&amp;quot;: &amp;quot;%name% %letter%&amp;quot;,
      &amp;quot;display&amp;quot;: &amp;quot;LINE&amp;quot;,
      &amp;quot;format&amp;quot;: &amp;quot;number&amp;quot;,
      &amp;quot;draw_null_as_zero&amp;quot;: true,
      &amp;quot;metrics&amp;quot;: [
        {
          &amp;quot;name&amp;quot;: &amp;quot;track_post_search&amp;quot;,
          &amp;quot;fields&amp;quot;: [
            {
              &amp;quot;field&amp;quot;: &amp;quot;COUNTER&amp;quot;
            }
          ],
          &amp;quot;tags&amp;quot;: [
            {
              &amp;quot;key&amp;quot;: &amp;quot;letter&amp;quot;,
              &amp;quot;value&amp;quot;: &amp;quot;*&amp;quot;
            }
          ]
        }
      ],
      &amp;quot;type&amp;quot;: &amp;quot;timeseries&amp;quot;
    },
    {
      &amp;quot;title&amp;quot;: &amp;quot;Search&amp;quot;,
      &amp;quot;line_label&amp;quot;: &amp;quot;%name% %starts_with%&amp;quot;,
      &amp;quot;display&amp;quot;: &amp;quot;LINE&amp;quot;,
      &amp;quot;format&amp;quot;: &amp;quot;number&amp;quot;,
      &amp;quot;draw_null_as_zero&amp;quot;: true,
      &amp;quot;metrics&amp;quot;: [
        {
          &amp;quot;name&amp;quot;: &amp;quot;posts_index&amp;quot;,
          &amp;quot;fields&amp;quot;: [
            {
              &amp;quot;field&amp;quot;: &amp;quot;GAUGE&amp;quot;
            }
          ],
          &amp;quot;tags&amp;quot;: [
            {
              &amp;quot;key&amp;quot;: &amp;quot;starts_with&amp;quot;,
              &amp;quot;value&amp;quot;: &amp;quot;*&amp;quot;
            }
          ]
        }
      ],
      &amp;quot;type&amp;quot;: &amp;quot;timeseries&amp;quot;
    }
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;Video fileName=&quot;/images/blog/2022-01/custom-dashboard&quot; /&gt;

&lt;p&gt;You should see data on your graphs within a few minutes. Hovering over
the lines shows you a legend of the metrics collected within
the timeframe you&amp;#39;re viewing.&lt;/p&gt;
&lt;p&gt;Notice that this shows different lines for each tag value. Currently, our fake
traffic is only searching for the letter &lt;code&gt;e&lt;/code&gt;, but because we manually searched
for other letters, you will see a new line on the graph for each one to indicate
another data point.&lt;/p&gt;
&lt;p&gt;Thought that was enough?
AppSignal has more custom instrumentation solutions to offer that we won&amp;#39;t
be covering here. One that&amp;#39;s worth a quick mention is
&lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/breadcrumbs.html&quot;&gt;breadcrumbs&lt;/a&gt;.
Breadcrumbs allow you to track a list of actions in your application, which will
then be reported in an error. You&amp;#39;ll have even more specific and ordered
information about what led up to an error.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/&quot;&gt;Read all about custom instrumentation in the guides&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-custom-instrumentation-and-monitoring-for-ruby-apps-with-appsignal&quot;&gt;Wrap-up: Custom Instrumentation and Monitoring for Ruby Apps with AppSignal&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://appsignal-nextjs-blog-p18ainqzq-appsignal.vercel.app/2021/12/01/ruby-on-rails-application-monitoring-with-appsignal.html&quot;&gt;Part 1 of this series&lt;/a&gt; covered the basic setup and use of AppSignal for your Ruby applications.&lt;/p&gt;
&lt;p&gt;In this part, we&amp;#39;ve taken an application that already has great out-of-the-box monitoring and made
it even better using the AppSignal gem.&lt;/p&gt;
&lt;p&gt;AppSignal&amp;#39;s custom instrumentation, error tracking, and performance
monitoring features give you the insights you need into how
your applications are behaving. It gives
your application a lot out of the box while letting you take control when needed.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s time to let your code run free in the wild, as
long as you keep an eye on how it&amp;#39;s doing. Happy coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Ruby on Rails Application Monitoring with AppSignal</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/12/01/ruby-on-rails-application-monitoring-with-appsignal.html">
    <id>https://blog.appsignal.com/2021/12/01/ruby-on-rails-application-monitoring-with-appsignal.html</id>
    <published>2021-12-01T00:00:00+00:00</published>
    <updated>2021-12-01T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In the first of this two-part series, we'll set up monitoring for a Ruby on Rails application with AppSignal.</summary>
    <content type="html">&lt;p&gt;When running and maintaining an application in a production environment, we want
to feel confident about the behavior of the application and know
when it isn&amp;#39;t working as expected. At the least, we want to track
errors, monitor performance, and collect specific metrics throughout the
application.&lt;/p&gt;
&lt;p&gt;Because we&amp;#39;re developers and love maintainable solutions (right?), we also
don&amp;#39;t want to end up in a jumble of tools, integrations, and dependencies that
make it harder for us to keep track of everything.&lt;/p&gt;
&lt;p&gt;In this post, we will add AppSignal to a Ruby on Rails
application to help give clear insights into application
behavior.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prerequisites if you want to follow along with the code:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An account on &lt;a href=&quot;https://www.appsignal.com/&quot;&gt;www.appsignal.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.docker.com/products/docker-desktop&quot;&gt;Docker&lt;/a&gt; installed and running
(to use &lt;code&gt;docker-compose&lt;/code&gt;).
&lt;em&gt;*only required if using the sample application in
this post&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;setting-up-appsignal&quot;&gt;Setting up AppSignal&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: &lt;em&gt;You can skip this section if you&amp;#39;re adding AppSignal to your own Rails application. In that case, you can also ignore the instructions
related to Docker or how to restart your Rails server throughout the post — you instead
restart/redeploy your application as you usually would.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;We will use a sample application to get us started and run it on
our machine using Docker.&lt;/p&gt;
&lt;p&gt;Run the following commands to clone the repository, install dependencies, and run the application:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ git clone --branch appsignal-setup/start-docker --single-branch https://github.com/choncou/sample_rails_app appsignal-setup
$ cd appsignal-setup
$ yarn start:compose
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you run this for the first time, it may take a while to build the docker images and
download all the dependencies. Once it is complete, it will start the Rails
server, PostgreSQL database, and Redis. You should see requests in the
logs and view the running application on
&lt;a href=&quot;http://localhost:3000/&quot;&gt;http://localhost:3000/&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;about-our-sample-application&quot;&gt;About Our Sample Application&lt;/h3&gt;
&lt;p&gt;The application we&amp;#39;re working with is very minimal, so there are only a few things to note.&lt;/p&gt;
&lt;p&gt;We have a &lt;code&gt;Post&lt;/code&gt; model, &lt;code&gt;PostsController&lt;/code&gt;, and all CRUD actions exposed via the &lt;code&gt;/posts&lt;/code&gt; route.&lt;/p&gt;
&lt;p&gt;We also have a home page rendered by the &lt;code&gt;PagesController&lt;/code&gt;, which enqueues a
background job &lt;code&gt;CreateRandomPostsJob&lt;/code&gt; to generate random posts asynchronously.&lt;/p&gt;
&lt;p&gt;Lastly, we&amp;#39;re using &lt;a href=&quot;https://github.com/mperham/sidekiq&quot;&gt;Sidekiq&lt;/a&gt; for background job processing.&lt;/p&gt;
&lt;p&gt;Our small blogging platform also already has some active users. There is a
script (&lt;code&gt;./bin/traffic&lt;/code&gt;) running in the background together with the server
that regularly makes a few requests to imitate traffic on the applications.&lt;/p&gt;
&lt;p&gt;That&amp;#39;s it. We&amp;#39;ve just released a product, and everything works perfectly...&lt;/p&gt;
&lt;p&gt;Or,
at least that&amp;#39;s what we think until we start seeing user reports about the
application&amp;#39;s performance and users running into errors.&lt;/p&gt;
&lt;p&gt;So how do we figure out what&amp;#39;s going on? When we&amp;#39;re working in a development
environment, it&amp;#39;s easier to look into errors. But when our application is
running in production, this becomes harder. There must be a better way to find errors
than to search through those server logs.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AppSignal to the rescue!&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;getting-started-with-appsignal&quot;&gt;Getting Started with AppSignal&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s begin our monitoring journey by adding AppSignal to our application.
You&amp;#39;ll need to log into your account at
&lt;a href=&quot;https://www.appsignal.com/&quot;&gt;www.appsignal.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;re a new AppSignal user, you will see the page below to add an
application (whereas existing users need to click on &amp;#39;Add app&amp;#39;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-12/appsignal-install.png&quot; alt=&quot;Appsignal Install: step 1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Select &amp;quot;Install for Ruby&amp;quot;, which will then give us a few simple steps to follow:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Add the gem to your &lt;code&gt;Gemfile&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Gemfile
gem &amp;#39;appsignal&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install the gem by running &lt;code&gt;bundle install&lt;/code&gt; inside of the docker container,
which you can access with &lt;code&gt;yarn compose:sh&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn compose:sh
# We are now in a bash console within a docker container
$ bundle install
# Stay in this console for the next command
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Install AppSignal&lt;/p&gt;
&lt;p&gt;During the installation, you&amp;#39;ll need to respond to two prompts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Do you want to change how this is displayed in AppSignal? (y/n): n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;How do you want to configure AppSignal?&lt;/code&gt; : Input &lt;code&gt;1&lt;/code&gt; because we will use a config file instead of just environment variables&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Use the API key shown on the AppSignal setup page:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ bundle exec appsignal install &amp;lt;your-api-key&amp;gt;
...
...
#####################################
## AppSignal installation complete ##
#####################################

  Sending example data to AppSignal...
  Example data sent!
  It may take about a minute for the data to appear on https://appsignal.com/accounts

  Please return to your browser and follow the instructions.
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;After you run the install script, you&amp;#39;ll notice when the
AppSignal setup is complete in your browser. You can then &amp;#39;Go to app&amp;#39; to view your AppSignal
dashboard for your development environment:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-12/install-complete.png&quot; alt=&quot;AppSignal Install: complete&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The installation command creates a &lt;code&gt;config/appsignal.yml&lt;/code&gt; which allows you to
configure AppSignal settings for different environments. You can learn more in the
&lt;a href=&quot;https://docs.appsignal.com/ruby/configuration/&quot;&gt;AppSignal Ruby configuration docs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the &lt;code&gt;config/appsignal.yml&lt;/code&gt; is your push API key. You would
usually remove it from this file and use an environment variable instead. For
this post, that won&amp;#39;t be necessary.&lt;/p&gt;
&lt;p&gt;We need to restart the application to ensure that our changes take effect
because we have installed a new gem. The simplest way is to stop the
docker containers with &lt;code&gt;ctrl-c&lt;/code&gt; inside of the terminal window running
the server and start docker-compose again with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ yarn start:compose
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can take a while because it rebuilds the docker image when the dependencies change.&lt;/p&gt;
&lt;h2 id=&quot;appsignal-main-dashboard&quot;&gt;AppSignal Main Dashboard&lt;/h2&gt;
&lt;p&gt;Now that we have the application running with AppSignal installed, we can view
the dashboard. To view all the applications and environments you have running on
AppSignal, you can go to
&lt;a href=&quot;https://appsignal.com/accounts&quot;&gt;appsignal.com/accounts&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-12/application-list.png&quot; alt=&quot;AppSignal application list&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Click on the application name, and you can explore what AppSignal monitors
out-of-the-box.&lt;/p&gt;
&lt;p&gt;Within a few minutes, some data will already be collected because of your
traffic generation script.&lt;/p&gt;
&lt;p&gt;From the main dashboard, you can get a good high-level overview of a few
essential application metrics. We&amp;#39;re now going to dig into some of the more specific
areas within AppSignal.&lt;/p&gt;
&lt;h2 id=&quot;errors-dashboard-in-appsignal&quot;&gt;Errors Dashboard in AppSignal&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-12/dashboard-errors.png&quot; alt=&quot;AppSignal dashboard errors&quot;/&gt;&lt;/p&gt;
&lt;p&gt;On the errors page, you find a list of all errors reported
by your application. When we ran the install script, a test error was sent to
AppSignal. You can see that we also have an error that seems to be occurring
pretty regularly. Clicking on the error will open up a page with more details,
which can be useful to debug the issue.&lt;/p&gt;
&lt;p&gt;In this case, we can see from the backtrace section that on the homepage of the
application (&lt;code&gt;/&lt;/code&gt;) there is a validation error occurring on
&lt;code&gt;app/controllers/pages_controller.rb:7 home&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;other-appsignal-dashboards&quot;&gt;Other AppSignal Dashboards&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-12/magic-dashboards.png&quot; alt=&quot;AppSignal magic dashboards&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Under &amp;#39;Dashboard&amp;#39; in the sidebar, you can see that AppSignal has provided us
with a few different dashboards already.&lt;/p&gt;
&lt;p&gt;The &amp;#39;Overview&amp;#39; dashboard is available for every application and provides:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Your application error rate&lt;/li&gt;
&lt;li&gt;Throughput&lt;/li&gt;
&lt;li&gt;Response times&lt;/li&gt;
&lt;li&gt;Other recent activity that you can dig into for more details&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You also have two magic dashboards — one for Active Job and another for Sidekiq. AppSignal has built-in integrations for many popular
frameworks and gems that work automatically with your Rails application.&lt;/p&gt;
&lt;p&gt;When viewing these dashboards, you can
see information relevant to the activity of that integration. In the Active Job
dashboard, you&amp;#39;ll see graphs for the number of jobs in each queue, the recorded
duration of each job, and more. Give it a look!&lt;/p&gt;
&lt;h2 id=&quot;performance-of-your-app&quot;&gt;Performance of Your App&lt;/h2&gt;
&lt;p&gt;Inside of &lt;em&gt;Performance → Issue list&lt;/em&gt;, you can view a list of actions that
AppSignal measures. These measurements can provide some valuable insights
into what parts of your application consume a lot of performance.&lt;/p&gt;
&lt;p&gt;For example, by clicking into the issue for the action &lt;code&gt;PostsController#index&lt;/code&gt;, we can dive
deeper into the controller&amp;#39;s performance. You can quickly see a breakdown of
where the most time is spent, or the most object allocations happen.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-12/performance-dashboard.png&quot; alt=&quot;AppSignal performance dashboard&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;quick-wins-and-hidden-gems-from-appsignal-using-puma&quot;&gt;Quick Wins and Hidden Gems from AppSignal: Using Puma&lt;/h2&gt;
&lt;p&gt;There are a few hidden gems (not the Ruby kind) that you can get from AppSignal
without much effort. Let&amp;#39;s see how easily we can get these up and running with an example.&lt;/p&gt;
&lt;p&gt;Inside of &lt;code&gt;config/puma.rb&lt;/code&gt;, add the following line:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/puma.rb
plugin :appsignal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before we restart the application, add the following environment variable after
line 12 in the &lt;code&gt;docker-compose.yml&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# docker-compose.yml
APP_REVISION: &amp;quot;latest_version_tag&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Because we&amp;#39;ve updated the Puma server config and our docker-compose config, we
will need to restart the docker containers with &lt;code&gt;ctrl-c&lt;/code&gt; and start-up
docker-compose again with &lt;code&gt;yarn start:compose&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;tracking-your-new-insights&quot;&gt;Tracking Your New Insights&lt;/h3&gt;
&lt;p&gt;After the server restarts, allow it to run for about a minute, then head
back to the AppSignal dashboard and refresh the page. There are two main areas
with new information now:&lt;/p&gt;
&lt;p&gt;The first is the new automatically generated Puma metrics magic dashboard.
Because of AppSignal&amp;#39;s built-in integration with Puma, we now have information about
the application server&amp;#39;s activity. Specifying the &lt;code&gt;plugin&lt;/code&gt; in the config file has activated a &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/minutely-probes.html&quot;&gt;minutely
probe&lt;/a&gt;
that reports metrics about the Puma server.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-12/puma-metrics.png&quot; alt=&quot;Puma metrics&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Lastly, across the entire AppSignal dashboard, there are now &lt;a href=&quot;https://docs.appsignal.com/application/markers/deploy-markers.html#revision-config-option&quot;&gt;deployment
markers&lt;/a&gt;.
You can set the &lt;code&gt;APP_REVISION&lt;/code&gt; environment variable to any value that helps you
determine the current version of your application, such as a git commit SHA.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-12/deploy-marker.png&quot; alt=&quot;Deploy Marker&quot;/&gt;&lt;/p&gt;
&lt;p&gt;You can also see a history of your deployments by viewing the &amp;#39;Deploys&amp;#39; section
in the AppSignal dashboard and filter insights (such as
Errors/Performance issue lists) by deploy. View
how performance or reliability has changed between deploys, making it a bit
easier to dig into which changes could have introduced a new bug.&lt;/p&gt;
&lt;h2 id=&quot;next-up-custom-instrumentation-and-monitoring-for-ruby-apps&quot;&gt;Next Up: Custom Instrumentation and Monitoring for Ruby Apps&lt;/h2&gt;
&lt;p&gt;This post has shown how you can set up and use AppSignal in your applications to
help increase your code&amp;#39;s visibility in the wild.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ve demonstrated how AppSignal automatically integrates into Rails and some
of the application&amp;#39;s dependencies, such as Sidekiq and Puma. AppSignal works with
many more Ruby frameworks and gems out-of-the-box. &lt;a href=&quot;https://docs.appsignal.com/ruby/integrations/&quot;&gt;You can find a complete list of AppSignal&amp;#39;s Ruby integrations here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Part 2 of this series will cover how to add custom instrumentation and monitoring to your Ruby on Rails application for deeper insights.&lt;/p&gt;
&lt;p&gt;Until next time!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Practical Garbage Collection Tuning in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/11/17/practical-garbage-collection-tuning-in-ruby.html">
    <id>https://blog.appsignal.com/2021/11/17/practical-garbage-collection-tuning-in-ruby.html</id>
    <published>2021-11-17T00:00:00+00:00</published>
    <updated>2021-11-17T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Explore how to implement and customize garbage collection in Ruby.</summary>
    <content type="html">&lt;p&gt;&lt;em&gt;We have discovered that the below post is based on an article by Nate Berkopec from 2017 called &lt;a href=&quot;https://www.speedshop.co/2017/03/09/a-guide-to-gc-stat.html&quot;&gt;&amp;#39;Understanding Ruby GC through GC.stat&amp;#39;&lt;/a&gt;. It appears that parts of this article were plagiarised, something we were unaware of until the original author mentioned it. We run all of our articles through a plagiarism tool before publishing, but it didn&amp;#39;t pick this up. We give huge apologies to Nate and our readers for this inadvertent error.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;It is vital that you understand how garbage collection works in Ruby to stay in complete control of your app&amp;#39;s performance.&lt;/p&gt;
&lt;p&gt;In this post, we will dive into how to implement and customize garbage collection in Ruby.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s get going!&lt;/p&gt;
&lt;h2 id=&quot;the-ruby-garbage-collector-module&quot;&gt;The Ruby Garbage Collector Module&lt;/h2&gt;
&lt;p&gt;The Ruby Garbage Collector module is an interface to Ruby&amp;#39;s mark and sweep garbage collection mechanism.&lt;/p&gt;
&lt;p&gt;While it runs automatically in the background when needed, the GC module lets you call the GC manually whenever required and gain insights into how garbage collection cycles are running. The module provides some parameters which you can alter to moderate performance.&lt;/p&gt;
&lt;p&gt;Some of the most commonly used methods of this module are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;start/garbage_collect&lt;/strong&gt;: This method initiates the garbage collection cycle manually.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;enable/disable&lt;/strong&gt;: These methods enable or disable the automatic garbage collection cycles. They return a boolean value indicating if the operation was successful.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stat&lt;/strong&gt;: This method provides a list of keys and values that describe the performance of the GC module. We will take a look at these metrics in detail in the next section.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;understanding-ruby-garbage-collector-parameters&quot;&gt;Understanding Ruby Garbage Collector Parameters&lt;/h2&gt;
&lt;p&gt;To understand how Ruby’s GC works internally, let’s look at the GC module&amp;#39;s metrics. Run the following command on a freshly booted irb:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;puts GC.stat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You will notice that a bunch of numbers pop up on your screen, looking something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;{
    :count=&amp;gt;12,
    :heap_allocated_pages=&amp;gt;49,
    :heap_sorted_length=&amp;gt;49,
    :heap_allocatable_pages=&amp;gt;0,
    :heap_available_slots=&amp;gt;19975,
    :heap_live_slots=&amp;gt;19099,
    :heap_free_slots=&amp;gt;876,
    :heap_final_slots=&amp;gt;0,
    :heap_marked_slots=&amp;gt;16659,
    :heap_eden_pages=&amp;gt;49,
    :heap_tomb_pages=&amp;gt;0,
    :total_allocated_pages=&amp;gt;49,
    :total_freed_pages=&amp;gt;0,
    :total_allocated_objects=&amp;gt;66358,
    :total_freed_objects=&amp;gt;47259,
    :malloc_increase_bytes=&amp;gt;16216,
    :malloc_increase_bytes_limit=&amp;gt;16777216,
    :minor_gc_count=&amp;gt;10,
    :major_gc_count=&amp;gt;2,
    :remembered_wb_unprotected_objects=&amp;gt;191,
    :remembered_wb_unprotected_objects_limit=&amp;gt;312,
    :old_objects=&amp;gt;16024,
    :old_objects_limit=&amp;gt;23556,
    :oldmalloc_increase_bytes=&amp;gt;158824,
    :oldmalloc_increase_bytes_limit=&amp;gt;16777216
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This holds all the information about how garbage collection has been happening in the runtime. Let&amp;#39;s examine each of these numbers in detail.&lt;/p&gt;
&lt;h3 id=&quot;counts-in-ruby-garbage-collector&quot;&gt;Counts in Ruby Garbage Collector&lt;/h3&gt;
&lt;p&gt;We&amp;#39;ll begin by describing these keys:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;{
    :count=&amp;gt;12,
    #…
    :minor_gc_count=&amp;gt;10,
    :major_gc_count=&amp;gt;2,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are GC counts, and they convey pretty straightforward information. &lt;code&gt;minor_gc_count&lt;/code&gt; and &lt;code&gt;major_gc_count&lt;/code&gt; are the counts of each type of garbage collection run.&lt;/p&gt;
&lt;p&gt;There are two types of garbage collections in Ruby.&lt;/p&gt;
&lt;p&gt;Minor GC refers to a garbage collection attempt that tries to garbage collect only those objects that are new, i.e., they have survived three or fewer garbage collection cycles.&lt;/p&gt;
&lt;p&gt;On the other hand, major GC is a garbage collection attempt that tries to garbage collect all objects, even those that have survived more than three garbage collection cycles. &lt;code&gt;count&lt;/code&gt; is the sum of &lt;code&gt;minor_gc_count&lt;/code&gt; and &lt;code&gt;major_gc_count&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Tracking the GC count can be helpful for a few reasons. You can figure out if a particular job or process always triggers GCs and the number of times it triggers them. It might not be 100% accurate in cases like multithreaded applications, but it is a good starting point to figure out where your memory is bleeding.&lt;/p&gt;
&lt;h3 id=&quot;heap-numbers-slots-and-pages&quot;&gt;Heap Numbers: Slots and Pages&lt;/h3&gt;
&lt;p&gt;Next, let’s talk about these keys, also known as &lt;em&gt;heap numbers&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;{
    # page numbers
    :heap_allocated_pages=&amp;gt;49,
    :heap_sorted_length=&amp;gt;49,
    :heap_allocatable_pages=&amp;gt;0,

    # slots
    :heap_available_slots=&amp;gt;19975,
    :heap_live_slots=&amp;gt;19099,
    :heap_free_slots=&amp;gt;876,
    :heap_final_slots=&amp;gt;0,
    :heap_marked_slots=&amp;gt;16659,

    # Eden and Tomb pages
    :heap_eden_pages=&amp;gt;49,
    :heap_tomb_pages=&amp;gt;0,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The heap that we are talking about here is a C data structure. It contains references to all the currently live Ruby objects. A heap &lt;em&gt;page&lt;/em&gt; is composed of memory slots, and each slot includes information on only one live Ruby object:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;heap_allocated_pages&lt;/code&gt; is the number of currently allocated heap pages. These pages can be completely empty, completely filled, or partly filled.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap_sorted_length&lt;/code&gt; is the actual size that the heap has occupied in memory and is different from &lt;code&gt;heap_allocated_pages&lt;/code&gt;, as the length is the &lt;em&gt;length&lt;/em&gt; of the heap pages put together, not their &lt;em&gt;count&lt;/em&gt;. If you initially allocated 10 pages and then freed one from the middle of the set, your &lt;code&gt;heap_allocated_pages&lt;/code&gt; would be 9, but the &lt;code&gt;heap_sorted_length&lt;/code&gt; would still be 10.&lt;/li&gt;
&lt;li&gt;Finally, &lt;code&gt;heap_allocatable_pages&lt;/code&gt; is the count of heaps that Ruby currently owns that can be used when needed.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, coming to the slots:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;heap_available_slots&lt;/code&gt; is the total number of available slots in the heap pages.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap_live_slots&lt;/code&gt; is the number of live objects in the memory.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap_free_slots&lt;/code&gt; are slots in the allocated heap pages that are empty.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap_final_slots&lt;/code&gt; is the count of slots whose objects have &lt;em&gt;finalizers&lt;/em&gt; attached to them. Finalizers are Procs that run when an object is freed, similarly to destructors in OOPS.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;heap_marked_slots&lt;/code&gt; is the count of old objects (i.e., the objects that have been around for more than 3 GC cycles) and write-barrier unprotected objects.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then we have &lt;code&gt;tomb_pages&lt;/code&gt; and &lt;code&gt;eden_pages&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;tomb_pages&lt;/code&gt; is the count of pages that contain no live objects. These pages are eventually released back to the operating system by Ruby.&lt;/p&gt;
&lt;p&gt;On the other hand, &lt;code&gt;eden_pages&lt;/code&gt; is the count of those pages that contain at least one live object, so they can&amp;#39;t be released back to the operating system.&lt;/p&gt;
&lt;p&gt;Consider monitoring the metric &lt;code&gt;heap_free_slots&lt;/code&gt; if you face memory bloat issues in your application.&lt;/p&gt;
&lt;p&gt;A high number of free slots (more than 250,000) usually indicates that you have a handful of controller actions that allocate many objects at once and then free them. This can permanently bloat the size of your running Ruby process.&lt;/p&gt;
&lt;h3 id=&quot;cumulative-numbers&quot;&gt;Cumulative Numbers&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;{
    :total_allocated_pages=&amp;gt;49,
    :total_freed_pages=&amp;gt;0,
    :total_allocated_objects=&amp;gt;66358,
    :total_freed_objects=&amp;gt;47259,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These numbers are cumulative or additive in nature for the entire life of the process. They are never reset by the GC and can&amp;#39;t technically go down. All four of these numbers are self-explanatory.&lt;/p&gt;
&lt;h3 id=&quot;garbage-collection-thresholds&quot;&gt;Garbage Collection Thresholds&lt;/h3&gt;
&lt;p&gt;To understand these numbers, you first need to understand when GC is triggered:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;{
    :malloc_increase_bytes=&amp;gt;16216,
    :malloc_increase_bytes_limit=&amp;gt;16777216,
    :remembered_wb_unprotected_objects=&amp;gt;191,
    :remembered_wb_unprotected_objects_limit=&amp;gt;312,
    :old_objects=&amp;gt;16024,
    :old_objects_limit=&amp;gt;23556,
    :oldmalloc_increase_bytes=&amp;gt;158824,
    :oldmalloc_increase_bytes_limit=&amp;gt;16777216
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Contrary to a common assumption that GC runs happen at fixed intervals, GC runs are triggered when Ruby starts running out of memory space. Minor GC happens when Ruby runs out of &lt;code&gt;free_slots&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If Ruby is still low on &lt;code&gt;free_slots&lt;/code&gt; after a minor GC run — or the threshold of oldmalloc, malloc, old object count, or &lt;em&gt;shady&lt;/em&gt;/write-barrier-unprotected count is exceeded — a major GC run is triggered. The above part of gc.stat shows the values of these thresholds.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;malloc_increase_bytes&lt;/code&gt; refers to the amount of memory allocated outside of the &lt;em&gt;heap&lt;/em&gt; we talked about so far. When the size of an object exceeds the standard size of a memory slot — say, 40 bytes — Ruby &lt;code&gt;malloc&lt;/code&gt;s some space somewhere else just for that object. When the total extra allocated space exceeds &lt;code&gt;malloc_increase_bytes_limit&lt;/code&gt;, a major GC is triggered.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;oldmalloc_increase_bytes&lt;/code&gt; is a similar threshold for old objects. &lt;code&gt;old_objects&lt;/code&gt; is a count of object slots marked as old. When the number exceeds the &lt;code&gt;old_objects_limit&lt;/code&gt;, major GC is triggered.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;remembered_wb_unprotected_objects&lt;/code&gt; is the total count of objects that are not protected by the &lt;em&gt;write-barrier&lt;/em&gt; and are a part of the &lt;em&gt;remembered set&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;The write-barrier is an interface between Ruby runtime and its objects, which allows the interpreter to track references to and from the object as soon as they are created.&lt;/p&gt;
&lt;p&gt;C-extensions can make new references to objects without using the write-barrier, in which case the objects are marked &lt;em&gt;shady&lt;/em&gt; or &lt;em&gt;write-barrier unprotected&lt;/em&gt;. The remembered set is simply a list of &lt;em&gt;old&lt;/em&gt; objects with at least one reference to a &lt;em&gt;new&lt;/em&gt; object.&lt;/p&gt;
&lt;h2 id=&quot;customize-ruby-garbage-collection-performance&quot;&gt;Customize Ruby Garbage Collection Performance&lt;/h2&gt;
&lt;p&gt;Now that you understand how Ruby GC manages your application&amp;#39;s memory, it is time to look at the options available to customize GC&amp;#39;s behavior.&lt;/p&gt;
&lt;p&gt;Here are environment variables that you can use to moderate the performance of Ruby GC and, in turn, improve the performance of your application:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;RUBY_GC_HEAP_INIT_SLOTS
RUBY_GC_HEAP_FREE_SLOTS
RUBY_GC_HEAP_GROWTH_FACTOR
RUBY_GC_HEAP_GROWTH_MAX_SLOTS
RUBY_GC_HEAP_OLDOBJECT_LIMIT_FACTOR
and other variables
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;#39;s talk about the important parameters here, one by one:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RUBY_GC_HEAP_INIT_SLOTS&lt;/code&gt;: defines the initial number of slots on the Ruby heap and is set to 10000 by default. You might want to change this parameter if you&amp;#39;re sure that your app will initially allocate most of its objects.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUBY_GC_HEAP_FREE_SLOTS&lt;/code&gt;: controls the minimum number of free slots that must be available right after a GC cycle. Its default value is 4096. This value is only used once at runtime during the first heap growth.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUBY_GC_HEAP_GROWTH_FACTOR&lt;/code&gt;: the factor by which available heaps to the Ruby interpreter grow. Its default value is 1.8. Changing this makes little sense, as Ruby is already aggressive at heap growth. It will not make much difference if you try decreasing it since heaps are allocated on-demand in modern interpreters.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUBY_GC_HEAP_GROWTH_MAX_SLOTS&lt;/code&gt;: the maximum number of slots Ruby can add to the heap space at once. The default value is 0, which stands for no limit on the number. If your app needs to allocate millions of objects in its lifetime, you might want to put a cap on this parameter. However, it will have a pretty low effect on the GC time of your app.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUBY_GC_HEAP_OLDOBJECT_LIMIT_FACTOR&lt;/code&gt; forces the interpreter to carry out a major GC cycle when the total number of old objects in memory = more than this number x number of old objects in memory after the last GC cycle. You might want to increase this number if you think many of your objects will become unused after they enter the old generation. However, this is rarely needed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUBY_GC_MALLOC_LIMIT&lt;/code&gt; is the minimum limit of malloc calls for the new generation. Its default value is 16 MB. &lt;code&gt;RUBY_GC_MALLOC_LIMIT_MAX&lt;/code&gt; is the maximum limit for the same malloc calls. Its default value is 32 MB. You might want to increase these two limits if your application uses higher than average memory. However, be careful not to raise these too much. Otherwise, they might lead to higher peak memory consumption. Always increase these limits incrementally — say, by 4 or 8 MB.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUBY_GC_MALLOC_LIMIT_GROWTH_FACTOR&lt;/code&gt; is the growth factor of the malloc limit for the new generation. Its default value is 1.4. You should consider increasing this number if your app allocates memory in chunks rather than whole at once.&lt;/li&gt;
&lt;li&gt;Similarly, &lt;code&gt;RUBY_GC_OLDMALLOC_LIMIT&lt;/code&gt; and &lt;code&gt;RUBY_GC_OLDMALLOC_LIMIT_MAX&lt;/code&gt; are the minimum and maximum malloc limits for the old generation. The default values of these parameters are 16 MB and 128 MB.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RUBY_GC_OLDMALLOC_LIMIT_GROWTH_FACTOR&lt;/code&gt; is the growth factor of this limit. Its default value is 1.2. You can consider changing these with the new generation limits for maximum effect.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;fine-tuning-garbage-collection-in-ruby&quot;&gt;Fine-tuning Garbage Collection in Ruby&lt;/h2&gt;
&lt;p&gt;We discussed some common and simple ways to customize the GC module to help you improve your application&amp;#39;s overall performance. However, these tweaks might not work in all cases. You need to figure out the memory usage pattern of your app before deciding what to customize.&lt;/p&gt;
&lt;p&gt;On the flip side, you can consider running an automated test that finds the best values of these parameters for you. Tools like &lt;a href=&quot;https://rubygems.org/gems/tunemygc/versions/1.0.4&quot;&gt;TuneMyGC&lt;/a&gt; are pretty straightforward when figuring out the best set of values for your environment variables.&lt;/p&gt;
&lt;p&gt;Definitely look at GC parameters if your application is behaving weirdly. A small change here can go a long way to bring down your app&amp;#39;s memory consumption and prevent memory bloats.&lt;/p&gt;
&lt;p&gt;I hope this article has given you a good idea of what to look out for when customizing your Ruby Garbage Collection module. For more of an introduction, check out the Introduction to Garbage Collection &lt;a href=&quot;https://blog.appsignal.com/2016/07/12/ruby-magic-garbage-collection-part-1.html&quot;&gt;Part I&lt;/a&gt; and &lt;a href=&quot;https://blog.appsignal.com/2016/07/28/ruby-magic-garbage-collection-part-2.html&quot;&gt;Part II&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Have fun coding!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Optimistic Locking in Rails REST APIs</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/10/20/optimistic-locking-in-rails-rest-apis.html">
    <id>https://blog.appsignal.com/2021/10/20/optimistic-locking-in-rails-rest-apis.html</id>
    <published>2021-10-20T00:00:00+00:00</published>
    <updated>2021-10-20T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Implement optimistic locking in Rails APIs to avoid potentially critical issues.</summary>
    <content type="html">&lt;p&gt;Imagine the following hypothetical scenario: in a rental property management system, Employee A starts editing contact info for Rental X, adding some extra phone numbers. Around the same time, Employee B notices a typo in the contact info for exactly that Rental X and performs an update. A couple of minutes later, Employee A updates Rental X&amp;#39;s contact info with the new phone numbers, and ... the update fixing the typo is now gone!&lt;/p&gt;
&lt;p&gt;That&amp;#39;s definitely not great! And this is a pretty trivial scenario. Imagine a similar conflict happening in a financial system!&lt;/p&gt;
&lt;p&gt;Could we avoid such scenarios in the future? Fortunately, the answer is yes! We need concurrency protection and locking — specifically, optimistic locking — to prevent such problems.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s explore optimistic locking in Rails REST APIs.&lt;/p&gt;
&lt;h2 id=&quot;lost-updates-and-optimistic-locking-vs-pessimistic-locking&quot;&gt;&amp;#39;Lost Updates&amp;#39; and Optimistic Locking vs. Pessimistic Locking&lt;/h2&gt;
&lt;p&gt;The scenario we&amp;#39;ve just gone through is a type of &amp;#39;Lost Update&amp;#39;. When two concurrent transactions update the same column of the same row, the second one will override the changes from the first one, essentially as if the first transaction never happened.&lt;/p&gt;
&lt;p&gt;Usually, this problem can be addressed by:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Setting a proper &lt;a href=&quot;https://fauna.com/blog/introduction-to-transaction-isolation-levels&quot;&gt;Transaction Isolation level&lt;/a&gt;, which handles the problem on the database level.&lt;/li&gt;
&lt;li&gt;Pessimistic locking — preventing concurrent transactions from updating the same row. The second transaction waits for the first transaction to finish before it even reads the data. The great advantage here is that it is impossible to operate on stale data. The major disadvantage, though, is that it also blocks reading the data from a given row.&lt;/li&gt;
&lt;li&gt;Optimistic locking — stops the modification of the given row if its state at the time of modification is different from when it was read.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our problem is not about concurrent database transactions (more like business transactions) — so the first solution is not really applicable. This means we&amp;#39;re left with pessimistic locking and optimistic locking.&lt;/p&gt;
&lt;p&gt;Pessimistic locking would prevent the lost update from happening in our hypothetical scenario in the first place. However, it would also make life difficult for users if it blocked access to data for a very long time (imagine it reading and editing some fields for 30 minutes or more).&lt;/p&gt;
&lt;p&gt;Optimistic locking would be far less restrictive, as it would allow multiple users to access data. However, if several users start editing the data concurrently, only one can perform the operation. The rest would see an error stating that they operated on stale data and need to retry. Not ideal, but with proper UX, this might not necessarily be that painful.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s see how we could implement optimistic locking in a hypothetical Rails REST API.&lt;/p&gt;
&lt;h2 id=&quot;optimistic-locking-in-rest-apis&quot;&gt;Optimistic Locking in REST APIs&lt;/h2&gt;
&lt;p&gt;Before we get to implementation in the actual Rails app, let&amp;#39;s think about what optimistic locking could look like in the context of general REST APIs.&lt;/p&gt;
&lt;p&gt;As described above, we need to track an object&amp;#39;s original state when reading it to compare against its later state during the update. If the state doesn&amp;#39;t change since the last read, the operation is allowed. If it has changed, though, it will fail.&lt;/p&gt;
&lt;p&gt;What we need to figure out in the context of REST APIs is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When reading the data of a given resource, how do we express the current state of an object and return it in a response for a consumer?&lt;/li&gt;
&lt;li&gt;How should consumers propagate the original state of a resource to an API when performing the update?&lt;/li&gt;
&lt;li&gt;What should the API return to the consumer if the state has changed and the update is not possible?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The great news is that all these questions can be answered and handled with HTTP semantics.&lt;/p&gt;
&lt;p&gt;As far as tracking the state of a resource goes, we can take advantage of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag&quot;&gt;&lt;code&gt;Entity Tags&lt;/code&gt;&lt;/a&gt; (or ETags). We can return the resource&amp;#39;s fingerprint/checksum/version number in the dedicated &lt;code&gt;ETag&lt;/code&gt; header to API consumers to send later with the PATCH request. We can use an &lt;code&gt;If-Match&lt;/code&gt; header, making it pretty straightforward for the API server to check if the resource has changed or not. It is just a case of comparing the checksums/version number/whatever else you choose as the ETag.&lt;/p&gt;
&lt;p&gt;The request will succeed if the current &lt;code&gt;ETag&lt;/code&gt; and &lt;code&gt;If-Match&lt;/code&gt; values are the same. If not, the API should respond with the rarely-used &lt;code&gt;412 Precondition Failed&lt;/code&gt; status, the most appropriate and expressive status that we can use for this purpose.&lt;/p&gt;
&lt;p&gt;There is one other possible scenario. We can only compare the ETags if the API consumer provides the &lt;code&gt;If-Match&lt;/code&gt; header. What if it doesn&amp;#39;t? You could ignore concurrency protection and forget about optimistic locking, but that might not be ideal. One other solution would be to make it a requirement to provide the &lt;code&gt;If-Match&lt;/code&gt; header and respond with &lt;code&gt;428 Precondition Required&lt;/code&gt; status if it&amp;#39;s not.&lt;/p&gt;
&lt;p&gt;Now that we have a solid overview of how optimistic locking could work in REST APIs, let&amp;#39;s implement it in Rails.&lt;/p&gt;
&lt;h2 id=&quot;optimistic-locking-in-rails&quot;&gt;Optimistic Locking in Rails&lt;/h2&gt;
&lt;p&gt;The great news is that Rails offers optimistic locking out-of-the-box — we can use the feature provided by &lt;code&gt;ActiveRecord::Locking::Optimistic&lt;/code&gt;. When you add the &lt;code&gt;lock_version&lt;/code&gt; column (or whatever else you want, although that requires additional declarations on the model level to define the locking column), ActiveRecord will increment it after each change and check if the currently assigned version is the expected one. If it&amp;#39;s stale, the &lt;code&gt;ActiveRecord::StaleObjectError&lt;/code&gt; exception will be raised on the update/destroy attempt.&lt;/p&gt;
&lt;p&gt;The easiest way to handle optimistic locking in our API is to use the value from &lt;code&gt;lock_version&lt;/code&gt; as an ETag. Let&amp;#39;s do this as the first step in our hypothetical &lt;code&gt;RentalsController&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class RentalsController
  after_action :assign_etag, only: [:show]

  def show
    @rental = Rental.find(params[:id])
    respond_with @rental
  end

  private

  def assign_etag
    response.headers[&amp;quot;ETag&amp;quot;] = @rental.lock_version
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is, of course, a very simplified version of the controller as we are only interested in whatever is required for optimistic locking, not authentication, authorization, or other concepts. This is enough to expose the proper ETag to the consumer. Let&amp;#39;s now take care of the &lt;code&gt;If-Match&lt;/code&gt; header that the consumers can provide:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class RentalsController
  after_action :assign_etag, only: [:show, :update]

  def show
    @rental = Rental.find(params[:id])
    respond_with @rental
  end

  def update
    @rental = Rental.find(params[:id])
    @rental.update(rental_params)
    respond_with @rental
  end

  private

  def assign_etag
    response.headers[&amp;quot;ETag&amp;quot;] = @rental.lock_version
  end

  def rental_params
    params
      .require(:rental)
      .permit(:some, :permitted, :attributes).merge(lock_version: lock_version_from_if_match_header)
  end

  def lock_version_from_if_match_header
    request.headers[&amp;quot;If-Match&amp;quot;].to_i
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that&amp;#39;s actually enough to have the minimal version of optimistic locking working! Although, clearly, we don&amp;#39;t want to return 500 responses if there is any conflict. We will make &lt;code&gt;If-Match&lt;/code&gt; required for any update too:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class RentalsController
  before_action :ensure_if_match_header_provided, only: [:update]
  after_action :assign_etag, only: [:show, :update]

  rescue_from ActiveRecord::StaleObjectError do
    head 412
  end

  def show
    @rental = Rental.find(params[:id])
    respond_with @rental
  end

  def update
    @rental = Rental.find(params[:id])
    @rental.update(rental_params)
    respond_with @rental
  end

  private

  def ensure_if_match_header_provided
     request.headers[&amp;quot;If-Match&amp;quot;].present? or head 428 and return
  end

  def assign_etag
    response.headers[&amp;quot;ETag&amp;quot;] = @rental.lock_version
  end

  def rental_params
    params
      .require(:rental)
      .permit(:some, :permitted, :attributes)
      .merge(lock_version: lock_version_from_if_match_header)
  end

  def lock_version_from_if_match_header
    request.headers[&amp;quot;If-Match&amp;quot;].to_i
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that&amp;#39;s pretty much everything required to implement all the functionality that we discussed earlier. We could improve way more things — e.g., by providing some extra error messages besides just the response code — but that would be outside the scope of this article.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-the-importance-of-optimistic-locking-in-rails-apis&quot;&gt;Wrap-up: The Importance of Optimistic Locking in Rails APIs&lt;/h2&gt;
&lt;p&gt;Concurrency protection is often overlooked when designing REST APIs, which can lead to severe consequences.&lt;/p&gt;
&lt;p&gt;Nevertheless, implementing optimistic locking in Rails APIs is pretty straightforward — as demonstrated in this article — and will help avoid potentially critical issues.&lt;/p&gt;
&lt;p&gt;Have fun coding!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>How to Reduce Memory Bloat in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/09/21/how-to-reduce-memory-bloat-in-ruby.html">
    <id>https://blog.appsignal.com/2021/09/21/how-to-reduce-memory-bloat-in-ruby.html</id>
    <published>2021-09-21T00:00:00+00:00</published>
    <updated>2021-09-21T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Memory bloat can be a serious issue in Ruby. This article explores two common causes of memory bloat and how you can overcome them.</summary>
    <content type="html">&lt;p&gt;The issue of memory bloat in Ruby applications is a topic of frequent discussion. In this post, we will look at how Ruby memory management can go wrong, and what you can do to prevent your Ruby application from blowing up.&lt;/p&gt;
&lt;p&gt;First, we need to understand what bloat means in the context of an application’s memory.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s dive in!&lt;/p&gt;
&lt;h2 id=&quot;what-is-memory-bloat-in-ruby&quot;&gt;What Is Memory Bloat in Ruby?&lt;/h2&gt;
&lt;p&gt;Memory bloat is when your application’s memory usage increases all of a sudden without an apparent explanation. This increase may or may not be quick, but in most cases, it becomes continuous. It is different from a memory leak, which results from multiple executions taking place over some time.&lt;/p&gt;
&lt;p&gt;Memory bloat can be one of the worst things to happen to your Ruby application in production. However, it is avoidable if you take proper measures. For example, if you notice a spike in your application’s memory usage, it is best to check for signs of memory bloat before troubleshooting other issues.&lt;/p&gt;
&lt;p&gt;Before we explore how to diagnose and fix memory bloat, let’s take a quick walkthrough of Ruby’s memory architecture.&lt;/p&gt;
&lt;h2 id=&quot;rubys-memory-structure&quot;&gt;Ruby&amp;#39;s Memory Structure&lt;/h2&gt;
&lt;p&gt;Ruby&amp;#39;s memory usage revolves around specific elements that manage the judicious use of available system resources. These elements include the Ruby language, host operating system, and the system kernel.&lt;/p&gt;
&lt;p&gt;Apart from these, the garbage collection process also plays a vital role in determining how Ruby memory is managed and reused.&lt;/p&gt;
&lt;h2 id=&quot;ruby-heap-pages-and-memory-slots&quot;&gt;Ruby Heap Pages and Memory Slots&lt;/h2&gt;
&lt;p&gt;The Ruby language organizes objects into segments called heap pages. The entire heap space (available memory) is divided into used and empty sections. These heap pages are further split into equal-sized slots, which allow one unit-sized object each.&lt;/p&gt;
&lt;p&gt;When allocating memory to a new object, Ruby first looks in the used heap space for free slots. If none are found, it allocates a new heap page from the empty section.&lt;/p&gt;
&lt;p&gt;Memory slots are small memory locations, each nearly 40 bytes in size. The data that overflows out of these slots is stored in a different area outside the heap page and each slot stores a pointer to the external information.&lt;/p&gt;
&lt;p&gt;A system’s memory allocator makes all allocations in the Ruby runtime environment, including heap pages and external data pointers.&lt;/p&gt;
&lt;h2 id=&quot;operating-system-memory-allocation-in-ruby&quot;&gt;Operating System Memory Allocation in Ruby&lt;/h2&gt;
&lt;p&gt;Memory allocation calls made by the Ruby language are handled and responded to by the host operating system’s memory allocator.&lt;/p&gt;
&lt;p&gt;Usually, the memory allocator consists of a group of C functions, namely &lt;em&gt;malloc&lt;/em&gt;, &lt;em&gt;calloc&lt;/em&gt;, &lt;em&gt;realloc&lt;/em&gt;, and &lt;em&gt;free&lt;/em&gt;. Let’s quickly take a look at each:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Malloc&lt;/strong&gt;: Malloc stands for memory allocation, and it is used to allocate free memory to objects. It takes in the size of the memory to be allocated and returns a pointer to the starting index of the allocated memory block.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Calloc&lt;/strong&gt;: Calloc stands for contiguous allocation, and it allows the Ruby language to allocate consecutive blocks of memory. It is beneficial when allocating object arrays of known length.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Realloc&lt;/strong&gt;: Realloc stands for re-allocation, and it allows the language to re-allocate memory with a new size.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Free&lt;/strong&gt;: Free is used to clear out pre-allocated sets of memory locations. It takes in a pointer to the starting index of the memory block that has to be freed.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;garbage-collection-in-ruby&quot;&gt;Garbage Collection in Ruby&lt;/h2&gt;
&lt;p&gt;The garbage collection process of a language runtime dramatically affects how well it utilizes its available memory.&lt;/p&gt;
&lt;p&gt;Ruby happens to have pretty advanced garbage collection that uses all of the above-described API methods to optimize application memory consumption at all times.&lt;/p&gt;
&lt;p&gt;An interesting fact about the garbage collection process in Ruby is that it halts the complete application! This ensures that no new object allocation happens during garbage collection. Because of this, your garbage collection routine should be infrequent and as quick as possible.&lt;/p&gt;
&lt;h2 id=&quot;two-common-causes-of-memory-bloat-in-ruby&quot;&gt;Two Common Causes of Memory Bloat in Ruby&lt;/h2&gt;
&lt;p&gt;This section will discuss two of the most significant reasons why memory bloats occur in Ruby: fragmentation and slow release.&lt;/p&gt;
&lt;h2 id=&quot;memory-fragmentation&quot;&gt;Memory Fragmentation&lt;/h2&gt;
&lt;p&gt;Memory fragmentation is when object allocations in memory are scattered all over, reducing the number of contiguous chunks of free memory. Memory can&amp;#39;t be allocated to objects without contiguous blocks, even if more than enough free memory is available on the disk. This problem can occur in any programming language or environment, and each language has its methods for solving the issue.&lt;/p&gt;
&lt;p&gt;Fragmentation can occur at two different levels: the language’s level and the memory allocator’s level. Let’s take a look at both of these in detail.&lt;/p&gt;
&lt;h2 id=&quot;fragmentation-at-the-ruby-level&quot;&gt;Fragmentation at the Ruby Level&lt;/h2&gt;
&lt;p&gt;Fragmentation at the language level occurs due to the design of the garbage collection process. The garbage collection process marks a Ruby heap page slot as free, allowing reuse of that slot to allocate another object in the memory. If a complete Ruby heap page consists of only free slots, then that heap page can be released to the memory allocator for reuse.&lt;/p&gt;
&lt;p&gt;But what if a tiny number of slots are not marked free on a heap? It will not be released back to the memory allocator. Now, think about the many slots in various heap pages simultaneously allocated and freed by garbage collection. It is improbable for entire heap pages to be released at once. Even though the garbage collection process frees memory, it can&amp;#39;t be reused by the memory allocator since memory blocks partially occupy it.&lt;/p&gt;
&lt;h2 id=&quot;fragmentation-at-the-memory-allocator-level&quot;&gt;Fragmentation at the Memory Allocator Level&lt;/h2&gt;
&lt;p&gt;The memory allocator itself faces a similar problem: it has to release OS heaps once they are all entirely free. But it is improbable that an entire OS heap can be freed at once considering the random nature of the garbage collection process.&lt;/p&gt;
&lt;p&gt;The memory allocator also provisions OS heaps from system memory for an application’s use. It will simply move to provision new OS heaps, even if the existing heaps have enough free memory to satisfy the application’s memory requirements. This is the perfect recipe for a spike in the memory metrics of an application.&lt;/p&gt;
&lt;h2 id=&quot;slow-release&quot;&gt;Slow Release&lt;/h2&gt;
&lt;p&gt;Another important cause of memory bloat in Ruby is a slow release of freed memory back to the system. In this situation, memory is freed much more slowly than the rate at which new memory blocks are allocated to objects. While this is not a conventional or a rookie issue to solve, it intensely affects memory bloat — even more so than fragmentation!&lt;/p&gt;
&lt;p&gt;Upon investigating the memory allocator’s source, it turns out that the allocator is designed to release OS pages just at the end of OS heaps, and even then, only very occasionally. This is probably for performance reasons, but it can backfire and be counter-productive.&lt;/p&gt;
&lt;h2 id=&quot;how-to-fix-ruby-memory-bloat&quot;&gt;How to Fix Ruby Memory Bloat&lt;/h2&gt;
&lt;p&gt;Now that we know what causes Ruby’s memory to bloat, let’s take a look at how you can fix these issues and improve your app&amp;#39;s performance through defragmentation and trimming.&lt;/p&gt;
&lt;h2 id=&quot;fix-ruby-memory-bloat-with-defragmentation&quot;&gt;Fix Ruby Memory Bloat with Defragmentation&lt;/h2&gt;
&lt;p&gt;Fragmentation happens due to the design of garbage collection, and there isn&amp;#39;t much you can do to fix it. However, there are a few steps that you can follow to reduce the chances of ending up with a fragmented memory disk:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you declare a reference to an object that uses a considerable amount of memory, make sure you free it manually when its job is done.&lt;/li&gt;
&lt;li&gt;Try to declare all of your static object allocations in one big block. This will put all your permanent classes, objects, and other data on the same heap pages. Later, when you play around with dynamic allocations, you won’t have to worry about the static heap pages.&lt;/li&gt;
&lt;li&gt;If possible, try to do large dynamic allocations at the &lt;em&gt;beginning&lt;/em&gt; of your code. This will put them close to your bigger static allocation memory blocks and will keep the rest of your memory clean.&lt;/li&gt;
&lt;li&gt;If you use a small and rarely cleared cache, it is better to group it with permanent static allocation in the beginning. You can even consider removing it altogether to improve your app’s memory management.&lt;/li&gt;
&lt;li&gt;Use &lt;a href=&quot;https://github.com/jemalloc/jemalloc&quot;&gt;jemalloc&lt;/a&gt; instead of the standard glibc memory allocator. This small tweak can bring down your Ruby memory consumption &lt;a href=&quot;https://www.mikeperham.com/2018/04/25/taming-rails-memory-bloat/&quot;&gt;by up to four times&lt;/a&gt;. The only caveat here is that it might not be compatible in all environments, so be sure to test your app thoroughly before rolling into production.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;trimming-to-fix-ruby-memory-bloat&quot;&gt;Trimming to Fix Ruby Memory Bloat&lt;/h2&gt;
&lt;p&gt;You need to override the garbage collection process and release memory more often to fix slow memory release. There is an API that can do this called &lt;em&gt;malloc_trim&lt;/em&gt;. All you need to do is modify Ruby to call this function during the garbage collection process.&lt;/p&gt;
&lt;p&gt;Here’s the modified Ruby 2.6 code that calls &lt;em&gt;malloc_trim&lt;/em&gt; in gc.c function &lt;code&gt;gc_start&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;gc_prof_timer_start(objspace);
{
    gc_marks(objspace, do_full_mark);
    // BEGIN MODIFICATION
    if (do_full_mark)
    {
        malloc_trim(0);
    }
    // END MODIFICATION
}
gc_prof_timer_stop(objspace);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Note:&lt;/em&gt; This is not recommended in production applications as it can make your app unstable. However, it comes in handy when slow memory release causes major hits to your performance, and you are ready to try out any solution.&lt;/p&gt;
&lt;h2 id=&quot;wrap-up-and-next-steps&quot;&gt;Wrap-up and Next Steps&lt;/h2&gt;
&lt;p&gt;Memory bloats are tricky to identify and even more challenging to fix.&lt;/p&gt;
&lt;p&gt;This article looked at two significant reasons behind memory bloats in Ruby apps — fragmentation and slow release — and two fixes: defragmentation and trimming.&lt;/p&gt;
&lt;p&gt;You must keep a constant eye on your app’s metrics to identify an impending bloat incident and fix it before it takes your app down.&lt;/p&gt;
&lt;p&gt;I hope that I&amp;#39;ve helped you take some steps towards fixing memory bloat in your Ruby application.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Our guest author Kumar Harsh is an up-and-coming software developer by craft. He is a spirited writer who puts together content around popular web technologies like Ruby and JavaScript. You can find out more about him &lt;a href=&quot;https://kumarharsh.me/&quot;&gt;through his website&lt;/a&gt; and &lt;a href=&quot;https://twitter.com/krharsh17&quot;&gt;follow him on Twitter&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Responsible Monkeypatching in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/08/24/responsible-monkeypatching-in-ruby.html">
    <id>https://blog.appsignal.com/2021/08/24/responsible-monkeypatching-in-ruby.html</id>
    <published>2021-08-24T00:00:00+00:00</published>
    <updated>2021-08-24T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Monkeypatching can be a great way to improve existing code if used right. Let's find out how.</summary>
    <content type="html">&lt;p&gt;When I first started writing Ruby code professionally back in 2011, one of the things that impressed me the most about the language was its flexibility. It felt as though with Ruby, everything was possible. Compared to the rigidity of languages like C# and Java, Ruby programs almost seemed like they were &lt;em&gt;alive&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Consider how many incredible things you can do in a Ruby program. You can define and delete methods at will. You can call methods that don&amp;#39;t exist. You can conjure entire nameless classes out of thin air. It&amp;#39;s absolutely wild.&lt;/p&gt;
&lt;p&gt;But that&amp;#39;s not where the story ends. While you can apply these techniques inside your own code, Ruby also lets you apply them to anything loaded into the virtual machine. In other words, you can mess with other people&amp;#39;s code as easily as you can your own.&lt;/p&gt;
&lt;h2 id=&quot;what-are-monkeypatches&quot;&gt;What Are Monkeypatches?&lt;/h2&gt;
&lt;p&gt;Enter the &lt;em&gt;monkeypatch&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In short, monkeypatches &amp;quot;monkey with&amp;quot; existing code. The existing code is often code you don&amp;#39;t have direct access to, like code from a gem or from the Ruby standard library. Patches are usually designed to alter the original code&amp;#39;s behavior to fix a bug, improve performance, etc.&lt;/p&gt;
&lt;p&gt;The most unsophisticated monkeypatches reopen ruby classes and modify behavior by adding or overriding methods.&lt;/p&gt;
&lt;p&gt;This reopening idea is core to Ruby&amp;#39;s object model. Whereas in Java, classes can only be defined once, Ruby classes (and modules for that matter) can be defined multiple times. When we define a class a second, third, fourth time, etc, we say that we&amp;#39;re &lt;em&gt;reopening&lt;/em&gt; it. Any new methods we define are added to the existing class definition and can be called on instances of that class.&lt;/p&gt;
&lt;p&gt;This short example illustrates the class reopening concept:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Sounds
  def honk
    &amp;quot;Honk!&amp;quot;
  end
end

class Sounds
  def squeak
    &amp;quot;Squeak!&amp;quot;
  end
end

sounds = Sounds.new
sounds.honk    # =&amp;gt; &amp;quot;Honk!&amp;quot;
sounds.squeak  # =&amp;gt; &amp;quot;Squeak!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that both the &lt;code&gt;#honk&lt;/code&gt; and &lt;code&gt;#squeak&lt;/code&gt; methods are available on the &lt;code&gt;Sounds&lt;/code&gt; class through the magic of reopening.&lt;/p&gt;
&lt;p&gt;Essentially, monkeypatching is the act of reopening classes in 3rd-party code.&lt;/p&gt;
&lt;h2 id=&quot;is-monkeypatching-dangerous&quot;&gt;Is Monkeypatching Dangerous?&lt;/h2&gt;
&lt;p&gt;If the previous sentence scared you, that&amp;#39;s probably a good thing. Monkeypatching, especially when done carelessly, can cause real chaos.&lt;/p&gt;
&lt;p&gt;Consider for a moment what would happen if we were to redefine &lt;code&gt;Array#&amp;lt;&amp;lt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Array
  def &amp;lt;&amp;lt;(*args)
    # do nothing 😈
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With these four lines of code, every single array instance in the entire program is now broken.&lt;/p&gt;
&lt;p&gt;What&amp;#39;s more, the original implementation of &lt;code&gt;#&amp;lt;&amp;lt;&lt;/code&gt; is gone. Aside from restarting the Ruby process, there&amp;#39;s no way to get it back.&lt;/p&gt;
&lt;h2 id=&quot;when-monkeypatching-goes-horribly-wrong&quot;&gt;When Monkeypatching Goes Horribly Wrong&lt;/h2&gt;
&lt;p&gt;Back in 2011, I worked for a prominent social networking company. At the time, the codebase was a massive Rails monolith running on Ruby 1.8.7. Several hundred engineers contributed to the codebase on a daily basis, and the pace of development was very fast.&lt;/p&gt;
&lt;p&gt;At one point, my team decided to monkeypatch &lt;code&gt;String#%&lt;/code&gt; to make writing plurals easier for internationalization purposes. Here&amp;#39;s an example of what our patch could do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;replacements = {
  horse_count: 3,
  horses: {
    one: &amp;quot;is 1 horse&amp;quot;,
    other: &amp;quot;are %{horse_count} horses&amp;quot;
  }
}

# &amp;quot;there are 3 horses in the barn&amp;quot;
&amp;quot;there %{horse_count:horses} in the barn&amp;quot; % replacements
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We wrote up the patch and eventually got it deployed into production... only to find that it didn&amp;#39;t work. Our users were seeing strings with literal &lt;code&gt;%{...}&lt;/code&gt; characters instead of nicely pluralized text. It didn&amp;#39;t make sense. The patch had worked perfectly well in the development environment on my laptop. Why wasn&amp;#39;t it working in production?&lt;/p&gt;
&lt;p&gt;Initially, we thought we&amp;#39;d found a bug in Ruby itself, only later, to find that a production Rails console produced a different result than a Rails console in development. Since both consoles ran on the same Ruby version, we could rule out a bug in the Ruby standard library. Something else was going on.&lt;/p&gt;
&lt;p&gt;After several days of head-scratching, a co-worker was able to track down a Rails initializer that added &lt;em&gt;another&lt;/em&gt; implementation of &lt;code&gt;String#%&lt;/code&gt; that none of us had seen before. To further complicate things, this earlier implementation also contained a bug, so the results we saw in the production console differed from Ruby&amp;#39;s official documentation.&lt;/p&gt;
&lt;p&gt;That&amp;#39;s not the end of the story though. In tracking down the earlier monkeypatch, we also found no less than three others, &lt;em&gt;all patching the same method.&lt;/em&gt; We looked at each other in horror. How did this ever work??&lt;/p&gt;
&lt;p&gt;We eventually chalked the inconsistent behavior up to Rails&amp;#39; eager loading. In development, Rails lazy loads Ruby files, i.e., only loads them when they are &lt;code&gt;require&lt;/code&gt;d. In production, however, Rails loads all of the app&amp;#39;s Ruby files at initialization. This can throw a big monkey wrench into monkeypatching.&lt;/p&gt;
&lt;h2 id=&quot;consequences-of-reopening-a-class&quot;&gt;Consequences of Reopening a Class&lt;/h2&gt;
&lt;p&gt;In this case, each of the monkeypatches reopened the &lt;code&gt;String&lt;/code&gt; class and effectively replaced the existing version of the &lt;code&gt;#%&lt;/code&gt; method with another one. There are several major pitfalls to this approach:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The last patch applied &amp;quot;wins&amp;quot;, meaning, behavior is dependent on load order&lt;/li&gt;
&lt;li&gt;There&amp;#39;s no way to access the original implementation&lt;/li&gt;
&lt;li&gt;Patches leave almost no audit trail, which makes them very difficult to find later&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Not surprisingly, perhaps, we ran into all of these.&lt;/p&gt;
&lt;p&gt;At first, we didn&amp;#39;t even know there were other monkeypatches at play. Because of the bug in the winning method, it appeared the original implementation was broken. When we discovered the other competing patches, it was impossible to tell which won without adding copious &lt;code&gt;puts&lt;/code&gt; statements.&lt;/p&gt;
&lt;p&gt;Finally, even when we did discover which method won in development, a different one would win in production. It was also programmatically difficult to tell which patch had been applied last since Ruby 1.8 didn&amp;#39;t have the wonderful &lt;code&gt;Method#source_location&lt;/code&gt; method we now have.&lt;/p&gt;
&lt;p&gt;I spent at least a week trying to figure out what was going on, time I essentially wasted chasing an entirely avoidable problem.&lt;/p&gt;
&lt;p&gt;Eventually, we decided to introduce the &lt;code&gt;LocalizedString&lt;/code&gt; wrapper class with an accompanying &lt;code&gt;#%&lt;/code&gt; method. Our &lt;code&gt;String&lt;/code&gt; monkeypatch then simply became:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class String
  def localize
    LocalizedString.new(self)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;when-monkeypatching-fails&quot;&gt;When Monkeypatching Fails&lt;/h2&gt;
&lt;p&gt;In my experience, monkeypatches often fail for one of two reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;The patch itself is broken.&lt;/strong&gt; In the codebase I mentioned above, not only were there several competing implementations of the same method, but the method that &amp;quot;won&amp;quot; didn&amp;#39;t work.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Assumptions are invalid.&lt;/strong&gt; The host code has been updated and the patch no longer applies as written.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;#39;s look at the second bullet point in more detail.&lt;/p&gt;
&lt;h2 id=&quot;even-the-best-laid-plans&quot;&gt;Even the Best-Laid Plans...&lt;/h2&gt;
&lt;p&gt;Monkeypatching often fails for the same reason you reached for it in the first place — because you don&amp;#39;t have access to the original code. For precisely that reason, the original code can change out from under you.&lt;/p&gt;
&lt;p&gt;Consider this example in a gem that your app depends on:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Sale
  def initialize(amount, discount_pct, tax_rate = nil)
    @amount = amount
    @discount_pct = discount_pct
    @tax_rate = tax_rate
  end

  def total
    discounted_amount + sales_tax
  end

  private

  def discounted_amount
    @amount * (1 - @discount_pct)
  end

  def sales_tax
    if @tax_rate
      discounted_amount * @tax_rate
    else
      0
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Wait, that&amp;#39;s not right. Sales tax should be applied to the full amount, not the discounted amount. You submit a pull request to the project. While you&amp;#39;re waiting for the maintainer to merge your PR, you add this monkeypatch to your app:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Sale
  private

  def sales_tax
    if @tax_rate
      @amount * @tax_rate
    else
      0
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It works perfectly. You check it in and forget about it.&lt;/p&gt;
&lt;p&gt;Everything is fine for a long time. Then one day the finance team sends you an email asking why the company hasn&amp;#39;t been collecting sales tax for a month.&lt;/p&gt;
&lt;p&gt;Confused, you start digging into the issue and eventually notice one of your co-workers recently updated the gem that contains the &lt;code&gt;Sale&lt;/code&gt; class. Here&amp;#39;s the updated code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Sale
  def initialize(amount, discount_pct, sales_tax_rate = nil)
    @amount = amount
    @discount_pct = discount_pct
    @sales_tax_rate = sales_tax_rate
  end

  def total
    discounted_amount + sales_tax
  end

  private

  def discounted_amount
    @amount * (1 - @discount_pct)
  end

  def sales_tax
    if @sales_tax_rate
      discounted_amount * @sales_tax_rate
    else
      0
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looks like one of the project maintainers renamed the &lt;code&gt;@tax_rate&lt;/code&gt; instance variable to &lt;code&gt;@sales_tax_rate&lt;/code&gt;. The monkeypatch checks the value of the old &lt;code&gt;@tax_rate&lt;/code&gt; variable, which is always &lt;code&gt;nil&lt;/code&gt;. Nobody noticed because no errors were ever raised. The app chugged along as if nothing had happened.&lt;/p&gt;
&lt;h2 id=&quot;why-monkeypatch&quot;&gt;Why Monkeypatch?&lt;/h2&gt;
&lt;p&gt;Given these examples, it might seem like monkeypatching just isn&amp;#39;t worth the potential headaches. So why do we do it? In my opinion, there are three major use-cases:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;To fix broken or incomplete 3rd-party code&lt;/li&gt;
&lt;li&gt;To quickly test a change or multiple changes in development&lt;/li&gt;
&lt;li&gt;To wrap existing functionality with instrumentation or annotation code&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In some cases, the &lt;em&gt;only&lt;/em&gt; viable way to address a bug or performance issue in 3rd-party code is to apply a monkeypatch.&lt;/p&gt;
&lt;p&gt;But with great power comes great responsibility.&lt;/p&gt;
&lt;h2 id=&quot;monkeypatching-responsibly&quot;&gt;Monkeypatching Responsibly&lt;/h2&gt;
&lt;p&gt;I like to frame the monkeypatching conversation around responsibility instead of whether or not it&amp;#39;s good or bad. Sure, monkeypatching can cause chaos when done poorly. However, if done with some care and diligence, there&amp;#39;s no reason to avoid reaching for it when the situation warrants it.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s the list of rules I try to follow:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Wrap the patch in a module with an obvious name and use &lt;code&gt;Module#prepend&lt;/code&gt; to apply it&lt;/li&gt;
&lt;li&gt;Make sure you&amp;#39;re patching the right thing&lt;/li&gt;
&lt;li&gt;Limit the patch&amp;#39;s surface area&lt;/li&gt;
&lt;li&gt;Give yourself escape hatches&lt;/li&gt;
&lt;li&gt;Over-communicate&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For the remainder of this article, we&amp;#39;re going to use these rules to write up a monkeypatch for Rails&amp;#39; &lt;code&gt;DateTimeSelector&lt;/code&gt; so it optionally skips rendering discarded fields. This is a change I actually tried to make to Rails a few years ago. &lt;a href=&quot;https://github.com/rails/rails/pull/31533&quot;&gt;You can find the details here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You don&amp;#39;t have to know much about discarded fields to understand the monkeypatch, though. At the end of the day, all it does is replace a single method called &lt;code&gt;build_hidden&lt;/code&gt; with one that effectively does nothing.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s get started!&lt;/p&gt;
&lt;h3 id=&quot;use-moduleprepend&quot;&gt;Use &lt;code&gt;Module#prepend&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;In the codebase I encountered in my previous role, all the implementations of &lt;code&gt;String#%&lt;/code&gt; were applied by reopening the &lt;code&gt;String&lt;/code&gt; class. Here&amp;#39;s an augmented list of the drawbacks I mentioned earlier:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Errors appear to have originated from the host class or module instead of from the patch code&lt;/li&gt;
&lt;li&gt;Any methods you define in the patch replace existing methods with the same name, meaning, there&amp;#39;s no way of invoking the original implementation.&lt;/li&gt;
&lt;li&gt;There&amp;#39;s no way to know which patches were applied and therefore, which methods &amp;quot;won&amp;quot;&lt;/li&gt;
&lt;li&gt;Patches leave almost no audit trail, which makes them very difficult to find later&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Instead, it&amp;#39;s much better to wrap your patch in a module and apply it using &lt;code&gt;Module#prepend&lt;/code&gt;. Doing so leaves you free to call the original implementation, and a quick call to &lt;code&gt;Module#ancestors&lt;/code&gt; will show the patch in the inheritance hierarchy so it&amp;#39;s easier to find if things go wrong.&lt;/p&gt;
&lt;p&gt;Finally, a simple &lt;code&gt;prepend&lt;/code&gt; statement is easy to comment out if you need to disable the patch for some reason.&lt;/p&gt;
&lt;p&gt;Here are the beginnings of a module for our Rails monkeypatch:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module RenderDiscardedMonkeypatch
end

ActionView::Helpers::DateTimeSelector.prepend(
  RenderDiscardedMonkeypatch
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;patch-the-right-thing&quot;&gt;Patch the Right Thing&lt;/h3&gt;
&lt;p&gt;If you take one thing away from this article, let it be this: don&amp;#39;t apply a monkeypatch unless you know you&amp;#39;re patching the right code. In most cases, it should be possible to verify programmatically that your assumptions still hold (this is Ruby after all). Here&amp;#39;s a checklist:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Make sure the class or module you&amp;#39;re trying to patch exists&lt;/li&gt;
&lt;li&gt;Make sure methods exist and have the right arity&lt;/li&gt;
&lt;li&gt;If the code you&amp;#39;re patching lives in a gem, check the gem&amp;#39;s version&lt;/li&gt;
&lt;li&gt;Bail out with a helpful error message if assumptions don&amp;#39;t hold&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Right off the bat, our patch code has made a pretty important assumption. It assumes a constant called &lt;code&gt;ActionView::Helpers::DateTimeSelector&lt;/code&gt; exists and is a class or module.&lt;/p&gt;
&lt;h3 id=&quot;check-classmodule&quot;&gt;Check Class/Module&lt;/h3&gt;
&lt;p&gt;Let&amp;#39;s ensure that constant exists before trying to patch it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module RenderDiscardedMonkeypatch
end

const = begin
  Kernel.const_get(&amp;#39;ActionView::Helpers::DateTimeSelector&amp;#39;)
rescue NameError
end

if const
  const.prepend(RenderDiscardedMonkeypatch)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great, but now we&amp;#39;ve leaked a local variable (&lt;code&gt;const&lt;/code&gt;) into the global scope. Let&amp;#39;s fix that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module RenderDiscardedMonkeypatch
  def self.apply_patch
    const = begin
      Kernel.const_get(&amp;#39;ActionView::Helpers::DateTimeSelector&amp;#39;)
    rescue NameError
    end

    if const
      const.prepend(self)
    end
  end
end

RenderDiscardedMonkeypatch.apply_patch
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;check-methods&quot;&gt;Check Methods&lt;/h3&gt;
&lt;p&gt;Next, let&amp;#39;s introduce the patched &lt;code&gt;build_hidden&lt;/code&gt; method. Let&amp;#39;s also add a check to make sure it exists and accepts the right number of arguments (i.e. has the right arity). If those assumptions don&amp;#39;t hold, something&amp;#39;s probably wrong:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module RenderDiscardedMonkeypatch
  class &amp;lt;&amp;lt; self
    def apply_patch
      const = find_const
      mtd = find_method(const)

      if const &amp;amp;&amp;amp; mtd &amp;amp;&amp;amp; mtd.arity == 2
        const.prepend(self)
      end
    end

    private

    def find_const
      Kernel.const_get(&amp;#39;ActionView::Helpers::DateTimeSelector&amp;#39;)
    rescue NameError
    end

    def find_method(const)
      return unless const
      const.instance_method(:build_hidden)
    rescue NameError
    end
  end

  def build_hidden(type, value)
    &amp;#39;&amp;#39;
  end
end

RenderDiscardedMonkeypatch.apply_patch
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;check-gem-versions&quot;&gt;Check Gem Versions&lt;/h3&gt;
&lt;p&gt;Finally, let&amp;#39;s check that we&amp;#39;re using the right version of Rails. If Rails gets upgraded, we might need to update the patch too (or get rid of it entirely).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module RenderDiscardedMonkeypatch
  class &amp;lt;&amp;lt; self
    def apply_patch
      const = find_const
      mtd = find_method(const)

      if const &amp;amp;&amp;amp; mtd &amp;amp;&amp;amp; mtd.arity == 2 &amp;amp;&amp;amp; rails_version_ok?
        const.prepend(self)
      end
    end

    private

    def find_const
      Kernel.const_get(&amp;#39;ActionView::Helpers::DateTimeSelector&amp;#39;)
    rescue NameError
    end

    def find_method(const)
      return unless const
      const.instance_method(:build_hidden)
    rescue NameError
    end

    def rails_version_ok?
      Rails::VERSION::MAJOR == 6 &amp;amp;&amp;amp; Rails::VERSION::MINOR == 1
    end
  end

  def build_hidden(type, value)
    &amp;#39;&amp;#39;
  end
end

RenderDiscardedMonkeypatch.apply_patch
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;bail-out-helpfully&quot;&gt;Bail Out Helpfully&lt;/h3&gt;
&lt;p&gt;If your verification code uncovers a discrepancy between expectations and reality, it&amp;#39;s a good idea to raise an error or at least print a helpful warning message. The idea here is to alert you and your co-workers when something seems amiss.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s how we might modify our Rails patch:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module RenderDiscardedMonkeypatch
  class &amp;lt;&amp;lt; self
    def apply_patch
      const = find_const
      mtd = find_method(const)

      unless const &amp;amp;&amp;amp; mtd &amp;amp;&amp;amp; mtd.arity == 2
        raise &amp;quot;Could not find class or method when patching &amp;quot;\
          &amp;quot;ActionView&amp;#39;s date_select helper. Please investigate.&amp;quot;
      end

      unless rails_version_ok?
        puts &amp;quot;WARNING: It looks like Rails has been upgraded since &amp;quot;\
          &amp;quot;ActionView&amp;#39;s date_select helper was monkeypatched in &amp;quot;\
          &amp;quot;#{__FILE__}. Please reevaluate the patch.&amp;quot;
      end

      const.prepend(self)
    end

    private

    def find_const
      Kernel.const_get(&amp;#39;ActionView::Helpers::DateTimeSelector&amp;#39;)
    rescue NameError
    end

    def find_method(const)
      return unless const
      const.instance_method(:build_hidden)
    rescue NameError
    end

    def rails_version_ok?
      Rails::VERSION::MAJOR == 6 &amp;amp;&amp;amp; Rails::VERSION::MINOR == 1
    end
  end

  def build_hidden(type, value)
    &amp;#39;&amp;#39;
  end
end

RenderDiscardedMonkeypatch.apply_patch
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;limit-surface-area&quot;&gt;Limit Surface Area&lt;/h3&gt;
&lt;p&gt;While it may seem perfectly innocuous to define helper methods in a monkeypatch, remember that any methods defined via &lt;code&gt;Module#prepend&lt;/code&gt; will override existing ones through the magic of inheritance. While it might seem as though a host class or module doesn&amp;#39;t define a particular method, it&amp;#39;s difficult to know for sure. For this reason, I try to only define methods I intend to patch.&lt;/p&gt;
&lt;p&gt;Note that this also applies to methods defined in the object&amp;#39;s singleton class, i.e. methods defined inside &lt;code&gt;class &amp;lt;&amp;lt; self&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s how to modify our Rails patch to only replace the one &lt;code&gt;#build_hidden&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module RenderDiscardedMonkeypatch
  class &amp;lt;&amp;lt; self
    def apply_patch
      const = find_const
      mtd = find_method(const)

      unless const &amp;amp;&amp;amp; mtd &amp;amp;&amp;amp; mtd.arity == 2
        raise &amp;quot;Could not find class or method when patching&amp;quot;\
          &amp;quot;ActionView&amp;#39;s date_select helper. Please investigate.&amp;quot;
      end

      unless rails_version_ok?
        puts &amp;quot;WARNING: It looks like Rails has been upgraded since&amp;quot;\
          &amp;quot;ActionView&amp;#39;s date_selet helper was monkeypatched in &amp;quot;\
          &amp;quot;#{__FILE__}. Please reevaluate the patch.&amp;quot;
      end

      const.prepend(InstanceMethods)
    end

    private

    def find_const
      Kernel.const_get(&amp;#39;ActionView::Helpers::DateTimeSelector&amp;#39;)
    rescue NameError
    end

    def find_method(const)
      return unless const
      const.instance_method(:build_hidden)
    rescue NameError
    end

    def rails_version_ok?
      Rails::VERSION::MAJOR == 6 &amp;amp;&amp;amp; Rails::VERSION::MINOR == 1
    end
  end

  module InstanceMethods
    def build_hidden(type, value)
      &amp;#39;&amp;#39;
    end
  end
end

RenderDiscardedMonkeypatch.apply_patch
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;give-yourself-escape-hatches&quot;&gt;Give Yourself Escape Hatches&lt;/h3&gt;
&lt;p&gt;When possible, I like to make my monkeypatch&amp;#39;s functionality opt-in. That&amp;#39;s only really an option if you have control over where the patched code is invoked. In the case of our Rails patch, it&amp;#39;s doable via the &lt;code&gt;@options&lt;/code&gt; hash in &lt;code&gt;DateTimeSelector&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module RenderDiscardedMonkeypatch
  class &amp;lt;&amp;lt; self
    def apply_patch
      const = find_const
      mtd = find_method(const)

      unless const &amp;amp;&amp;amp; mtd &amp;amp;&amp;amp; mtd.arity == 2
        raise &amp;quot;Could not find class or method when patching&amp;quot;\
          &amp;quot;ActionView&amp;#39;s date_select helper. Please investigate.&amp;quot;
      end

      unless rails_version_ok?
        puts &amp;quot;WARNING: It looks like Rails has been upgraded since&amp;quot;\
          &amp;quot;ActionView&amp;#39;s date_selet helper was monkeypatched in &amp;quot;\
          &amp;quot;#{__FILE__}. Please reevaluate the patch.&amp;quot;
      end

      const.prepend(InstanceMethods)
    end

    private

    def find_const
      Kernel.const_get(&amp;#39;ActionView::Helpers::DateTimeSelector&amp;#39;)
    rescue NameError
    end

    def find_method(const)
      return unless const
      const.instance_method(:build_hidden)
    rescue NameError
    end

    def rails_version_ok?
      Rails::VERSION::MAJOR == 6 &amp;amp;&amp;amp; Rails::VERSION::MINOR == 1
    end
  end

  module InstanceMethods
    def build_hidden(type, value)
      if @options.fetch(:render_discarded, true)
        super
      else
        &amp;#39;&amp;#39;
      end
    end
  end
end

RenderDiscardedMonkeypatch.apply_patch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nice! Now callers can opt-in by calling the &lt;code&gt;date_select&lt;/code&gt; helper with the new option. No other codepaths are affected:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;date_select(@user, :date_of_birth, {
  order: [:month, :day],
  render_discarded: false
})
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;over-communicate&quot;&gt;Over-Communicate&lt;/h3&gt;
&lt;p&gt;The last piece of advice I have for you is perhaps the most important — communicating what your patch does and when it&amp;#39;s time to re-examine it. Your goal with monkeypatches should always be to eventually remove the patch altogether. To that end, a responsible monkeypatch includes comments that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Describe what the patch does&lt;/li&gt;
&lt;li&gt;Explain why the patch is necessary&lt;/li&gt;
&lt;li&gt;Outline the assumptions the patch makes&lt;/li&gt;
&lt;li&gt;Specify a date in the future when your team should reconsider alternative solutions, like pulling in an updated gem&lt;/li&gt;
&lt;li&gt;Include links to relevant pull requests, blog posts, StackOverflow answers, etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You might even print a warning or fail a test on a predetermined date to urge the team to reconfirm the patch&amp;#39;s assumptions and consider whether or not it&amp;#39;s still necessary.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s the final version of our Rails &lt;code&gt;date_select&lt;/code&gt; patch, complete with comments and a date check:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# ActionView&amp;#39;s date_select helper provides the option to &amp;quot;discard&amp;quot; certain
# fields. Discarded fields are (confusingly) still rendered to the page
# using hidden inputs, i.e. &amp;lt;input type=&amp;quot;hidden&amp;quot; /&amp;gt;. This patch adds an
# additional option to the date_select helper that allows the caller to
# skip rendering the chosen fields altogether. For example, to render all
# but the year field, you might have this in one of your views:
#
# date_select(:date_of_birth, order: [:month, :day])
#
# or, equivalently:
#
# date_select(:date_of_birth, discard_year: true)
#
# To avoid rendering the year field altogether, set :render_discarded to
# false:
#
# date_select(:date_of_birth, discard_year: true, render_discarded: false)
#
# This patch assumes the #build_hidden method exists on
# ActionView::Helpers::DateTimeSelector and accepts two arguments.
#
module RenderDiscardedMonkeypatch
  class &amp;lt;&amp;lt; self
    EXPIRATION_DATE = Date.new(2021, 8, 15)

    def apply_patch
      if Date.today &amp;gt; EXPIRATION_DATE
        puts &amp;quot;WARNING: Please re-evaluate whether or not the ActionView &amp;quot;\
          &amp;quot;date_select patch present in #{__FILE__} is still necessary.&amp;quot;
      end

      const = find_const
      mtd = find_method(const)

      # make sure the class we want to patch exists;
      # make sure the #build_hidden method exists and accepts exactly
      # two arguments
      unless const &amp;amp;&amp;amp; mtd &amp;amp;&amp;amp; mtd.arity == 2
        raise &amp;quot;Could not find class or method when patching &amp;quot;\
          &amp;quot;ActionView&amp;#39;s date_select helper. Please investigate.&amp;quot;
      end

      # if rails has been upgraded, make sure this patch is still
      # necessary
      unless rails_version_ok?
        puts &amp;quot;WARNING: It looks like Rails has been upgraded since &amp;quot;\
          &amp;quot;ActionView&amp;#39;s date_select helper was monkeypatched in &amp;quot;\
          &amp;quot;#{__FILE__}. Please re-evaluate the patch.&amp;quot;
      end

      # actually apply the patch
      const.prepend(InstanceMethods)
    end

    private

    def find_const
      Kernel.const_get(&amp;#39;ActionView::Helpers::DateTimeSelector&amp;#39;)
    rescue NameError
      # return nil if the constant doesn&amp;#39;t exist
    end

    def find_method(const)
      return unless const
      const.instance_method(:build_hidden)
    rescue NameError
      # return nil if the method doesn&amp;#39;t exist
    end

    def rails_version_ok?
      Rails::VERSION::MAJOR == 6 &amp;amp;&amp;amp; Rails::VERSION::MINOR == 1
    end
  end

  module InstanceMethods
    # :render_discarded is an additional option you can pass to the
    # date_select helper in your views. Use it to avoid rendering
    # &amp;quot;discarded&amp;quot; fields, i.e. fields marked as discarded or simply
    # not included in date_select&amp;#39;s :order array. For example,
    # specifying order: [:day, :month] will cause the helper to
    # &amp;quot;discard&amp;quot; the :year field. Discarding a field renders it as a
    # hidden input. Set :render_discarded to false to avoid rendering
    # it altogether.
    def build_hidden(type, value)
      if @options.fetch(:render_discarded, true)
        super
      else
        &amp;#39;&amp;#39;
      end
    end
  end
end

RenderDiscardedMonkeypatch.apply_patch
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I totally get that some of the suggestions I&amp;#39;ve outlined above might seem like overkill. Our Rails patch contains way more defensive verification code than actual patch code!&lt;/p&gt;
&lt;p&gt;Think of all that extra code as a sheath for your broadsword. It&amp;#39;s a lot easier to avoid getting cut if it&amp;#39;s enveloped in a layer of protection.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-08/giphy-downsized.gif&quot; alt=&quot;Sword guitar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;What really matters, though, is that I feel confident deploying responsible monkeypatches into production. Irresponsible ones are just time bombs waiting to cost you or your company time, money, and developer health.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Ruby's Hidden Gems: Bullet</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/08/11/ruby-hidden-gems-bullet-and-how-it-integrates-with-appsignal.html">
    <id>https://blog.appsignal.com/2021/08/11/ruby-hidden-gems-bullet-and-how-it-integrates-with-appsignal.html</id>
    <published>2021-08-11T00:00:00+00:00</published>
    <updated>2021-08-11T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's dive into Bullet and find out how it can help you identify some database-related problems.</summary>
    <content type="html">&lt;p&gt;A database is the heart of many applications, and having problems with it may result in serious performance issues.&lt;/p&gt;
&lt;p&gt;ORMs such as ActiveRecord and Mongoid help us abstract implementation and deliver code faster, but sometimes, we forget to check what queries are running under the hood.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/flyerhzm/bullet&quot;&gt;bullet&lt;/a&gt; gem helps us identify some well-known database-related problems:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&amp;quot;N+1 Queries&amp;quot;: when the application runs a query to load each item of a list&lt;/li&gt;
&lt;li&gt;&amp;quot;Unused Eager Loading&amp;quot;: when the application loads data, usually to avoid N+1 queries, but doesn&amp;#39;t use it&lt;/li&gt;
&lt;li&gt;&amp;quot;Missing Counter Cache&amp;quot;: when the application needs to execute count queries to get the number of associated items&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In this post, I&amp;#39;m going to show:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;how to configure the &lt;code&gt;bullet&lt;/code&gt; gem in a Ruby project,&lt;/li&gt;
&lt;li&gt;examples of each problem mentioned before,&lt;/li&gt;
&lt;li&gt;how &lt;code&gt;bullet&lt;/code&gt; detects each,&lt;/li&gt;
&lt;li&gt;how to fix each problem, and&lt;/li&gt;
&lt;li&gt;how to integrate &lt;code&gt;bullet&lt;/code&gt; with AppSignal.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I will use some examples from &lt;a href=&quot;https://github.com/fabioperrella/bullet-test&quot;&gt;a project that I created for this post&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;how-to-configure-bullet-in-a-ruby-project&quot;&gt;How to Configure Bullet in a Ruby Project&lt;/h2&gt;
&lt;p&gt;First, add the gem to &lt;code&gt;Gemfile&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can add it to all environments given, we can enable or disable it and use a different approach on each one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;gem &amp;#39;bullet&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, it&amp;#39;s necessary to configure it.&lt;/p&gt;
&lt;p&gt;If you are in a Rails project, you can run the following command to generate the configuration code automatically:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bundle exec rails g bullet:install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you are in a non Rails project, you can add it manually, for example, by adding the following code in &lt;code&gt;spec_helper.rb&lt;/code&gt; after loading the application&amp;#39;s code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Bullet.enable        = true
Bullet.bullet_logger = true
Bullet.raise         = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And adding the following code in the main file after loading the application&amp;#39;s code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Bullet.enable = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I&amp;#39;m going to share more details on configurations in this post. If you want to see them all, go to &lt;a href=&quot;https://github.com/flyerhzm/bullet#configuration&quot;&gt;bullet&amp;#39;s README page&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;using-bullet-in-tests&quot;&gt;Using bullet In Tests&lt;/h2&gt;
&lt;p&gt;With the previously suggested configuration, Bullet will detect bad queries executed in tests and raise exceptions for them.&lt;/p&gt;
&lt;p&gt;Now, let&amp;#39;s see some examples.&lt;/p&gt;
&lt;h3 id=&quot;detecting-n1-queries&quot;&gt;Detecting N+1 Queries&lt;/h3&gt;
&lt;p&gt;Given an &lt;code&gt;index&lt;/code&gt; action as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/posts_controller.rb
class PostsController &amp;lt; ApplicationController
  def index
    @posts = Post.all
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And a view like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;# app/views/posts/index.html.erb

&amp;lt;h1&amp;gt;Posts&amp;lt;/h1&amp;gt;

&amp;lt;table&amp;gt;
  &amp;lt;thead&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
      &amp;lt;th&amp;gt;Comments&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/thead&amp;gt;

  &amp;lt;tbody&amp;gt;
    &amp;lt;% @posts.each do |post| %&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;td&amp;gt;&amp;lt;%= post.name %&amp;gt;&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;&amp;lt;%= post.comments.map(&amp;amp;:name) %&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;% end %&amp;gt;
  &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bullet&lt;/code&gt; will raise an error detecting an &amp;quot;N+1&amp;quot; when running an integrated test that executes code from the view and the controller, for example, using a request spec as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# spec/requests/posts_request_spec.rb
require &amp;#39;rails_helper&amp;#39;

RSpec.describe &amp;quot;Posts&amp;quot;, type: :request do
  describe &amp;quot;GET /index&amp;quot; do
    it &amp;#39;lists all posts&amp;#39; do
      post1 = Post.create!
      post2 = Post.create!

      get &amp;#39;/posts&amp;#39;

      expect(response.status).to eq(200)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, it will raise this exception:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Failures:

  1) Posts GET /index lists all posts
     Failure/Error: get &amp;#39;/posts&amp;#39;

     Bullet::Notification::UnoptimizedQueryError:
       user: fabioperrella
       GET /posts
       USE eager loading detected
         Post =&amp;gt; [:comments]
         Add to your query: .includes([:comments])
       Call stack
         /Users/fabioperrella/projects/bullet-test/app/views/posts/index.html.erb:17:in `map&amp;#39;
         ...
     # ./spec/requests/posts_controller_spec.rb:9:in `block (3 levels) in &amp;lt;top (required)&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This happens because the view is executing one query to load each comment name in &lt;code&gt;post.comments.map(&amp;amp;:name)&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Processing by PostsController#index as HTML
  Post Load (0.4ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot;
  ↳ app/views/posts/index.html.erb:14
  Comment Load (0.0ms)  SELECT &amp;quot;comments&amp;quot;.* FROM &amp;quot;comments&amp;quot; WHERE &amp;quot;comments&amp;quot;.&amp;quot;post_id&amp;quot; = ?  [[&amp;quot;post_id&amp;quot;, 1]]
  ↳ app/views/posts/index.html.erb:17:in `map&amp;#39;
  Comment Load (0.1ms)  SELECT &amp;quot;comments&amp;quot;.* FROM &amp;quot;comments&amp;quot; WHERE &amp;quot;comments&amp;quot;.&amp;quot;post_id&amp;quot; = ?  [[&amp;quot;post_id&amp;quot;, 2]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix it, we can simply follow the instruction in the error message and add &lt;code&gt;.includes([:comments])&lt;/code&gt; to the query:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;-@posts = Post.all
+@posts = Post.all.includes([:comments])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will instruct ActiveRecord to load all the comments with only 1 query.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Processing by PostsController#index as HTML
  Post Load (0.2ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot;
  ↳ app/views/posts/index.html.erb:14
  Comment Load (0.0ms)  SELECT &amp;quot;comments&amp;quot;.* FROM &amp;quot;comments&amp;quot; WHERE &amp;quot;comments&amp;quot;.&amp;quot;post_id&amp;quot; IN (?, ?)  [[&amp;quot;post_id&amp;quot;, 1], [&amp;quot;post_id&amp;quot;, 2]]
  ↳ app/views/posts/index.html.erb:14
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, &lt;code&gt;bullet&lt;/code&gt; will not raise an exception in a controller test like the following, because controller tests don&amp;#39;t render views by default, so the N+1 query will not be triggered.&lt;/p&gt;
&lt;p&gt;Note: &lt;a href=&quot;https://rspec.info/blog/2016/07/rspec-3-5-has-been-released/#rails-support-for-rails-5&quot;&gt;controller tests are discouraged&lt;/a&gt; since Rails 5:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# spec/controllers/posts_controller_spec.rb
require &amp;#39;rails_helper&amp;#39;

RSpec.describe PostsController do
  describe &amp;#39;GET index&amp;#39; do
    it &amp;#39;lists all posts&amp;#39; do
      post1 = Post.create!
      post2 = Post.create!

      get :index

      expect(response.status).to eq(200)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another example of a test that Bullet will not detect an &amp;quot;N+1&amp;quot; is a view test because, in this case, it will not run the N+1 queries in the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# spec/views/posts/index.html.erb_spec.rb
require &amp;#39;rails_helper&amp;#39;

describe &amp;quot;posts/index.html.erb&amp;quot; do
  it &amp;#39;lists all posts&amp;#39; do
    post1 = Post.create!(name: &amp;#39;post1&amp;#39;)
    post2 = Post.create!(name: &amp;#39;post2&amp;#39;)

    assign(:posts, [post1, post2])

    render

    expect(rendered).to include(&amp;#39;post1&amp;#39;)
    expect(rendered).to include(&amp;#39;post2&amp;#39;)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;a-tip-to-have-more-chances-to-detect-an-n1-in-tests&quot;&gt;A Tip to Have More Chances to Detect an N+1 in Tests&lt;/h3&gt;
&lt;p&gt;I recommend creating at least 1 request spec for each controller action, just to test if it returns the correct HTTP status, then &lt;code&gt;bullet&lt;/code&gt; will be watching the queries when rendering these views.&lt;/p&gt;
&lt;h3 id=&quot;detecting-unused-eager-loading&quot;&gt;Detecting Unused Eager Loading&lt;/h3&gt;
&lt;p&gt;Given the following &lt;code&gt;basic_index&lt;/code&gt; action:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/posts_controller.rb
class PostsController &amp;lt; ApplicationController
  def basic_index
    @posts = Post.all.includes(:comments)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the following &lt;code&gt;basic_index&lt;/code&gt; view:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;# app/views/posts/basic_index.html.erb

&amp;lt;h1&amp;gt;Posts&amp;lt;/h1&amp;gt;

&amp;lt;table&amp;gt;
  &amp;lt;thead&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/thead&amp;gt;

  &amp;lt;tbody&amp;gt;
    &amp;lt;% @posts.each do |post| %&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;td&amp;gt;&amp;lt;%= post.name %&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;% end %&amp;gt;
  &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we run the following test:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# spec/requests/posts_request_spec.rb
require &amp;#39;rails_helper&amp;#39;

RSpec.describe &amp;quot;Posts&amp;quot;, type: :request do
  describe &amp;quot;GET /basic_index&amp;quot; do
    it &amp;#39;lists all posts&amp;#39; do
      post1 = Post.create!
      post2 = Post.create!

      get &amp;#39;/posts/basic_index&amp;#39;

      expect(response.status).to eq(200)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Bullet will raise the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1) Posts GET /basic_index lists all posts
     Failure/Error: get &amp;#39;/posts/basic_index&amp;#39;

     Bullet::Notification::UnoptimizedQueryError:
       user: fabioperrella
       GET /posts/basic_index
       AVOID eager loading detected
         Post =&amp;gt; [:comments]
         Remove from your query: .includes([:comments])
       Call stack
         /Users/fabioperrella/projects/bullet-test/spec/requests/posts_request_spec.rb:20:in `block (3 levels) in &amp;lt;top (required)&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This happens because it&amp;#39;s not necessary to load the list of comments for this view.&lt;/p&gt;
&lt;p&gt;To fix the problem, we can simply follow the instruction in the error above and remove the query &lt;code&gt;.includes([:comments])&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt;-@posts = Post.all.includes(:comments)
+@posts = Post.all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;#39;s worth saying that it will not raise the same error if we run only a controller test, without &lt;code&gt;render_views&lt;/code&gt;, as shown before.&lt;/p&gt;
&lt;h3 id=&quot;detecting-missing-counter-cache&quot;&gt;Detecting Missing Counter Cache&lt;/h3&gt;
&lt;p&gt;Given a controller like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/posts_controller.rb
class PostsController &amp;lt; ApplicationController
  def index_with_counter
    @posts = Post.all
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And a view like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;# app/views/posts/index_with_counter.html.erb

&amp;lt;h1&amp;gt;Posts&amp;lt;/h1&amp;gt;

&amp;lt;table&amp;gt;
  &amp;lt;thead&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
      &amp;lt;th&amp;gt;Number of comments&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
  &amp;lt;/thead&amp;gt;

  &amp;lt;tbody&amp;gt;
    &amp;lt;% @posts.each do |post| %&amp;gt;
    &amp;lt;tr&amp;gt;
      &amp;lt;td&amp;gt;&amp;lt;%= post.name %&amp;gt;&amp;lt;/td&amp;gt;
      &amp;lt;td&amp;gt;&amp;lt;%= post.comments.size %&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;% end %&amp;gt;
  &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run the following request spec:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;describe &amp;quot;GET /index_with_counter&amp;quot; do
  it &amp;#39;lists all posts&amp;#39; do
    post1 = Post.create!
    post2 = Post.create!

    get &amp;#39;/posts/index_with_counter&amp;#39;

    expect(response.status).to eq(200)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;bullet&lt;/code&gt; will raise the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1) Posts GET /index_with_counter lists all posts
  Failure/Error: get &amp;#39;/posts/index_with_counter&amp;#39;

  Bullet::Notification::UnoptimizedQueryError:
    user: fabioperrella
    GET /posts/index_with_counter
    Need Counter Cache
      Post =&amp;gt; [:comments]
  # ./spec/requests/posts_request_spec.rb:31:in `block (3 levels) in &amp;lt;top (required)&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This happens because this view is executing 1 query to count the number of comments in &lt;code&gt;post.comments.size&lt;/code&gt; for each post.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Processing by PostsController#index_with_counter as HTML
  ↳ app/views/posts/index_with_counter.html.erb:14
  Post Load (0.4ms)  SELECT &amp;quot;posts&amp;quot;.* FROM &amp;quot;posts&amp;quot;
  ↳ app/views/posts/index_with_counter.html.erb:14
   (0.4ms)  SELECT COUNT(*) FROM &amp;quot;comments&amp;quot; WHERE &amp;quot;comments&amp;quot;.&amp;quot;post_id&amp;quot; = ?  [[&amp;quot;post_id&amp;quot;, 1]]
  ↳ app/views/posts/index_with_counter.html.erb:17
   (0.1ms)  SELECT COUNT(*) FROM &amp;quot;comments&amp;quot; WHERE &amp;quot;comments&amp;quot;.&amp;quot;post_id&amp;quot; = ?  [[&amp;quot;post_id&amp;quot;, 2]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix this, we can create a counter cache, which can be a bit complex, especially if there is data in the production database.&lt;/p&gt;
&lt;p&gt;A counter cache is a column that we can add to a table, that ActiveRecord will update automatically when we insert and delete associated models. There are more details in &lt;a href=&quot;/2018/06/19/activerecords-counter-cache.html&quot;&gt;this post&lt;/a&gt;. I suggest reading it to know how to create and sync the counter cache.&lt;/p&gt;
&lt;h2 id=&quot;using-bullet-in-development&quot;&gt;Using Bullet in Development&lt;/h2&gt;
&lt;p&gt;Sometimes, tests might not detect the problems previously mentioned, for example, if test coverage is low, so it&amp;#39;s possible to enable &lt;code&gt;bullet&lt;/code&gt; in other environments using different approaches.&lt;/p&gt;
&lt;p&gt;In the development environment, we can enable the following configurations:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Bullet.alert         = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, it will show alerts like this in the browser:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-08/bullet-alert.png&quot; alt=&quot;bullet adding an alert in the browser&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Bullet.add_footer    = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will add a footer on the page with the error:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-08/bullet-footer.png&quot; alt=&quot;bullet adding a footer to the page&quot;/&gt;&lt;/p&gt;
&lt;p&gt;It&amp;#39;s also possible to enable errors to be logged in the browser&amp;#39;s console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Bullet.console    = true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will add an error like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-08/bullet-console.png&quot; alt=&quot;bullet adding a message in the console&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;using-bullet-in-staging-with-appsignal&quot;&gt;Using Bullet in Staging with Appsignal&lt;/h2&gt;
&lt;p&gt;In the &lt;em&gt;staging&lt;/em&gt; environment, we don&amp;#39;t want these error messages to be shown to end-users, but it would be great to know if the application starts to have one of the problems mentioned previously.&lt;/p&gt;
&lt;p&gt;At the same time, &lt;code&gt;bullet&lt;/code&gt; may degrade performance and increase memory consumption in the application, so it&amp;#39;s better to enable it only temporarily in &lt;em&gt;staging&lt;/em&gt;, but don&amp;#39;t enable it in &lt;em&gt;production&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Assuming the &lt;em&gt;staging&lt;/em&gt; environment is using the same configuration file as the &lt;em&gt;production&lt;/em&gt; environment, which is a good practice to reduce the difference between them, we can use an environment variable to enable or disable &lt;code&gt;bullet&lt;/code&gt; as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/environments/production.rb
config.after_initialize do
  Bullet.enabled   = ENV.fetch(&amp;#39;BULLET_ENABLED&amp;#39;, false)
  Bullet.appsignal = true
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To receive notifications about issues Bullet has found in your staging environment, you can use AppSignal to report those notifications as errors. You&amp;#39;ll need to have the &lt;code&gt;appsignal&lt;/code&gt; gem installed and configured in your project. You can see more details in the &lt;a href=&quot;https://docs.appsignal.com/ruby/installation/&quot;&gt;Ruby gem docs&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Then, if a problem is detected by &lt;code&gt;bullet&lt;/code&gt;, it will create an error incident like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-08/bullet-error-on-appsignal.png&quot; alt=&quot;bullet error on Appsignal&quot;/&gt;&lt;/p&gt;
&lt;p&gt;This error is raised by the &lt;a href=&quot;https://github.com/flyerhzm/uniform_notifier&quot;&gt;uniform_notifier gem&lt;/a&gt; which was extracted from &lt;code&gt;bullet&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Unfortunately, the error message doesn&amp;#39;t show enough information, but I sent in &lt;a href=&quot;https://github.com/flyerhzm/uniform_notifier/pull/69&quot;&gt;a Pull Request to improve this&lt;/a&gt;!&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;bullet&lt;/code&gt; gem is a great tool that can help us detect problems that will degrade performance in applications.&lt;/p&gt;
&lt;p&gt;Try to keep good test coverage, as previously mentioned, to have greater chances of detecting these problems before going to production.&lt;/p&gt;
&lt;p&gt;As an extra tip, if you want to be even more protected against performance problems related to the database, take a look at the &lt;a href=&quot;https://github.com/WeTransfer/wt-activerecord-index-spy&quot;&gt;wt-activerecord-index-spy&lt;/a&gt; gem, which helps to detect queries that are not using proper indexes.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>An Introduction to Pattern Matching in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/07/28/introduction-to-pattern-matching-in-ruby.html">
    <id>https://blog.appsignal.com/2021/07/28/introduction-to-pattern-matching-in-ruby.html</id>
    <published>2021-07-28T00:00:00+00:00</published>
    <updated>2021-07-28T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Find out about pattern matching in Ruby, what it does, and how it can help improve code readability.</summary>
    <content type="html">&lt;p&gt;Let&amp;#39;s start with a brief discussion about pattern matching in Ruby, what it does, and how it can help improve code readability.&lt;/p&gt;
&lt;p&gt;If you are anything like me a few years ago, you might confuse it with pattern matching in Regex. Even a quick Google search of &amp;#39;pattern matching&amp;#39; with no other context brings you content that&amp;#39;s pretty close to that definition.&lt;/p&gt;
&lt;p&gt;Formally, pattern matching is the process of checking any data (be it a sequence of characters, a series of tokens, a tuple, or anything else) against other data.&lt;/p&gt;
&lt;p&gt;In terms of programming, depending on the capabilities of the language, this could mean any of the following:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Matching against an expected data type&lt;/li&gt;
&lt;li&gt;Matching against an expected hash structure (e.g. presence of specific keys)&lt;/li&gt;
&lt;li&gt;Matching against an expected array length&lt;/li&gt;
&lt;li&gt;Assigning the matches (or a part of them) to some variables&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;My first foray into pattern matching was through Elixir. Elixir has &lt;a href=&quot;https://elixir-lang.org/getting-started/pattern-matching.html&quot;&gt;first class support&lt;/a&gt; for pattern matching, so much so that the &lt;code&gt;=&lt;/code&gt; operator is, in fact, the &lt;code&gt;match&lt;/code&gt; operator, rather than simple assignment.&lt;/p&gt;
&lt;p&gt;This means that in Elixir, the following is actually valid code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-elixir&quot;&gt;iex&amp;gt; x = 1
iex&amp;gt; 1 = x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that in mind, let&amp;#39;s look at the new pattern matching support for Ruby 2.7+ and how we can use it to make our code more readable, starting from today.&lt;/p&gt;
&lt;h2 id=&quot;ruby-pattern-matching-with-casein&quot;&gt;Ruby Pattern Matching with &lt;code&gt;case&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Ruby supports pattern matching with a special &lt;code&gt;case&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; expression. The syntax is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;case &amp;lt;expression&amp;gt;
in &amp;lt;pattern1&amp;gt;
  # ...
in &amp;lt;pattern2&amp;gt;
  # ...
else
  # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is not to be confused with the &lt;code&gt;case&lt;/code&gt;/&lt;code&gt;when&lt;/code&gt; expression. &lt;code&gt;when&lt;/code&gt; and &lt;code&gt;in&lt;/code&gt; branches cannot be mixed in a single &lt;code&gt;case&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If you do not provide an &lt;code&gt;else&lt;/code&gt; expression, any failing match will raise a &lt;code&gt;NoMatchingPatternError&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;pattern-matching-arrays-in-ruby&quot;&gt;Pattern Matching Arrays in Ruby&lt;/h2&gt;
&lt;p&gt;Pattern matching can be used to match arrays to pre-required structures against data types, lengths or values.&lt;/p&gt;
&lt;p&gt;For example, all of the following are matches (note that only the first &lt;code&gt;in&lt;/code&gt; will be evaluated, as &lt;code&gt;case&lt;/code&gt; stops looking after the first match):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;case [1, 2, &amp;quot;Three&amp;quot;]
in [Integer, Integer, String]
  &amp;quot;matches&amp;quot;
in [1, 2, &amp;quot;Three&amp;quot;]
  &amp;quot;matches&amp;quot;
in [Integer, *]
  &amp;quot;matches&amp;quot; # because * is a spread operator that matches anything
in [a, *]
  &amp;quot;matches&amp;quot; # and the value of the variable a is now 1
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This type of pattern matching clause is very useful when you want to produce multiple signals from a method call.&lt;/p&gt;
&lt;p&gt;In the Elixir world, this is frequently used when performing operations that could have both an &lt;code&gt;:ok&lt;/code&gt; result and an &lt;code&gt;:error&lt;/code&gt; result, for example, inserted into a database.&lt;/p&gt;
&lt;p&gt;Here is how we can use it for better readability:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def create
  case save(model_params)
  in [:ok, model]
    render :json =&amp;gt; model
  in [:error, errors]
    render :json =&amp;gt; errors
  end
end

# Somewhere in your code, e.g. inside a global helper or your model base class (with a different name).
def save(attrs)
  model = Model.new(attrs)
  model.save ? [:ok, model] : [:error, model.errors]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;pattern-matching-objects-in-ruby&quot;&gt;Pattern Matching Objects in Ruby&lt;/h2&gt;
&lt;p&gt;You can also match objects in Ruby to enforce a specific structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;case {a: 1, b: 2}
in {a: Integer}
  &amp;quot;matches&amp;quot; # By default, all object matches are partial
in {a: Integer, **}
  &amp;quot;matches&amp;quot; # and is same as {a: Integer}
in {a: a}
  &amp;quot;matches&amp;quot; # and the value of variable a is now 1
in {a: Integer =&amp;gt; a}
  &amp;quot;matches&amp;quot; # and the value of variable a is now 1
in {a: 1, b: b}
  &amp;quot;matches&amp;quot; # and the value of variable b is now 2
in {a: Integer, **nil}
  &amp;quot;does not match&amp;quot; # This will match only if the object has a and no other keys
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works great when imposing strong rules for matching against any params.&lt;/p&gt;
&lt;p&gt;For example, if you are writing a fancy greeter, it could have the following (strongly opinionated) structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def greet(hash = {})
  case hash
  in {greeting: greeting, first_name: first_name, last_name: last_name}
    greet(greeting: greeting, name: &amp;quot;#{first_name} #{last_name}&amp;quot;)
  in {greeting: greeting, name: name}
    puts &amp;quot;#{greeting}, #{name}&amp;quot;
  in {name: name}
    greet(greeting: &amp;quot;Hello&amp;quot;, name: name)
  in {greeting: greeting}
    greet(greeting: greeting, name: &amp;quot;Anonymous&amp;quot;)
  else
    greet(greeting: &amp;quot;Hello&amp;quot;, name: &amp;quot;Anonymous&amp;quot;)
  end
end

greet # Hello, Anonymous
greet(name: &amp;quot;John&amp;quot;) # Hello, John
greet(first_name: &amp;quot;John&amp;quot;, last_name: &amp;quot;Doe&amp;quot;) # Hello, John Doe
greet(greeting: &amp;quot;Bonjour&amp;quot;, first_name: &amp;quot;John&amp;quot;, last_name: &amp;quot;Doe&amp;quot;) # Bonjour, John Doe
greet(greeting: &amp;quot;Bonjour&amp;quot;) # Bonjour, Anonymous
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;variable-binding-and-pinning-in-ruby&quot;&gt;Variable Binding and Pinning in Ruby&lt;/h2&gt;
&lt;p&gt;As we have seen in some of the above examples, pattern matching is really useful in assigning part of the patterns to arbitrary variables.
This is called variable binding, and there are several ways we can bind to a variable:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;With a strong type match, e.g. &lt;code&gt;in [Integer =&amp;gt; a]&lt;/code&gt; or &lt;code&gt;in {a: Integer =&amp;gt; a}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Without the type specification, e.g. &lt;code&gt;in [a, 1, 2]&lt;/code&gt; or &lt;code&gt;in {a: a}&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Without the variable name, which defaults to using the key name, e.g. &lt;code&gt;in {a:}&lt;/code&gt; will define a variable named &lt;code&gt;a&lt;/code&gt; with the value at key &lt;code&gt;a&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Bind rest, e.g. &lt;code&gt;in [Integer, *rest]&lt;/code&gt; or &lt;code&gt;in {a: Integer, **rest}&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;How, then, can we match when we want to use an existing variable as a sub-pattern? This is when we can use variable &lt;em&gt;pinning&lt;/em&gt; with the &lt;code&gt;^&lt;/code&gt; (pin) operator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;a = 1
case {a: 1, b: 2}
in {a: ^a}
  &amp;quot;matches&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can even use this when a variable is defined in a pattern itself, allowing you to write powerful patterns like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;case order
in {billing_address: {city:}, shipping_address: {city: ^city}}
  puts &amp;quot;both billing and shipping are to the same city&amp;quot;
else
  raise &amp;quot;both billing and shipping must be to the same city&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;One important quirk to mention with variable binding is that even if the pattern doesn&amp;#39;t fully match, the variable will still have been bound.
This can sometimes be useful.&lt;/p&gt;
&lt;p&gt;But, in most cases, this could also be a cause of subtle bugs — so make sure that you don&amp;#39;t rely on shadowed variable values that have been used inside a match.
For example, in the following, you would expect the city to be &amp;quot;Amsterdam&amp;quot;, but it would instead be &amp;quot;Berlin&amp;quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;city = &amp;quot;Amsterdam&amp;quot;
order = {billing_address: {city: &amp;quot;Berlin&amp;quot;}, shipping_address: {city: &amp;quot;Zurich&amp;quot;}}
case order
in {billing_address: {city:}, shipping_address: {city: ^city}}
  puts &amp;quot;both billing and shipping are to the same city&amp;quot;
else
  puts &amp;quot;both billing and shipping must be to the same city&amp;quot;
end
puts city # Berlin instead of Amsterdam
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;matching-rubys-custom-classes&quot;&gt;Matching Ruby&amp;#39;s Custom Classes&lt;/h2&gt;
&lt;p&gt;You can implement some special methods to make custom classes pattern matching aware in Ruby.&lt;/p&gt;
&lt;p&gt;For example, to pattern match a user against his &lt;code&gt;first_name&lt;/code&gt; and &lt;code&gt;last_name&lt;/code&gt;, we can define &lt;code&gt;deconstruct_keys&lt;/code&gt; on the class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User
  def deconstruct_keys(keys)
    {first_name: first_name, last_name: last_name}
  end
end

case user
in {first_name: &amp;quot;John&amp;quot;}
  puts &amp;quot;Hey, John&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;keys&lt;/code&gt; argument to &lt;code&gt;deconstruct_keys&lt;/code&gt; contains the keys that have been requested in the pattern.
This is a way for the receiver to provide only the required keys if computing all of them is expensive.&lt;/p&gt;
&lt;p&gt;In the same way as &lt;code&gt;deconstruct_keys&lt;/code&gt;, we could provide an implementation of &lt;code&gt;deconstruct&lt;/code&gt; to allow objects to be pattern matched as an array.
For example, let&amp;#39;s say we have a &lt;code&gt;Location&lt;/code&gt; class that has latitude and longitude. In addition to using &lt;code&gt;deconstruct_keys&lt;/code&gt; to provide latitude and longitude keys, we could expose an array in the form of &lt;code&gt;[latitude, longitude]&lt;/code&gt; as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Location
  def deconstruct
    [latitude, longitude]
  end
end

case location
in [Float =&amp;gt; latitude, Float =&amp;gt; longitude]
  puts &amp;quot;#{latitude}, #{longitude}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;using-guards-for-complex-patterns&quot;&gt;Using Guards for Complex Patterns&lt;/h2&gt;
&lt;p&gt;If we have complex patterns that cannot be represented with regular pattern match operators, we can also use an &lt;code&gt;if&lt;/code&gt; (or &lt;code&gt;unless&lt;/code&gt;) statement to provide a guard for the match:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;case [1, 2]
in [a, b] if b == a * 2
  &amp;quot;matches&amp;quot;
else
  &amp;quot;no match&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;pattern-matching-with-in-without-case&quot;&gt;Pattern Matching with &lt;code&gt;=&amp;gt;&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; Without &lt;code&gt;case&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;If you are on Ruby 3+, you have access to even more pattern matching magic. Starting from Ruby 3, pattern matching can be done in a single line without a case statement:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;[1, 2, &amp;quot;Three&amp;quot;] =&amp;gt; [Integer =&amp;gt; one, two, String =&amp;gt; three]
puts one # 1
puts two # 2
puts three # Three

# Same as above
[1, 2, &amp;quot;Three&amp;quot;] in [Integer =&amp;gt; one, two, String =&amp;gt; three]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Given that the above syntax does not have an &lt;code&gt;else&lt;/code&gt; clause, it is most useful when the data structure is known beforehand.&lt;/p&gt;
&lt;p&gt;As an example, this pattern could fit well inside a base controller that allows only admin users:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class AdminController &amp;lt; AuthenticatedController
  before_action :verify_admin

  private

  def verify_admin
    Current.user =&amp;gt; {role: :admin}
  rescue NoMatchingPatternError
    raise NotAllowedError
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;pattern-matching-in-ruby-watch-this-space&quot;&gt;Pattern Matching in Ruby: Watch This Space&lt;/h2&gt;
&lt;p&gt;At first, pattern matching can feel a bit strange to grasp.
To some, it might feel like glorified object/array deconstruction.&lt;/p&gt;
&lt;p&gt;But if the popularity of Elixir is any indication, pattern matching is a great tool to have in your arsenal.
Having first-hand experience using it on Elixir, I can confirm that it is hard to live without once you get used to it.&lt;/p&gt;
&lt;p&gt;If you are on Ruby 2.7, pattern matching (with &lt;code&gt;case&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt;) is still experimental. With Ruby 3, &lt;code&gt;case&lt;/code&gt;/&lt;code&gt;in&lt;/code&gt; has moved to stable while the newly introduced single-line pattern matching expressions are experimental.
Warnings can be turned off with &lt;code&gt;Warning[:experimental] = false&lt;/code&gt; in code or &lt;code&gt;-W:no-experimental&lt;/code&gt; command-line key.&lt;/p&gt;
&lt;p&gt;Even though pattern matching in Ruby is still in its early stages, I hope you&amp;#39;ve found this introduction useful and that you&amp;#39;re as excited as I am about future developments to come!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you’d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>General Ruby on Rails Problems and Takeaways</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/07/07/general-ruby-on-rails-problems-and-takeaways.html">
    <id>https://blog.appsignal.com/2021/07/07/general-ruby-on-rails-problems-and-takeaways.html</id>
    <published>2021-07-07T00:00:00+00:00</published>
    <updated>2021-07-07T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In this last part of the Rails Patterns and Anti-patterns series, I'll be going over the most common problems I've encountered while building and shipping Ruby on Rails applications.</summary>
    <content type="html">&lt;p&gt;Welcome to the last part of my Ruby on Rails Patterns and Anti-Patterns series. It&amp;#39;s been quite a ride writing and researching all of these topics. In this blog post, we&amp;#39;ll go over the most common problems I&amp;#39;ve encountered when building and shipping Ruby on Rails applications through the years.&lt;/p&gt;
&lt;p&gt;The ideas I&amp;#39;ll go through here apply to almost anywhere in the code. So consider them as general ideas, not something related to the Model-View-Controller pattern. If you are interested in patterns and anti-patterns related to the Rails MVC, you can check out the &lt;a href=&quot;/2020/11/18/rails-model-patterns-and-anti-patterns.html&quot;&gt;Model&lt;/a&gt;, &lt;a href=&quot;/2021/02/10/ruby-on-rails-view-patterns-and-anti-patterns.html&quot;&gt;View&lt;/a&gt;, and &lt;a href=&quot;/2021/04/14/ruby-on-rails-controller-patterns-and-anti-patterns.html&quot;&gt;Controller&lt;/a&gt; blog posts.&lt;/p&gt;
&lt;p&gt;So let&amp;#39;s jump into general problems and takeaways.&lt;/p&gt;
&lt;h2 id=&quot;selfish-objects-and-the-law-of-demeter&quot;&gt;Selfish Objects and the Law of Demeter&lt;/h2&gt;
&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Law_of_Demeter&quot;&gt;Law of Demeter&lt;/a&gt; is a heuristic that got its name when a group of people worked on the Demeter Project. The idea is that your objects are fine as long as they call one method at a time and don&amp;#39;t chain multiple method calls. What this means in practice is the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Bad
song.label.address

# Good
song.label_address
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now, the &lt;code&gt;song&lt;/code&gt; object no longer needs to know where the address comes from — the address is the responsibility of the &lt;code&gt;label&lt;/code&gt; object. You are encouraged to chain only one method call and make your objects &amp;#39;selfish&amp;#39; so that they don&amp;#39;t share their full information directly but through helper methods.&lt;/p&gt;
&lt;p&gt;Luckily, in Rails, you don&amp;#39;t have to write a helper method per se — you can use the &lt;code&gt;delegate&lt;/code&gt; helper:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def Label &amp;lt; ApplicationModel
  belongs_to :song

  delegate :address, to: :song
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can go ahead and play around with the options that delegate accepts in &lt;a href=&quot;https://apidock.com/rails/Module/delegate&quot;&gt;delegete&amp;#39;s docs&lt;/a&gt;. But the idea and execution are pretty simple. By applying the Law of Demeter, you reduce structural coupling. Together with the powerful &lt;code&gt;delegate&lt;/code&gt;, you do it in fewer lines and with great options included.&lt;/p&gt;
&lt;p&gt;Another idea that&amp;#39;s very similar to the Law of Demeter is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-responsibility_principle&quot;&gt;Single-responsibility Principle&lt;/a&gt; (or SRP for short). It states that a module, class, or function should be responsible for a single part of a system. Or, presented in another way:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Gather together the things that change for the same reasons. Separate those things that change for different reasons.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Folks can often have a different understanding of SRP, but the idea is to keep your building blocks responsible for a single thing. It might be challenging to achieve SRP as your Rails app expands, but be aware of it when refactoring.&lt;/p&gt;
&lt;p&gt;When adding features and increasing the LOC, I&amp;#39;ve found that folks often reach out for a quick solution. So let&amp;#39;s go through grabbing the quick fix.&lt;/p&gt;
&lt;h2 id=&quot;i-know-a-guy-do-you-need-that-ruby-gem&quot;&gt;I Know a Guy (Do You Need That Ruby Gem?)&lt;/h2&gt;
&lt;p&gt;Back in the day when Rails was a hot topic, there was a boom in open-source collaboration, with new Ruby gems popping up on every corner (like it is nowadays with all the emerging JavaScript libraries, but on a much smaller scale):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-07/npm-vs-rubygems.png&quot; alt=&quot;NPM vs RubyGems&quot;/&gt;
👆 Information from &lt;a href=&quot;http://www.modulecounts.com/&quot;&gt;Module Counts&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Anyway, a common approach was to find an existing gem to solve your problem.&lt;/p&gt;
&lt;p&gt;There&amp;#39;s nothing wrong with that, but I&amp;#39;d like to share some bits of advice before you decide to install a gem.&lt;/p&gt;
&lt;p&gt;First, ask yourself these questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What portion of the gem&amp;#39;s features are you going to use?&lt;/li&gt;
&lt;li&gt;Is there a similar gem out there that is &amp;#39;simpler&amp;#39; or more up-to-date?&lt;/li&gt;
&lt;li&gt;Can you implement the feature you need easily and with confidence?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Evaluate whether it&amp;#39;s worth doing the implementation if you don&amp;#39;t plan to use the whole array of gem features. Or, if the gem&amp;#39;s implementation is too complex and you believe you can do it more simply, opt for a custom solution.&lt;/p&gt;
&lt;p&gt;Another factor that I consider is how active the gem&amp;#39;s repository is — are there any active maintainers? When was the last time a release happened?&lt;/p&gt;
&lt;p&gt;You should also watch out for the gem&amp;#39;s dependencies. You don&amp;#39;t want to get locked into a specific version of a dependency, so always check the &lt;code&gt;Gemfile.spec&lt;/code&gt; file. Consult the &lt;a href=&quot;https://guides.rubygems.org/patterns/#pessimistic-version-constraint&quot;&gt;RubyGems way of specifying gem versions&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;While we&amp;#39;re on the topic of gems, there is a related idea that I&amp;#39;ve encountered: the &amp;#39;Not Invented Here&amp;#39; (or NIH) phenomenon that applies to the Rails/Ruby world. Let&amp;#39;s see what it&amp;#39;s about in the next section.&lt;/p&gt;
&lt;h2 id=&quot;not-invented-here-maybe-you-need-that-ruby-gem-after-all&quot;&gt;Not Invented Here (Maybe You Need That Ruby Gem after All?)&lt;/h2&gt;
&lt;p&gt;In a couple of occurrences in my career, I had a chance to experience people (me included) fall for &amp;#39;Not Invented Here&amp;#39; syndrome. The idea is similar to &amp;#39;reinventing the wheel&amp;#39;. Sometimes, teams and organizations do not trust libraries (gems) that they can&amp;#39;t control. Lack of trust might be a trigger for them to reinvent a gem that is already out there.&lt;/p&gt;
&lt;p&gt;Sometimes, experiencing NIH can be a good thing. Making an in-house solution can be great, especially if you improve it over the other solutions out there. If you decide to open-source the solution, that can be even better (take a look at Ruby on Rails or React). But if you want to reinvent the wheel for the sake of it, don&amp;#39;t do it. The wheel itself is pretty great already.&lt;/p&gt;
&lt;p&gt;This topic is quite tricky, and if you ever get caught in such a situation, ask yourself these questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Are we confident that we can make a better solution than existing ones?&lt;/li&gt;
&lt;li&gt;If the existing open-source solution differs from what we need, can we make an open-source contribution and improve it?&lt;/li&gt;
&lt;li&gt;Furthermore, can we become the maintainers of the open-source solution and possibly improve lots of developers&amp;#39; lives?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But sometimes, you just have to go your own way and create a library yourself. Maybe your organization doesn&amp;#39;t like licensing an open-source library, so you are forced to build your own. But whatever you do, I&amp;#39;d say avoid reinventing the wheel.&lt;/p&gt;
&lt;h2 id=&quot;lifeguard-on-duty-over-rescuing-exceptions&quot;&gt;Lifeguard on Duty (Over-rescuing Exceptions)&lt;/h2&gt;
&lt;p&gt;People tend to rescue more exceptions than they originally aimed for.&lt;/p&gt;
&lt;p&gt;This topic is a bit more related to the code than the previous ones. It might be common sense to some, but it can be seen in the code from time to time. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;begin
  song.upload_lyrics
rescue
  puts &amp;#39;Lyrics upload failed&amp;#39;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we don&amp;#39;t specify the exception we want to rescue, we will catch some exceptions that we didn&amp;#39;t plan to.&lt;/p&gt;
&lt;p&gt;In this case, the problem might be that the &lt;code&gt;song&lt;/code&gt; object is &lt;code&gt;nil&lt;/code&gt;. When that exception gets reported to the error tracker, you might think that something is off with the upload process, whereas actually, you might be experiencing something totally different.&lt;/p&gt;
&lt;p&gt;So, to be safe, when rescuing exceptions, make sure you get a list of all the exceptions that might occur. If you can&amp;#39;t obtain every exception for some reason, it&amp;#39;s better to under-rescue than to over-rescue. Rescue the exceptions that you know and handle the others at a later stage.&lt;/p&gt;
&lt;h2 id=&quot;you-ask-too-much-too-many-sql-queries&quot;&gt;You Ask Too Much (Too Many SQL Queries)&lt;/h2&gt;
&lt;p&gt;In this section, we are going to go through another web development, relation-database problem.&lt;/p&gt;
&lt;p&gt;You bomb the webserver with too many SQL queries in one request. How does that problem arise? Well, it can happen if you try to fetch multiple records from multiple tables in one request. But what most often happens is the infamous N+1 query problem.&lt;/p&gt;
&lt;p&gt;Imagine the following models:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Song &amp;lt; ApplicationRecord
  belongs_to :artist
end

class Artist &amp;lt; ApplicationRecord
  has_many :songs
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we want to show a couple of songs in a genre and their artists:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;songs = Song.where(genre: genre).limit(10)

songs.each do |song|
  puts &amp;quot;#{song.title} by #{song.artist.name}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This piece of code will trigger one SQL query to get ten songs. After that, one extra SQL query will be performed to fetch the artist for each song. That&amp;#39;s eleven (11) queries total.&lt;/p&gt;
&lt;p&gt;Imagine the scenario if we load more songs — we&amp;#39;ll put the database under a heavier load trying to get all the artists.&lt;/p&gt;
&lt;p&gt;Alternatively, use &lt;code&gt;includes&lt;/code&gt; from Rails:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;songs = Song.includes(:artists).where(genre: genre).limit(10)

songs.each do |song|
  puts &amp;quot;#{song.title} by #{song.artist.name}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the &lt;code&gt;includes&lt;/code&gt;, we now only get two SQL queries, no matter how many songs we decide to show. How neat.&lt;/p&gt;
&lt;p&gt;One way you can diagnose too many SQL queries is in development. If you see a group of similar SQL queries fetching data from the same table, then something fishy is going on there. That&amp;#39;s why I strongly encourage you to turn on SQL logging for your development environment. Also, Rails supports &lt;a href=&quot;https://guides.rubyonrails.org/debugging_rails_applications.html#verbose-query-logs&quot;&gt;verbose query logs&lt;/a&gt; that show where a query is called from in the code.&lt;/p&gt;
&lt;p&gt;If looking at logs is not your thing, or you want something more serious, try out &lt;a href=&quot;/2020/06/09/n-plus-one-queries-explained.html&quot;&gt;AppSignal&amp;#39;s performance measuring and N+1 query detection&lt;/a&gt;. There, you will get an excellent indicator of whether your issue comes from an N+1 query. Here&amp;#39;s how it looks below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-07/nplus1.png&quot; alt=&quot;AppSignal&amp;#39;s N+1 query detection&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;sum-up&quot;&gt;Sum Up&lt;/h2&gt;
&lt;p&gt;Thanks for reading this blog post series. I&amp;#39;m glad you joined me for this interesting ride, where we went from introducing patterns and anti-patterns in Rails to exploring what they are inside the Rails MVC pattern, before this final blog post on general problems.&lt;/p&gt;
&lt;p&gt;I hope you learned a lot, or at least revised and established what you already know. Do not stress about memorizing all of it. You can always consult the series if you are having trouble in any area.&lt;/p&gt;
&lt;p&gt;You will surely encounter both patterns and anti-patterns because this world (and software engineering especially) is not ideal. That shouldn&amp;#39;t worry you either.&lt;/p&gt;
&lt;p&gt;Mastering patterns and anti-patterns will make you a great software engineer. But what makes you even better is knowing when to break those patterns and molds, because there is no perfect solution.&lt;/p&gt;
&lt;p&gt;Thanks again for joining and reading. See you in the next one — and cheers!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Performance, Stress, and Load Tests in Rails</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/06/09/performance-stress-and-load-tests-in-rails.html">
    <id>https://blog.appsignal.com/2021/06/09/performance-stress-and-load-tests-in-rails.html</id>
    <published>2021-06-09T00:00:00+00:00</published>
    <updated>2021-06-09T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's jump into theoretical and practical aspects of performance testing in Rails.</summary>
    <content type="html">&lt;p&gt;Tests are an integral part of most well-working Rails applications where maintenance isn&amp;#39;t a nightmare and new features are consistently added, or existing ones are improved. Unfortunately, for many applications, a production environment is where they are put under heavy workload or significant traffic for the first time. This is understandable as such tests are costly.&lt;/p&gt;
&lt;p&gt;Thankfully, Rails has good support not only for unit, end-to-end, and integration tests but also for tests related to performance and loading. I’ll cover all of them in the article and show some practical examples that will help you understand how to efficiently use tools that test the performance level of your application.&lt;/p&gt;
&lt;p&gt;The article is divided into two sections:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Theoretical&lt;/strong&gt; — I&amp;#39;ll show you why testing is necessary, the kinds of tests we can perform and the metrics that are essential when performing tests on an application&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Practical&lt;/strong&gt; — we&amp;#39;ll get our hands dirty and write tests for an actual application to get the output&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After reading the two sections, you&amp;#39;ll have a deeper understanding of the different types of tests and how to perform them on your Rails application. Sounds interesting? Then let&amp;#39;s get started with a pinch of theory about tests.&lt;/p&gt;
&lt;h2 id=&quot;testing-in-theory&quot;&gt;Testing in Theory&lt;/h2&gt;
&lt;p&gt;Testing should always be an inherent part of the development of any type of application. If you are still not convinced about that or haven’t written any tests yet, here are some arguments for testing that will help you:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Introduce changes without worrying about breaking something&lt;/strong&gt; — this is the major reason why tests are necessary. Imagine working on a huge app where you have to click through the whole app to make sure nothing is broken each time you introduce some change, even a small one. With tests, you just execute one command and the verification process is automatic and fast.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Easy refactoring process&lt;/strong&gt; — I mentioned above that tests are essential when adding new features or making changes. With testing in place, you are also more comfortable with improving your existing code.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tests are a form of documentation&lt;/strong&gt; — well-written tests can be a form of documentation for various sets of features in the application. They not only describe what the feature is but also how it should be working.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Opportunity to rethink the implementation&lt;/strong&gt; — when you write a test, you have a chance to think again if the way you want to implement the code is correct and reasonable. Also, you simply check if your code is working the way you expect it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I hope the above arguments convinced you to use tests during the development of any app. While knowing why to test the code is essential, it’s also crucial to learn about different types of tests.&lt;/p&gt;
&lt;h3 id=&quot;different-types-of-tests&quot;&gt;Different Types of Tests&lt;/h3&gt;
&lt;p&gt;There are three primary types of tests that you can write to ensure that your Rails application’s performance is correct and the infrastructure is working well under the heavy workload. Those types are the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Load testing&lt;/strong&gt; — this type of test answers the following question: how many simultaneous users can the system handle for a given period. Imagine that you launch a top-rated product on your website and thousands of users want to make the order at the same time. Without proper loading tests, you risk a crash during the most critical time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stress testing&lt;/strong&gt; — with this type of test, you don’t focus on verifying the number of users the system can handle simultaneously, but on how the system will behave when the limit of the users is hit.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Performance testing&lt;/strong&gt; — I would say that this type of test is a parent of stress and load testing. The primary purpose of such tests is to get a specific set of metrics on which base we can take some action to improve the application’s code. I will talk about those metrics in a while.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That being said, we are now prepared to move to the last step of the theory part: learning what metrics are essential when doing performance testing on a Rails application. Without that knowledge, we won’t correctly interpret the test output and decide if we should change the code or not.&lt;/p&gt;
&lt;h2 id=&quot;important-metrics&quot;&gt;Important Metrics&lt;/h2&gt;
&lt;p&gt;The type of metrics you can receive can be different depending on the tool you use for testing, but generally, we can group them into a set of metrics that are pretty common:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Response time&lt;/strong&gt; — the time between the request being made and the response getting rendered in the browser. This metric shows us how long the user needs to wait before receiving the information he requested. It’s sometimes called process time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Memory usage&lt;/strong&gt; — the amount of memory consumed for the given request. This is a piece of essential information as it points you to the place where you can improve the code so the system can respond faster and use fewer resources.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Objects allocation&lt;/strong&gt; — a high memory allocation causes high memory usage and long response times. This metric can lead you to the exact place in code where many objects are allocated, so you can immediately inspect that.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can have more metrics when testing, but those three are the most important and will be valid for any application that you test. We can now get our hands dirty and write real tests.&lt;/p&gt;
&lt;h2 id=&quot;practice&quot;&gt;Practice&lt;/h2&gt;
&lt;p&gt;We aren&amp;#39;t able to write tests without having something to test. That’s why the first step in the practice part is to write a simple Rails application that we can write the tests for.&lt;/p&gt;
&lt;h3 id=&quot;sample-rails-application&quot;&gt;Sample Rails Application&lt;/h3&gt;
&lt;p&gt;I will use Ruby 3.0.1 and Rails 6.1.3.1 but feel free to use any version you are comfortable with. If you have Ruby and Rails installed, the next step is to create the application’s skeleton:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails new simpleapp -d=postgresql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the article&amp;#39;s purpose, I&amp;#39;ll create an app where a list of users is presented along with their pet’s names. Such a structure will allow us to easily create the N+1 queries that will offer more fun when doing performance tests and checking the impact on speed and other metrics that changes will have.&lt;/p&gt;
&lt;p&gt;Before we generate the models, let’s create the database first:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd simpleapp/
bin/rails db:create
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we can generate the models:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails g model User name:string
rails g model Animal name:string user:references
bin/rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Just one small update to the &lt;code&gt;User&lt;/code&gt; model to reflect the relationship with the &lt;code&gt;Animal&lt;/code&gt; model:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User &amp;lt; ApplicationRecord
  has_many :animals
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now add some seeds in &lt;code&gt;db/seeds.rb&lt;/code&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;people = {
  &amp;#39;Tim&amp;#39; =&amp;gt; [&amp;#39;Pinky&amp;#39;, &amp;#39;Rick&amp;#39;],
  &amp;#39;Martha&amp;#39; =&amp;gt; [&amp;#39;Rudolph&amp;#39;],
  &amp;#39;Mark&amp;#39; =&amp;gt; [&amp;#39;Niki&amp;#39;, &amp;#39;Miki&amp;#39;, &amp;#39;Bella&amp;#39;],
  &amp;#39;Tina&amp;#39; =&amp;gt; [&amp;#39;Tom&amp;#39;, &amp;#39;Luna&amp;#39;]
}

people.each_pair do |name, pets|
  user = User.create(name: name)
  pets.each do |pet_name|
    user.animals.create(name: pet_name)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and load the data into the database:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bin/rails db:seed
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I&amp;#39;ll create one controller with the users’ assignment, and then in view, I&amp;#39;ll list all users with their pets’ names. I’m intentionally using code that is causing performance problems so you can measure the improvements later.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;touch app/controllers/home_controller.rb
mkdir app/views/home
touch app/views/home/index.html.erb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The controller is simple:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class HomeController &amp;lt; ApplicationController
  def index
    @users = User.all
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the view also:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;h1&amp;gt;List&amp;lt;/h1&amp;gt;

&amp;lt;ul&amp;gt;
  &amp;lt;% @users.each do |user| %&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;%= user.name %&amp;gt; (&amp;lt;%= user.animals.count %&amp;gt;)
      &amp;lt;ul&amp;gt;
        &amp;lt;% user.animals.each do |animal| %&amp;gt;
          &amp;lt;li&amp;gt;&amp;lt;%= animal.name %&amp;gt;&amp;lt;/li&amp;gt;
        &amp;lt;% end %&amp;gt;
      &amp;lt;/ul&amp;gt;
    &amp;lt;/li&amp;gt;
  &amp;lt;% end %&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last step is to update the &lt;code&gt;config/routes.rb&lt;/code&gt; file to let Rails know what we would like to see when visiting the main URL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Rails.application.routes.draw do
  root to: &amp;#39;home#index&amp;#39;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;load-tests-with-jmeter&quot;&gt;Load Tests With JMeter&lt;/h3&gt;
&lt;p&gt;JMeter is an open-source software created by the Apache software foundation, designed to load test functional behavior. Since it’s a program created with Java, you can install it on any operating system. You can download the files here: &lt;a href=&quot;https://jmeter.apache.org/download_jmeter.cgi&quot;&gt;https://jmeter.apache.org/download_jmeter.cgi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you are working on a macOS system, you can easily install JMeter with Homebrew:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;brew install jmeter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After installation, you can run the program with the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;jmeter
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Configuring the test&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The configuration process consists of the following steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Adding the thread group — specifying the number of users and how long each will visit your website&lt;/li&gt;
&lt;li&gt;Configuring HTTP request — specifying the endpoint that JMeter should hit&lt;/li&gt;
&lt;li&gt;Setting the metrics we are interested in&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let’s walk step-by-step through a simple test configuration to simulate a single user request to the main page of the simple app we created before.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Add thread group&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Select the Add -&amp;gt; Threads (Users) -&amp;gt; Thread Group from the menu that expands after you right-click on the “Test Plan”:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-06/images/1.png&quot; alt=&quot;alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Specify the number of users and additional attributes:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-06/images/2.png&quot; alt=&quot;alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Configure HTTP request&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Right-click on the thread we created in the previous step and select Add -&amp;gt; Sampler -&amp;gt; HTTP Request:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-06/images/3.png&quot; alt=&quot;alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Configure the protocol, server name, port, and the path of the request:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-06/images/4.png&quot; alt=&quot;alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Specify the result view&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Right-click on the HTTP request and select Add -&amp;gt; Listener -&amp;gt; View Results Tree:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-06/images/5.png&quot; alt=&quot;alt text&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;running-the-test&quot;&gt;Running the Test&lt;/h3&gt;
&lt;p&gt;The test is now configured, and we can trigger it. To do this, simply click on the green play button:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-06/images/6.png&quot; alt=&quot;alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;As you can see, the application passed the test, but it was just a single request, so the result was obvious. You can now experiment with the number of users and other configuration options to see how the application will behave. From my tests, the simple app started to crash when around 200 users started accessing it simultaneously.&lt;/p&gt;
&lt;h3 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h3&gt;
&lt;p&gt;After performing the load test, you&amp;#39;ll know the pain points of your application. Understanding the user limit, you can now perform the stress test to see how the application will behave.&lt;/p&gt;
&lt;h2 id=&quot;performance-tests-with-ruby-prof&quot;&gt;Performance Tests With Ruby-prof&lt;/h2&gt;
&lt;p&gt;The performance test feature was built-in in Rails until version 3, and then it was extracted to the separate gem &lt;a href=&quot;https://github.com/rails/rails-perftest&quot;&gt;https://github.com/rails/rails-perftest&lt;/a&gt;. Since I had some problems using it with the latest version of Rails, I decided not to include it in this article. Instead, I will use the ruby-prof library that works very well.&lt;/p&gt;
&lt;p&gt;As usual, the first step is to add a gem to our application:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;bundle add ruby-prof
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The second and the last step of the configuration process is to update the &lt;code&gt;config/application.rb&lt;/code&gt; and use the middleware for the gem so the library can automatically inspect our requests and produce reports based on them:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Simpleapp
  class Application &amp;lt; Rails::Application
    config.middleware.use Rack::RubyProf, :path =&amp;gt; &amp;#39;./tmp/profile&amp;#39;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can now access the app, and each time you perform a request, the gem will generate a new report. It looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-06/images/7.png&quot; alt=&quot;alt text&quot;/&gt;&lt;/p&gt;
&lt;p&gt;You can find it under the configured path, which is &lt;code&gt;tmp/profile&lt;/code&gt; in our case. The second report is also generated, and it shows the call stack, which is also a pretty helpful metric when debugging performance issues in a Rails application.&lt;/p&gt;
&lt;p&gt;It’s important to remember that setting the &lt;code&gt;cache_classes&lt;/code&gt; and &lt;code&gt;cache_template_loading&lt;/code&gt; settings to &lt;code&gt;true&lt;/code&gt; will slow down the application and overwhelm the application metrics as Rails will try to load the required files.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Testing is an essential part of every development process. Checking if the code behaves as we want it to is as crucial as verifying if our solutions have good performance. Skipping tests leads to serious problems that impact the app’s performance and your users’ trust. Hopefully, testing is not that hard.&lt;/p&gt;
&lt;p&gt;In this article, we covered the following important aspects of testing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the reason you should test your code&lt;/li&gt;
&lt;li&gt;the different types of performance tests&lt;/li&gt;
&lt;li&gt;the way you can test the performance of your Rails app&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I hope that you are now more convinced why it is important to write tests since you know why and how.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;re interested in monitoring your app’s performance not just locally but also in the production or staging environments, you should also &lt;a href=&quot;https://www.appsignal.com/&quot;&gt;check out AppSignal&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Three Ways To Avoid Duplicate Sidekiq Jobs</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/05/12/three-ways-to-avoid-duplicate-sidekiq-jobs.html">
    <id>https://blog.appsignal.com/2021/05/12/three-ways-to-avoid-duplicate-sidekiq-jobs.html</id>
    <published>2021-05-12T00:00:00+00:00</published>
    <updated>2021-05-12T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Sidekiq is used to handle background processing. Whatever your background jobs may be, you'll eventually run into duplicate jobs. Let's see how to de-duplicate them.</summary>
    <content type="html">&lt;p&gt;Chances are, if you are writing Ruby code, you are using
Sidekiq to handle background processing. If you are coming from &lt;code&gt;ActiveJob&lt;/code&gt;
or some other background, stay tuned, some of the tips covered can be applied there as
well.&lt;/p&gt;
&lt;p&gt;Folks utilize (Sidekiq) background jobs for different cases. Some crunch
numbers, some dispatch welcome emails to users, and some schedule data
syncing. Whatever your case may be, you might eventually run into a requirement to
avoid duplicate jobs. By duplicate jobs, I envision two jobs that do the exact
same thing. Let&amp;#39;s dive in on that a bit.&lt;/p&gt;
&lt;h2 id=&quot;why-de-duplicate-jobs&quot;&gt;Why De-Duplicate Jobs?&lt;/h2&gt;
&lt;p&gt;Imagine a scenario where your job looks like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class BookSalesWorker
  include Sidekiq::Worker

  def perform(book_id)
    crunch_some_numbers(book_id)

    upload_to_s3
  end

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;BookSalesWorker&lt;/code&gt; always does the same thing — queries the DB for a book
based on the &lt;code&gt;book_id&lt;/code&gt; and fetches the latest sales data to calculate some
numbers. Then, it uploads them to a storage service. Keep in mind that every time a
book is sold on your website, you will have this job enqueued.&lt;/p&gt;
&lt;p&gt;Now, what if you got 100 sales at once? You&amp;#39;d have 100 of these jobs doing
the exact same thing. Maybe you are fine with that. You don&amp;#39;t care about S3
writes that much, and your queues aren&amp;#39;t as congested, so you can handle the
load. But, &amp;quot;does it scale?&amp;quot;™️&lt;/p&gt;
&lt;p&gt;Well, definitely not. If you start receiving more sales for more
books, your queue will quickly pile up with unnecessary work. If you have 100
jobs that do the same thing for a single book, and you have 10 books selling in
parallel, you are now 1000 jobs deep in your queue, where in reality, you could
just have 10 jobs for each book.&lt;/p&gt;
&lt;p&gt;Now, let&amp;#39;s go through a couple of options on how you can prevent duplicate jobs
from piling up your queues.&lt;/p&gt;
&lt;h2 id=&quot;1-diy-way&quot;&gt;1. DIY Way&lt;/h2&gt;
&lt;p&gt;If you are not a fan of external dependencies and complex logic, you can go
ahead and add some custom solutions to your codebase. I created a
sample repo to try out our examples first-hand. There will be a link in each
approach to the example.&lt;/p&gt;
&lt;h3 id=&quot;11-one-flag-approach&quot;&gt;1.1 One Flag Approach&lt;/h3&gt;
&lt;p&gt;You can add one flag that decides whether to enqueue a job or not.
One might add a &lt;code&gt;sales_enqueued_at&lt;/code&gt; in their Book table and maintain that
one. For example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;module BookSalesService
  def schedule_with_one_flag(book)
    # Check if the job was enqueued more than 10 minutes ago
    if book.sales_enqueued_at &amp;lt; 10.minutes.ago
      book.update(sales_enqueued_at: Time.current)

      BookSalesWorker.perform_async(book.id)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That means that no new jobs will be enqueued until 10 minutes have passed from
the time the last job got enqueued. After 10 minutes have passed, we then update the
&lt;code&gt;sales_enqueued_at&lt;/code&gt; and enqueue a new job.&lt;/p&gt;
&lt;p&gt;Another thing you can do is set one flag that is a boolean, e.g.
&lt;code&gt;crunching_sales&lt;/code&gt;. You set &lt;code&gt;crunching_sales&lt;/code&gt; to true before the first job is
enqueued. Then, you set it to false once the job is complete. All other jobs
that try to get scheduled will be rejected until &lt;code&gt;crunching_sales&lt;/code&gt; is false.&lt;/p&gt;
&lt;p&gt;You can try this approach
&lt;a href=&quot;https://github.com/nikolalsvk/duplicate-sidekiq-jobs#1-one-flag-approach&quot;&gt;in the example repo&lt;/a&gt;
I created.&lt;/p&gt;
&lt;h3 id=&quot;12-two-flags-approach&quot;&gt;1.2 Two Flags Approach&lt;/h3&gt;
&lt;p&gt;If &amp;quot;locking&amp;quot; a job from being enqueued for 10 minutes sounds too scary, but you are
still fine with extra flags in your code, then the next suggestion might interest you.&lt;/p&gt;
&lt;p&gt;You can add another flag to the existing &lt;code&gt;sales_enqueued_at&lt;/code&gt; — the &lt;code&gt;sales_calculated_at&lt;/code&gt;.
Then our code will look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;module BookSalesService
  def schedule_with_two_flags(book)
    # Check if sales are being calculated right now
    if book.sales_enqueued_at &amp;lt;= book.sales_calculated_at
      book.update(sales_enqueued_at: Time.current)

      BookSalesWorker.perform_async(book.id)
    end
  end
end

class BookSalesWorker
  include Sidekiq::Worker

  def perform(book_id)
    crunch_some_numbers(book_id)

    upload_to_s3

    # New adition
    book.update(sales_calculated_at: Time.current)
  end

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To try it out, check out the &lt;a href=&quot;https://github.com/nikolalsvk/duplicate-sidekiq-jobs#2-two-flag-approach&quot;&gt;instructions in the example repo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Now we control a portion of the time between when a job is enqueued and finished. In that
portion of time, no job can be enqueued. While the job is running, the
&lt;code&gt;sales_enqueued_at&lt;/code&gt; will be larger than &lt;code&gt;sales_calculated_at&lt;/code&gt;. When the job
finishes running, the &lt;code&gt;sales_calculated_at&lt;/code&gt; will be larger (more recent) than
the &lt;code&gt;sales_enqueued_at&lt;/code&gt; and a new job will get enqueued.&lt;/p&gt;
&lt;p&gt;Using two flags might be interesting, so you could show the last time
those sales numbers got updated in the UI. Then the users that read them
can have an idea of how recent the data is. A win-win situation.&lt;/p&gt;
&lt;h3 id=&quot;flag-sum-up&quot;&gt;Flag Sum Up&lt;/h3&gt;
&lt;p&gt;It might be tempting to create solutions like these in times of need, but to me,
they look a bit clumsy, and they add some overhead. I would recommend using
this if your use case is simple, but as soon as it proves complex or not
enough, I&amp;#39;d urge you to try out other options.&lt;/p&gt;
&lt;p&gt;A huge con with the flag approach is that you will lose all the jobs
that tried to enqueue during those 10 minutes. A huge pro is that you are not
bringing in dependencies, and it will alleviate the job number in queues
pretty quickly.&lt;/p&gt;
&lt;h3 id=&quot;13-traversing-the-queue&quot;&gt;1.3 Traversing The Queue&lt;/h3&gt;
&lt;p&gt;Another approach you can take is to create a custom locking mechanism to
prevent the same jobs from enqueueing. We will check the Sidekiq queue we
are interested in and see if the job (worker) is already there. The code
will look something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;module BookSalesService
  def schedule_unique_across_queue(book)
    queue = Sidekiq::Queue.new(&amp;#39;default&amp;#39;)

    queue.each do |job|
      return if job.klass == BookSalesWorker.to_s &amp;amp;&amp;amp;
        job.args == [book.id]
    end

    BookSalesWorker.perform_async(book.id)
  end
end

class BookSalesWorker
  include Sidekiq::Worker

  def perform(book_id)
    crunch_some_numbers(book_id)

    upload_to_s3
  end

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above we are checking whether the
&lt;code&gt;&amp;#39;default&amp;#39;&lt;/code&gt; queue has a job with the class name of &lt;code&gt;BookSalesWorker&lt;/code&gt;. We are also
checking if the job arguments match the book ID. If the &lt;code&gt;BookSalesWorker&lt;/code&gt; job
with the same Book ID is in the queue, we will return early and not schedule
another one.&lt;/p&gt;
&lt;p&gt;Note that some of them might get scheduled if you schedule jobs too fast
because the queue is empty. The exact thing happened to me when testing it
locally with:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;100.times { BookSalesService.schedule_unique_across_queue(book) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can try it out in the &lt;a href=&quot;https://github.com/nikolalsvk/duplicate-sidekiq-jobs#3-traverse-sidekiq-queue-approach&quot;&gt;example repo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The good thing about this approach is that you can traverse all queues to search
for an existing job if you need it. The con is that you can still have
duplicate jobs if your queue is empty and you schedule a lot of them at once.
Also, you are potentially traversing through all the jobs in the queue before
scheduling one, so that might be costly depending on the size of your queue.&lt;/p&gt;
&lt;h2 id=&quot;2-upgrading-to-sidekiq-enterprise&quot;&gt;2. Upgrading to Sidekiq Enterprise&lt;/h2&gt;
&lt;p&gt;If you or your organization has some money lying around, you can upgrade to
the Enterprise version of Sidekiq. It starts at $179 per month, and it has a cool
feature that helps you avoid duplicate jobs. Unfortunately, I don&amp;#39;t have Sidekiq
Enterprise, but I believe &lt;a href=&quot;https://github.com/mperham/sidekiq/wiki/Ent-Unique-Jobs&quot;&gt;their documentation&lt;/a&gt;
is sufficient.
You can easily have unique (non-duplicated) jobs with the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class BookSalesWorker
  include Sidekiq::Worker
  sidekiq_options unique_for: 10.minutes

  def perform(book_id)
    crunch_some_numbers(book_id)

    upload_to_s3
  end

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that&amp;#39;s it. You have a similar job implementation to what we described in
the &amp;#39;One Flag Approach&amp;#39; section. The job will be unique for 10 minutes, meaning that
no other job with the same arguments can be scheduled in that time period.&lt;/p&gt;
&lt;p&gt;Pretty cool one-liner, huh? Well, if you have Enterprise Sidekiq and you just
found out about this feature, I am truly glad I helped. Most of us are
not going to use it, so let&amp;#39;s jump into the next solution.&lt;/p&gt;
&lt;h2 id=&quot;3-sidekiq-unique-jobs-to-the-rescue&quot;&gt;3. sidekiq-unique-jobs To The Rescue&lt;/h2&gt;
&lt;p&gt;Yes, I know we are about to mention a gem. And yes, it has some Lua files in it
which might put some people off. But bear with me, it&amp;#39;s a really sweet deal you
are getting with it. The &lt;a href=&quot;https://github.com/mhenrixon/sidekiq-unique-jobs&quot;&gt;sidekiq-unique-job&lt;/a&gt;
gem comes with a lot of locking and other configuration options — probably more
than you need.&lt;/p&gt;
&lt;p&gt;To get started quickly, put &lt;code&gt;sidekiq-unique-jobs&lt;/code&gt; gem into your Gemfile, do
&lt;code&gt;bundle&lt;/code&gt; and configure your worker as shown:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class UniqueBookSalesWorker
  include Sidekiq::Worker

  sidekiq_options lock: :until_executed,
                  on_conflict: :reject

  def perform(book_id)
    book = Book.find(book_id)

    logger.info &amp;quot;I am a Sidekiq Book Sales worker - I started&amp;quot;
    sleep 2
    logger.info &amp;quot;I am a Sidekiq Book Sales worker - I finished&amp;quot;

    book.update(sales_calculated_at: Time.current)
    book.update(crunching_sales: false)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a lot of options, but I decided to simplify and use this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;sidekiq_options lock: :until_executed, on_conflict: :reject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;lock: :until_executed&lt;/code&gt; will lock the first &lt;code&gt;UniqueBookSalesWorker&lt;/code&gt; job
until it is executed. With &lt;code&gt;on_conflict: :reject&lt;/code&gt;, we are saying that we want
all other jobs that try to get executed to be rejected into the dead queue. What we
achieved here is similar to what we did in our DIY examples in the topics above.&lt;/p&gt;
&lt;p&gt;A slight improvement over those DIY examples is that we have a kind of log
of what happened. To get a sense of how it looks, let&amp;#39;s try the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;5.times { UniqueBookSalesWorker.perform_async(Book.last.id) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Only one job will fully execute, and the other four jobs will be sent off to the
dead queue, where you can retry them. This approach differs from our examples where
duplicate jobs were just ignored.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-05/dead-queue.png&quot; alt=&quot;Dead queue&quot;/&gt;&lt;/p&gt;
&lt;p&gt;There are a lot of options to choose from when it comes to locking and conflict resolving.
I suggest you consult the &lt;a href=&quot;https://github.com/mhenrixon/sidekiq-unique-jobs&quot;&gt;gem&amp;#39;s documentation&lt;/a&gt;
for your specific use case.&lt;/p&gt;
&lt;h3 id=&quot;great-insights&quot;&gt;Great Insights&lt;/h3&gt;
&lt;p&gt;The great thing about this gem is that you can view the locks and the history of what went down in your queues.
All you need to do is add the following lines in your &lt;code&gt;config/routes.rb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# config/routes.rb
require &amp;#39;sidekiq_unique_jobs/web&amp;#39;

Rails.application.routes.draw do
  mount Sidekiq::Web, at: &amp;#39;/sidekiq&amp;#39;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It will include the original Sidekiq client, but it will also give you two more
pages — one for job locks and the other for the changelog. This is how it looks:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-05/new-pages.png&quot; alt=&quot;New Sidekiq Client pages&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Notice how we have two new pages, &amp;quot;Locks&amp;quot; and &amp;quot;Changelogs&amp;quot;. Pretty cool feature.&lt;/p&gt;
&lt;p&gt;You can try all of this in &lt;a href=&quot;https://github.com/nikolalsvk/duplicate-sidekiq-jobs#4-using-sidekiq-unique-jobs-gem&quot;&gt;the example
project&lt;/a&gt;
where the gem is installed and ready to go.&lt;/p&gt;
&lt;h3 id=&quot;why-lua&quot;&gt;Why Lua?&lt;/h3&gt;
&lt;p&gt;First of all, I am not the author of the gem, so I&amp;#39;m just assuming things
here. The first time I saw the gem, I wondered: why use Lua inside a Ruby gem? It
might appear odd at first, but Redis supports running Lua scripts. I guess the
author of the gem had this in mind and wanted to do more nimble logic in Lua.&lt;/p&gt;
&lt;p&gt;If you look at the
&lt;a href=&quot;https://github.com/mhenrixon/sidekiq-unique-jobs/tree/master/lib/sidekiq_unique_jobs/lua&quot;&gt;Lua files in the gem&amp;#39;s repo&lt;/a&gt;,
they aren&amp;#39;t that complicated. All of the Lua scripts are called later from
the Ruby code in the
&lt;a href=&quot;https://github.com/mhenrixon/sidekiq-unique-jobs/blob/master/lib/sidekiq_unique_jobs/script/caller.rb&quot;&gt;&lt;code&gt;SidekiqUniqueJobs::Script::Caller&lt;/code&gt; here&lt;/a&gt;.
Please take a look at the source code, it is interesting to read and figure out how things work.&lt;/p&gt;
&lt;h3 id=&quot;alternative-gem&quot;&gt;Alternative Gem&lt;/h3&gt;
&lt;p&gt;If you use &lt;code&gt;ActiveJob&lt;/code&gt; extensively, you can try the &lt;code&gt;active-job-uniqueness&lt;/code&gt; gem &lt;a href=&quot;https://github.com/veeqo/activejob-uniqueness&quot;&gt;right here&lt;/a&gt;.
The idea is similar, but instead of custom Lua scripts, it uses &lt;a href=&quot;https://github.com/leandromoreira/redlock-rb&quot;&gt;Redlock&lt;/a&gt; to
lock items in Redis.&lt;/p&gt;
&lt;p&gt;To have a unique job using this gem, you can imagine a job like this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class BookSalesJob &amp;lt; ActiveJob::Base
  unique :until_executed

  def perform
    ...
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The syntax is less verbose but very similar to the &lt;code&gt;sidekiq-unique-jobs&lt;/code&gt;
gem. It might solve your case if you highly rely on &lt;code&gt;ActiveJob&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;I hope you gained some knowledge in how to deal with duplicate jobs in your
app. I definitely had fun researching and playing around with different
solutions. If you didn&amp;#39;t end up finding what you were looking for, I hope that some of
the examples inspired you to create something of your own.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s the &lt;a href=&quot;https://github.com/nikolalsvk/duplicate-sidekiq-jobs&quot;&gt;example project&lt;/a&gt; with all the code snippets.&lt;/p&gt;
&lt;p&gt;I will see you in the next one, cheers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Linting Ruby Code</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/04/28/ruby-linting.html">
    <id>https://blog.appsignal.com/2021/04/28/ruby-linting.html</id>
    <published>2021-04-28T00:00:00+00:00</published>
    <updated>2021-04-28T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's take a look at what linting is and a few problems that come with it.</summary>
    <content type="html">&lt;p&gt;Linting is the process of statically analyzing code in search of potential problems.&lt;/p&gt;
&lt;p&gt;What constitutes a problem, in this case, can vary across programming languages, or even
across projects within the same language.
I would put these problems under a few different categories:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Programmatic&lt;/li&gt;
&lt;li&gt;Security&lt;/li&gt;
&lt;li&gt;Stylistic&lt;/li&gt;
&lt;li&gt;Performance&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;#39;s take a look at a few examples of each.&lt;/p&gt;
&lt;h2 id=&quot;stylistic-problems&quot;&gt;Stylistic Problems&lt;/h2&gt;
&lt;p&gt;There&amp;#39;s no objectively right way of styling code, as it&amp;#39;s all about the
reader&amp;#39;s preference. The key is consistency though. Common points of debate
include:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;double-quotes vs single-quotes&lt;/li&gt;
&lt;li&gt;tabs vs space&lt;/li&gt;
&lt;li&gt;maximum line length&lt;/li&gt;
&lt;li&gt;indentation of multiline calls, as shown below:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# always single-line
foo(:a, :b, :c)

# aligned with first argument
foo(:a,
    :b,
    :c
)

# aligned with function name
foo(
  :a,
  :b
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These are entirely subjective, but it&amp;#39;s usually beneficial to agree on a standard
for each particular project, to keep the entire codebase consistent.&lt;/p&gt;
&lt;h2 id=&quot;programmatic-problems&quot;&gt;Programmatic Problems&lt;/h2&gt;
&lt;p&gt;I include here such problems as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extremely long method bodies, which leads to readability &amp;amp; maintainability
issues&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Cyclomatic_complexity&quot;&gt;Cyclomatic Complexity&lt;/a&gt;,
a metric commonly used to measure code complexity&lt;/li&gt;
&lt;li&gt;Assignments within conditions. Most likely, if you type &lt;code&gt;if x = true&lt;/code&gt;, you
actually meant &lt;code&gt;if x == true&lt;/code&gt;. and even if you did mean an assignment, it&amp;#39;s
still a less-intuitive approach&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;security-problems&quot;&gt;Security Problems&lt;/h2&gt;
&lt;p&gt;Some functions or practices have potential security problems that developers may
not be aware of.&lt;/p&gt;
&lt;p&gt;For instance, in Ruby, &lt;code&gt;Kernel#open&lt;/code&gt; is a flexible function
that allows opening files or external URLs. But it also allows arbitrary
filesystem access, with weird calls such as &lt;code&gt;open(&amp;quot;| ls&amp;quot;)&lt;/code&gt;.
Therefore, it is sensible to warn developers about it so that they can either use
a safer approach (&lt;code&gt;File#open&lt;/code&gt;, &lt;code&gt;IO.popen&lt;/code&gt;, &lt;code&gt;URI.parse#open&lt;/code&gt;), or explicitly
decide to keep the behavior at their own risk.&lt;/p&gt;
&lt;h2 id=&quot;performance-problem&quot;&gt;Performance Problem&lt;/h2&gt;
&lt;p&gt;There are many details about Ruby&amp;#39;s inner workings that make some options more
performant than others, depending on the context.&lt;/p&gt;
&lt;p&gt;A linter warning us about them helps us learn along the way while optimizing
some details of our program.&lt;/p&gt;
&lt;p&gt;For example, Ruby 2.5 introduced &lt;code&gt;String#delete_suffix&lt;/code&gt; which deletes
a substring from the end of a string. These two lines are equivalent, but the
latter one is more performant since it doesn&amp;#39;t rely on a generic string regex
match:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;str = &amp;#39;string_with_suffix&amp;#39;

# bad
str.gsub(/suffix\z/, &amp;#39;&amp;#39;)

# good
str.delete_suffix(&amp;#39;suffix&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;auto-fixing&quot;&gt;Auto Fixing&lt;/h2&gt;
&lt;p&gt;An important aspect of linters is their ability to automatically fix some or all
of the found issues.
Styling aspects such as line length are easily automated, so it makes sense to
remove that burden from the developer.
Other issues might be subjective or require human intervention, such as
refactoring a large method. In these cases, no automation is possible.&lt;/p&gt;
&lt;h2 id=&quot;convention-or-configuration&quot;&gt;Convention or Configuration&lt;/h2&gt;
&lt;p&gt;There is often heavy debate within a community or project on which rules make
sense.&lt;/p&gt;
&lt;p&gt;The traditional solution is to allow each team to solve the debate within
its members by allowing them to configure linting rules to their own taste.
However, in recent years, there has been a push across several languages to
standardize to a single convention.
While this isn&amp;#39;t enforced everywhere, the general idea is to entirely remove the
mental overhead developers have when styling code. Instead of discussing which
line length works best, everyone just uses the community-agreed rules.&lt;/p&gt;
&lt;p&gt;In Ruby, this more or less translates to the two existing linters:
&lt;a href=&quot;https://github.com/rubocop/rubocop&quot;&gt;RuboCop&lt;/a&gt;, which allows full-configuration
and &lt;a href=&quot;https://github.com/testdouble/standard&quot;&gt;StandardRB&lt;/a&gt;, which takes the
opposite approach and defines a common standard.&lt;/p&gt;
&lt;h2 id=&quot;rubocop&quot;&gt;RuboCop&lt;/h2&gt;
&lt;p&gt;Employes the usual approach of providing a documented set of rules, each of
which looks for a particular problem. Developers are able to disable or tweak
certain rules within their own projects:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;# configure max allowed line length
Layout/LineLength:
  Max: 80

# disable cyclomatic complexity
Metrics/CyclomaticComplexity:
  Enabled: false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It already includes sane defaults, so configuration is only needed for the
specific rules you want to change.&lt;/p&gt;
&lt;p&gt;Running &lt;code&gt;bundle exec rubocop&lt;/code&gt; will make RuboCop analyze the entire codebase
and list all the issues it found:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# test.rb
def badName
  if something
    return &amp;quot;inner result&amp;quot;
  end

  &amp;quot;outer result&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ bundle exec rubocop
Inspecting 1 file
C

Offenses:

test.rb:1:1: C: [Correctable] Style/FrozenStringLiteralComment: Missing frozen string literal comment.
def badName
^
test.rb:1:5: C: Naming/MethodName: Use snake_case for method names.
def badName
    ^^^^^^^
test.rb:2:3: C: [Correctable] Style/IfUnlessModifier: Favor modifier if usage when having a single-line body. Another good alternative is the usage of control flow &amp;amp;&amp;amp;/||.
  if something
  ^^
test.rb:3:12: C: [Correctable] Style/StringLiterals: Prefer single-quoted strings when you don&amp;#39;t need string interpolation or special symbols.
    return &amp;quot;inner result&amp;quot;
           ^^^^^^^^^^^^^^
test.rb:6:3: C: [Correctable] Style/StringLiterals: Prefer single-quoted strings when you don&amp;#39;t need string interpolation or special symbols.
  &amp;quot;outer result&amp;quot;
  ^^^^^^^^^^^^^^

1 file inspected, 5 offenses detected, 4 offenses auto-correctable
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can then run &lt;code&gt;bundle exec rubocop --auto-correct&lt;/code&gt;, and a large majority of
your issues will be fixed according to your configurations.&lt;/p&gt;
&lt;p&gt;Setting up &lt;code&gt;bundle exec rubocop&lt;/code&gt; as part of your CI pipeline will ensure no code
gets through without first fulfilling the linting rules.&lt;/p&gt;
&lt;h2 id=&quot;standardrb&quot;&gt;StandardRB&lt;/h2&gt;
&lt;p&gt;A more recent project, which actually uses RuboCop under the hood.
The main goal of StandardRB is not to build an entirely separate linter, but to
reach a standard that everyone can just use instead of arguing about.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://www.youtube.com/watch?v=uLyV5hOqGQ8&quot;&gt;lightning talk&lt;/a&gt; where it was first announced is pretty clear about the
motivations: If people spend less time arguing about syntactic details and just
follow the decisions of a community-wide agreement, we can all spend more time
doing what really matters: building great products and libraries.&lt;/p&gt;
&lt;p&gt;Since RuboCop is used underneath, the output you get is actually in the same
format.
The only difference is that you&amp;#39;re not allowed to customize any of the rules.&lt;/p&gt;
&lt;p&gt;StandardRB recently reached 1.0.0, which means most of the discussion about
which rules to use has already happened on their &lt;a href=&quot;https://github.com/testdouble/standard/issues?q=is%3Aissue+is%3Aclosed&quot;&gt;issues page&lt;/a&gt;.
If you care or disagree about a particular rule, chances are you&amp;#39;ll see a related discussion about it in there.&lt;/p&gt;
&lt;p&gt;Ultimately though, you can be confident it was discussed in some depth.
It&amp;#39;s impossible for an entire community to agree 100% on all points. The
philosophy of this approach is that people are flexible and can &lt;a href=&quot;https://en.wikipedia.org/wiki/Disagree_and_commit&quot;&gt;disagree and
commit&lt;/a&gt; to a decision.&lt;/p&gt;
&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;After spending more time than I&amp;#39;m proud of nitpicking linting rules in past
projects, I definitely see the value in StandardRB&amp;#39;s approach and I recommend
using it whenever possible.&lt;/p&gt;
&lt;p&gt;Keeping all the benefits of consistency while removing the overhead of
discussions, along with the automated fixes for most rules helps us deliver
better software more efficiently, and focus on what really matters.&lt;/p&gt;
&lt;p&gt;Other languages are adopting similar low-configurability code formatters. &lt;code&gt;mix formatter&lt;/code&gt; in Elixir, and &lt;code&gt;rustfmt&lt;/code&gt; in Rust both allow for some configurability, but
the community is surprisingly onboard with keeping within the standard.&lt;/p&gt;
&lt;p&gt;With that said, RuboCop is still a perfectly valid option if you, ironically,
disagree with this sentiment.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Ruby on Rails Controller Patterns and Anti-patterns</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/04/14/ruby-on-rails-controller-patterns-and-anti-patterns.html">
    <id>https://blog.appsignal.com/2021/04/14/ruby-on-rails-controller-patterns-and-anti-patterns.html</id>
    <published>2021-04-14T00:00:00+00:00</published>
    <updated>2021-04-14T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In this part of the series on Rails patterns and anti-patterns, we are going to analyze the final part of the MVC (Model-View-Controller) design pattern — the Controller.</summary>
    <content type="html">&lt;p&gt;Welcome back to the fourth installment of the Ruby on Rails Patterns and Anti-Patterns series.&lt;/p&gt;
&lt;p&gt;Previously, we covered patterns and anti-patterns in general as well as in
relation to Rails Models and Views. In this post, we are going to analyze
the final part of the MVC (Model-View-Controller) design pattern — the
Controller. Let&amp;#39;s dive in and go through the patterns and anti-patterns
related to Rails Controllers.&lt;/p&gt;
&lt;h2 id=&quot;at-the-front-lines&quot;&gt;At The Front Lines&lt;/h2&gt;
&lt;p&gt;Since Ruby on Rails is a web framework, HTTP requests are a vital
part of it. All sorts of Clients reach out to Rails backends via
requests and this is where controllers shine. Controllers are at the front
lines of receiving and handling requests. That makes them a fundamental
part of the Ruby on Rails framework. Of course, there is code that comes before
controllers, but controller code is something most of us can control.&lt;/p&gt;
&lt;p&gt;Once you define routes at the &lt;code&gt;config/routes.rb&lt;/code&gt;, you can hit the server on the
set route, and the corresponding controller will take care of the rest. Reading
the previous sentence might give an impression that everything is as simple as
that. But, often, a lot of the weight falls on the controller&amp;#39;s shoulders.
There is the concern of authentication and authorization, then there are
problems of how to fetch the needed data, as well as where and how to perform
business logic.&lt;/p&gt;
&lt;p&gt;All of these concerns and responsibilities that can occur inside the controller
can lead to some anti-patterns. One of the most &amp;#39;famous&amp;#39; ones is the
anti-pattern of a &amp;quot;fat&amp;quot; controller.&lt;/p&gt;
&lt;h2 id=&quot;fat-obese-controllers&quot;&gt;Fat (Obese) Controllers&lt;/h2&gt;
&lt;p&gt;The problem with putting too much logic in the controller is that you are
starting to violate the Single Responsibility Principle (SRP). This means that
we are doing too much work inside the controller. Often, this leads to a lot of
code and responsibilities piling up there. Here, &amp;#39;fat&amp;#39; refers to the
extensive code contained in the controller files, as well as the logic the
controller supports. It is often considered an anti-pattern.&lt;/p&gt;
&lt;p&gt;There are a lot of opinions on what a controller should do. A common ground of
the responsibilities a controller should have include the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Authentication and authorization&lt;/strong&gt; — checking whether the entity (oftentimes,
a user) behind the request is who it says it is and whether it is allowed
to access the resource or perform the action. Often, authentication is
saved in the session or the cookie, but the controller should still check
whether authentication data is still valid.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data fetching&lt;/strong&gt; — it should call the logic for finding the right data based on
the parameters that came with the request. In the perfect world, it should be
a call to one method that does all the work. The controller should not do the
heavy work, it should delegate it further.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Template rendering&lt;/strong&gt; — finally, it should return the right response by
rendering the result with the proper format (HTML, JSON, etc.). Or, it should
redirect to some other path or URL.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Following these ideas can save you from having too much going on inside
the controller actions and controller in general. Keeping it simple at the
controller level will allow you to delegate work to other areas of your
application. Delegating responsibilities and testing them one by one will
ensure that you are developing your app to be robust.&lt;/p&gt;
&lt;p&gt;Sure, you can follow the above principles, but you must be eager for some
examples. Let&amp;#39;s dive in and see what patterns we can use to relieve
controllers of some weight.&lt;/p&gt;
&lt;h2 id=&quot;query-objects&quot;&gt;Query Objects&lt;/h2&gt;
&lt;p&gt;One of the problems that happen inside controller actions is too much
querying of data. If you followed our blog post on
&lt;a href=&quot;/2020/11/18/rails-model-patterns-and-anti-patterns.html&quot;&gt;Rails Model anti-patterns and patterns&lt;/a&gt;,
we went through a similar problem where models had too much querying logic.
But, this time we&amp;#39;ll use a pattern called Query Object. A Query Object is a
technique that isolates your complex queries into a single object.&lt;/p&gt;
&lt;p&gt;In most cases, Query Object is a Plain Old Ruby Object that is initialized with
an &lt;code&gt;ActiveRecord&lt;/code&gt; relation. A typical Query Object might look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/queries/all_songs_query.rb

class AllSongsQuery
  def initialize(songs = Song.all)
    @songs = songs
  end

  def call(params, songs = Song.all)
    songs.where(published: true)
         .where(artist_id: params[:artist_id])
         .order(:title)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It is made to be used inside the controller like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class SongsController &amp;lt; ApplicationController
  def index
    @songs = AllSongsQuery.new.call(all_songs_params)
  end

  private

  def all_songs_params
    params.slice(:artist_id)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can also try out another approach of the query object:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/queries/all_songs_query.rb

class AllSongsQuery
  attr_reader :songs

  def initialize(songs = Song.all)
    @songs = songs
  end

  def call(params = {})
    scope = published(songs)
    scope = by_artist_id(scope, params[:artist_id])
    scope = order_by_title(scope)
  end

  private

  def published(scope)
    scope.where(published: true)
  end

  def by_artist_id(scope, artist_id)
    artist_id ? scope.where(artist_id: artist_id) : scope
  end

  def order_by_title(scope)
    scope.order(:title)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The latter approach makes the query object more robust by making &lt;code&gt;params&lt;/code&gt;
optional. Also, notice that we can now call &lt;code&gt;AllSongsQuery.new.call&lt;/code&gt;.
If you&amp;#39;re not a big fan of this, you can resort to class methods. If you write
your query class with class methods, it will no longer be an &amp;#39;object&amp;#39;, but this
is a matter of personal taste. For illustration purposes, let&amp;#39;s see how we can make&lt;code&gt;AllSongsQuery&lt;/code&gt; simpler to call in the wild.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/queries/all_songs_query.rb

class AllSongsQuery
  class &amp;lt;&amp;lt; self
    def call(params = {}, songs = Song.all)
      scope = published(songs)
      scope = by_artist_id(scope, params[:artist_id])
      scope = order_by_title(scope)
    end

    private

    def published(scope)
      scope.where(published: true)
    end

    def by_artist_id(scope, artist_id)
      artist_id ? scope.where(artist_id: artist_id) : scope
    end

    def order_by_title(scope)
      scope.order(:title)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we can call &lt;code&gt;AllSongsQuery.call&lt;/code&gt; and we&amp;#39;re done. We can pass in &lt;code&gt;params&lt;/code&gt;
with &lt;code&gt;artist_id&lt;/code&gt;. Also, we can pass the initial scope if we need to change it
for some reason. If you really want to avoid calling &lt;code&gt;new&lt;/code&gt; over a query class, try out this &amp;#39;trick&amp;#39;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/queries/application_query.rb

class ApplicationQuery
  def self.call(*params)
    new(*params).call
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can create the &lt;code&gt;ApplicationQuery&lt;/code&gt; and then inherit from it in other query
classes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/queries/all_songs_query.rb
class AllSongsQuery &amp;lt; ApplicationQuery
  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You still kept the &lt;code&gt;AllSongsQuery.call&lt;/code&gt;, but you made it more elegant.&lt;/p&gt;
&lt;p&gt;What&amp;#39;s great about query objects is that you can test them in isolation and
ensure that they are doing what they should do. Furthermore, you can extend these query
classes and test them without worrying too much about the logic in the
controller. One thing to note is that you should handle your request parameters
elsewhere, and not rely on the query object to do so. What do you think, are you going to give query object a try?&lt;/p&gt;
&lt;h2 id=&quot;ready-to-serve&quot;&gt;Ready To Serve&lt;/h2&gt;
&lt;p&gt;OK, so we&amp;#39;ve handled ways to delegate the gathering and fetching of data into Query
Objects. What do we do with the pilled-up logic between data gathering and the
step where we render it? Good that you asked, because one of the solutions is
to use what are called Services. A service is oftentimes regarded as a PORO
(Plain Old Ruby Object) that performs a single (business) action. We will go ahead and explore this idea a bit below.&lt;/p&gt;
&lt;p&gt;Imagine we have two services. One creates a receipt, the other sends a receipt
to the user like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/services/create_receipt_service.rb
class CreateReceiptService
  def self.call(total, user_id)
    Receipt.create!(total: total, user_id: user_id)
  end
end

# app/services/send_receipt_service.rb
class SendReceiptService
  def self.call(receipt)
    UserMailer.send_receipt(receipt).deliver_later
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, in our controller we would call the &lt;code&gt;SendReceiptService&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/controllers/receipts_controller.rb

class ReceiptsController &amp;lt; ApplicationController
  def create
    receipt = CreateReceiptService.call(total: receipt_params[:total],
                                        user_id: receipt_params[:user_id])

    SendReceiptService.call(receipt)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you have two services doing all the work, and the controller just
calls them. You can test these separately, but the problem is, there&amp;#39;s no
clear connection between the services. Yes, in theory, all of them perform a
single business action. But, if we consider the abstraction level from the
stakeholders&amp;#39; perspective — their view of the action of creating a receipt
involves sending an email of it. Whose level of abstraction is &amp;#39;right&amp;#39;™️?&lt;/p&gt;
&lt;p&gt;To make this thought experiment a bit more complex, let&amp;#39;s add a requirement that
the total sum on the receipt has to be calculated or fetched from somewhere
during the creation of the receipt. What do we do then? Write another service to
handle the summation of the total sum? The answer might be to follow the Single
Responsibility Principle (SRP) and abstract things away from each other.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/services/create_receipt_service.rb
class CreateReceiptService
  ...
end

# app/services/send_receipt_service.rb
class SendReceiptService
  ...
end

# app/services/calculate_receipt_total_service.rb
class CalculateReceiptTotalService
  ...
end

# app/controllers/receipts_controller.rb
class ReceiptsController &amp;lt; ApplicationController
  def create
    total = CalculateReceiptTotalService.call(user_id: receipts_controller[:user_id])

    receipt = CreateReceiptService.call(total: total,
                                        user_id: receipt_params[:user_id])

    SendReceiptService.call(receipt)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By following SRP, we make sure that our services can be composed together into
larger abstractions, like the &lt;code&gt;ReceiptCreation&lt;/code&gt; process. By creating this &amp;#39;process&amp;#39;
class, we can group all the actions needed to complete the process. What do you
think about this idea? It might sound like too much abstraction at first,
but it might prove beneficial if you are calling these actions all over the place.
If this sounds good to you, check out the &lt;a href=&quot;https://trailblazer.to/2.1/docs/operation.html&quot;&gt;Trailblazer&amp;#39;s Operation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To sum up, the new &lt;code&gt;CalculateReceiptTotalService&lt;/code&gt; service can deal with all the
number crunching. Our &lt;code&gt;CreateReceiptService&lt;/code&gt; is responsible for writing a
receipt to the database. The &lt;code&gt;SendReceiptService&lt;/code&gt; is there to dispatch emails
to users about their receipts. Having these small and focused classes can make
combining them in other use cases easier, thus resulting in an easier to
maintain and easier to test codebase.&lt;/p&gt;
&lt;h3 id=&quot;the-service-backstory&quot;&gt;The Service Backstory&lt;/h3&gt;
&lt;p&gt;In the Ruby world, the approach of using service classes is also known as actions,
operations, and similar. What these all boil down to is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Command_pattern&quot;&gt;Command pattern&lt;/a&gt;.
The idea behind the Command pattern is that an object (or in our example, a
class) is encapsulating all the information needed to perform a business
action or trigger an event. The information that the caller of the command
should know is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name of the command&lt;/li&gt;
&lt;li&gt;method name to call on the command object/class&lt;/li&gt;
&lt;li&gt;values to be passed for the method parameters&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, in our case, the caller of a command is a controller. The approach
is very similar, just that the naming in Ruby is &amp;#39;Service&amp;#39;.&lt;/p&gt;
&lt;h2 id=&quot;split-up-the-work&quot;&gt;Split Up The Work&lt;/h2&gt;
&lt;p&gt;If your controllers are calling some 3rd party services and they are blocking
your rendering, maybe it&amp;#39;s time to extract these calls and render them
separately with another controller action. An example of this
can be when you try to render a book&amp;#39;s information and fetch its rating from some other service
that you can&amp;#39;t really influence (like Goodreads).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/controllers/books_controller.rb

class BooksController &amp;lt; ApplicationController
  def show
    @book = Book.find(params[:id])

    @rating = GoodreadsRatingService.new(book).call
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If Goodreads is down or something similar, your users are going to have to wait
for the request to Goodreads servers to timeout. Or, if something is slow on their
servers, the page will load slowly. You can extract the calling of the 3rd party service
into another action like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/controllers/books_controller.rb

class BooksController &amp;lt; ApplicationController
  ...

  def show
    @book = Book.find(params[:id])
  end

  def rating
    @rating = GoodreadsRatingService.new(@book).call

    render partial: &amp;#39;book_rating&amp;#39;
  end

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, you will have to call the &lt;code&gt;rating&lt;/code&gt; path from your views, but hey, your show
action doesn&amp;#39;t have a blocker anymore. Also, you need the &amp;#39;book_rating&amp;#39;
partial. To do this more easily, you can use the &lt;a href=&quot;https://github.com/renderedtext/render_async&quot;&gt;render_async gem&lt;/a&gt;.
You just need to put the following statement where you render your book&amp;#39;s rating:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;%= render_async book_rating_path %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Extract HTML for rendering the rating into the &lt;code&gt;book_rating&lt;/code&gt; partial, and put:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;%= content_for :render_async %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Inside your layout file, the gem will call &lt;code&gt;book_rating_path&lt;/code&gt; with an AJAX
request once your page loads, and when the rating is fetched, it will show it
on the page. One big gain in this is that your users get to see the book page
faster by loading ratings separately.&lt;/p&gt;
&lt;p&gt;Or, if you want, you can use &lt;a href=&quot;https://turbo.hotwire.dev/handbook/frames#lazily-loading-frames&quot;&gt;Turbo Frames&lt;/a&gt; from Basecamp.
The idea is the same, but you just use the &lt;code&gt;&amp;lt;turbo-frame&amp;gt;&lt;/code&gt; element in your markup like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;turbo-frame id=&amp;quot;rating_1&amp;quot; src=&amp;quot;/books/1/rating&amp;quot;&amp;gt; &amp;lt;/turbo-frame&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Whatever option you choose, the idea is to split the heavy or flaky work from
your main controller action and show the page to the user as soon as possible.&lt;/p&gt;
&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;If you like the idea of keeping controllers thin and picture them as just
&amp;#39;callers&amp;#39; of other methods, then I believe this post brought some insight on
how to keep them that way. The few patterns and anti-patterns that we mentioned
here are, of course, not an exhaustive list. If you have an idea on what is better or
what you prefer, please reach out on Twitter and we can discuss.&lt;/p&gt;
&lt;p&gt;Definitely stay tuned on this series, we are going to do at least one more
blog post where we sum up common Rails problems and takeaways from the series.&lt;/p&gt;
&lt;p&gt;Until next time, cheers!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Troubleshooting ActiveRecord Performance</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/02/24/troubleshooting-activerecord-performance.html">
    <id>https://blog.appsignal.com/2021/02/24/troubleshooting-activerecord-performance.html</id>
    <published>2021-02-24T00:00:00+00:00</published>
    <updated>2021-02-24T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">You usually don't need to worry about AcriveRecord and its inner workings. This post comes in handy when performance issues arise and you have to start worrying about it.</summary>
    <content type="html">&lt;p&gt;ActiveRecord is Ruby on Rails’ most magical feature. We don’t usually need to worry about its inner workings, but when we do, here’s how AppSignal can help us know what’s going on under the hood.&lt;/p&gt;
&lt;h2 id=&quot;what-is-activerecord&quot;&gt;What Is ActiveRecord?&lt;/h2&gt;
&lt;p&gt;To talk about ActiveRecord, we need to first think of frameworks, specifically about MVC frameworks. MVC stands for Model-View-Controller, and it’s a popular software design pattern for graphical and web applications.&lt;/p&gt;
&lt;p&gt;MVC frameworks are composed of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Model&lt;/strong&gt;: handles business logic and data persistence.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;View&lt;/strong&gt;: drives the presentation layer and draws the user interface.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Controller&lt;/strong&gt;: ties everything together.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ActiveRecord is the &lt;em&gt;model&lt;/em&gt; component in the Ruby in Rails framework. It introduces an abstraction layer between code and data, so we don’t have to write SQL code ourselves. Each model is mapped to one table and provides various methods to perform CRUD operations (Create, Read, Update and Delete).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/activerecord.png&quot; alt=&quot;ActiveRecord in action&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;monitoring-activerecord-with-appsignal&quot;&gt;Monitoring ActiveRecord With AppSignal&lt;/h2&gt;
&lt;p&gt;Abstractions feel magical — they help us ignore details we don’t need to know and focus on the task at hand. But when things don’t work as expected, the complexity they add can make it harder to determine the root cause. AppSignal can give us a detailed breakdown of what’s really happening in Rails.&lt;/p&gt;
&lt;h2 id=&quot;the-response-time-graph&quot;&gt;The Response Time Graph&lt;/h2&gt;
&lt;p&gt;Let’s get a first look into the problem. Troubleshooting performance issues is an iterative process. Once you have your Rails application &lt;a href=&quot;https://docs.appsignal.com/ruby/integrations/rails.html&quot;&gt;reporting to AppSignal&lt;/a&gt;, go to &lt;a href=&quot;https://appsignal.com/redirect-to/app?to=performance&quot;&gt;&lt;strong&gt;Incidents&lt;/strong&gt; &amp;gt; &lt;strong&gt;Performance&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/response-time.png&quot; alt=&quot;Response Time Graph&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The Response Time graph will show the response time percentiles for each &lt;a href=&quot;https://docs.appsignal.com/guides/namespaces.html&quot;&gt;namespace&lt;/a&gt;. ActiveRecord events are automatically assigned to the namespace the request or background job the queries are executed in.&lt;/p&gt;
&lt;p&gt;Next, look at the Event Group graph. It shows how much time is consumed by category. Check how much relative time is spent by &lt;code&gt;active_record&lt;/code&gt;. Check the usage in all your namespaces.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/events-group1.png&quot; alt=&quot;Event Group&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The graph will immediately tell us where we should focus our code-optimizing efforts.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/events-group2.png&quot; alt=&quot;Event Group Durations&quot;/&gt;&lt;/p&gt;
&lt;p&gt;While you’re in the performance graph dashboard, check the response time and the throughput to ensure there isn’t any higher-than-usual activity on your application.&lt;/p&gt;
&lt;h2 id=&quot;the-slow-queries-dashboard&quot;&gt;The Slow Queries Dashboard&lt;/h2&gt;
&lt;p&gt;Now that we’ve identified that the problem is data-bound let’s see if we can zoom in to determine the root cause.&lt;/p&gt;
&lt;p&gt;Open the &lt;a href=&quot;https://appsignal.com/redirect-to/app?to=improve/queries&quot;&gt;&lt;strong&gt;Improve&lt;/strong&gt; &amp;gt; &lt;strong&gt;Slow Queries&lt;/strong&gt;&lt;/a&gt; dashboard. This page shows the list of SQL queries ranked by impact on the overall time. All ActiveRecord-originated queries are shown as a &lt;code&gt;sql.active_record&lt;/code&gt; events.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/slow-queries1.png&quot; alt=&quot;Slow Query List&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Try clicking on the topmost query to see its details. The dashboard shows the average duration and the query text.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/query-detail3.png&quot; alt=&quot;Query Detail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Scrolling below will show you the query’s response time in the last few hours and the originating action.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/query-detail2.png&quot; alt=&quot;Query Action&quot;/&gt;&lt;/p&gt;
&lt;p&gt;You might find that some of the actions have an associated incident. This means that AppSignal created a performance incident while the query was running, but it doensn’t necessarily mean that ActiveRecord is the cause of it.&lt;/p&gt;
&lt;h2 id=&quot;performance-measurements-dashboard&quot;&gt;Performance Measurements Dashboard&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.appsignal.com/application/notification-settings.html#performance-incident-notification-settings&quot;&gt;Performance measurement incidents&lt;/a&gt; are opened when AppSignal records a new endpoint or background job.&lt;/p&gt;
&lt;p&gt;Incidents are located on &lt;a href=&quot;https://appsignal.com/redirect-to/app?to=performance&quot;&gt;&lt;strong&gt;Performance&lt;/strong&gt; &amp;gt; &lt;strong&gt;Issue List&lt;/strong&gt;&lt;/a&gt; dashboard.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/web-incidents.png&quot; alt=&quot;Performance issue list&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The incident page shows the elapsed time and number of allocations for each of the MVC components. ActiveRecord problems will exhibit long durations in the &lt;code&gt;active_record&lt;/code&gt; category.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/incident1-sample.png&quot; alt=&quot;Sample breakdown of an ActiveRecord incident&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The event timeline shows how the event progressed over time.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/incident1-timeline.png&quot; alt=&quot;Incident timeline&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;finding-activerecord-issues&quot;&gt;Finding ActiveRecord Issues&lt;/h2&gt;
&lt;p&gt;In this section, we’ll see how AppSignal can help us identify some common ActiveError issues.&lt;/p&gt;
&lt;h2 id=&quot;selecting-the-relevant-columns&quot;&gt;Selecting the Relevant Columns&lt;/h2&gt;
&lt;p&gt;Database wisdom says that we should always retrieve the columns needed for the job. For example, instead of &lt;code&gt;SELECT * FROM people&lt;/code&gt; we should &lt;code&gt;SELECT first_name, surname, birthdate FROM people&lt;/code&gt;. That’s all well and good, but how do we do it on Rails?&lt;/p&gt;
&lt;p&gt;By default, ActiveRecord retrieves all columns.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Person.all.each {
      # process data
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Luckily, we have the &lt;code&gt;select&lt;/code&gt; method to pick and choose the required columns:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Person.select(:name, :address, :birthdate).each {
      # process data
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It may sound like I’m being obsessive about little details. But on wide tables, selecting all columns is just wasteful. You’ll notice that when this happens, ActiveRecord allocates big chunks of memory:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/allocations.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;n1-problems&quot;&gt;N+1 Problems&lt;/h2&gt;
&lt;p&gt;The N+1 problem happens when the application gets a set of records from the database and loops through it. This causes the application to execute N+1 queries, where N is the number of rows initially obtained. As you might imagine, this pattern scales poorly as the table grows. It’s such a damaging problem that AppSignal specifically warns you about it:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/n+1-warning.png&quot; alt=&quot;N+1 Warning&quot;/&gt;&lt;/p&gt;
&lt;p&gt;N+1 problems usually appear with associated models. Imagine we have a Person model:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Person &amp;lt; ApplicationRecord
    has_many :addresses
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each person can have many addresses:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Address &amp;lt; ApplicationRecord
    belongs_to :person
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The most straightforward way of retrieving the data leads to the N+1 problem:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class RelatedTablesController &amp;lt; ApplicationController
    def index
        Person.all.each do |person|
            person.addresses.each do |address|
            address.address
            end
        end
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see in AppSignal that the application is running a &lt;code&gt;SELECT&lt;/code&gt; per person:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/related-query.png&quot; alt=&quot;N+1 Query&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The fix for this particular case is simple: use &lt;a href=&quot;https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-includes&quot;&gt;includes&lt;/a&gt;, which tells ActiveRecord to optimize the query for the needed columns:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class RelatedTablesController &amp;lt; ApplicationController
    def index
        Person.all.includes(:addresses).each do |person|
            person.addresses.each do |address|
            address.address
            end
        end
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have two queries instead of N+1:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Processing by RelatedTablesController#index as HTML
   (0.2ms)  SELECT sqlite_version(*)
  ↳ app/controllers/related_tables_controller.rb:12:in `index&amp;#39;
  Person Load (334.6ms)  SELECT &amp;quot;people&amp;quot;.* FROM &amp;quot;people&amp;quot;
  ↳ app/controllers/related_tables_controller.rb:12:in `index&amp;#39;

  Address Load (144.4ms)  SELECT &amp;quot;addresses&amp;quot;.* FROM &amp;quot;addresses&amp;quot; WHERE &amp;quot;addresses&amp;quot;.&amp;quot;person_id&amp;quot; IN (1, 2, 3, . . .)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;execute-the-least-necessary-queries-per-table&quot;&gt;Execute the Least Necessary Queries Per Table&lt;/h2&gt;
&lt;p&gt;This is sometimes confused with the N+1 problem, but it’s a bit different. When we query a table, we should retrieve all the data we think we’ll need to minimize read operations. There is, however, a lot of innocent-looking code that triggers redundant queries. For example, look how &lt;code&gt;count&lt;/code&gt; always results in a &lt;code&gt;SELECT COUNT(*)&lt;/code&gt; query in the following view:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;lt;ul&amp;gt;
    &amp;lt;% @people.each do |person| %&amp;gt;
        &amp;lt;li&amp;gt;&amp;lt;%= person.name %&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;% end %&amp;gt;
&amp;lt;/ul&amp;gt;

&amp;lt;h2&amp;gt;Number of Persons: &amp;lt;%= @people.count %&amp;gt;&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now ActiveRecord does two queries:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Rendering duplicated_table_query/index.html.erb within layouts/application
  (69.1ms)  SELECT COUNT(*) FROM &amp;quot;people&amp;quot; WHERE &amp;quot;people&amp;quot;.&amp;quot;name&amp;quot; = ?  [[&amp;quot;name&amp;quot;, &amp;quot;John Waters&amp;quot;]]
↳ app/views/duplicated_table_query/index.html.erb:3
Person Load (14.6ms)  SELECT &amp;quot;people&amp;quot;.* FROM &amp;quot;people&amp;quot; WHERE &amp;quot;people&amp;quot;.&amp;quot;name&amp;quot; = ?  [[&amp;quot;name&amp;quot;, &amp;quot;John Waters&amp;quot;]]
↳ app/views/duplicated_table_query/index.html.erb:6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In AppSignal, the symptom you’ll notice is that there are two &lt;code&gt;active_record&lt;/code&gt; events on the same table:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/duplicated-events.png&quot; alt=&quot;Duplicated Query&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The reality is that we don’t need two queries; we already have all the data we need in memory. In this case, the solution is to swap &lt;code&gt;count&lt;/code&gt; with &lt;code&gt;size&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;lt;ul&amp;gt;
&amp;lt;% @people.each do |person| %&amp;gt;
&amp;lt;li&amp;gt;&amp;lt;%= person.name %&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;% end %&amp;gt;
&amp;lt;/ul&amp;gt;

&amp;lt;h2&amp;gt;Number of Persons: &amp;lt;%= @people.size %&amp;gt;&amp;lt;/h2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have a single &lt;code&gt;SELECT&lt;/code&gt;, as it should be:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Rendering duplicated_table_query/index.html.erb within layouts/application
Person Load (63.2ms)  SELECT &amp;quot;people&amp;quot;.* FROM &amp;quot;people&amp;quot; WHERE &amp;quot;people&amp;quot;.&amp;quot;name&amp;quot; = ?  [[&amp;quot;name&amp;quot;, &amp;quot;Abdul Strosin&amp;quot;]]
↳ app/views/duplicated_table_query/index.html.erb:5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another solution is to use &lt;a href=&quot;https://api.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-preload&quot;&gt;preload&lt;/a&gt; to cache the data in memory.&lt;/p&gt;
&lt;h2 id=&quot;computing-aggregated-data-in-rails&quot;&gt;Computing Aggregated Data in Rails&lt;/h2&gt;
&lt;p&gt;Aggregation is used to compute a value based on a set of data. Databases are great at working with big datasets. This is what they do and what we use them for. On the other hand, using Rails to aggregate doesn&amp;#39;t scale since it requires getting all the records from the database, holding them in memory, and then calculating using high-level code.&lt;/p&gt;
&lt;p&gt;We’re doing aggregation in Rails whenever we resort to Ruby functions like &lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, or &lt;code&gt;sum&lt;/code&gt; over ActiveRecord elements or other enumerables.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class AggregatedColumnsController &amp;lt; ApplicationController
    def index
        @mean = Number.pluck(:number).sum()
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/aggregated-query.png&quot; alt=&quot;Aggregation on Rails&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Fortunately, ActiveRecord models include specific methods that map to aggregation functions in the database. For example, the following query maps to &lt;code&gt;SELECT SUM(number) FROM ...&lt;/code&gt;, which is much faster and cheaper to run than the previous example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# controller

class AggregatedColumnsController &amp;lt; ApplicationController
    def index
        @mean = Number.sum(:number)
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;Processing by AggregatedColumnsController#index as */*
  (2.4ms)  SELECT SUM(&amp;quot;numbers&amp;quot;.&amp;quot;number&amp;quot;) FROM &amp;quot;numbers&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you need more complex or combined aggregation functions, you may need to include a bit of raw SQL code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;sql = &amp;quot;SELECT AVG(number), STDDEV(number), VAR(number) FROM ...&amp;quot;
@results = ActiveRecord::Base.connection.execute(sql)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;managing-big-transactions&quot;&gt;Managing Big Transactions&lt;/h2&gt;
&lt;p&gt;SQL transactions ensure consistent and atomic updates. When we use a transaction to make a change, either every row is updated successfully, or the whole thing is rolled back. In any case, the database always remains in a consistent state.&lt;/p&gt;
&lt;p&gt;We can bundle a batch of changes in a single transaction with &lt;code&gt;ActiveRecord::Base.transaction&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class BigTransactionController &amp;lt; ApplicationController
    def index
        ActiveRecord::Base.transaction do
            (1..1000).each do
                Person.create(name: &amp;#39;Les Claypool&amp;#39;)
            end
        end
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a lot of legitimate cases for using large transactions. These, however, run into the risk of slowing the database down. Besides, transactions exceeding certain thresholds will result in the database rejecting them.&lt;/p&gt;
&lt;p&gt;The first sign of transactions being too big is spending a lot of time on &lt;code&gt;commit transaction&lt;/code&gt; events:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/img/bigtran.png&quot; alt=&quot;Commit Event in the Slow Dashboard&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Barring configuration issues on the database itself, the solution is to break down the transaction into smaller chunks.&lt;/p&gt;
&lt;h2 id=&quot;monitoring-the-database&quot;&gt;Monitoring The Database&lt;/h2&gt;
&lt;p&gt;Sometimes even though we search the code, we can’t find anything wrong with it. Then, there may be a problem in the database itself. Database engines are complex, and many things can go wrong: low memory, default settings, missing indexes, inconveniently-scheduled backup jobs. The picture can’t be complete unless we get information about the machine running the database.&lt;/p&gt;
&lt;p&gt;If we’re running our own databases, we can install the &lt;a href=&quot;https://docs.appsignal.com/standalone-agent/installation.html&quot;&gt;standalone agent&lt;/a&gt; to capture host metrics. To learn more about how to use the standalone agent, read: &lt;a href=&quot;/2020/09/23/monitoring-any-system-with-statsd-and-the-standalone-appsignal-agent.html&quot;&gt;Monitoring Any System with StatsD and AppSignal’s Standalone Agent&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The following signs might show something is going on with the database. Go to the &lt;a href=&quot;https://appsignal.com/redirect-to/app?to=host_metrics&quot;&gt;&lt;strong&gt;Inspect&lt;/strong&gt; &amp;gt; &lt;strong&gt;Host Metrics&lt;/strong&gt;&lt;/a&gt; dashboard to see the resource usage in your server:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;High memory usage&lt;/strong&gt;: databases need a lot of memory — more than most other systems — to run correctly. As the dataset grows, memory requirements usually scale along. We’ll need to either add more memory or split the dataset among different machines from time to time.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Swap usage&lt;/strong&gt;: ideally, database machines should not need swap memory at all. Swapping kills database performance. Its presence means there’s a more in-depth configuration or memory problem.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;High I/O usage&lt;/strong&gt;: peaks in disk activity can be due to maintenance tasks such as re-indexing or backing up the database. Doing these tasks during peak hours will definitely hit performance.&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;👋 If you like this article, there is a lot more we wrote about &lt;a href=&quot;https://www.appsignal.com/ruby&quot;&gt;Ruby (on Rails) performance&lt;/a&gt;, check out our &lt;a href=&quot;https://www.appsignal.com/ruby#ruby-monitoring-checklist&quot;&gt;Ruby performance monitoring checklist&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Diagnosing performance issues is never an easy task. Today, we’ve learned how to use Appsignal to quickly pinpoint the source of the problem.&lt;/p&gt;
&lt;p&gt;Let’s keep learning about AppSignal and Ruby on Rails:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/2018/04/24/active-record-performance-the-n-1-queries-antipattern.html&quot;&gt;ActiveRecord performance: the N+1 queries antipattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/01/22/rails-is-fast-optimize-your-view-performance.html&quot;&gt;Rails is Fast: Optimize Your View Performance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/08/05/introduction-to-ruby-on-rails-patterns-and-anti-patterns.html&quot;&gt;Introduction to Ruby on Rails Patterns and Anti-patterns&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Using Webpacker in Your Ruby on Rails Application — a Deep Dive</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/02/17/using-webpacker-in-your-ruby-on-rails-app-deep-dive.html">
    <id>https://blog.appsignal.com/2021/02/17/using-webpacker-in-your-ruby-on-rails-app-deep-dive.html</id>
    <published>2021-02-17T00:00:00+00:00</published>
    <updated>2021-02-17T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's take a deep dive into Webpacker and see how the tool works under the hood.</summary>
    <content type="html">&lt;p&gt;At the beginning of the internet age, websites were much simpler and not very interactive. With the advancement of technology, devices, and programming languages, they became more complex and consisted of several files, including assets like images and CSS stylesheets.&lt;/p&gt;
&lt;p&gt;The more interactive your website is, the more JavaScript code you have to use. To use such code, you have to include all HTML code files using the script tag. Such an approach is error-prone because you have to remember to include every single file and keep the correct order, otherwise, your code may not work. With the Webpack tool, these problems go away. Webpacker is a bridge between Webpack and a Rails application.&lt;/p&gt;
&lt;p&gt;This article takes a deep dive into Webpacker and offers a detailed explanation that will enable you to understand how this tool works under the hood. To make the content as valuable as possible, I decided to divide it into the following sections:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;High-level overview&lt;/strong&gt; — before we do the deep dive, I will explain the high-level overview of both Webpack and Webpacker. You can treat it as the preparation for more advanced topics.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Structure explanation&lt;/strong&gt; — since we&amp;#39;ll explore multiple files, it is good to know why the particular structure was used and how it responds to the general purpose.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anatomy explanation&lt;/strong&gt; — this part covers the investigation of the most important files of the Webpack setup. Knowing how they work is essential for the effective and hassle-free development process.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Environment specific setup&lt;/strong&gt; — the last part explains how Webpacker works in development and production environments.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After reading this article, you&amp;#39;ll know what Webpack and Webpacker are and why we need them in our Rails application. The deep dive into Webpacker’s internals will help you understand how the tool connects with Webpack and how it communicates with the Rails application.&lt;/p&gt;
&lt;h2 id=&quot;before-diving-in&quot;&gt;Before Diving In&lt;/h2&gt;
&lt;p&gt;Before going out into deep water, we first need to prepare. A high-level overview is a great way to start working with any technology as it helps us understand the purpose of a given tool and the problems it solves without going deep into its internals.&lt;/p&gt;
&lt;h2 id=&quot;webpack&quot;&gt;Webpack&lt;/h2&gt;
&lt;p&gt;I already mentioned that Webpack helps us organize our JavaScript file code to avoid errors and improve a website’s performance. It organizes the code into bundles.&lt;/p&gt;
&lt;p&gt;A bundle is a file where multiple modules are intelligently placed, respecting the dependency graph that is first created. Thanks to this process, we can be sure that our code will work as expected and before we invoke a given library’s code, it will have been loaded.&lt;/p&gt;
&lt;p&gt;Webpack isn&amp;#39;t the only tool that is used by default in the newest version of Rails. When the project is generated, the configuration files for Babel and PostCSS are created as well. PostCSS is a tool for transforming CSS with JavaScript, and Babel is a JavaScript compiler that enables us to write modern JavaScript without worrying about browser support.&lt;/p&gt;
&lt;h2 id=&quot;webpacker&quot;&gt;Webpacker&lt;/h2&gt;
&lt;p&gt;Webpacker is a tool that integrates Webpack with a Rails application. It makes it easy to configure and develop JavaScript-like applications and optimize them for the production environment.&lt;/p&gt;
&lt;p&gt;The source code is available as a gem, and the library comes with a development server that makes the development of the app very fast as you don’t have to stop and start the server to see the changes introduced in the JavaScript files.&lt;/p&gt;
&lt;h2 id=&quot;the-deep-immersion&quot;&gt;The Deep Immersion&lt;/h2&gt;
&lt;p&gt;Now that you know why Webpack was created and what role Wepacker plays in a Rails application, we can focus on Webpacker’s internals to see how it organizes files, speeds up the development process, and optimizes files for the production environment.&lt;/p&gt;
&lt;p&gt;Webpacker is available out-of-the-box in the newest version of Rails. Before creating a new project, ensure that the Node version is greater or equal to 10.17.0 as the &lt;code&gt;webpacker:install&lt;/code&gt; command will be automatically invoked with rails new command.&lt;/p&gt;
&lt;h2 id=&quot;webpacker-file-structure&quot;&gt;Webpacker File Structure&lt;/h2&gt;
&lt;p&gt;After the install command is executed, the following files are created:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;config/webpacker.yml&lt;/code&gt; — the main configuration file that contains the default configuration and configs for specific environments&lt;/li&gt;
&lt;li&gt;&lt;code&gt;config/webpacker/&lt;/code&gt; — the directory where the JavaScript configuration files for particular environments are created&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bin/webpack&lt;/code&gt; — an executable file that invokes webpack to create bundles&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bin/webpack-dev-server&lt;/code&gt; — an executable file that starts the development server, which reloads webpack every time you make a change inside the JavaScript files included in the bundle&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;the-anatomy-of-the-configuration-file&quot;&gt;The Anatomy of the Configuration File&lt;/h2&gt;
&lt;p&gt;The main configuration file for Webpacker is located under the config directory, and it’s named &lt;code&gt;webpacker.yml&lt;/code&gt;. Unlike Webpacker, configuration for Webpack is stored separately for each environment under the &lt;code&gt;config/webpack&lt;/code&gt; directory.&lt;/p&gt;
&lt;h3 id=&quot;webpacker-1&quot;&gt;Webpacker&lt;/h3&gt;
&lt;p&gt;By default, the configuration file contains many entries — default ones, and sections for each environment where you can overwrite specific settings. Let’s take a look at the most important settings:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;source_path&lt;/code&gt; — the primary source of javascript files in your application. It’s set to &lt;code&gt;app/javascript&lt;/code&gt; by default, and usually, there&amp;#39;s no need to change this value.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source_entry_path&lt;/code&gt; — the name of the directory under the source_path where you keep the pack files, aka entry points. By default, this setting is set to the packs’ directory.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public_root_path&lt;/code&gt; — path to the directory in your application that is accessible from a browser. In a typical Rails application, it’s a public directory&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public_output_path&lt;/code&gt; — when Webpacker compiles your files, it will put all compiled files in this directory under the &lt;code&gt;public_root_path&lt;/code&gt;. By default, the directory is named packs, but you can call it whatever you want.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;webpack_compile_output&lt;/code&gt; — if the flag is set to true, then output messages are displayed when files are compiled. It’s useful when compilation fails, as you&amp;#39;ll be aware of that and can take action.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It is worth mentioning that the development section also contains configuration for the dev server that is used to compile files in the development environment without the need for restarting the server.&lt;/p&gt;
&lt;p&gt;If you would like to access the configuration from the rails console or code level, you can call &lt;code&gt;Webpacker.manifest.config&lt;/code&gt;, which will return the configuration class instance.&lt;/p&gt;
&lt;h3 id=&quot;webpack-1&quot;&gt;Webpack&lt;/h3&gt;
&lt;p&gt;Each environment has its configuration file, but in every file, the main environment file is imported: &lt;code&gt;config/webpack/environment.js&lt;/code&gt;. In the environment configuration file, there is a place for loading custom plugins that will modify the default behavior of Webpack. We can also add custom rules for compiling our files.&lt;/p&gt;
&lt;h2 id=&quot;the-anatomy-of-the-pack-file&quot;&gt;The Anatomy of the Pack File&lt;/h2&gt;
&lt;p&gt;Packs are located under the &lt;code&gt;app/javascript/packs&lt;/code&gt; directory. Each pack file is treated by Webpacker as an entry point when the compilation process starts.&lt;/p&gt;
&lt;h3 id=&quot;the-default-pack-file&quot;&gt;The Default Pack File&lt;/h3&gt;
&lt;p&gt;When you generate a new Rails project, a default pack file named application.js is created with the following content:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;import Rails from &amp;quot;@rails/ujs&amp;quot;;
import Turbolinks from &amp;quot;turbolinks&amp;quot;;
import * as ActiveStorage from &amp;quot;@rails/activestorage&amp;quot;;
import &amp;quot;channels&amp;quot;;

Rails.start();
Turbolinks.start();
ActiveStorage.start();
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, the first step is to import the given library and then call its initialization method when it’s needed. When you call import, the system searches for a given node module or a local library. With the standard approach, you don’t have to explicitly initialize the library as it’s initialized when you include it in the page source with the script tag.&lt;/p&gt;
&lt;h3 id=&quot;good-practices-for-a-pack-file&quot;&gt;Good Practices for a Pack File&lt;/h3&gt;
&lt;p&gt;While you can put regular JavaScript code inside the pack file and execute it, it is not recommended to keep JavaScript code inside the pack file. The best approach is to keep the files clean and only import and initialize libraries here and keep other logic outside the packs directory.&lt;/p&gt;
&lt;h3 id=&quot;including-pack-files-in-the-application&quot;&gt;Including Pack Files in the Application&lt;/h3&gt;
&lt;p&gt;Pack files are not automatically included in the website’s source. Just like in the asset pipeline case, we have to use a special tag inside our views:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;lt;%= javascript_packs_with_chunks_tag &amp;#39;application&amp;#39; %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;How does this method work? Under the hood, it calls the Webpacker configuration that holds the data you put in the &lt;code&gt;config/webpacker.yml&lt;/code&gt; file. It looks for an application.js file inside the entry points directory, which, in our case, is &lt;code&gt;app/javascript/packs&lt;/code&gt;. You can verify it by calling the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Webpacker.manifest.config.source_entry_path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When entries are found, Webpacker calls &lt;code&gt;javascript_include_tag&lt;/code&gt; method, a helper from the &lt;code&gt;ActionView&lt;/code&gt; library available by default in Rails. The method accepts one or more sources and returns script tags that you can apply straight to your view.&lt;/p&gt;
&lt;h2 id=&quot;the-development-server&quot;&gt;The Development Server&lt;/h2&gt;
&lt;p&gt;Webpacker development server’s entry point is the executable file placed inside the &lt;code&gt;bin&lt;/code&gt; folder and named &lt;code&gt;webpack-dev-server&lt;/code&gt;. The process of running the server consists of five steps:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Setting environment&lt;/strong&gt; — the environment name for Node and Rails is set. When the environment is not specified, the program assumes that the server will be executed in the development environment.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Loading configuration&lt;/strong&gt; — the file &lt;code&gt;config/webpacker.yml&lt;/code&gt; is loaded with settings for the environment set in the previous step.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Validating command options&lt;/strong&gt; — the program checks if we passed appropriate options to the server command. For example, it will throw an error when the &lt;code&gt;--https&lt;/code&gt; option is given, but we didn’t specify it in the &lt;code&gt;config/webpacker.yml&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Verifying port’s availability&lt;/strong&gt; — the program checks if the given port is available to use. If another program is already using it, it will throw an error letting you know that you have to update the webpack server configuration inside the &lt;code&gt;config/webpacker.yml&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Executing webpack serve command&lt;/strong&gt; — when the node modules directory exists, the program executes the command within the directory, otherwise, it executes it with yarn. The program passes the configuration option to the command that points to one of the files placed inside the &lt;code&gt;config/webpack/&lt;/code&gt; directory.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The server is now running, and it compiles your code on the fly, so you don’t have to restart the server to see the changes and check if webpack was able to create the bundle with the new code.&lt;/p&gt;
&lt;p&gt;The development server’s code is quite simple. It only loads the config from the configuration file in YAML format and passes the proper config in JavaScript format directly to the &lt;code&gt;webpack serve&lt;/code&gt; command. You can also run it by hand, but you don’t have to take care of proper command arguments with the built-in command.&lt;/p&gt;
&lt;h2 id=&quot;compiling-files-for-the-production-environment&quot;&gt;Compiling Files for the Production Environment&lt;/h2&gt;
&lt;p&gt;Suppose you want to deploy the application that&amp;#39;s using webpacker. In that case, you can simply invoke the &lt;code&gt;assets:precompile&lt;/code&gt; task as Webpacker automatically hooks up the task &lt;code&gt;webpacker:compile&lt;/code&gt; to it.&lt;/p&gt;
&lt;p&gt;How does the &lt;code&gt;webpacker:compile&lt;/code&gt; task work under the hood? Let’s dig into it and see. It does the following things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It wraps the main call into two blocks ensuring that the &lt;code&gt;NODE&lt;/code&gt; environment is set and Webpacker logs are output to the standard out.&lt;/li&gt;
&lt;li&gt;It calls Webpack and then parses its logs to determine if the action was successful or not.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can now visit the &lt;code&gt;public/packs/js&lt;/code&gt; directory to see the compiled files. They should be deployed to the server.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;We have just learned how Webpacker works under the hood. You can treat it as a bridge between the Webpack library and a Rails application that allows you to configure Webpack with Ruby and easily use javascript code inside your application.&lt;/p&gt;
&lt;p&gt;To summarize the whole article, let’s recall the main elements of Webpacker again:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Configuration — it’s placed inside the &lt;code&gt;config/webpacker.yml&lt;/code&gt; file and allows you to point Webpacker to the directory where you keep your javascript files and packs&lt;/li&gt;
&lt;li&gt;Pack — it’s a single entry point from which Webpacker begins compilation. Each library imported and initialized in that file will be automatically compiled.&lt;/li&gt;
&lt;li&gt;Development server — a simple script that allows you to compile files on the fly, so you don’t have to restart the server each time you modify JavaScript files&lt;/li&gt;
&lt;li&gt;Compile task — a simple rake task that invokes Webpack and compiles files under the public directory so you can deploy them to the production server and make them available for end-users&lt;/li&gt;
&lt;li&gt;View helper — helper that allows you to include compiled files inside the views&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For many developers without much experience, Wepacker seems to be a little magical, but in fact, it’s a simple library that helps us use Webpack in a Ruby way.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Ruby on Rails View Patterns and Anti-patterns</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/02/10/ruby-on-rails-view-patterns-and-anti-patterns.html">
    <id>https://blog.appsignal.com/2021/02/10/ruby-on-rails-view-patterns-and-anti-patterns.html</id>
    <published>2021-02-10T00:00:00+00:00</published>
    <updated>2021-02-10T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Rails views are sometimes amazing and fast, and at other times, they can have all sorts of issues. If you want to increase confidence over how you handle your views, then this blog post is for you.</summary>
    <content type="html">&lt;p&gt;Welcome back to the third installment of the Ruby on Rails Patterns and Anti-Patterns series. In the previous posts, we covered patterns and
anti-patterns in general as well as in relation to Rails Models. In this post, we
are going to go over some patterns and anti-patterns associated with Rails views.&lt;/p&gt;
&lt;p&gt;Rails views can sometimes work perfectly and be fast, and at other times, they can have all sorts of issues.
If you want to increase confidence over how you handle your views or you
just want to learn more on the topic, then this blog post is
for you. Let&amp;#39;s dive right in.&lt;/p&gt;
&lt;p&gt;As you probably know, the Rails framework follows convention over configuration.
And since Rails is big on the Model-View-Controller (MVC) pattern, the motto
naturally applies to the View code as well. This includes your markup (ERB or
Slim files), JavaScript and CSS files. At first glance, you might think that the View layer
is pretty straightforward and easy, but keep in mind that these
days, there is a mix of technologies living in the View layer.&lt;/p&gt;
&lt;p&gt;We use JavaScript, HTML, and CSS in the view. These three can
lead to confusion and disorganization of code — leading to implementation
that doesn&amp;#39;t make much sense in the long run. Luckily, today we are going to go
through some common problems and solutions with the Rails View layer.&lt;/p&gt;
&lt;h2 id=&quot;powerlifting-views&quot;&gt;Powerlifting Views&lt;/h2&gt;
&lt;p&gt;This is a mistake that doesn&amp;#39;t happen that often, but when it does, it&amp;#39;s an
eyesore. Sometimes, people tend to put the domain logic or querying directly
inside the View. This makes the View layer do the heavy-lifting or
powerlifting. What is interesting is that Rails actually allows this to easily happen.
There is no &amp;#39;safety net&amp;#39; when it comes to this, you are allowed to do
whatever you want in the View layer.&lt;/p&gt;
&lt;p&gt;By definition, the View layer of the MVC pattern should contain presentation
logic. It shouldn&amp;#39;t be bothered with domain logic or with querying data. In Rails,
you get ERB files (Embedded Ruby) that allow you to write Ruby code
that will then get evaluated into HTML. If we consider an example of a
website that lists songs on the index page, then the view logic would be in
the &lt;code&gt;app/views/songs/index.html.erb&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To illustrate what &amp;quot;powerlifting&amp;quot; means and what not do to, let&amp;#39;s take a look
at the following example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;# app/views/songs/index.html.erb

&amp;lt;div class=&amp;quot;songs&amp;quot;&amp;gt;
  &amp;lt;% Song.where(published: true).order(:title) do |song| %&amp;gt;
    &amp;lt;section id=&amp;quot;song_&amp;lt;%= song.id %&amp;gt;&amp;quot;&amp;gt;
      &amp;lt;span&amp;gt;&amp;lt;%= song.title %&amp;gt;&amp;lt;/span&amp;gt;

      &amp;lt;span&amp;gt;&amp;lt;%= song.description %&amp;gt;&amp;lt;/span&amp;gt;

      &amp;lt;a href=&amp;quot;&amp;lt;%= song.download_url %&amp;gt;&amp;quot;&amp;gt;Download&amp;lt;/a&amp;gt;
    &amp;lt;/section&amp;gt;
  &amp;lt;% end %&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A huge anti-pattern here is the fetching of songs right in the markup. The
responsibility of fetching the data should be delegated to the controller or a
service that is being called from the controller. I sometimes see people prepare
some data in the controller and later fetch more data in the views. This
is bad design and it makes your website slower because you are
stressing your database with queries more often.&lt;/p&gt;
&lt;p&gt;What you should do instead is to expose a &lt;code&gt;@songs&lt;/code&gt; instance variable from the
controller action and call that in the markup, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class SongsController &amp;lt; ApplicationController
  ...

  def index
    @songs = Song.all.where(published: true).order(:title)
  end

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;# app/views/songs/index.html.erb

&amp;lt;div class=&amp;quot;songs&amp;quot;&amp;gt;
  &amp;lt;% @songs.each do |song| %&amp;gt;
    &amp;lt;section id=&amp;quot;song_&amp;lt;%= song.id %&amp;gt;&amp;quot;&amp;gt;
      &amp;lt;span&amp;gt;&amp;lt;%= song.title %&amp;gt;&amp;lt;/span&amp;gt;

      &amp;lt;span&amp;gt;&amp;lt;%= song.description %&amp;gt;&amp;lt;/span&amp;gt;

      &amp;lt;a href=&amp;quot;&amp;lt;%= song.download_url %&amp;gt;&amp;quot;&amp;gt;Download&amp;lt;/a&amp;gt;
    &amp;lt;/section&amp;gt;
  &amp;lt;% end %&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These examples are far from perfect. If you want to keep your controller code
more readable and avoid SQL Pasta, I urge you to check out the
&lt;a href=&quot;/2020/11/18/rails-model-patterns-and-anti-patterns.html&quot;&gt;previous blog post&lt;/a&gt;.
Also, leaving out the logic in the View layer increases the
chances that other people will try to build their solutions off of it.&lt;/p&gt;
&lt;h2 id=&quot;make-use-of-what-rails-gives-you&quot;&gt;Make Use of What Rails Gives You&lt;/h2&gt;
&lt;p&gt;We will keep it short here. Ruby on Rails as a framework comes with a lot of
neat helpers, especially inside the view. These nifty little helpers allow you
to build your View layer quickly and effortlessly. As a beginner user of Rails,
you might be tempted to write the full HTML inside your ERb files like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;# app/views/songs/new.html.erb

&amp;lt;form action=&amp;quot;/songs&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
    &amp;lt;label for=&amp;quot;song_title&amp;quot;&amp;gt;Title&amp;lt;/label&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;song[title]&amp;quot; id=&amp;quot;song_title&amp;quot;&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
    &amp;lt;label for=&amp;quot;song_description&amp;quot;&amp;gt;Description&amp;lt;/label&amp;gt;
    &amp;lt;textarea name=&amp;quot;song[description]&amp;quot; id=&amp;quot;song_description&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
    &amp;lt;label for=&amp;quot;song_download_url&amp;quot;&amp;gt;Download URL&amp;lt;/label&amp;gt;
    &amp;lt;textarea name=&amp;quot;song[download_url]&amp;quot; id=&amp;quot;song_download_url&amp;quot;&amp;gt;&amp;lt;/textarea&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;input type=&amp;quot;submit&amp;quot; name=&amp;quot;commit&amp;quot; value=&amp;quot;Create Song&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this HTML, you should get a nice form for a new song as seen in the screenshot below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-02/new-song-form.png&quot; alt=&quot;New song form&quot;/&gt;&lt;/p&gt;
&lt;p&gt;But, with Rails, you don&amp;#39;t need and you shouldn&amp;#39;t write plain HTML like that
since Rails has your back right there. You can use the &lt;code&gt;form_with&lt;/code&gt; view helper that
will generate the HTML for you. &lt;code&gt;form_with&lt;/code&gt; was introduced in Rails 5.1 and it
is there to replace &lt;code&gt;form_tag&lt;/code&gt; and &lt;code&gt;form_for&lt;/code&gt; that might be familiar to some
folk. Let&amp;#39;s see how &lt;code&gt;form_with&lt;/code&gt; can relieve us from writing extra code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;%= form_with(model: song, local: true) do |form| %&amp;gt;
  &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
    &amp;lt;%= form.label :title %&amp;gt;
    &amp;lt;%= form.text_field :title %&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
    &amp;lt;%= form.label :description %&amp;gt;
    &amp;lt;%= form.text_area :description %&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;div class=&amp;quot;field&amp;quot;&amp;gt;
    &amp;lt;%= form.label :download_url do %&amp;gt;
      Download URL
    &amp;lt;% end %&amp;gt;
    &amp;lt;%= form.text_area :download_url %&amp;gt;
  &amp;lt;/div&amp;gt;

  &amp;lt;%= form.submit %&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Besides generating HTML for us, &lt;code&gt;form_with&lt;/code&gt; also generates an authenticity
token that prevents CSRF attacks. So in almost all cases, you are better off
using designated helpers since they might play well with the Rails framework.
If you tried to submit a plain HTML form, it will fail because there was no
valid authenticity token submitted with the request.&lt;/p&gt;
&lt;p&gt;Besides &lt;code&gt;form_with&lt;/code&gt;, &lt;code&gt;label&lt;/code&gt;, &lt;code&gt;text_area&lt;/code&gt;, and &lt;code&gt;submit&lt;/code&gt; helpers, there are a
bunch more of these view helpers that come out-of-the-box with Rails. They are
there to make your lives easier and you should get to know them better. One of the &amp;quot;all-stars&amp;quot; is definitely &lt;code&gt;link_to&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;%= link_to &amp;quot;Songs&amp;quot;, songs_path %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which will generate the following HTML:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&amp;quot;/songs&amp;quot;&amp;gt;Songs&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I won&amp;#39;t go into much detail on each helper, since this post will be too
long and going through all of them is not part of today&amp;#39;s topic. I suggest you go
through
&lt;a href=&quot;https://guides.rubyonrails.org/action_view_helpers.html&quot;&gt;Rails Action View helpers guide&lt;/a&gt;
and pick what you need for your website.&lt;/p&gt;
&lt;h2 id=&quot;reusing-and-organizing-view-code&quot;&gt;Reusing and Organizing View Code&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s imagine the perfect web application. In the perfect use-case, there are
no if-else statements, just pure code that takes data from the controller and
puts it between HTML tags. That kind of application exists maybe in hackathons
and dreams, but real-world applications have a bunch of branches and
conditions when rendering views.&lt;/p&gt;
&lt;p&gt;What should you do when the logic for showing parts of a page gets too complex? Where do you go from
there? A general answer would be to perhaps reach for a modern JavaScript
library or framework and build something complex. But, since this post
is about Rails Views, let&amp;#39;s look at the options we have inside them.&lt;/p&gt;
&lt;h2 id=&quot;after-market-custom-helpers&quot;&gt;After-Market (Custom) Helpers&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s say you want to show a call-to-action (CTA) button below a song. But,
there is a catch — a Song can either have a download URL or, for whatever reason,
it can be missing. We might be tempted to code something similar to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;app/views/songs/show.html.erb

...

&amp;lt;div class=&amp;quot;song-cta&amp;quot;&amp;gt;
  &amp;lt;% if @song.download_url %&amp;gt;
    &amp;lt;%= link_to &amp;quot;Download&amp;quot;, download_url %&amp;gt;
  &amp;lt;% else %&amp;gt;
    &amp;lt;%= link_to &amp;quot;Subscribe to artists updates&amp;quot;,
                artist_updates_path(@song.artist) %&amp;gt;
  &amp;lt;% end %&amp;gt;
&amp;lt;/div&amp;gt;

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we look at the example above as an isolated presentational logic, it doesn&amp;#39;t
look too bad, right? But, if there are more of these conditional
renders, then the code becomes less readable. It also increases the chances
of something, somewhere not getting rendered properly, especially if there
are more conditions.&lt;/p&gt;
&lt;p&gt;One way to fight these is to extract them to a separate helper. Luckily, Rails
provides us a way to easily write custom helpers. In the &lt;code&gt;app/helpers&lt;/code&gt; we can create a &lt;code&gt;SongsHelper&lt;/code&gt;, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;module SongsHelper
  def song_cta_link
    content_tag(:div, class: &amp;#39;song-cta&amp;#39;) do
      if @song.download_url
        link_to &amp;quot;Download&amp;quot;, @song.download_url
      else
        link_to &amp;quot;Subscribe to artists updates&amp;quot;,
                artist_updates_path(@song.artist)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we open up the show page of a song, we will still get the same results.
However, we can make this example a bit better. In the example above, we used an
instance variable &lt;code&gt;@song&lt;/code&gt;. This might not be available if we decide to use this
helper at a place where &lt;code&gt;@song&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt;. So to cut off an external dependency in the form of an instance variable, we can pass in an argument to the helper like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;module SongsHelper
  def song_cta_link(song)
    content_tag(:div, class: &amp;#39;song-cta&amp;#39;) do
      if song.download_url
        link_to &amp;quot;Download&amp;quot;, song.download_url
      else
        link_to &amp;quot;Subscribe to artists updates&amp;quot;,
                artist_updates_path(song.artist)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, in the view, we can call the helper like below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;app/views/songs/show.html.erb

...

&amp;lt;%= song_cta_link(@song) %&amp;gt;

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that, we should get the same results in the view as we did before. The good thing
about using helpers is that you can write tests for them ensuring that no
regression happens regarding them in the future. A con is that they are
globally defined and you have to ensure that helper names are unique across
your app.&lt;/p&gt;
&lt;p&gt;If you are not a big fan of writing Rails custom helpers, you can always opt-in
for a View Model pattern with the
&lt;a href=&quot;https://github.com/drapergem/draper&quot;&gt;Draper gem&lt;/a&gt;.
Or you can roll your own View Model pattern here, it shouldn&amp;#39;t be that
complicated. If you are just starting out with your web app, I suggest starting
slowly by writing custom helpers and if that brings pain, turn to other
solutions.&lt;/p&gt;
&lt;h2 id=&quot;dry-up-your-views&quot;&gt;DRY up Your Views&lt;/h2&gt;
&lt;p&gt;What I really liked when I started with Rails was the ability to easily DRY up your
markup that it was almost unbelievable to me. Rails gives you the ability
to create partials — reusable code pieces that you can include anywhere. For
example, if you are rendering songs in multiple places, and you have the same
code across multiple files, it makes sense to create a song partial.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s say you show your song as shown below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;# app/views/songs/show.html.erb

&amp;lt;p id=&amp;quot;notice&amp;quot;&amp;gt;&amp;lt;%= notice %&amp;gt;&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
  &amp;lt;strong&amp;gt;Title:&amp;lt;/strong&amp;gt;
  &amp;lt;%= @song.title %&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
  &amp;lt;strong&amp;gt;Description:&amp;lt;/strong&amp;gt;
  &amp;lt;%= @song.description %&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;%= song_cta_link %&amp;gt;

&amp;lt;%= link_to &amp;#39;Edit&amp;#39;, edit_song_path(@song) %&amp;gt; |
&amp;lt;%= link_to &amp;#39;Back&amp;#39;, songs_path %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But, you also want to show it on another page with the same markup. Then you can
create a new file with an underscore prefix like &lt;code&gt;app/views/songs/_song.html.erb&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;# app/views/songs/_song.html.erb

&amp;lt;p&amp;gt;
  &amp;lt;strong&amp;gt;Title:&amp;lt;/strong&amp;gt;
  &amp;lt;%= @song.title %&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
  &amp;lt;strong&amp;gt;Description:&amp;lt;/strong&amp;gt;
  &amp;lt;%= @song.description %&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;%= song_cta_link(@song) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then wherever you want to include the song partial, you just do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;...

&amp;lt;%= render &amp;quot;song&amp;quot; %&amp;gt;

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rails will do an auto-lookup of whether the &lt;code&gt;_song&lt;/code&gt; partial exists and it will
render it. Similar to an example with custom helpers, it is best if we get rid of the instance variable &lt;code&gt;@song&lt;/code&gt; in our partial.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;
# app/views/songs/_song.html.erb
&amp;lt;p&amp;gt;
  &amp;lt;strong&amp;gt;Title:&amp;lt;/strong&amp;gt;
  &amp;lt;%= song.title %&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;p&amp;gt;
  &amp;lt;strong&amp;gt;Description:&amp;lt;/strong&amp;gt;
  &amp;lt;%= song.description %&amp;gt;
&amp;lt;/p&amp;gt;

&amp;lt;%= song_cta_link(song) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, we will need to pass in the song variable to the partial, making it more
reusable and suitable to being included in other places.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;...

&amp;lt;%= render &amp;quot;song&amp;quot;, song: @song %&amp;gt;

...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;That&amp;#39;s all folks for this post. To summarize, we went through a few
patterns and anti-patterns that you can come across in the Rails View realm. Here are a few
takeaways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Avoid complex logic in the UI (do not make the View do lots of powerlifting)&lt;/li&gt;
&lt;li&gt;Learn what Rails gives you out-of-the-box in terms of View helpers.&lt;/li&gt;
&lt;li&gt;Structure and reuse your code with custom helpers and partials&lt;/li&gt;
&lt;li&gt;Do not depend on instance variables too much.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the next post, we will cover Rails Controller patterns and anti-patterns
where things can get pretty messy. Stay tuned for that.&lt;/p&gt;
&lt;p&gt;Until the next one, cheers!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>RBS: A New Ruby 3 Typing Language in Action</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/01/27/rbs-the-new-ruby-3-typing-language-in-action.html">
    <id>https://blog.appsignal.com/2021/01/27/rbs-the-new-ruby-3-typing-language-in-action.html</id>
    <published>2021-01-27T00:00:00+00:00</published>
    <updated>2021-01-27T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's discover the differences and similarities between Sorbet and the recently released RBS through some practical examples.</summary>
    <content type="html">&lt;p&gt;The long-awaited version 3.0.0 of Ruby has finally been &lt;a href=&quot;https://www.ruby-lang.org/en/news/2020/12/25/ruby-3-0-0-released/&quot;&gt;released&lt;/a&gt;. Along with many great improvements, such as a 3x faster performance boost compared to the previous version, concurrency-parallel experimental features, etc., the Ruby team also introduced a new syntax language for dynamic typing in Ruby: &lt;a href=&quot;https://github.com/ruby/rbs&quot;&gt;RBS&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;That was something the team &lt;a href=&quot;https://developer.squareup.com/blog/the-state-of-ruby-3-typing/&quot;&gt;had been discussing&lt;/a&gt; for years, based on the success of community-developed tools for static type checking such as &lt;a href=&quot;https://sorbet.org/&quot;&gt;Sorbet&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Sorbet is a powerful type checker backed by Stripe. It checks your code by both annotating and/or defining &lt;a href=&quot;https://sorbet.org/docs/rbi&quot;&gt;RBI&lt;/a&gt; files. RBI files, in turn, work as interfaces between static and dynamic components providing a &amp;quot;description&amp;quot; of them (constants, ancestors, metaprogramming code, and more).&lt;/p&gt;
&lt;p&gt;So, if Sorbet mostly deals with static checking and RBS was made to address dynamic typing, what&amp;#39;s the difference between them? How will they both coexist? When should I use one instead of the other?&lt;/p&gt;
&lt;p&gt;Those are fairly common questions about the major role of RBS. That&amp;#39;s why we decided to write this piece. To clarify, in practice, why you should consider adopting it based on what it&amp;#39;s capable of. Let&amp;#39;s dive right in!&lt;/p&gt;
&lt;h2 id=&quot;starting-with-the-basics&quot;&gt;Starting with the Basics&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s start with a clear understanding of the difference between &lt;em&gt;static typing _and&lt;/em&gt; dynamic typing_. Although it&amp;#39;s basic, it is a key concept to grasp in order to understand the role of RBS.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s take a code snippet from a statically typed language as a reference:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;➜
String str = &amp;quot;&amp;quot;;
str = 2.4;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;#39;s no news that such a language cares for the types of its objects and variables. That being said, code like the one above will throw an error.&lt;/p&gt;
&lt;p&gt;Ruby, like many other languages such as JavaScript, Python, and Objective-C, doesn&amp;#39;t give that much attention to which types you&amp;#39;re targeting for your objects.&lt;/p&gt;
&lt;p&gt;The same code in Ruby will just successfully run, as seen below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;➜  irb
str = &amp;quot;&amp;quot;
str = 2.4
puts str # prints 2.4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is possible because Ruby&amp;#39;s interpreter knows how to &lt;strong&gt;dynamically&lt;/strong&gt; switch from one type to another.&lt;/p&gt;
&lt;p&gt;However, there&amp;#39;s a limit to what the interpreter allows. For example, take the following code change:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;➜  irb
val = &amp;quot;6.0&amp;quot;
result = val + 2.0
puts result
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will, in turn, produce the following error:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-01/Figure01.png&quot; alt=&quot;Error&quot;/&gt;
&lt;em&gt;Error: no implicit conversion of Float into String&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Running the same code with JavaScript, for instance, would run just fine.&lt;/p&gt;
&lt;p&gt;Moral of the story: Ruby does infer types dynamically, indeed; but, unlike other major dynamic languages, it won&amp;#39;t accept everything. Be aware of that!&lt;/p&gt;
&lt;p&gt;And that&amp;#39;s where type checkers (whether static or dynamic) become useful.&lt;/p&gt;
&lt;h2 id=&quot;rbs-vs-sorbet&quot;&gt;RBS vs Sorbet&lt;/h2&gt;
&lt;p&gt;Right, I&amp;#39;ve got your point about the dynamic vs static thing. But, what about Sorbet? Will it get deprecated?&lt;/p&gt;
&lt;p&gt;Not at all. The primary (and perhaps the most important) difference between RBS and Sorbet is that the former is just a language, while the latter is a complete type checker itself.&lt;/p&gt;
&lt;p&gt;The Ruby team asserts RBS&amp;#39; main goal as to &lt;em&gt;describe the structure&lt;/em&gt; of your code. It won&amp;#39;t perform the type checking, but rather, define the structure that type checkers (like Sorbet or any other) can use to, well, type check. The code structure is stored within a new file extension — &lt;em&gt;.rbs&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;To check it out, let&amp;#39;s take the following Ruby class as an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Super
    def initialize(val)
      @val = val
    end


    def val?
      @val
    end
end

class Test &amp;lt; Super
  def initialize(val, flag)
    super(val)
    @flag = flag
  end

  def flag?
    @flag
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It represents a simple inheritance in Ruby. The interesting thing to note here is that we can&amp;#39;t guess the types of each attribute used in the class, except for &lt;code&gt;flag&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since &lt;code&gt;flag&lt;/code&gt; comes initialized with a default value, both the developer and a type checker can infer the type to prevent further misuse.&lt;/p&gt;
&lt;p&gt;The following will be a proper representation of the above class in RBS format:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Super
  attr_reader val : untyped

  def initialize : (val: untyped) -&amp;gt; void
end

class Test &amp;lt; Super
  attr_reader flag : bool

  def initialize : (val: untyped, ?flag: bool) -&amp;gt; void
  def flag? : () -&amp;gt; bool
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Take some time to digest this. It&amp;#39;s a declaration language, so only signatures may appear in an RBS file. Simple, isn’t it?&lt;/p&gt;
&lt;p&gt;Whether it was autogenerated by a CLI tool (more on that later) or by you, it&amp;#39;s safer to annotate a type as &lt;code&gt;untyped&lt;/code&gt; when it can&amp;#39;t be guessed.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;re sure about the type of &lt;code&gt;val&lt;/code&gt;, for example, your RBS mapping could be switched to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Super
  attr_reader val : Integer

  def initialize : (val: Integer) -&amp;gt; void
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;#39;s also important to note that both the Ruby and Sorbet teams were working (and still are) towards the creation and improvement of RBS. It was the Sorbet team&amp;#39;s experience with type checking, for years, that helped the Ruby team to fine-tune a lot of stuff with this project.&lt;/p&gt;
&lt;p&gt;The interoperability between RBS and RBI files is still under development. The goal is for Sorbet and any other checker tools to have an official and centralized basis to follow.&lt;/p&gt;
&lt;h2 id=&quot;the-rbs-cli-tool&quot;&gt;The RBS CLI Tool&lt;/h2&gt;
&lt;p&gt;One important consideration the Ruby team had when developing RBS was to ship a CLI tool that could help developers to try it out and learn how to use it. It&amp;#39;s called &lt;em&gt;rbs&lt;/em&gt; and comes by default with Ruby 3. If you still haven&amp;#39;t upgraded your Ruby version, you can add its gem directly to your project, as well:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  gem install rbs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The command &lt;code&gt;rbs help&lt;/code&gt; will show the command usage along with the available commands.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2021-01/Figure02.png&quot; alt=&quot;List of available commands&quot;/&gt;
&lt;em&gt;List of available commands&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Most of these commands focus on parsing and analyzing the Ruby code structures. For example, the command &lt;code&gt;ancestors&lt;/code&gt; sweeps the hierarchical structure of a given class to check for its ancestors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;➜  rbs ancestors ::String
::String
::Comparable
::Object
::Kernel
::BasicObject
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The command &lt;code&gt;methods&lt;/code&gt; displays all the method structures of a given class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;➜  rbs methods ::String
! (public)
!= (public)
!~ (public)
...
Array (private)
Complex (private)
Float (private)
...
autoload? (private)
b (public)
between? (public)
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Want to see a specific method structure? Go for &lt;code&gt;method&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;➜  rbs method ::String split
::String#split
  defined_in: ::String
  implementation: ::String
  accessibility: public
  types:
      (?::Regexp | ::string pattern, ?::int limit) -&amp;gt; ::Array[::String]
    | (?::Regexp | ::string pattern, ?::int limit) { (::String) -&amp;gt; void } -&amp;gt; self
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For those starting with RBS today, the command &lt;code&gt;prototype&lt;/code&gt; can help a lot with scaffolding types for classes that already exist. The command generates prototypes of RBS files.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s take the previous &lt;code&gt;Test &amp;lt; Super&lt;/code&gt; inheritance example and save the code into a file called &lt;em&gt;appsignal.rb&lt;/em&gt;. Then, run the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  rbs prototype rb appsignal.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since the command allows for &lt;em&gt;rb&lt;/em&gt;, &lt;em&gt;rbi&lt;/em&gt;, and &lt;em&gt;runtime&lt;/em&gt; generators, you need to provide the specific type of file you&amp;#39;re scaffolding right after the &lt;code&gt;prototype&lt;/code&gt; command, followed by the file pathname.&lt;/p&gt;
&lt;p&gt;The following is the result of the execution:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Super
  def initialize: (untyped val) -&amp;gt; untyped

  def val?: () -&amp;gt; untyped
end

class Test &amp;lt; Super
  def initialize: (untyped val, ?flag: bool flag) -&amp;gt; untyped

  def flag?: () -&amp;gt; untyped
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty similar to our first RBS version. As mentioned earlier, the tool marks as &lt;code&gt;untyped&lt;/code&gt; any type that couldn&amp;#39;t be guessed.&lt;/p&gt;
&lt;p&gt;It also counts for method returns. Notice the return type of the &lt;code&gt;flag&lt;/code&gt; definition. As a developer, you&amp;#39;re probably sure that the method always returns a boolean, but due to Ruby’s dynamic nature, the tool is unable to 100% say that it is so.&lt;/p&gt;
&lt;p&gt;And that&amp;#39;s when another Ruby 3 child comes to the rescue: the &lt;a href=&quot;https://github.com/ruby/typeprof&quot;&gt;TypeProf&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;the-typeprof-tool&quot;&gt;The TypeProf Tool&lt;/h2&gt;
&lt;p&gt;TypeProf is a type analysis tool for Ruby that was created on top of some &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;syntax tree&lt;/a&gt; interpretation.&lt;/p&gt;
&lt;p&gt;Despite still being experimental, it has proved to be very powerful when it comes to understanding what your code is trying to do.&lt;/p&gt;
&lt;p&gt;If you don&amp;#39;t have Ruby 3 yet, simply add the gem to your project:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  gem install typeprof
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let&amp;#39;s run the same &lt;em&gt;appsignal.rb&lt;/em&gt; file against it:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;➜  typeprof appsignal.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Classes
class Super
  @val: untyped
  def initialize: (untyped) -&amp;gt; untyped
  def val?: -&amp;gt; untyped
end

class Test &amp;lt; Super
  @val: untyped
  @flag: true

  def initialize: (untyped, ?flag: true) -&amp;gt; true
  def flag?: -&amp;gt; true
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note how the &lt;code&gt;flag&lt;/code&gt; is mapped now. This is only possible because, unlike what the RBS prototype does, the TypeProf scans the method&amp;#39;s body trying to understand what actions are being performed over that specific variable. Since it couldn&amp;#39;t identify any direct change to this variable, TypeProf safely mapped the method return as a boolean.&lt;/p&gt;
&lt;p&gt;Consider, for example, that TypeProf will have access to other classes that instantiate and use the &lt;code&gt;Test&lt;/code&gt; class. With that in hand, it can go even deeper into your code and fine-tune its predictions. Say that the following code snippet is added at the end of the &lt;em&gt;appsignal.rb&lt;/em&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;testSub = Test.new(&amp;quot;My value&amp;quot;, &amp;quot;My value&amp;quot; == &amp;quot;&amp;quot;)
testSup = Super.new(&amp;quot;My value&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that you changed the &lt;code&gt;initialize&lt;/code&gt; method signature to the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def initialize(val, flag)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When you re-run the command, this should be the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Classes
class Super
  @val: String

  def initialize: (String) -&amp;gt; String
  def val?: -&amp;gt; String
end

class Test &amp;lt; Super
  @val: String
  @flag: bool

  def initialize: (String val, bool flag) -&amp;gt; bool
  def flag?: -&amp;gt; bool
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Super cool!&lt;/p&gt;
&lt;p&gt;TypeProf can&amp;#39;t deal with inherited attributes very well. That&amp;#39;s why we&amp;#39;re instantiating a new &lt;code&gt;Super&lt;/code&gt; object. Otherwise, it wouldn&amp;#39;t get that &lt;code&gt;val&lt;/code&gt; is a &lt;code&gt;String&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The major pro of TypeProf is its safety. Whenever it&amp;#39;s unable to figure something out for sure, then &lt;code&gt;untyped&lt;/code&gt; will be returned.&lt;/p&gt;
&lt;h2 id=&quot;partial-rbs-specification&quot;&gt;Partial RBS Specification&lt;/h2&gt;
&lt;p&gt;One important warning from the official docs states that, although TypeProf is very powerful, you should be aware of its limitations regarding what it can and cannot generate in terms of RBS code.&lt;/p&gt;
&lt;p&gt;For example, a common practice among Ruby developers is method overloading in which you invoke different behavior of a method depending on its arguments.&lt;/p&gt;
&lt;p&gt;Consider that a new method &lt;code&gt;spell&lt;/code&gt; is added to the &lt;code&gt;Super&lt;/code&gt; class, which returns an &lt;code&gt;Integer&lt;/code&gt; or a &lt;code&gt;String&lt;/code&gt; based on the parameter type:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def spell(val)
  if val.is_a?(String)
    &amp;quot;&amp;quot;
  else
    0
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;RBS embraces this practice by allowing you to deal with overloading through the &lt;a href=&quot;https://sorbet.org/docs/union-types&quot;&gt;union type&lt;/a&gt; (a value that represents multiple possible types) syntax:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def spell: (String) -&amp;gt; String | (Integer) -&amp;gt; Integer
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TypeProf can&amp;#39;t infer this just by analyzing the method&amp;#39;s body. To help it out, you can manually add such a definition to your RBS file and TypeProf will always check there first for instructions.&lt;/p&gt;
&lt;p&gt;For this, you must add the RBS file path at the end of the command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;typeprof appsignal.rb appsignal.rbs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;See below the new output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Super
  ...
  def spell: (untyped val) -&amp;gt; (Integer | String)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Plus, we can also verify the real types during runtime via &lt;code&gt;Kernel#p&lt;/code&gt; to test if the overloading is working by adding the next two lines to the end of the &lt;em&gt;appsignal.rb&lt;/em&gt; file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;p testSup.spell(42)
p testSup.spell(&amp;quot;str&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This should be the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Revealed types
#  appsignal.rb:11 #=&amp;gt; Integer
#  appsignal.rb:12 #=&amp;gt; String

...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Make sure to refer to the &lt;a href=&quot;https://github.com/ruby/typeprof/blob/master/doc/doc.md&quot;&gt;official docs&lt;/a&gt; for more information, especially the section concerning TypeProf &lt;a href=&quot;https://github.com/ruby/typeprof/blob/master/doc/doc.md#limitations&quot;&gt;limitations&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;duck-typing&quot;&gt;Duck Typing&lt;/h2&gt;
&lt;p&gt;You&amp;#39;ve heard of that before. If a Ruby object does everything a duck does, then it is a duck.&lt;/p&gt;
&lt;p&gt;As we&amp;#39;ve seen, Ruby doesn&amp;#39;t care about what your objects are meant to be. Types can change dynamically as well as object references.&lt;/p&gt;
&lt;p&gt;Although helpful, duck typing can be tricky. Let&amp;#39;s see an example.&lt;/p&gt;
&lt;p&gt;Suppose that, from now on, the &lt;code&gt;val&lt;/code&gt; attribute you&amp;#39;ve declared for the &lt;code&gt;Super&lt;/code&gt; class, which is a &lt;code&gt;String&lt;/code&gt;, must always be convertible to an integer.&lt;/p&gt;
&lt;p&gt;Rather than trusting that developers will always guarantee the conversion (perhaps, throwing an error otherwise), you can create an &lt;strong&gt;interface&lt;/strong&gt; stating that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;interface _IntegerConvertible
   def to_int: () -&amp;gt; Integer
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Interface types provide one or more methods that are detached from concrete classes and modules. This way, when you want a certain type to be passed on to the Super instantiation, you can simply do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Super
  attr_reader val : _IntegerConvertible

  def initialize : (val: _IntegerConvertible) -&amp;gt; void
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The concrete class or module that implements this interface will have to make sure the proper validation is done.&lt;/p&gt;
&lt;h2 id=&quot;metaprogramming&quot;&gt;Metaprogramming&lt;/h2&gt;
&lt;p&gt;Perhaps one of the most dynamic features of Ruby is the capability of creating code that creates code by itself during runtime. That&amp;#39;s metaprogramming.&lt;/p&gt;
&lt;p&gt;Because of the uncertain nature of things, the RBS CLI tool isn&amp;#39;t able to generate RBS out of metaprogramming code.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s take the following snippet as an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Test
    define_method :multiply do |*args|
        args.inject(1, :*)
    end
end

p Test.new.multiply(2, 3, 5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This class defines a method called &lt;code&gt;multiply&lt;/code&gt; at runtime and instructs it to inject the arguments and multiply each one with the previous result.&lt;/p&gt;
&lt;p&gt;Once you run the RBS &lt;code&gt;prototype&lt;/code&gt; command, this should be the output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Test
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Depending on the complexity of your metaprogramming code, TypeProf will still try its best to extract something from it. But it&amp;#39;s not always guaranteed.&lt;/p&gt;
&lt;p&gt;Remember, you can always add your own type mappings to the RBS file and TypeProf will obey them in advance. That&amp;#39;s also valid for metaprogramming.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s also important to keep updated with the latest repository changes since the team is constantly releasing new features, which may well include updates on metaprogramming.&lt;/p&gt;
&lt;p&gt;That being said, if your codebase includes some type of metaprogramming, be careful with these tools. Don&amp;#39;t use them blindly!&lt;/p&gt;
&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;There are plenty more details about what we&amp;#39;ve discussed so far, as well as edge use cases for both &lt;a href=&quot;https://github.com/ruby/rbs/blob/master/docs/syntax.md&quot;&gt;RBS&lt;/a&gt; and &lt;a href=&quot;https://github.com/ruby/typeprof/blob/master/doc/doc.md&quot;&gt;TypeProf&lt;/a&gt; that you should be aware of.&lt;/p&gt;
&lt;p&gt;So, make sure to refer to the official docs for more on that.&lt;/p&gt;
&lt;p&gt;RBS is still so fresh but has already caused a huge impact on Rubyists that are used to type checking their codebases with other tools.&lt;/p&gt;
&lt;p&gt;What about you? Have you tried it out? What are your thoughts on RBS?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>How to Use Mixins and Modules in Your Ruby on Rails Application</title>
    <link rel="alternate" href="https://blog.appsignal.com/2021/01/13/using-mixins-and-modules-in-your-ruby-on-rails-application.html">
    <id>https://blog.appsignal.com/2021/01/13/using-mixins-and-modules-in-your-ruby-on-rails-application.html</id>
    <published>2021-01-13T00:00:00+00:00</published>
    <updated>2021-01-13T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Find out how to create and mix modules into other classes and discover what are the benefits from using them in a Ruby on Rails application.</summary>
    <content type="html">&lt;p&gt;Modules and mixins are, without doubt, great resources that make Ruby so attractive. They give the application the ability to share the code that can be used with ease in other places. It also helps us organize our code by grouping functionalities and concerns, which improves the readability and maintainability of our code.&lt;/p&gt;
&lt;p&gt;In this article, we will go through the concepts behind modules and mixins. We&amp;#39;ll learn how to create and mix modules into other classes and discuss the benefits of using them in a Ruby on Rails application.&lt;/p&gt;
&lt;p&gt;I hope you&amp;#39;ll enjoy the journey!&lt;/p&gt;
&lt;h2 id=&quot;what-are-modules&quot;&gt;What are Modules&lt;/h2&gt;
&lt;p&gt;Modules are one of the shiniest resources of Ruby because they provide two great benefits: we can create namespaces to prevent name clashes and we can use them as mixins to share code across the application.&lt;/p&gt;
&lt;p&gt;In structural terms, a module is pretty similar to any Ruby class. In fact, for Ruby, a &lt;code&gt;Class&lt;/code&gt; is a &lt;code&gt;Module&lt;/code&gt;, as we can see below in an &lt;code&gt;irb&lt;/code&gt; console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;gt; Class.is_a?(Module)
 =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Similar to classes, with modules we also group methods and constants and share code. However, there are a few differences between a module and a plain Ruby class:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We start the definition with the &lt;code&gt;module&lt;/code&gt; keyword instead of &lt;code&gt;class&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;We can&amp;#39;t instantiate modules, so no objects can be created from it;&lt;/li&gt;
&lt;li&gt;We can&amp;#39;t inherit from modules, so we use them as mixins instead;&lt;/li&gt;
&lt;li&gt;Modules are standalone code, so there&amp;#39;s no inheritance hierarchy of modules;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Modules are great places to have services, concerns, constants and any other code that, by having the same responsibility they should stay together.&lt;/p&gt;
&lt;p&gt;This is how a module should look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# lib/modules/invoice_creator.rb
module InvoiceCreator
  TAX_FEE = 0.5

  def self.generate
    puts &amp;quot;Don&amp;#39;t worry! I&amp;#39;ll generate the invoice for you at #{TAX_FEE}%&amp;quot;
  end

  def invoice_total
    puts &amp;quot;I&amp;#39;ll return the invoice total&amp;quot;
    1000
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we can observe that a module can provide two kinds of methods: module methods and instance methods.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;self.generate&lt;/code&gt; is a module method, which means that we can use it without having to include (or extend) the module in any other object. This is very common when we are creating service objects, for example. We can call our module method like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;2.5.3 :006 &amp;gt; InvoiceCreator.generate
Don&amp;#39;t worry! I&amp;#39;ll generate the invoice for you
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;invoice_total&lt;/code&gt; is an instance method and to be able to use it we need to include the module to a class, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/invoice.rb
class Invoice &amp;lt; ApplicationRecord
  include InvoiceCreator # This includes our module in the Invoice class

  def calculate_tax
    total = invoice_total # included method from our module
    tax = total * InvoiceCreator::TAX_FEE
    puts &amp;quot;This is the invoice tax: #{tax}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All instance methods from &lt;code&gt;InvoiceCreator&lt;/code&gt; becomes available to the &lt;code&gt;Invoice&lt;/code&gt; instances, so we can call the &lt;code&gt;calculate_tax&lt;/code&gt; method pretty easily:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;2.5.3 :008 &amp;gt; Invoice.new.calculate_tax
&amp;quot;I&amp;#39;ll return the invoice total&amp;quot;
&amp;quot;This is the invoice tax: 500.0&amp;quot;
 =&amp;gt; nil
2.5.3 :009 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition, inside the &lt;code&gt;calculate_tax&lt;/code&gt; you notice that we are using a constant that was defined inside our module. As I mentioned before, modules are great constant keepers!&lt;/p&gt;
&lt;p&gt;Imagine now a scenario where we need to have two kinds of &lt;code&gt;InvoiceCreator&lt;/code&gt; to generate totally different invoices for suppliers and customers. We would end up having a name classing, and to avoid this, we make use of the other great benefit of modules: namespaces. Let&amp;#39;s take a look in the next section.&lt;/p&gt;
&lt;h2 id=&quot;namespaces-everywhere&quot;&gt;Namespaces Everywhere&lt;/h2&gt;
&lt;p&gt;Namespaces can be defined as a way to organize our code when we want to create a local context for a given functionality, which is what we need for the scenario I just described: a different context for the customer&amp;#39;s invoice creator and another one for the supplier&amp;#39;s invoice creator.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s get back to our code. We&amp;#39;ll need to create two different modules:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# lib/modules/customer/invoice_creator.rb
module Customer
  module InvoiceCreator
    def self.generate
      puts &amp;quot;Don&amp;#39;t worry! I&amp;#39;ll generate the customer invoice for you&amp;quot;
    end
  end
end

# lib/modules/supplier/invoice_creator.rb
module Supplier
  module InvoiceCreator
    def self.generate
      puts &amp;quot;Don&amp;#39;t worry! I&amp;#39;ll generate the supplier invoice for you&amp;quot;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we can use &lt;code&gt;Customer::InvoiceCreator&lt;/code&gt; or &lt;code&gt;Supplier::InvoiceCreator&lt;/code&gt; where we need it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;2.5.3 :014 &amp;gt; Customer::InvoiceCreator.generate
Don&amp;#39;t worry! I&amp;#39;ll generate the customer invoice for you
 =&amp;gt; nil
2.5.3 :015 &amp;gt; Supplier::InvoiceCreator.generate
Don&amp;#39;t worry! I&amp;#39;ll generate the supplier invoice for you
 =&amp;gt; nil
2.5.3 :016 &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That way each specific code will be wrapped up inside its own module, respecting the &lt;a href=&quot;https://deviq.com/separation-of-concerns/&quot;&gt;separation of concerns&lt;/a&gt; principle. Besides that, namespacing everywhere is also a great way to keep our code well organized.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s see now how we can make use of the other benefits of Ruby modules: mixins.&lt;/p&gt;
&lt;h2 id=&quot;the-magic-of-using-mixins&quot;&gt;The Magic of Using Mixins&lt;/h2&gt;
&lt;p&gt;As you might already know, one characteristic of Ruby is that it implements the single inheritance mechanism, which means that a class can only inherit from one other class. We may often need to inherit from more classes. In Ruby, we can cover that need by using the &lt;a href=&quot;https://thoughtbot.com/blog/reusable-oo-composition-vs-inheritance&quot;&gt;composition over inheritance&lt;/a&gt; pattern.&lt;/p&gt;
&lt;p&gt;This is doable by using the mixins. When we mix in a piece of code in another Ruby class we are adding to this class more behavior without using inheritance and this is amazing. Therefore, in Ruby, mixins are modules that we include in classes where they are needed. With that we gain by keeping our code clean and the responsibilities separated, as they should be.&lt;/p&gt;
&lt;p&gt;For example, let&amp;#39;s say that our &lt;code&gt;InvoiceCreator&lt;/code&gt; module is a service that needs to use functionalities provided by several other modules, such as &lt;code&gt;InvoiceCalculator&lt;/code&gt;, &lt;code&gt;InvoiceRenderer&lt;/code&gt; and &lt;code&gt;InvoiceSender&lt;/code&gt;, they will be necessary to fulfill the invoice creation process.&lt;/p&gt;
&lt;p&gt;We can achieve this by including a chain of modules as mixins in our code, so we can use the methods directly, like the example below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# lib/modules/invoice_calculator.rb
module InvoiceCalculator
  def calculate_items_total
    puts &amp;quot;imagine some math here&amp;quot;
  end
end

# lib/modules/invoice_renderer.rb
module InvoiceRenderer
  def generate_invoice_pdf
    puts &amp;quot;imagine that we are using some PDF generation magic here&amp;quot;
  end
end

# lib/modules/invoice_sender.rb
module InvoiceSender
  def send_invoice
    puts &amp;quot;imagine your favorite mail service being used here&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we can&amp;#39;t make the &lt;code&gt;InvoiceCreator&lt;/code&gt; inherit from all the other three modules, we are including them instead. This way the &lt;code&gt;InvoiceCreator&lt;/code&gt; includes all the methods from the other Invoice modules, and we can call these in any class/module the &lt;code&gt;InvoiceCreator&lt;/code&gt; module gets included in. Be careful though! If any of the modules have methods with the same name, they will overwrite each other.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# lib/modules/customer/invoice_creator.rb
module Customer
  module InvoiceCreator
    include InvoiceCalculator
    include InvoiceRenderer
    include InvoiceSender

    def generate_invoice
      calculate_items_total # from InvoiceCalculator
      generate_invoice_pdf # from InvoiceRenderer
      send_invoice # from InvoiceSender
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can call our service methods anywhere we include it by doing this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/invoice.rb
class Invoice &amp;lt; ApplicationRecord
  include Customer::InvoiceCreator

  def send_invoice_to_customer
    puts &amp;quot;Don&amp;#39;t worry! I&amp;#39;ll generate the customer invoice for you&amp;quot;
    generate_invoice
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will be the result, calling the methods from the included Invoice modules through the &lt;code&gt;InvoiceCreator&lt;/code&gt; module:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;2.5.3 :051 &amp;gt; Invoice.new.generate_invoice
Don&amp;#39;t worry! I&amp;#39;ll generate the supplier invoice for you
imagine some math here
imagine that we are using some PDF generation magic here
imagine your favorite mail service being used here
 =&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that this is how we use composition over inheritance principle. This principle stands that you should prefer to use composition whenever you can. In composition, we create classes that are responsible to provide specific functionalities to others, which is exactly what we are doing.&lt;/p&gt;
&lt;h2 id=&quot;thats-all-folks&quot;&gt;That&amp;#39;s all Folks!&lt;/h2&gt;
&lt;p&gt;As Ruby developers, we love to use its facilities and syntax sugar when planning, writing, maintaining and refactoring our code. I hope that through this article you can appreciate why modules are such a great resource to help improve the readability of our code, to keep things with only one responsibility and to keep our codebase clean and easy to maintain. And also that we can use the mixins magic to include modules in our code in cases where we would need to inherit from multiple sources.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ll keep talking about the greatest resources of Ruby and Rails here, so stay tuned!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Top 5 Ruby Blog Posts in 2020 from AppSignal</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/12/16/top-5-ruby-posts-in-2020-from-appsignal.html">
    <id>https://blog.appsignal.com/2020/12/16/top-5-ruby-posts-in-2020-from-appsignal.html</id>
    <published>2020-12-16T00:00:00+00:00</published>
    <updated>2020-12-16T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Check out the most appreciated Ruby posts on our blog in 2020.</summary>
    <content type="html">&lt;p&gt;There&amp;#39;s no doubt that 2020 is a year we&amp;#39;re all looking forward to leave behind. Let&amp;#39;s grab a stroopwafel and think a bit about nice things and the people who spent their time sharing their knowledge with you, even in a year like this.&lt;/p&gt;
&lt;p&gt;For today&amp;#39;s post, we&amp;#39;ve compiled a Ruby list with top 5 posts that received the most attention from you. Let&amp;#39;s hit it off with &lt;a href=&quot;https://www.youtube.com/watch?v=cCqEyJc-wdk&quot;&gt;some nice tunes in the background&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;top-5-ruby-blog-posts-in-2020-💎&quot;&gt;Top 5 Ruby Blog Posts in 2020 💎&lt;/h2&gt;
&lt;h3 id=&quot;using-service-objects-in-ruby-on-rails&quot;&gt;&lt;a href=&quot;/2020/06/17/using-service-objects-in-ruby-on-rails.html&quot;&gt;Using Service Objects in Ruby on Rails&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There’s a lot of functionality that your app needs to handle, but that logic doesn’t necessarily belong in the controller or even the model. Some examples include checking out with a cart, registering for the site, or starting a subscription. This post will show you what service objects are and why you should use them in cases like these.&lt;/p&gt;
&lt;h3 id=&quot;rails-is-fast-optimize-your-view-performance&quot;&gt;&lt;a href=&quot;/2020/01/22/rails-is-fast-optimize-your-view-performance.html&quot;&gt;Rails is Fast: Optimize Your View Performance&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In this post, we’ll look into tried and true methods of improving Rails view performance. Specifically, we will focus on database efficiency, view manipulation, and caching.&lt;/p&gt;
&lt;h3 id=&quot;building-a-rails-app-with-multiple-subdomains&quot;&gt;&lt;a href=&quot;/2020/03/04/building-a-rails-app-with-multiple-subdomains.html&quot;&gt;Building a Rails App With Multiple Subdomains&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Learn how to build a Rails app that can support multiple subdomains. Let’s assume that we have a gaming website &lt;code&gt;funkygames.co&lt;/code&gt; and we want to support multiple subdomains such as &lt;code&gt;app.funkygames.co&lt;/code&gt;, &lt;code&gt;api.funkygames.co&lt;/code&gt;, and &lt;code&gt;dev.funkygames.co&lt;/code&gt; with a single Rails application.&lt;/p&gt;
&lt;h3 id=&quot;rails-concerns-to-concern-or-not-to-concern&quot;&gt;&lt;a href=&quot;/2020/09/16/rails-concers-to-concern-or-not-to-concern.html&quot;&gt;Rails Concerns: To Concern Or Not To Concern&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If you’ve ever used Ruby on Rails, you’ve probably come across the concept of concerns. Whenever you jumpstart a new Rails project, you get a directory &lt;code&gt;app/controllers/concerns&lt;/code&gt; and &lt;code&gt;app/models/concerns&lt;/code&gt;. But what are concerns? And why do people from the Rails community sometimes talk badly about them?&lt;/p&gt;
&lt;h3 id=&quot;introduction-to-ruby-on-rails-patterns-and-anti-patterns&quot;&gt;&lt;a href=&quot;/2020/08/05/introduction-to-ruby-on-rails-patterns-and-anti-patterns.html&quot;&gt;Introduction to Ruby on Rails Patterns and Anti-patterns&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;This is the first post in &lt;a href=&quot;/category/rails-patterns-and-anti-patterns.html&quot;&gt;our series about Ruby on Rails Patterns and Anti-patterns&lt;/a&gt;. In each of the posts, we’ll take a deep dive into all sorts of patterns you might come across while working with Rails apps.&lt;/p&gt;
&lt;h2 id=&quot;holiday-season-is-approaching-🎊🎉🎄❄️&quot;&gt;Holiday Season is Approaching 🎊🎉🎄❄️&lt;/h2&gt;
&lt;p&gt;That was all for this roundup of favorite articles of 2020! The whole AppSignal team wishes you all the best for the coming year, with little errors and many amazing insights ☃️&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. Don&amp;#39;t forget to subscribe to our &lt;a href=&quot;/ruby-magic&quot;&gt;Ruby Magic&lt;/a&gt; newsletter!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Setting Up AppSignal Monitoring for a Ruby on Rails Application</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/12/10/setting-up-appsignal-monitoring-for-a-ruby-on-rails-application.html">
    <id>https://blog.appsignal.com/2020/12/10/setting-up-appsignal-monitoring-for-a-ruby-on-rails-application.html</id>
    <published>2020-12-10T00:00:00+00:00</published>
    <updated>2020-12-10T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Find out how to integrate AppSignal into a Rails application in our latest video.</summary>
    <content type="html">&lt;p&gt;As we&amp;#39;re doing our best to make monitoring easy, we&amp;#39;ve wanted to make more content that would really &lt;strong&gt;show&lt;/strong&gt; and not just tell you how easy it is to set up monitoring with AppSignal.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ve been collaborating with &lt;a href=&quot;https://www.youtube.com/user/leighhalliday&quot;&gt;Leigh Hallday&lt;/a&gt; on making this video for you that will show you everything you need to know about the setup process. We&amp;#39;ll be posting more videos like this on &lt;a href=&quot;https://www.youtube.com/channel/UCaiU0x1JVGBpZPXypwkAGbw&quot;&gt;our YouTube channel&lt;/a&gt;, so you should subscribe to it if you&amp;#39;d like to get notifications about future videos. You know how that works 😉&lt;/p&gt;
&lt;h2 id=&quot;whats-in-the-video&quot;&gt;What&amp;#39;s In the Video&lt;/h2&gt;
&lt;p&gt;In this video, Leigh will show you how easy it is to integrate AppSignal into a Rails application. He covers installation and setup, how to troubleshoot and fix performance issues, specifically showing a common use-case with N+1 queries.&lt;/p&gt;
&lt;p&gt;The N+1 query anti-pattern happens when a query is executed for every single result of a previous query. The query count is N + 1, where N is the number of queries for every result of the initial query. Now if that initial query has one result, then N+1 = 2. If it has 1000 results, N+1 = 1001 queries 🙀. It&amp;#39;s easy to spot them, Leigh will show you how.&lt;/p&gt;
&lt;p&gt;He&amp;#39;ll then show you AppSignal&amp;#39;s Sidekiq integration along with its magic dashboard, which can really help pinpoint performance issues. The whole process is automated as Sidekiq is detected during setup, and things like throughput, duration per job and queue length are plotted on their own graphs. That way you can see when peak, and set up alerting and fix issues with as little work as possible.&lt;/p&gt;
&lt;iframe
  width=&quot;560&quot;
  height=&quot;315&quot;
  src=&quot;https://www.youtube.com/embed/hzOxE-ii9Do&quot;
  frameborder=&quot;0&quot;
  allow=&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;
  allowfullscreen
&gt;&lt;/iframe&gt;

&lt;br /&gt;

&lt;h2 id=&quot;monitoring-made-easy-and-sweet-🍪&quot;&gt;Monitoring Made Easy And Sweet 🍪&lt;/h2&gt;
&lt;p&gt;Hope you enjoyed the video! If you&amp;#39;d like us to cover more topics in this format feel free to &lt;a href=&quot;mailto:support@appsignal.com&quot;&gt;reach out and let us know&lt;/a&gt;. We can promise you a free box of &lt;a href=&quot;https://www.appsignal.com/waffles&quot;&gt;stroopwafels&lt;/a&gt; if your suggestion gets accepted.&lt;/p&gt;
&lt;p&gt;If you haven&amp;#39;t used AppSignal before, now you know how we save you time by making monitoring easier. You can &lt;a href=&quot;https://www.appsignal.com/ruby&quot;&gt;try us out&lt;/a&gt; for 30 days free of charge 😀&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Building a Multi-tenant Ruby on Rails App With Subdomains</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/12/02/building-a-multi-tenant-ruby-on-rails-app-with-subdomains.html">
    <id>https://blog.appsignal.com/2020/12/02/building-a-multi-tenant-ruby-on-rails-app-with-subdomains.html</id>
    <published>2020-12-02T00:00:00+00:00</published>
    <updated>2020-12-02T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Discover different approaches to multitenancy and build a simple app with multiple tenants where each tenant will have its subdomain.</summary>
    <content type="html">&lt;p&gt;According to a definition of multitenancy, when an app serves multiple tenants, it means that there are a few groups of users who share common access to the software instance. An excellent example of an app that supports multitenancy is the Jira platform, where each company has its subdomain to access the software, for example, &lt;code&gt;mycompany.atlassian.net&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In this article, I’m going to familiarize you with both theoretical and practical aspects of multitenancy. After discussing a few popular types of approaches to implement support for multiple tenants in your application, I will show you how you can implement two of them in your Rails application. We will build together a simple app with multiple tenants where each tenant will have its subdomain.&lt;/p&gt;
&lt;p&gt;After reading this article, you will be able to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Discuss different types of multi-tenant apps and tell when the given approach is the right choice,&lt;/li&gt;
&lt;li&gt;Create a Ruby on Rails application with support for multiple tenants, and&lt;/li&gt;
&lt;li&gt;Use custom subdomains for your customers inside the Ruby on Rails application.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A base knowledge about Rails is required to follow this article and get most of its benefits.&lt;/p&gt;
&lt;h2 id=&quot;multitenancy-in-theory&quot;&gt;Multitenancy in Theory&lt;/h2&gt;
&lt;p&gt;As I mentioned before, we can say that the app supports multitenancy when it serves a few groups of users who share common access to the application’s features. A good example of such an app is a blogging platform where every user gets a separate subdomain in the main domain. Each blog has its subdomain but shares the same features as other blogs: comments, articles, and administration dashboard.&lt;/p&gt;
&lt;p&gt;Though it might look like multi-tenant apps work similarly on the surface, they can implement different types of multitenancy architecture under the hood. Let’s take a look at the most popular and efficient types of them.&lt;/p&gt;
&lt;h2 id=&quot;database-row-level&quot;&gt;Database-row Level&lt;/h2&gt;
&lt;p&gt;If you don’t want to use multiple databases in your application, you can select an approach that operates on one central database. Each table in the database consists of the &lt;code&gt;tenant_id&lt;/code&gt; column used in every query performed inside the application to pull data that belongs to the given tenant.&lt;/p&gt;
&lt;p&gt;The tenant’s setup time in such structure is fast, there are no additional costs, and implementation of this variant is possible everywhere. However, we should be careful as we can lead to a data leak if we forget to include the tenant’s id in the query. Database structure modification would be difficult to maintain for given groups of users, so we should have this disadvantage in mind.&lt;/p&gt;
&lt;h2 id=&quot;schema-level&quot;&gt;Schema Level&lt;/h2&gt;
&lt;p&gt;You can still have one central database but with separate tables and schema for each tenant. In contrast to the database-row level approach, you have to change the search path to the tables when switching between tenants instead of modifying the query. In PostgreSQL, you can use the set &lt;code&gt;search_path&lt;/code&gt; statement, and in MySQL &lt;code&gt;use&lt;/code&gt; statement to switch between schemas.&lt;/p&gt;
&lt;p&gt;Before selecting this approach, ensure that it’s possible to use the mentioned statements on your DB server. Keep also in mind that adding new tenants is relatively slow as you have to create a new schema and create tables in the database.&lt;/p&gt;
&lt;h2 id=&quot;database-level&quot;&gt;Database Level&lt;/h2&gt;
&lt;p&gt;If you can afford the cost of a new database each time you add a new tenant to your application, this approach might be right for you. This approach is the slowest from all discussed architectures when it comes to adding new tenants.&lt;/p&gt;
&lt;p&gt;It is most likely tough to lead to a data leak because to switch to another tenant, you have to establish a new connection to the database. You can also easily modify the database structure of every group of users if you would like to.&lt;/p&gt;
&lt;h2 id=&quot;creating-an-application-skeleton&quot;&gt;Creating an Application Skeleton&lt;/h2&gt;
&lt;p&gt;We will create two separate applications: one with multi-tenancy supported by one database and one with multi-tenancy supported by multiple databases. They represent a different approach to deal with numerous tenants, but the configuration phase is the same.&lt;/p&gt;
&lt;p&gt;Ruby’s latest version is 2.7.2 and 6.1 RC1 of Ruby on Rails gem as of writing this article. Make sure you have the right version of Ruby installed in your system and attempt to install the correct version of the framework:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;gem install rails -v 6.1.0.rc1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now generate the project files with the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails _6.1.0.rc1_ new tenantapp -d=mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enter the project directory, run the server, and check if you can see the welcome screen so we can continue:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;cd tenantapp/
rails s
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;multi-tenant-rails-application-with-one-database&quot;&gt;Multi-tenant Rails Application with One Database&lt;/h2&gt;
&lt;p&gt;It’s time to code something. This part of the article will show you how to implement multitenancy in your Rails application. I’m going to use the approach with one database and one schema.&lt;/p&gt;
&lt;p&gt;The plan is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We will create a skeleton for a Rails application using the newest available version of Ruby and Ruby on Rails framework&lt;/li&gt;
&lt;li&gt;We will scaffold some models to have the data we can operate on&lt;/li&gt;
&lt;li&gt;To the functionality we created in the previous step, we will add support for multitenancy by updating the database tables and code in our application&lt;/li&gt;
&lt;li&gt;The last step would be to add support for custom subdomains to allow users to access their tenants easily&lt;/li&gt;
&lt;li&gt;We will explore ideas for some features that you can implement later on your own&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;preparing-the-test-data&quot;&gt;Preparing the Test Data&lt;/h2&gt;
&lt;p&gt;Let’s assume that we are building a blog platform where users can view articles published by multiple authors.&lt;/p&gt;
&lt;p&gt;I will create the author model first, which will store the author’s data:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails g scaffold author slug:string name:string description:string
rake db:create
rake db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can now visit &lt;a href=&quot;http://localhost:3000/authors&quot;&gt;http://localhost:3000/authors&lt;/a&gt; address and add a few authors so we can later assign them to the articles.&lt;/p&gt;
&lt;p&gt;The next step is to create articles:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails g scaffold article title:string content:text
rake db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;adding-multitenancy-support&quot;&gt;Adding Multitenancy Support&lt;/h2&gt;
&lt;p&gt;In the application we are creating, authors are our tenants. Each author should have access only to his articles. As I mentioned before, when we want to implement multitenancy support in one database and one schema, the critical requirement is to add the &lt;code&gt;tenant_id&lt;/code&gt; field to every model that is going to be managed by our tenants.&lt;/p&gt;
&lt;h3 id=&quot;create-proper-migrations-in-the-database&quot;&gt;Create proper migrations in the database&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails g migration AddTenantIdToArticle tenant_id:integer
rake db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above migration will add the new column to our &lt;code&gt;Article&lt;/code&gt; model. This column will be used in any query to pull access only data assigned to the current tenant.&lt;/p&gt;
&lt;h3 id=&quot;assign-article-to-the-tenant&quot;&gt;Assign article to the tenant&lt;/h3&gt;
&lt;p&gt;In this step, I’m going to update the code so we can assign the given author to the article and later render articles only for the selected author. Open &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; and add the following changes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ArticlesController &amp;lt; ApplicationController
 before_action :set_article, only: [:show, :edit, :update, :destroy]
 before_action :set_authors, only: [:edit, :update, :new, :create]

 # ...

 private
   # Only allow a list of trusted parameters through.
   def article_params
     params.require(:article).permit(:title, :content, :tenant_id)
   end

   def set_authors
     @authors = Author.all
   end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In our view we can now use the &lt;code&gt;@authors&lt;/code&gt; variable which contains the collection of authors added in our app. We can now add the select field that will contain authors’ names and assign a proper &lt;code&gt;tenant_id&lt;/code&gt;. Open &lt;code&gt;app/views/articles/_form.html.erb&lt;/code&gt; and add the following section:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;lt;div className=&amp;quot;field&amp;quot;&amp;gt;
 &amp;lt;%= form.label :author %&amp;gt;
 &amp;lt;%= form.select :tenant_id, options_from_collection_for_select(@authors, &amp;#39;id&amp;#39;, &amp;#39;name&amp;#39;, article.tenant_id), include_blank: true %&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Go ahead and create a few authors and then some articles to later render articles assigned only to the given author.&lt;/p&gt;
&lt;h2 id=&quot;adding-support-for-custom-subdomains&quot;&gt;Adding Support for Custom Subdomains&lt;/h2&gt;
&lt;p&gt;We created the author with the name John Doe and set the slug value to &lt;code&gt;johndoe&lt;/code&gt;. Our goal is to visit &lt;a href=&quot;http://johndoe.localhost:3000/&quot;&gt;http://johndoe.localhost:3000/&lt;/a&gt; address and see the data related only to the given tenant, John Doe, in this case.&lt;/p&gt;
&lt;h3 id=&quot;subdomain-configuration&quot;&gt;Subdomain configuration&lt;/h3&gt;
&lt;p&gt;We would like to manage and visit articles when the tenant is set. We can achieve this by updating the &lt;code&gt;config/routes.rb&lt;/code&gt; file and wrapping the definition of the articles resource into the constraints block:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Rails.application.routes.draw do
 constraints subdomain: /.*/ do
   resources :articles
 end

 resources :authors
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, Rails set the top-level domain length to 1, but we want to use localhost to set this setting to 0. We can do this by adding the following line to the file &lt;code&gt;config/environments/development.rb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;config.action_dispatch.tld_length = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;making-subdomains-work-with-the-multitenancy&quot;&gt;Making subdomains work with the multitenancy&lt;/h3&gt;
&lt;p&gt;Now, it’s possible to assign any author to the article. It shouldn’t be possible when the subdomain is used. We have to alter the behavior of &lt;code&gt;ArticlesController&lt;/code&gt;, and instead of setting all authors, we have to set the author for which the subdomain was requested:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;
class ArticlesController &amp;lt; ApplicationController
 before_action :set_author
 before_action :set_article, only: [:show, :edit, :update, :destroy]

 # GET /articles
 # GET /articles.json
 def index
   @articles = Article.where(tenant_id: @author.id)
 end

 # ...

 private
   def set_article
     @article = Article.find_by!(id: params[:id], tenant_id: @author.id)
   end

   # ...

   def set_author
     @author = Author.find_by!(slug: request.subdomain)
   end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I made a few changes to the controller:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Instead of the &lt;code&gt;set_authors&lt;/code&gt; method, I defined the &lt;code&gt;set_author&lt;/code&gt; method, which set the author requested via the subdomain. It is crucial to call this method in &lt;code&gt;before_filter&lt;/code&gt; before the &lt;code&gt;set_article&lt;/code&gt; is called. The author has to be assigned before we attempt to set the article.&lt;/li&gt;
&lt;li&gt;I updated the &lt;code&gt;set_article&lt;/code&gt; method to look for the article with the given id and the assigned author. We don’t want to render articles created by Tom while our current tenant is John.&lt;/li&gt;
&lt;li&gt;I updated the index action to select only articles assigned to our current tenant.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When you work on a multitenant app and use one database with one schema, you always have to remember to scope any query by &lt;code&gt;tenant_id&lt;/code&gt; column; otherwise, you will provide data that is not assigned to the requested tenant.&lt;/p&gt;
&lt;p&gt;The controller is updated, so the next step is to update the form view. Open &lt;code&gt;app/views/articles/_form.html.erb&lt;/code&gt; file and replace the previous section with the simple hidden field:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;lt;%= form.hidden_field :tenant_id, value: @author.id %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before those changes, the user was able to select the author of the article using the form. The user can choose the author for all actions by using a given subdomain in the website address.&lt;/p&gt;
&lt;p&gt;You can now test the code we created. Create a new author, for example, with the name John Doe and slug &lt;code&gt;johndoe&lt;/code&gt;. Visit &lt;a href=&quot;http://johndoe.localhost:3000/articles/new&quot;&gt;http://johndoe.localhost:3000/articles/new&lt;/a&gt; address and add a new article. After adding a new article, you can view it on the list that is available under &lt;a href=&quot;http://johndoe.localhost:3000/articles&quot;&gt;http://johndoe.localhost:3000/articles&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Congratulations! You have just created a multi-tenant app where each author has its subdomain.&lt;/p&gt;
&lt;h2 id=&quot;further-improvements&quot;&gt;Further Improvements&lt;/h2&gt;
&lt;p&gt;You can now extend the code of the application by adding new features. Our blog platform is straightforward; maybe it’s time to add some comments section? No matter what functionality you add, you must remember to add the &lt;code&gt;tenant_id&lt;/code&gt; column to the new model and use it when querying the resource.&lt;/p&gt;
&lt;p&gt;You can create a special scope and wrap it into the concern:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Tenantable
 extend ActiveSupport::Concern

 included do
   scope :for_author, -&amp;gt; (author) { where(tenant_id: author.id) }
 end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then use it in every model that contains data for tenants:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Article &amp;lt; ApplicationRecord
 include Tenantable
end

author = Author.find(1)
Article.for_author(author)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the above approach, you would have to update only one place in case of renaming the &lt;code&gt;tenant_id&lt;/code&gt; column or introducing more conditions when it comes to querying tenant-related data.&lt;/p&gt;
&lt;h2 id=&quot;multi-tenant-rails-application-with-multiple-databases&quot;&gt;Multi-tenant Rails Application with Multiple Databases&lt;/h2&gt;
&lt;p&gt;In the previous paragraphs, we built a Rails application that supports multiple tenants with one database and one schema. The most significant disadvantage of such an approach is the high possibility of a data leak.&lt;/p&gt;
&lt;p&gt;The good news is that the newest version of the Ruby on Rails framework has built-in support for managing multiple databases. I will explore it and show you how you can use it to build a multi-tenant Rails application with numerous databases and custom subdomains.&lt;/p&gt;
&lt;p&gt;The plan is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;We will create a skeleton for a Rails application using the newest available version of Ruby and Ruby on Rails framework&lt;/li&gt;
&lt;li&gt;We will scaffold some models to have the data we can operate on&lt;/li&gt;
&lt;li&gt;We will add support for custom subdomains.&lt;/li&gt;
&lt;li&gt;We will learn how to add new tenants by creating and configuring new databases.&lt;/li&gt;
&lt;li&gt;The last step would be to update the application to switch the database when the given subdomain is requested.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;preparing-the-test-data-1&quot;&gt;Preparing the Test Data&lt;/h2&gt;
&lt;p&gt;Let’s assume that we are building a blog platform where users can view articles published by multiple authors. Each author will have a dedicated database.&lt;/p&gt;
&lt;p&gt;Start with creating the &lt;code&gt;Author&lt;/code&gt; model along with scaffolded features that will help us to view and create new authors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails g scaffold author slug:string name:string description:string
rake db:create
rake db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can now visit &lt;a href=&quot;http://localhost:3000/authors&quot;&gt;http://localhost:3000/authors&lt;/a&gt; and see what Rails have generated for us.&lt;/p&gt;
&lt;h3 id=&quot;adding-a-new-author&quot;&gt;Adding a new author&lt;/h3&gt;
&lt;p&gt;I created a new author with the name John Doe and slug &lt;code&gt;johndoe&lt;/code&gt;. The slug value will be used later to detect which author we should display the information using the subdomain.&lt;/p&gt;
&lt;p&gt;Because each author will have a separate database, we have to add manually new database for John. Open &lt;code&gt;config/database.yml&lt;/code&gt; and add the following changes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;development:
 primary:
   &amp;lt;&amp;lt;: *default
   database: tenantapp_development
 primary_johndoe:
   &amp;lt;&amp;lt;: *default
   database: tenantapp_johndoe_development
   migrations_paths: db/tenants_migrations
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We are going to use a separate directory for migrations that are used by our tenants. We don’t need them in the central database. You can now create a database for John by using the default command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rake db:create
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;adding-articles&quot;&gt;Adding articles&lt;/h3&gt;
&lt;p&gt;We can now scaffold the &lt;code&gt;Article&lt;/code&gt; model along with the controller and views:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rails g scaffold article title:string content:text --database primary_johndoe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I passed the &lt;code&gt;--database&lt;/code&gt; param to let Rails know that the migration shouldn’t be placed in the default &lt;code&gt;db/migrations&lt;/code&gt; directory used by the primary database. We can now run the migrate command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rake db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Right now, we have two schemas: &lt;code&gt;db/schema.rb&lt;/code&gt; and &lt;code&gt;db/primary_johndoe_schema.rb&lt;/code&gt;. If you would like to create different tables for tenants, you can achieve this by setting a unique &lt;code&gt;migrations_path&lt;/code&gt; value in the &lt;code&gt;config/database.yml&lt;/code&gt; file for the given tenant. In this article, we want to have the same tables for all tenants, so the path to migrations will be the same.&lt;/p&gt;
&lt;h2 id=&quot;adding-multi-tenancy-support&quot;&gt;Adding Multi-tenancy Support&lt;/h2&gt;
&lt;p&gt;In the application where multi-tenancy is supported by one database, to get data for the given tenant, we just have to update the query to the database with the proper &lt;code&gt;tenant_id&lt;/code&gt; value. In our case, each tenant has their database, so we have to switch between databases.&lt;/p&gt;
&lt;p&gt;Rails 6.1 comes with built-in support for horizontal sharding. Shard is a horizontal data partition that contains a subset of the total dataset. We could store articles for all authors in one table in one database, but thanks to the sharding, we can split the data into multiple tables with the same structure but placed in separate databases.&lt;/p&gt;
&lt;p&gt;Let’s define our shards in the parent class for all models. They are stored under &lt;code&gt;app/models/application_record.rb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ActiveRecord::Base.connected_to(role: :reading, shard: :johndoe) do
  Article.all # get all articles created by John
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Without wrapping our call into the &lt;code&gt;connected_to&lt;/code&gt; block, the default shard will be used. Before we move forward, we have to introduce one more change. Since all shards share the same data structure, we can delete the &lt;code&gt;app/models/primary_johndoe_record.rb&lt;/code&gt; model created automatically when we were scaffolding articles.&lt;/p&gt;
&lt;p&gt;We also have to edit the &lt;code&gt;app/models/article.rb&lt;/code&gt; model and change the parent class from &lt;code&gt;PrimaryJohndoeRecord&lt;/code&gt; to &lt;code&gt;ApplicationRecord&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Article &amp;lt; ApplicationRecord
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;adding-more-tenants&quot;&gt;Adding more tenants&lt;/h3&gt;
&lt;p&gt;Currently, we have only one author in our database. To test the functionality of switching between our tenants (databases), we have to add one more author. Open &lt;a href=&quot;http://localhost:3000/authors/new&quot;&gt;http://localhost:3000/authors/new&lt;/a&gt; address and add a new author. I added the author with the name Tim Doe and slug &lt;code&gt;timdoe&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We have a record for the new author, so we have to define a new database:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;development:
 primary:
   &amp;lt;&amp;lt;: *default
   database: tenantapp_development
 primary_johndoe:
   &amp;lt;&amp;lt;: *default
   database: tenantapp_johndoe_development
   migrations_paths: db/tenants_migrations
 primary_timdoe:
   &amp;lt;&amp;lt;: *default
   database: tenantapp_timdoe_development
   migrations_paths: db/tenants_migrations
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now create a new database and run migrations:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;rake db:create
rake db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last step is to update &lt;code&gt;ApplicationRecord&lt;/code&gt; model and define a new shard:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ApplicationRecord &amp;lt; ActiveRecord::Base
 self.abstract_class = true

 connects_to shards: {
   default: { writing: :primary, reading: :primary },
   johndoe: { writing: :primary_johndoe, reading: :primary_johndoe },
   timdoe: { writing: :primary_timdoe, reading: :primary_timdoe },
 }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can now create articles for each author:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ActiveRecord::Base.connected_to(role: :writing, shard: :johndoe) do
  Article.create!(title: &amp;#39;Article from John&amp;#39;, content: &amp;#39;content&amp;#39;)
end

ActiveRecord::Base.connected_to(role: :writing, shard: :timdoe) do
  Article.create!(title: &amp;#39;Article from Tim&amp;#39;, content: &amp;#39;content&amp;#39;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;adding-support-for-a-custom-subdomain&quot;&gt;Adding Support for a Custom Subdomain&lt;/h2&gt;
&lt;p&gt;We can’t visit the articles list for the given author yet because we don’t know when we should show articles from John and Tim. We will solve this problem by implementing custom subdomains. When visiting &lt;a href=&quot;http://johndoe.localhost:3000/articles&quot;&gt;http://johndoe.localhost:3000/articles&lt;/a&gt;, we should see articles from John, and when visiting &lt;a href=&quot;http://timedoe.localhost:3000/articles&quot;&gt;http://timedoe.localhost:3000/articles&lt;/a&gt; articles from Tim.&lt;/p&gt;
&lt;h3 id=&quot;subdomain-configuration-1&quot;&gt;Subdomain configuration&lt;/h3&gt;
&lt;p&gt;We would like to manage and visit articles when the tenant is set. We can achieve this by updating the &lt;code&gt;config/routes.rb&lt;/code&gt; file and wrapping the definition of the articles resource into the constraints block:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Rails.application.routes.draw do
 constraints subdomain: /.*/ do
   resources :articles
 end

 resources :authors
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, Rails set the top-level domain length to 1, but we want to use localhost to set this setting to 0. We can do this by adding the following line to the file &lt;code&gt;config/environments/development.rb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;config.action_dispatch.tld_length = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;making-subdomains-work-with-the-multitenancy-1&quot;&gt;Making subdomains work with the multitenancy&lt;/h3&gt;
&lt;p&gt;To standardize reading the database for the current tenant, I will create a controller concern called &lt;code&gt;Tenantable&lt;/code&gt;. It provides the &lt;code&gt;read_with_tenant&lt;/code&gt; method, which accepts a block and executes it in the context of the requested tenant:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Tenantable
 extend ActiveSupport::Concern

 private

 def read_with_tenant(&amp;amp;block)
   author = Author.find_by!(slug: request.subdomain)

   ActiveRecord::Base.connected_to(role: :reading, shard: author.slug.to_sym) do
     block.call
   end
 end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Save this file as &lt;code&gt;app/controllers/concerns/tenantable.rb&lt;/code&gt; and include in &lt;code&gt;ArticlesController&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ArticlesController &amp;lt; ApplicationController
 include Tenantable

 before_action :set_article, only: [:show, :edit, :update, :destroy]

 def index
   read_with_tenant do
     @articles = Article.all
   end
 end
 # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you can visit &lt;a href=&quot;http://johndoe.localhost:3000/articles&quot;&gt;http://johndoe.localhost:3000/articles&lt;/a&gt; or &lt;a href=&quot;http://timdoe.localhost:3000/articles&quot;&gt;http://timdoe.localhost:3000/articles&lt;/a&gt;, and you will see different articles displayed on the list.&lt;/p&gt;
&lt;p&gt;If you would like to create new articles using the form, you have to define a new method called &lt;code&gt;write_with_tenant&lt;/code&gt; and update the Tenantable concern and methods inside the &lt;code&gt;ArticlesController&lt;/code&gt; accordingly.&lt;/p&gt;
&lt;h2 id=&quot;further-improvements-1&quot;&gt;Further Improvements&lt;/h2&gt;
&lt;p&gt;The approach presented above is just a simple wrapper method that executes code wrapped into a block within a given connection to the database. To make it more universal, you can create a middleware that will parse the subdomain and establish a connection before executing any code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ActiveRecord::Base.establish_connection(:primary_timdoe)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final solution depends on your needs and the number of places where you want to use the assigned data to a specific tenant.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Congratulations, you just built two versions of a multi-tenant Rails application and gained knowledge about the different ways of dealing with multiple tenants in a modern web application.&lt;/p&gt;
&lt;p&gt;Let’s just quickly summarize what we have learned during this article:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There are three primary multi-tenancy levels in a web application - database-row, schema, and database level.&lt;/li&gt;
&lt;li&gt;Each approach has its advantages and disadvantages, and your choice depends on the hardware possibilities and the level of isolation of the tenant information.&lt;/li&gt;
&lt;li&gt;It is possible to implement all multi-tenancy levels within the Ruby on Rails framework without any external libraries.&lt;/li&gt;
&lt;li&gt;Ruby on Rails supports custom subdomain out of the box, so it’s a perfect addition for a multi-tenant application where each tenant can have its subdomain assigned.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I hope you enjoyed reading this article and building multi-tenant Ruby on Rails applications.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Ruby on Rails Model Patterns and Anti-patterns</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/11/18/rails-model-patterns-and-anti-patterns.html">
    <id>https://blog.appsignal.com/2020/11/18/rails-model-patterns-and-anti-patterns.html</id>
    <published>2020-11-18T00:00:00+00:00</published>
    <updated>2020-11-18T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">If you're struggling with models, this blog post is for you. We will quickly go through the process of putting your models on a diet and finish strongly with some things to avoid when writing migrations.</summary>
    <content type="html">&lt;p&gt;Welcome back to the second post in the Ruby on Rails Patterns and Anti-patterns series.
In the &lt;a href=&quot;/2020/08/05/introduction-to-ruby-on-rails-patterns-and-anti-patterns.html&quot;&gt;last blog post&lt;/a&gt;, we went over what patterns and
anti-patterns are in general. We also mentioned some of the most famous patterns
and anti-patterns in the Rails world. In this blog post, we&amp;#39;ll go through a
couple of Rails model anti-patterns and patterns.&lt;/p&gt;
&lt;p&gt;If you&amp;#39;re struggling with models, this blog post is for you. We
will quickly go through the process of putting your models on a diet and finish
strongly with some things to avoid when writing migrations. Let&amp;#39;s jump right in.&lt;/p&gt;
&lt;h2 id=&quot;fat-overweight-models&quot;&gt;&lt;del&gt;Fat&lt;/del&gt; Overweight Models&lt;/h2&gt;
&lt;p&gt;When developing a Rails application, whether it&amp;#39;s a full-blown Rails website
or an API, people tend to store most of the logic in the model. In the
last blog post, we had an example of a &lt;code&gt;Song&lt;/code&gt; class that did many things.
Keeping a lot of things in the model breaks the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Single-responsibility_principle&quot;&gt;Single Responsibility Principle&lt;/a&gt; (SRP).&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s have a look.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Song &amp;lt; ApplicationRecord
  belongs_to :album
  belongs_to :artist
  belongs_to :publisher

  has_one :text
  has_many :downloads

  validates :artist_id, presence: true
  validates :publisher_id, presence: true

  after_update :alert_artist_followers
  after_update :alert_publisher

  def alert_artist_followers
    return if unreleased?

    artist.followers.each { |follower| follower.notify(self) }
  end

  def alert_publisher
    PublisherMailer.song_email(publisher, self).deliver_now
  end

  def includes_profanities?
    text.scan_for_profanities.any?
  end

  def user_downloaded?(user)
    user.library.has_song?(self)
  end

  def find_published_from_artist_with_albums
    ...
  end

  def find_published_with_albums
    ...
  end

  def to_wav
    ...
  end

  def to_mp3
    ...
  end

  def to_flac
    ...
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem with models like these is that they become a dumping ground for the
different logic related to a song. Methods start piling up as they
get added slowly, one by one over time.&lt;/p&gt;
&lt;p&gt;I suggested splitting the code inside the model into smaller modules.
But by doing that, you are simply moving code from one place to another.
Nonetheless, moving code around allows you to organize code better and
avoid obese models with reduced readability.&lt;/p&gt;
&lt;p&gt;Some people even resort to using
&lt;a href=&quot;/2020/09/16/rails-concers-to-concern-or-not-to-concern.html&quot;&gt;Rails concerns&lt;/a&gt;
and find that the logic can be reused across models. I previously wrote about it
and some people loved it, others didn&amp;#39;t. Anyway, the story with concerns is
similar to modules. You should be aware that you are just moving code to a
module that can be included anywhere.&lt;/p&gt;
&lt;p&gt;Another alternative is to create small classes and then call them whenever needed.
For example, we can extract the song converting code to a separate class.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class SongConverter
  attr_reader :song

  def initialize(song)
    @song = song
  end

  def to_wav
    ...
  end

  def to_mp3
    ...
  end

  def to_flac
    ...
  end
end

class Song
  ...

  def converter
    SongConverter.new(self)
  end

  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have the &lt;code&gt;SongConverter&lt;/code&gt; that has the purpose of converting songs to a
different format. It can have its own tests and future logic about converting.
And, if we want to convert a song to MP3, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;@song.converter.to_mp3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To me, this looks a bit clearer than using a module or a concern. Maybe because
I prefer to use composition over inheritance. I consider it more intuitive and readable.
I suggest you review both cases before deciding which way to go. Or you
can choose both if you want, nobody is stopping you.&lt;/p&gt;
&lt;h2 id=&quot;sql-pasta-parmesan&quot;&gt;SQL Pasta Parmesan&lt;/h2&gt;
&lt;p&gt;Who doesn&amp;#39;t love some good pasta in real life? On the other hand, when it comes
to code pasta, almost no one is a fan. And for good reasons. In Rails
models, you can quickly turn your Active Record usage into spaghetti, swirling
around all over the codebase. How do you avoid this?&lt;/p&gt;
&lt;p&gt;There are a few ideas out there that seem to keep those long queries
from turning into lines of spaghetti. Let&amp;#39;s first see how database-related
code can be everywhere. Let&amp;#39;s go back to our &lt;code&gt;Song&lt;/code&gt; model. Specifically, to when we
try to fetch something from it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class SongReportService
  def gather_songs_from_artist(artist_id)
    songs = Song.where(status: :published)
                .where(artist_id: artist_id)
                .order(:title)

    ...
  end
end

class SongController &amp;lt; ApplicationController
  def index
    @songs = Song.where(status: :published)
                 .order(:release_date)

    ...
  end
end

class SongRefreshJob &amp;lt; ApplicationJob
  def perform
    songs = Song.where(status: :published)

    ...
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, we have three use-cases where the &lt;code&gt;Song&lt;/code&gt; model is being
queried. In the &lt;code&gt;SongReporterService&lt;/code&gt; that is used for reporting data about
songs, we try to get published songs from a concrete artist. Then, in the
&lt;code&gt;SongController&lt;/code&gt;, we get published songs and order them by the release date.
And finally, in the &lt;code&gt;SongRefreshJob&lt;/code&gt; we get only published songs and do
something with them.&lt;/p&gt;
&lt;p&gt;This is all fine, but what if we suddenly decide to change the status name to
&lt;code&gt;released&lt;/code&gt; or make some other changes to the way we fetch songs? We would have
to go and edit all occurrences separately. Also, the code above is not DRY. It
repeats itself across the application. Don&amp;#39;t let this get you down. Luckily, there
are solutions to this problem.&lt;/p&gt;
&lt;p&gt;We can use &lt;strong&gt;Rails scopes&lt;/strong&gt; to DRY this code out. Scoping allows you to define
commonly-used queries, which can be called on associations and objects. This makes
our code readable and easier to change. But, maybe the most important thing is that
scopes allow us to chain other Active Record methods such as &lt;code&gt;joins&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;,
etc. Let&amp;#39;s see how our code looks with scopes.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Song &amp;lt; ApplicationRecord
  ...

  scope :published, -&amp;gt;            { where(published: true) }
  scope :by_artist, -&amp;gt;(artist_id) { where(artist_id: artist_id) }
  scope :sorted_by_title,         { order(:title) }
  scope :sorted_by_release_date,  { order(:release_date) }

  ...
end

class SongReportService
  def gather_songs_from_artist(artist_id)
    songs = Song.published.by_artist(artist_id).sorted_by_title

    ...
  end
end

class SongController &amp;lt; ApplicationController
  def index
    @songs = Song.published.sorted_by_release_date

    ...
  end
end

class SongRefreshJob &amp;lt; ApplicationJob
  def perform
    songs = Song.published

    ...
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There you go. We managed to cut the repeating code and put it in the model. But
this doesn&amp;#39;t always work out for the best, especially if you are diagnosed with the
case of a fat model or a &lt;a href=&quot;https://en.wikipedia.org/wiki/God_object&quot;&gt;God Object&lt;/a&gt;.
Adding more and more methods and responsibilities to the model might not be such
a great idea.&lt;/p&gt;
&lt;p&gt;My advice here is to keep scope usage to a minimum and only extract the
common queries there. In our case, maybe the &lt;code&gt;where(published: true)&lt;/code&gt; would be
a perfect scope since it is used everywhere. For other SQL related code, you could use
something called a Repository pattern. Let&amp;#39;s find out what it is.&lt;/p&gt;
&lt;h2 id=&quot;repository-pattern&quot;&gt;Repository Pattern&lt;/h2&gt;
&lt;p&gt;What we are about to show is not a 1:1 Repository pattern as defined in the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-driven_design&quot;&gt;Domain-Driven Design&lt;/a&gt; book.
The idea behind ours and the Rails Repository pattern is to separate database logic
from business logic. We could also go full-on and create a repository class
that does the raw SQL calls for us instead of Active Record, but I wouldn&amp;#39;t
recommend such things unless you really need it.&lt;/p&gt;
&lt;p&gt;What we can do is create a &lt;code&gt;SongRepository&lt;/code&gt; and put the database logic in there.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class SongRepository
  class &amp;lt;&amp;lt; self
    def find(id)
      Song.find(id)
    rescue ActiveRecord::RecordNotFound =&amp;gt; e
      raise RecordNotFoundError, e
    end

    def destroy(id)
      find(id).destroy
    end

    def recently_published_by_artist(artist_id)
      Song.where(published: true)
          .where(artist_id: artist_id)
          .order(:release_date)
    end
  end
end

class SongReportService
  def gather_songs_from_artist(artist_id)
    songs = SongRepository.recently_published_by_artist(artist_id)

    ...
  end
end

class SongController &amp;lt; ApplicationController
  def destroy
    ...

    SongRepository.destroy(params[:id])

    ...
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What we did here is we isolated the querying logic into a testable class.
Also, the model is no longer concerned with scopes and logic. The controller
and models are thin, and everyone&amp;#39;s happy. Right? Well, there is still Active
Record doing all the heavy pulling there. In our scenario, we use &lt;code&gt;find&lt;/code&gt;, which
generates the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;SELECT &amp;quot;songs&amp;quot;.* FROM &amp;quot;songs&amp;quot; WHERE &amp;quot;songs&amp;quot;.&amp;quot;id&amp;quot; = $1 LIMIT $2  [[&amp;quot;id&amp;quot;, 1], [&amp;quot;LIMIT&amp;quot;, 1]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &amp;quot;right&amp;quot; way would be to have all this defined inside the
&lt;code&gt;SongRepository&lt;/code&gt;. As I said, I would not recommend that. You don&amp;#39;t need it and you
want to have full control. A use case for going away from Active Record would
be that you need some complex tricks inside SQL that are not easily supported
by Active Record.&lt;/p&gt;
&lt;p&gt;Talking about raw SQL and Active Record, I also have to bring up one topic. The
topic of migrations and how to do them properly. Let&amp;#39;s dive in.&lt;/p&gt;
&lt;h2 id=&quot;migrations--who-cares&quot;&gt;Migrations — Who Cares?&lt;/h2&gt;
&lt;p&gt;I often hear an argument when writing migrations that the code there should not
be as good as it is in the rest of the application. And that argument doesn&amp;#39;t
sit well with me. People tend to use this excuse to set up smelly code in the
migrations since it will only be run once and forgotten. Maybe
this is true if you are working with a couple of people and everyone is in
constant sync all the time.&lt;/p&gt;
&lt;p&gt;The reality is often different. The application can be used by a larger number of
people not knowing what happens with different application parts. And if you
put some questionable one-off code there, you might break someone&amp;#39;s development
environment for a couple of hours because of the corrupted database state or
just a weird migration. Not sure if this is an anti-pattern, but you should be aware of it.&lt;/p&gt;
&lt;p&gt;How to make migrations more convenient for other people? Let&amp;#39;s go through a list
that will make migrations easier for everyone on the project.&lt;/p&gt;
&lt;h3 id=&quot;make-sure-you-always-provide-a-down-method&quot;&gt;Make Sure You Always Provide a Down Method&lt;/h3&gt;
&lt;p&gt;You never know when something is going to be rolled back. If your migration is
not reversible, make sure to raise &lt;code&gt;ActiveRecord::IrreversibleMigration&lt;/code&gt;
exception like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;def down
  raise ActiveRecord::IrreversibleMigration
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;try-to-avoid-active-record-in-migrations&quot;&gt;Try to Avoid Active Record in Migrations&lt;/h3&gt;
&lt;p&gt;The idea here is to minimize external dependencies except for the state of the
database at the time when the migration should be executed. So there will be no
Active Record validations to ruin (or maybe save) your day. You are left
with plain SQL. For example, let&amp;#39;s write a migration that will publish all
songs from a certain artist.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class UpdateArtistsSongsToPublished &amp;lt; ActiveRecord::Migration[6.0]
  def up
    execute &amp;lt;&amp;lt;-SQL
      UPDATE songs
      SET published = true
      WHERE artist_id = 46
    SQL
  end

  def down
    execute &amp;lt;&amp;lt;-SQL
      UPDATE songs
      SET published = false
      WHERE artist_id = 46
    SQL
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you have a great need for the &lt;code&gt;Song&lt;/code&gt; model, a suggestion would be to define it
inside the migration. That way, you can bulletproof your migration from any
potential changes in the actual Active Record model inside the &lt;code&gt;app/models&lt;/code&gt;.
But, is this all fine and dandy? Let&amp;#39;s go to our next point.&lt;/p&gt;
&lt;h3 id=&quot;separate-schema-migrations-from-data-migrations&quot;&gt;Separate Schema Migrations From Data Migrations&lt;/h3&gt;
&lt;p&gt;Going through the &lt;a href=&quot;https://edgeguides.rubyonrails.org/active_record_migrations.html&quot;&gt;Rails Guides on migrations&lt;/a&gt;, you&amp;#39;ll read the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Migrations are a feature of Active Record that allows you to evolve your &lt;strong&gt;database schema&lt;/strong&gt; over time. Rather than write schema modifications in pure SQL, migrations allow you to use a Ruby DSL to describe changes to your tables.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In the summary of the guide, there is no mention of editing the actual data of
the database table, only the structure. So, the fact that we used the regular migration
to update songs in the second point is not completely right.&lt;/p&gt;
&lt;p&gt;If you need to regularly do something similar in your project, consider using
the &lt;a href=&quot;https://github.com/ilyakatz/data-migrate&quot;&gt;&lt;code&gt;data_migrate&lt;/code&gt; gem&lt;/a&gt;. It is a nice way
of separating data migrations from schema migrations. We can easily rewrite our previous example
with it. To generate the data migration, we can do the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;bin/rails generate data_migration update_artists_songs_to_published
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then add the migration logic there:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class UpdateArtistsSongsToPublished &amp;lt; ActiveRecord::Migration[6.0]
  def up
    execute &amp;lt;&amp;lt;-SQL
      UPDATE songs
      SET published = true
      WHERE artist_id = 46
    SQL
  end

  def down
    execute &amp;lt;&amp;lt;-SQL
      UPDATE songs
      SET published = false
      WHERE artist_id = 46
    SQL
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This way, you are keeping all your schema migrations inside the &lt;code&gt;db/migrate&lt;/code&gt;
directory and all the migrations that deal with the data inside the &lt;code&gt;db/data&lt;/code&gt;
directory.&lt;/p&gt;
&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;
&lt;p&gt;Dealing with models and keeping them readably in Rails is a constant struggle.
Hopefully, in this blog post, you got to see the possible pitfalls and solutions
to common problems. The list of model anti-patterns and patterns is far from
complete in this post, but these are the most notable ones I found recently.&lt;/p&gt;
&lt;p&gt;If you are interested in more Rails patterns and anti-patterns, stay tuned for
the next installment in the series. In upcoming posts, we&amp;#39;ll go through
common problems and solutions to the view and controller side of the Rails MVC.&lt;/p&gt;
&lt;p&gt;Until next time, cheers!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Structuring Monitoring Data in Monolithic Applications With Namespaces</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/11/04/structuring-monitoring-data-in-monolith-applications-through-namespaces.html">
    <id>https://blog.appsignal.com/2020/11/04/structuring-monitoring-data-in-monolith-applications-through-namespaces.html</id>
    <published>2020-11-04T00:00:00+00:00</published>
    <updated>2020-11-04T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Namespaces help you make sense of what’s happening in your application. Knowing how they work is especially useful for large monolithic projects.</summary>
    <content type="html">&lt;h2 id=&quot;what-are-namespaces&quot;&gt;What Are Namespaces?&lt;/h2&gt;
&lt;p&gt;Everything that happens in an AppSignal-monitored application is logged under a namespace. Namespaces work like folders, grouping events, issues, and monitoring data into manageable chunks.&lt;/p&gt;
&lt;p&gt;By default, every application starts with three default namespaces: &lt;code&gt;web&lt;/code&gt;, &lt;code&gt;background&lt;/code&gt;, and &lt;code&gt;frontend&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The web namespace holds all your HTTP requests. In MVC-oriented frameworks such as Rails or Sinatra, this includes controller actions.&lt;/li&gt;
&lt;li&gt;The background namespace holds activity from background jobs, libraries, and tasks.&lt;/li&gt;
&lt;li&gt;The frontend namespace logs the events sent by the &lt;a href=&quot;https://docs.appsignal.com/front-end/&quot;&gt;AppSignal for JavaScript&lt;/a&gt; integration.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AppSignal maps incoming events using built-in per-application and per-integration rules. However, you can change these mappings at any time and even create new namespaces to model your application structure.&lt;/p&gt;
&lt;h2 id=&quot;trying-out-namespaces-in-ruby&quot;&gt;Trying Out Namespaces in Ruby&lt;/h2&gt;
&lt;p&gt;Let’s try out namespaces on a Ruby on Rails (ROR) application. After creating a fresh Rails project with &lt;code&gt;rails new&lt;/code&gt; and setting up the &lt;a href=&quot;https://docs.appsignal.com/ruby/integrations/rails.html&quot;&gt;rails integration&lt;/a&gt;, you’ll find the &lt;code&gt;web&lt;/code&gt; namespace in your dashboard.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/web1.png&quot; alt=&quot;Dashboard showing web namespace&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AppSignal shows the namespace as soon as it receives transactions from any of the controllers.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/web1-controllers.png&quot; alt=&quot;Most recent actions. Shows controller events.&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The rest of the default namespaces won’t appear until there is some activity in them. Let’s add something in the background namespace to make things more interesting. This is how the dashboard looks after adding &lt;a href=&quot;https://sidekiq.org/&quot;&gt;Sidekiq&lt;/a&gt; to the project (check the code in &lt;a href=&quot;https://github.com/appsignal/appsignal-examples/tree/rails-5+sidekiq&quot;&gt;examples repository&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/bg1a.png&quot; alt=&quot;Dashboard showing the background namespace&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AppSignal assigns the action to the background namespace because it recognizes Sidekiq as a job processor. AppSignal integrates with most of the popular background processors out there, but if yours is omitted, you can always &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/background-jobs.html&quot;&gt;add instrumentation&lt;/a&gt; to your jobs manually.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/bg1b.png&quot; alt=&quot;Last events in the background namespace&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;creating-custom-namespaces&quot;&gt;Creating Custom Namespaces&lt;/h2&gt;
&lt;p&gt;On large monolithic applications, the default namespaces can feel too generic. A big website typically serves static content, dynamic pages, API endpoints, among other web services. Most of this would all end up on the &lt;code&gt;web&lt;/code&gt; namespace.&lt;/p&gt;
&lt;p&gt;Also, every part of the application has a different priority. A login page problem is a lot more urgent than one in the internal administration panel. Yet AppSignal treats all issues within a namespace as equal. When there is a lot of activity, it can be hard to identify the most critical issues.&lt;/p&gt;
&lt;p&gt;So, we should organize namespaces by priority and areas of responsibility. Then we can attach separate notification policies and alert only the interested parties. Following this reasoning, we could create custom namespaces for the &lt;code&gt;login_page&lt;/code&gt;, &lt;code&gt;api_endpoints&lt;/code&gt;, and &lt;code&gt;admin_panel&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/namespace-comparison.png&quot; alt=&quot;Custom namespaces let us create fine-grained zones for the application&quot;/&gt;&lt;/p&gt;
&lt;p&gt;To create a &lt;a href=&quot;https://docs.appsignal.com/guides/namespaces.html&quot;&gt;new namespace in Ruby&lt;/a&gt;, we’ll use &lt;code&gt;Appsignal.set_namespace&lt;/code&gt;. Take a look at the following code, which creates a job in a namespace called &lt;code&gt;urgent_background&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class FetchPricesWorker
    include Sidekiq::Worker

    def perform
        Appsignal.set_namespace(&amp;quot;urgent_background&amp;quot;)

        # worker code ...

    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once we made this change and restarted the app, these new jobs will appear in the newly-created namespace:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/ubg1a.png&quot; alt=&quot;Dashboard showing the urgent_background namespace&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We can confirm that the actual job has been logged by checking the action name in the dashboard:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/ubg1b.png&quot; alt=&quot;Last events in the urgent_background namespace&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Custom namespaces also work in &lt;a href=&quot;https://docs.appsignal.com/guides/namespaces.html&quot;&gt;all integrations&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;ignoring-namespaces&quot;&gt;Ignoring Namespaces&lt;/h2&gt;
&lt;p&gt;Another benefit of custom namespaces is that they let us disregard events from parts of the application we don’t care about. For instance, we may choose to ignore events from the &lt;code&gt;admin_panel&lt;/code&gt; completely.&lt;/p&gt;
&lt;p&gt;Ignoring a namespace takes three steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Assign the parts we don’t want to monitor to a custom namespace.&lt;/li&gt;
&lt;li&gt;Configure the integration to ignore the namespace.&lt;/li&gt;
&lt;li&gt;Restart your app.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For Ruby, add the &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/namespaces.html#ignore-by-namespace&quot;&gt;ignore_namespaces&lt;/a&gt; option in the AppSignal config file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;production:
  ignore_namespaces:
    - &amp;quot;admin_panel&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ignoring a namespace skips all the transaction and span data at the source. Custom metric data is still reported.&lt;/p&gt;
&lt;p&gt;The Elixir and JavaScript integrations have similar options. For more details check the &lt;a href=&quot;https://docs.appsignal.com/guides/filter-data/ignore-namespaces.html&quot;&gt;ignoring namespaces guide&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;namespaces-for-monolithic-applications&quot;&gt;Namespaces for Monolithic Applications&lt;/h2&gt;
&lt;p&gt;Now that we know how namespaces work, let’s examine a few ways we can use them to partition a monolithic application.&lt;/p&gt;
&lt;p&gt;While there are no set rules, partitioning boils down to two strategies. You may choose one of them or a mix of both as a starting point:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;By role&lt;/strong&gt;: we assign namespaces to functional or logical units within the project. Thus, we may find it sensible to define namespaces such as &lt;code&gt;billing&lt;/code&gt;, &lt;code&gt;sign_in&lt;/code&gt; or &lt;code&gt;sign_up&lt;/code&gt;, &lt;code&gt;admin_panel&lt;/code&gt;, and &lt;code&gt;homepage&lt;/code&gt;. One glance at the AppSigal dashboard and you will understand what’s going on in each part of the application. This approach works well when the code can be nicely broken up by clear boundaries.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;By severity&lt;/strong&gt;: here we use namespaces as a prioritizing device. It’s up to you to establish which parts of the code are &lt;code&gt;critical&lt;/code&gt;, &lt;code&gt;important&lt;/code&gt;, &lt;code&gt;medium&lt;/code&gt;, or &lt;code&gt;low&lt;/code&gt;. This approach lets you immediately sort out what problems you want to address first.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Suppose that we have a controllers that handle user sign in and registration. When choosing to partition by role, we could map them to the &lt;code&gt;user_login&lt;/code&gt; namespace.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# in Rails we use before_action callback to change
# the namespace before the request starts
class LoginController &amp;lt; ApplicationController
    before_action :set_appsignal_namespace

    def set_appsignal_namespace
        # Sets the namespace
        Appsignal.set_namespace(&amp;quot;user_login&amp;quot;)
    end

    # controller actions ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But if you prefer using priority namespaces, a controller in charge of billing would probably go in the &lt;code&gt;critical&lt;/code&gt; namespace.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class BillingPageController &amp;lt; ApplicationController
    before_action :set_appsignal_namespace

    def set_appsignal_namespace
        Appsignal.set_namespace(&amp;quot;critical&amp;quot;)
    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Controllers that inherit from these share the same namespace as their parents:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# any controllers that inherit from LoginController
# are also part of the &amp;quot;user_login&amp;quot; namespace
class RegistrationController &amp;lt; LoginController

    # there’s no need for before_action here
    # this controller already reports to the parent’s namespace

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we’ve seen, jobs and tasks are automatically assigned to the &lt;code&gt;background&lt;/code&gt; namespace. Whenever possible, we should assign them into more specific ones. For instance, a database cleanup job could go into the &lt;code&gt;database&lt;/code&gt; namespace, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class ActiveJobDatabaseCleanupJob &amp;lt; ActiveJob::Base
  queue_as :default

  def perform(argument = nil, options = {})
    Appsignal.set_namespace(&amp;quot;database&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Priorities also work for jobs. We could assign unimportant tasks to &lt;code&gt;low&lt;/code&gt; for instance, as in this Rake task:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;task :unimportant_job do

  # Run this rake job in the low namespace
  Appsignal.set_namespace(&amp;quot;low&amp;quot;)

  # job code ...

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In some cases, you will want to log actions using a manual transaction. You can define the namespace while creating it, like in the following example, which codes a custom mailer job:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Job
    def perform

        # Create a transaction for this job and set the namespace
        transaction = Appsignal::Transaction.create(
            SecureRandom.uuid,
            &amp;quot;mailer&amp;quot;,
            Appsignal::Transaction::GenericRequest.new(ENV.to_hash)
        )

        # job code ...

    end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;namespaces-and-notifications&quot;&gt;Namespaces and Notifications&lt;/h2&gt;
&lt;p&gt;Not everyone in the team needs to be notified about every problem. Frontend specialists don’t care about background jobs as much as backend developers. Still, they may want to know when there’s a problem in the backend. Backend developers will surely like to be notified of performance issues on the &lt;code&gt;web&lt;/code&gt; namespace. Namespaces let us route notifications to the right people.&lt;/p&gt;
&lt;h3 id=&quot;setting-up-per-namespace-notifiers&quot;&gt;Setting Up Per-Namespace Notifiers&lt;/h3&gt;
&lt;p&gt;We can create notification groups that are only active for specific namespaces. For instance, we could send emails for errors in the &lt;code&gt;web&lt;/code&gt; namespace, or send a message into the #frontend Slack channel for issues in the &lt;code&gt;frontend&lt;/code&gt; namespace.&lt;/p&gt;
&lt;p&gt;To create per-namespace notification groups, go to App Settings &amp;gt; Notifications &amp;gt; Notifiers and click on &lt;strong&gt;Add Integration&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/add-integration.png&quot; alt=&quot;Adding an integration&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Select one of the integrations and type its name. Choose which type of messages to send and for which namespace. For example, let’s create a Slack notification for the &lt;code&gt;#frontend&lt;/code&gt; channel.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/frontend-slack.png&quot; alt=&quot;slack integration&quot;/&gt;&lt;/p&gt;
&lt;p&gt;While we’re still here, create a second notification for the backend developers:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/notification-web.png&quot; alt=&quot;New notification group for web&quot;/&gt;&lt;/p&gt;
&lt;p&gt;You can configure as many notifiers as you need to keep the team up to date with everything that’s happening.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/notifiers.png&quot; alt=&quot;Notifiers for different parts of the application&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;changing-per-namespace-notifications&quot;&gt;Changing Per-Namespace Notifications&lt;/h3&gt;
&lt;p&gt;When an incident is created, AppSignal will apply a notification policy. This policy is based on the namespace the error comes from. We can define separate policies for each namespace.&lt;/p&gt;
&lt;p&gt;To see the &lt;a href=&quot;https://docs.appsignal.com/application/notification-settings.html#organization-and-app-namespace-defaults&quot;&gt;namespace defaults&lt;/a&gt; for your application, go to &lt;a href=&quot;https://appsignal.com/redirect-to/app?to=notifications&quot;&gt;App Settings &amp;gt; Notifications &amp;gt; &lt;strong&gt;Namespace defaults&lt;/strong&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/namespace-defaults.png&quot; alt=&quot;Namespace defaults for web, background and urgent_background&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here, you’ll find options to customize error and performance notifications for every namespace:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Every occurrence&lt;/strong&gt;: sends notifications every time an incident is triggered, with a 5-minute cooldown.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;First on deploy&lt;/strong&gt;: notifies you of the first error after deploying the application.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;First after close&lt;/strong&gt;: sends a notification the first time a closed issue is reopened.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Never notify&lt;/strong&gt;: disables notifications altogether.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;creating-per-namespace-triggers&quot;&gt;Creating Per-Namespace Triggers&lt;/h3&gt;
&lt;p&gt;Triggers tell AppSignal to create an incident and send notifications when a metric goes over or below a predefined value. Since different parts of an application may have different thresholds, we should create separate triggers for each namespace. The classic example is a trigger that alerts us when throughput is too low in the &lt;code&gt;web&lt;/code&gt; namespace.&lt;/p&gt;
&lt;p&gt;To create a trigger, go to &lt;a href=&quot;https://appsignal.com/redirect-to/app?to=triggers&quot;&gt;Anomaly Detection &amp;gt; Triggers&lt;/a&gt;, and click on &lt;strong&gt;Add your first trigger&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Select an Actions trigger type on the left menu and choose the relevant namespace. Then, set the thresholds that trigger the alert.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/create-trigger-web.png&quot; alt=&quot;Creating a new trigger for the web namespace&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here you can also define which groups should be notified. To finalize, click on &lt;strong&gt;Save Trigger&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-11/img/create-trigger-web-notify.png&quot; alt=&quot;This alert will send a notification to backend developers&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Namespaces let make sense of your application’s monitoring data. They are also indispensable for firing notifications and incidents on a fine-grained level, limiting noise, and avoiding false positives.&lt;/p&gt;
&lt;p&gt;After checking how custom namespaces work on &lt;a href=&quot;https://docs.appsignal.com/ruby/instrumentation/namespaces.html&quot;&gt;Ruby&lt;/a&gt;, &lt;a href=&quot;https://docs.appsignal.com/nodejs/2.x/tracing/namespaces.html&quot;&gt;Node.js&lt;/a&gt;, and &lt;a href=&quot;https://docs.appsignal.com/elixir/instrumentation/namespaces.html&quot;&gt;Elixir&lt;/a&gt;, read these next to continue learning how to use namespaces:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.appsignal.com/application/namespaces.html&quot;&gt;Namespaces in AppSignal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.appsignal.com/guides/namespaces.html&quot;&gt;Grouping with namespaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/03/25/whats-the-difference-between-monitoring-webhooks-and-background-jobs.html&quot;&gt;What&amp;#39;s The Difference Between Monitoring Webhooks and Background Jobs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2017/05/03/gem-2-2.html&quot;&gt;Gem 2.2 - Custom namespaces!&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>

  <entry>
    <title>Monitoring Any System with StatsD and AppSignal's Standalone Agent</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/09/23/monitoring-any-system-with-statsd-and-the-standalone-appsignal-agent.html">
    <id>https://blog.appsignal.com/2020/09/23/monitoring-any-system-with-statsd-and-the-standalone-appsignal-agent.html</id>
    <published>2020-09-23T00:00:00+00:00</published>
    <updated>2020-09-23T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">To extend monitoring everywhere and have all data in a single place, check out our standalone agent.</summary>
    <content type="html">&lt;p&gt;Monitoring your application alone is not always enough to get the full picture of your systems. Frequently, services running in satellite apps (or supporting apps) can have an acute impact on your day-to-day operations. Database servers are well-known examples of this. Backup scripts and other background jobs can also slow systems and are often overlooked.&lt;/p&gt;
&lt;p&gt;The AppSignal &lt;a href=&quot;https://www.appsignal.com/nodejs&quot;&gt;APM for Node.js&lt;/a&gt;, and the &lt;a href=&quot;https://www.appsignal.com/ruby/&quot;&gt;Ruby APM&lt;/a&gt; and &lt;a href=&quot;https://www.appsignal.com/elixir/&quot;&gt;Elixir APM&lt;/a&gt; automatically instrument your app itself. But AppSignal does not watch these satellite processes by default. To extend monitoring everywhere and have all your data in a single app, you can install AppSignal’s &lt;a href=&quot;https://docs.appsignal.com/standalone-agent/installation.html&quot;&gt;standalone agent&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;appsignals-standalone-agent&quot;&gt;AppSignal&amp;#39;s Standalone Agent&lt;/h2&gt;
&lt;p&gt;The standalone agent is based on the &lt;a href=&quot;https://docs.appsignal.com/appsignal/how-appsignal-operates.html#agent&quot;&gt;same software&lt;/a&gt; with which we usually instrument Ruby, Elixir, or JavaScript applications. This software can also run in standalone mode.&lt;/p&gt;
&lt;p&gt;The standalone agent can be used to monitor:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Infrastructure&lt;/strong&gt;: machines that are part of our system but do not run application code.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Background jobs&lt;/strong&gt;: such as intensive cron jobs or long-running data-processing scripts. If these background jobs are written in a supported language (Ruby, Elixir, or Node.js) you can use the standard integration.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;More languages&lt;/strong&gt;: programs written in languages other than those supported out of the box.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For instance, with the standalone agent, we could track a machine learning model written in Python, instrument backup scripts, &lt;a href=&quot;/2020/07/07/how-appsignal-monitors-their-own-kafka-brokers.html&quot;&gt;monitor Kafka brokers&lt;/a&gt;, or collect &lt;a href=&quot;https://docs.appsignal.com/metrics/host-metrics/index.html&quot;&gt;host metrics&lt;/a&gt; in our web farms. You can view all this information on AppSignal to complement the metrics you already have for your main applications.&lt;/p&gt;
&lt;h2 id=&quot;how-it-works&quot;&gt;How It Works&lt;/h2&gt;
&lt;p&gt;The agent is shipped as a deb or rpm package and doesn’t have any language dependencies. It runs in any Debian/Ubuntu or Red Hat-based systems. For detailed installation instructions, check the &lt;a href=&quot;https://docs.appsignal.com/standalone-agent/installation.html#installation&quot;&gt;agent documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Once installed, the agent is configured in a few minutes and keeps running forever as a daemon, silently monitoring your infrastructure. What is more, the agent includes a &lt;a href=&quot;https://docs.appsignal.com/standalone-agent/statsd.html&quot;&gt;StatsD&lt;/a&gt; server that relays any custom data you log into your AppSignal dashboard.&lt;/p&gt;
&lt;h3 id=&quot;what-is-statsd&quot;&gt;What Is StatsD?&lt;/h3&gt;
&lt;p&gt;StatsD is a standard for collecting and aggregating arbitrary data. It focuses on logging metric and performance information. It uses a lightweight text protocol over UDP connections that have a small footprint in your machine.&lt;/p&gt;
&lt;p&gt;A StatsD message looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEY:VALUE|TYPE
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where &lt;code&gt;KEY&lt;/code&gt; is any arbitrary string, and &lt;code&gt;VALUE&lt;/code&gt; is a number. The type value defines how the number is processed.&lt;/p&gt;
&lt;p&gt;We support three types of metrics:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;c&lt;/strong&gt;: this is a &lt;em&gt;counter&lt;/em&gt; that increments each time it is called. For instance, &lt;code&gt;active_users:1|c&lt;/code&gt; adds 1 to the &lt;code&gt;active_users&lt;/code&gt; counter.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;g&lt;/strong&gt;: a &lt;em&gt;gauge&lt;/em&gt; takes a numeric value and maintains it until updated. This is useful to record values that change up and down over time, such as throughput, number of active users, or number of pending tasks in a queue.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;t&lt;/strong&gt;: stores &lt;em&gt;timing&lt;/em&gt; values. This type is ideal for tracking durations. AppSignal calculates means, count, and percentiles for all the logged timings.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Other unsupported metric types will be silently ignored.&lt;/p&gt;
&lt;h2 id=&quot;sending-data-to-statsd&quot;&gt;Sending Data to StatsD&lt;/h2&gt;
&lt;p&gt;The standalone agent listens for UDP packets on port 8125. We can send StatsD-formatted strings from the command line using &lt;a href=&quot;http://netcat.sourceforge.net/&quot;&gt;netcat&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;echo -n &amp;quot;myscript.myevent.counter:1|c&amp;quot; | nc -4u -w0 localhost 8125
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since we’re using UDP, we don’t have to wait for a response.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.dest-unreach.org/socat/&quot;&gt;Socat&lt;/a&gt; also works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;echo -n &amp;quot;myscript.myevent.counter:1|c&amp;quot; | socat - udp:localhost:8125
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This makes it easy to instrument any batch or cron jobs. For instance, the following lines use a gauge to log how much data a backup job has generated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;backup_size=$(du -m /backups | cut -f1)
echo -n &amp;quot;backup.data:$backup_size|g&amp;quot; | nc -4u -w0 localhost 8125
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re not limited to integers. StatsD also works with floating-point numbers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;echo -n &amp;quot;network.latency:0.2|g&amp;quot; | nc -4u -w0 localhost 8125
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;using-tags&quot;&gt;Using Tags&lt;/h2&gt;
&lt;p&gt;You can add tags to your metrics. The StatsD server supports optional tags at the end of the message:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;KEY:VALUE|TYPE|#TAGS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can apply several tags in the same message and assign values for filtering later:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;echo -n &amp;quot;backup.data:$backup_size|g|#backups,env:production&amp;quot; | nc -4u -w0 localhost 8125
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll learn how to see the data in AppSignal in a bit.&lt;/p&gt;
&lt;h2 id=&quot;instrumenting-languages&quot;&gt;Instrumenting Languages&lt;/h2&gt;
&lt;p&gt;The StatsD server is compatible with any language that can send UDP packets. Let’s see a few examples.&lt;/p&gt;
&lt;p&gt;Python is a popular language for data mining and machine learning. We can add instrumentation into Python applications using the build-in &lt;code&gt;socket&lt;/code&gt; library:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import time

# measure time taken for function
start = time.process_time()
train_my_model()
training_time = time.process_time() - start

# send value to statsd
import socket

UDP_IP = &amp;quot;127.0.0.1&amp;quot;
UDP_PORT = 8125
MESSAGE = b&amp;quot;model.training.time:&amp;quot; + bytes(str(training_time), &amp;#39;utf-8&amp;#39;) + b&amp;quot;|t&amp;quot;

sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.sendto(MESSAGE, (UDP_IP, UDP_PORT))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We could achieve similar results in Java with the &lt;code&gt;java.net&lt;/code&gt; library:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;byte[] buffer = &amp;quot;mybatch.exception.counter:1|c&amp;quot;.getBytes();
InetAddress address = InetAddress.getByName(&amp;quot;127.0.0.1&amp;quot;);
DatagramPacket packet = new DatagramPacket(
    buffer, buffer.length, address, 8125
);
DatagramSocket datagramSocket = new DatagramSocket();
datagramSocket.send(packet);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PHP is another example of an incredibly popular language. We can send UDP packets with &lt;code&gt;socket_sendto&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-php&quot;&gt;$msg = &amp;quot;mywebsite.active_users:$ACTIVE_USERS|g&amp;quot;;
$len = strlen($msg);

$sock = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);
socket_sendto($sock, $msg, $len, 0, &amp;#39;127.0.0.1&amp;#39;, 8125);
socket_close($sock);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;statsd-clients&quot;&gt;StatsD Clients&lt;/h3&gt;
&lt;p&gt;Thus far, we used the built-in networking capabilities in every language. But there’s more. Many languages and products include third-party StatsD clients or addons. Any StatsD-compliant client should work, at least for the supported data types. You can find a list of clients at the &lt;a href=&quot;https://github.com/statsd/statsd/wiki&quot;&gt;StatsD project wiki&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;viewing-host-data-in-appsignal&quot;&gt;Viewing Host Data in AppSignal&lt;/h2&gt;
&lt;p&gt;The &lt;strong&gt;Host Metrics&lt;/strong&gt; dashboard shows your machine’s resource utilization:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/hosts-dashboard.png&quot; alt=&quot;Hosts metrics dashboard location&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AppSignal adds an entry for every machine running the standalone agent.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/host-ov.png&quot; alt=&quot;Available hosts&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The dashboard shows the load and CPU averages disk, network, memory, and swap usage:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/hosts1.png&quot; alt=&quot;Host dashboard&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/hosts2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;creating-dashboards&quot;&gt;Creating Dashboards&lt;/h2&gt;
&lt;p&gt;AppSignal doesn’t automatically generate dashboards for the StatsD value you sent—you’ll need to create custom dashboards for this.&lt;/p&gt;
&lt;p&gt;First, click on &lt;strong&gt;Add dashboard&lt;/strong&gt; under the dashboard menu:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/dash0.png&quot; alt=&quot;Location of the create dashboard button&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Give a name to the dashboard:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/dash1.png&quot; alt=&quot;Creating a dashboard&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Clicking the &lt;strong&gt;Add graph&lt;/strong&gt; button shows the graph builder:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/dash2.png&quot; alt=&quot;Empty custom dashboard&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Give a name to the graph, and click on &lt;strong&gt;Add metric&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/create1.png&quot; alt=&quot;Creating a graph&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Pick the metric you’re interested in from the menu.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/backup1.png&quot; alt=&quot;Adding metrics to the graph&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Optionally, use tags for filtering:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/backup2.png&quot; alt=&quot;Filtering by tags&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Next, click &lt;strong&gt;Back to overview&lt;/strong&gt;. You might want to try different graph types and value units to find out which one best suits the data you want to represent.&lt;/p&gt;
&lt;p&gt;Timing data looks better with area graphs because the mean and percentiles are shown more clearly.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/stats-timer.png&quot; alt=&quot;Changing display settings&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Line graphs work great for counters and gauges.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/create2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Once you’re happy with the result, click on &lt;strong&gt;Create graph&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/backup3.png&quot; alt=&quot;New graph created&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Note that you can also add a dashbaord for any other automatically instrumented or measured metrics if you have AppSignal set of as your &lt;a href=&quot;https://www.appsignal.com/nodejs&quot;&gt;performance monitoring tool (APM) for Node.js&lt;/a&gt;, or your &lt;a href=&quot;https://www.appsignal.com/ruby/&quot;&gt;Ruby (on Rails) APM&lt;/a&gt; or &lt;a href=&quot;https://www.appsignal.com/elixir/&quot;&gt;Elixir APM&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping Up&lt;/h2&gt;
&lt;p&gt;We’ve learned how to use AppSignal’s standalone server to watch your machines and satellite code. With its built-in StatsD server, you can record arbitrary performance data and instrument any process.&lt;/p&gt;
&lt;p&gt;Check the following links to learn more about using the standalone agent:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://appsignal.com&quot;&gt;StatsD reference&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.appsignal.com/metrics/custom.html&quot;&gt;How to send custom metrics&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.appsignal.com/metrics/dashboards.html&quot;&gt;Creating dashboards in AppSignal&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/2020/08/17/identifying-and-resolving-a-kafka-issue-with-appsignal.html&quot;&gt;Identifying and Resolving a Kafka Issue the Standalone Agent&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>

  <entry>
    <title>Rails Concerns: To Concern Or Not To Concern</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/09/16/rails-concers-to-concern-or-not-to-concern.html">
    <id>https://blog.appsignal.com/2020/09/16/rails-concers-to-concern-or-not-to-concern.html</id>
    <published>2020-09-16T00:00:00+00:00</published>
    <updated>2020-09-16T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Should you be concerned about Rails concerns?</summary>
    <content type="html">&lt;p&gt;If you&amp;#39;ve ever used Ruby on Rails, you&amp;#39;ve probably come across the
concept of concerns. Whenever you jumpstart a new Rails project, you get a
directory &lt;code&gt;app/controllers/concerns&lt;/code&gt; and &lt;code&gt;app/models/concerns&lt;/code&gt;. But what are
concerns? And why do people from the Rails community sometimes talk badly about them?&lt;/p&gt;
&lt;h2 id=&quot;quick-overview&quot;&gt;Quick Overview&lt;/h2&gt;
&lt;p&gt;A Rails Concern is any module that extends &lt;code&gt;ActiveSupport::Concern&lt;/code&gt; module. You
might ask — how are concerns so different from modules? The main difference is
that Rails concerns allow you to do a bit of magic, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# app/models/concerns/trashable.rb

module Trashable
  extend ActiveSupport::Concern

  included do
    scope :existing, -&amp;gt; { where(trashed: false) }
    scope :trashed, -&amp;gt; { where(trashed: true) }
  end

  def trash
    update_attribute :trashed, true
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You see that word included. It is a bit of Rails carbohydrates sprinkled upon
a Ruby module. What &lt;code&gt;ActiveSupport::Concern&lt;/code&gt; does for you is it allows you to put
code that you want evaluated inside the included block. For example, you want
to extract the trashing logic out of your model. The &lt;code&gt;included&lt;/code&gt; allows you to
do what we did and later include your model&amp;#39;s concern like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Song &amp;lt; ApplicationRecord
  include Trashable

  has_many :authors

  # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty handy and naive at this point, right? The Model lost a bit of weight and
trashing can now be reused throughout other models, not just our Song model.
Well, things can get complicated. Let&amp;#39;s dive in to find out.&lt;/p&gt;
&lt;h2 id=&quot;a-classic-example-of-a-mixin&quot;&gt;A Classic Example of a Mixin&lt;/h2&gt;
&lt;p&gt;Before we embark further into the depths of concerns, let&amp;#39;s add another explanation of them.
When you see &lt;code&gt;include SomeModule&lt;/code&gt; or &lt;code&gt;extend AnotherModule&lt;/code&gt;, these are called &lt;a href=&quot;https://en.wikipedia.org/wiki/Mixin&quot;&gt;mixins&lt;/a&gt;.
A mixin is a set of code that can be added to other classes. And, as we all know from the
&lt;a href=&quot;https://ruby-doc.org/core-2.2.0/Module.html&quot;&gt;Ruby documentation&lt;/a&gt;, a module is
a collection of methods and constants. So what we are doing here is including
modules with methods and constants into different classes so that they can use them.&lt;/p&gt;
&lt;p&gt;That is exactly what we did with the &lt;code&gt;Trashable&lt;/code&gt; concern. We extracted common logic
around trashing a model object into a module. This module can later be included in
other places. So, &lt;strong&gt;mixin&lt;/strong&gt; is a design pattern used not only in Ruby and Rails.
But, wherever it&amp;#39;s used, people either like it and think it is good, or they hate it
and think it can easily spin out of control.&lt;/p&gt;
&lt;p&gt;To better understand this, we&amp;#39;ll go through a couple of pros and cons of using
them. Hopefully, by doing this, we can gain an understanding of when or whether to
use concerns.&lt;/p&gt;
&lt;h2 id=&quot;i-have-it-all&quot;&gt;I Have It All&lt;/h2&gt;
&lt;p&gt;When you decide to extract something to a concern, like &lt;code&gt;Trashable&lt;/code&gt; concern, you
now have access to all of the functionality of wherever &lt;code&gt;Trashable&lt;/code&gt; is included. This
brings great power, but as Richard Schneeman said in &lt;a href=&quot;https://rollout.io/blog/when-to-be-concerned-about-concerns/&quot;&gt;his blog post&lt;/a&gt;
on the topic — &amp;quot;with great power comes great ability to make complicated code&amp;quot;.
He meant complicating code that you might rely on, something that is
&lt;em&gt;supposed&lt;/em&gt; to be there in your concerns.&lt;/p&gt;
&lt;p&gt;If we take a look at the &lt;code&gt;Trashable&lt;/code&gt; once more:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;module Trashable
  extend ActiveSupport::Concern

  included do
    scope :existing, -&amp;gt; { where(trashed: false) }
    scope :trashed, -&amp;gt; { where(trashed: true) }
  end

  def trash
    update_attribute :trashed, true
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The logic of the concern relies on the fact that the &lt;code&gt;trashed&lt;/code&gt; field exists
wherever the concern is included. Right? No biggie, this is what we want after
all. But, what I see happen is that people get tempted to pull in other stuff
from the model into the concern. To paint a picture of how this can happen,
let&amp;#39;s imagine that the &lt;code&gt;Song&lt;/code&gt; model has another method &lt;code&gt;featured_authors&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Song &amp;lt; ApplicationRecord
  include Trashable

  has_many :authors

  def featured_authors
    authors.where(featured: true)
  end

  # ...
end

class Album &amp;lt; ApplicationRecord
  include Trashable

  has_many :authors

  def featured_authors
    authors.where(featured: true)
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To better illustrate, I added an &lt;code&gt;Album&lt;/code&gt; model that also includes &lt;code&gt;Trashable&lt;/code&gt;.
Let&amp;#39;s then say we want to notify featured authors of the song and the album
when they get trashed. People will get tempted to put this logic inside
the concern like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;module Trashable
  extend ActiveSupport::Concern

  included do
    scope :existing, -&amp;gt; { where(trashed: false) }
    scope :trashed, -&amp;gt; { where(trashed: true) }
  end

  def trash
    update_attribute :trashed, true

    notify(featured_authors)
  end

  def notify(authors)
    # ...
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Right here, things are starting to get complicated a bit. Since we have
trashing logic outside our Song model, we might be tempted to put notifying in
the &lt;code&gt;Trashable&lt;/code&gt; concern. In there, something &amp;quot;wrong&amp;quot; happens. The
&lt;code&gt;featured_authors&lt;/code&gt; is taken from the &lt;code&gt;Song&lt;/code&gt; model. OK, let&amp;#39;s say this passes
pull request review and CI checks.&lt;/p&gt;
&lt;p&gt;Then, a couple of months down the road, a new requirement is set where the
developer needs to change the way we present &lt;code&gt;featured_authors&lt;/code&gt; for songs. For
example, a new requirement wants to show only featured authors from Europe.
Naturally, the developer will find where featured authors are defined and edit
them.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Song &amp;lt; ApplicationRecord
  include Trashable

  has_many :authors

  def featured_authors
    authors.where(featured: true).where(region: &amp;#39;Europe&amp;#39;)
  end

  # ...
end

class Album &amp;lt; ApplicationRecord
  include Trashable

  has_many :authors

  # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works nicely wherever we show authors, but after we deploy to production,
the folks from other parts of the world won&amp;#39;t get notified anymore about
their songs. Mistakes like these are easy to make when using concerns. The
example above is a simple and artificial one, but the ones that are &amp;quot;in
the wild&amp;quot; can be super tricky.&lt;/p&gt;
&lt;p&gt;What is risky here is that the concern (mixin) knows a lot about the model it gets
included in. It is what is called a &lt;strong&gt;circular dependency&lt;/strong&gt;. &lt;code&gt;Song&lt;/code&gt; and &lt;code&gt;Album&lt;/code&gt;
depend on &lt;code&gt;Trashable&lt;/code&gt; for trashing, &lt;code&gt;Trashable&lt;/code&gt; depends on both of them for
&lt;code&gt;featured_authors&lt;/code&gt; definition. The same can be said for the fact that a &lt;code&gt;trashed&lt;/code&gt; field
needs to exist in both models in order to have the &lt;code&gt;Trashable&lt;/code&gt; concern working.&lt;/p&gt;
&lt;p&gt;This is why a no-concern club might be against, and the pro-concern
club is for. I&amp;#39;d say, the &lt;em&gt;first&lt;/em&gt; version of &lt;code&gt;Trashable&lt;/code&gt; is the one I&amp;#39;d go
with in my codebase. Let&amp;#39;s see how we can make the second version with
notifying better.&lt;/p&gt;
&lt;h2 id=&quot;where-do-yall-come-from&quot;&gt;Where Do Y&amp;#39;all Come From&lt;/h2&gt;
&lt;p&gt;Looking back at our &lt;code&gt;Trashable&lt;/code&gt; with notifying, we have to do something about it.
Another thing that happens when using concerns is that we tend to over-DRY things.
Let&amp;#39;s try to do that, for demonstration purposes, to our existing models by creating
another concern (bear with me on this one):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;module Authorable
  has_many :authors

  def featured_authors
    authors.where(featured: true)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, our &lt;code&gt;Song&lt;/code&gt; and &lt;code&gt;Album&lt;/code&gt; will look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Song &amp;lt; ApplicationRecord
  include Trashable
  include Authorable

  # ...
end

class Album &amp;lt; ApplicationRecord
  include Trashable
  include Authorable

  # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We dried everything up, but now the requirement for featured authors from
Europe is not fulfilled. To make things worse, now the &lt;code&gt;Trashable&lt;/code&gt; concern and
the models depend on the &lt;code&gt;Authorable&lt;/code&gt;. What the hell? Exactly my question when
I was dealing with concerns some time ago. It&amp;#39;s hard to track down where
methods are coming from.&lt;/p&gt;
&lt;p&gt;My solution to all of this would be to keep &lt;code&gt;featured_authors&lt;/code&gt; as close to the
models as possible. The &lt;code&gt;notify&lt;/code&gt; method should &lt;strong&gt;not&lt;/strong&gt; be a part of &lt;code&gt;Trashable&lt;/code&gt;
concern at all. Each model should take care of that on its own, especially if
they tend to notify different subgroups. Let&amp;#39;s see how to do it less painfully:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;
# Concerns
module Trashable
  extend ActiveSupport::Concern

  included do
    scope :existing, -&amp;gt; { where(trashed: false) }
    scope :trashed, -&amp;gt; { where(trashed: true) }
  end

  def trash
    update_attribute :trashed, true
  end
end

module Authorable
  has_many :authors

  # Other useful methods that relate to authors across models.
  # If there are none, ditch the concern.
end

# Models
class Song &amp;lt; ApplicationRecord
  include Trashable
  include Authorable

  def featured_authors
    authors.where(featured: true).where(region: &amp;#39;Europe&amp;#39;)
  end

  # ...
end

class Album &amp;lt; ApplicationRecord
  include Trashable
  include Authorable

  def featured_authors
    authors.where(featured: true)
  end

  # ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Concerns like these are manageable and not too complex. I skipped the &lt;code&gt;notify&lt;/code&gt;
functionality I described earlier since that can be a topic for another day.&lt;/p&gt;
&lt;h1 id=&quot;the-final-boss&quot;&gt;The Final Boss&lt;/h1&gt;
&lt;p&gt;For Basecamp, the Rails creators, concerns referencing other concerns seem
perfectly fine as &lt;a href=&quot;https://twitter.com/dhh/status/964244090224128001&quot;&gt;DHH illustrated in a tweet&lt;/a&gt;
a while ago:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-09/where-do-yall-come-from.jpg&quot; alt=&quot;Final concern boss&quot;/&gt;&lt;/p&gt;
&lt;p&gt;By looking at the code screenshot, you are either opening your mouth in
awe or in appall. I feel there is no in-between here. If I got a chance to edit
this code, I would envision it as the &amp;quot;Final Concern Boss Fight&amp;quot;. But jokes
aside, the interesting thing here is that there are comments that say which concern
depends on which. Take a look at:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;  # ...

  include Subscribable # Depends on Readable
  include Eventable    # Depends on Recordables

  # ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Putting comments like these can be helpful, but it&amp;#39;s still set up for doing
something sketchy, especially if you are new to the codebase. Being new and not
being aware of all the &amp;quot;gotchas&amp;quot; a code has can certainly send you down the
concern downward spiral.&lt;/p&gt;
&lt;p&gt;Something like this is what DHH shared in a
&lt;a href=&quot;https://twitter.com/jubiweb/status/964346236588494848&quot;&gt;comment inside the discussion&lt;/a&gt;.
A response tweet inside asks how are folks who work with this codebase supposed
to interact with concerns like these. DHH responds that they don&amp;#39;t have much
written docs, they rarely hire so their team is well acquainted with these.&lt;/p&gt;
&lt;p&gt;But having an experienced team that knows the codebase well as an argument for
using them is weird and not strong. I guess it is more of a feeling whether to
use them or not. Are you more comfortable with multiple inheritances that modules
provide, or do you prefer composition? Your call.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;As we&amp;#39;ve seen, concerns are nothing more than modules that provide some useful syntax
sugar to extract and DRY up your code. If you have more useful tools under your
belt, maybe you shouldn&amp;#39;t reach out for concerns right away. Behavior like
handling file attachments and the trashing logic we showed in the examples
might be good candidates to extract into modules (concerns).&lt;/p&gt;
&lt;p&gt;Hopefully, you get to see the possible good and bad things when dealing with
concerns and modules in general. Bear in mind that no code is perfect. And in
the end, how can you learn what is good and what is bad for you if you don&amp;#39;t
try and possibly fail or succeed?&lt;/p&gt;
&lt;p&gt;No solution is perfect, and I hope you got to understand the Rails concerns way
of doing things in the blog post. As always, use your judgment and be aware of the
pros and cons.&lt;/p&gt;
&lt;p&gt;Until the next one, cheers!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Introduction to Ruby on Rails Patterns and Anti-patterns</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/08/05/introduction-to-ruby-on-rails-patterns-and-anti-patterns.html">
    <id>https://blog.appsignal.com/2020/08/05/introduction-to-ruby-on-rails-patterns-and-anti-patterns.html</id>
    <published>2020-08-05T00:00:00+00:00</published>
    <updated>2020-08-05T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Dig into the basics of design patterns and anti-patterns.</summary>
    <content type="html">&lt;p&gt;Welcome to the first post in our series about Ruby on Rails Patterns and Anti-patterns. In each of the posts, we&amp;#39;ll take a deep dive into all sorts of patterns you might come across while working with Rails apps.&lt;/p&gt;
&lt;p&gt;Today, we&amp;#39;ll show what a (design) pattern is and then try
to explain what an anti-pattern is as well. To better illustrate explanations, we will use the
Ruby on Rails framework that has been around for quite some time. If Rails isn&amp;#39;t
your cup of tea for some reason, hang on, the ideas (or patterns) described
here might resonate with whatever technology you wind up using.&lt;/p&gt;
&lt;p&gt;But before we jump into explaining what patterns and anti-patterns are, how did
we get to the point where we need them? Why do we need to have all these things
for our software? Why do we need to &lt;strong&gt;design&lt;/strong&gt; our solution?&lt;/p&gt;
&lt;h2 id=&quot;yes-you-are-a-designer&quot;&gt;Yes, You Are a Designer&lt;/h2&gt;
&lt;p&gt;Even from early computer programming days, people had to deal with the design
of the programs they were writing. To write a program (or software) is to
design a solution for a problem. When you write software, you are a designer—feel
free to append that to your job title. Designing good solutions
is important because the software we write will be read and/or edited by others.
Also, the solutions we come up with will be built on by others
in the future.&lt;/p&gt;
&lt;p&gt;Having all this in mind, generations of engineers started seeing similar
designs in code and architecture throughout their careers. Folks started
extracting and documenting standard solutions to problems. Some would say it&amp;#39;s
a natural way of how we as humans function. We like to &lt;a href=&quot;https://en.wikipedia.org/wiki/Principles_of_grouping&quot;&gt;categorize&lt;/a&gt;
and &lt;a href=&quot;https://en.wikipedia.org/wiki/Gestalt_psychology#Pr%C3%A4gnanz&quot;&gt;find patterns&lt;/a&gt;
in everything, and software is no exception to that.&lt;/p&gt;
&lt;p&gt;Being human, as we are, patterns started emerging more and more as software
engineering got more complex. Software design patterns began to develop and
cement themselves with engineers around the world. Books, essays, and talks were
given, further spreading ideas of well thought out and battle-tested solutions.
Those solutions saved a lot of people time and money, so let&amp;#39;s
go over the term design pattern, and see what it truly is.&lt;/p&gt;
&lt;h2 id=&quot;what-is-a-design-pattern&quot;&gt;What Is a Design Pattern?&lt;/h2&gt;
&lt;p&gt;In software engineering, a pattern is described as a solution that can be
reused to solve a common problem. The pattern is something that is considered a
good practice among software engineers. Since software engineers set them, they
can quickly go from patterns to their opposite—anti-patterns—but we&amp;#39;ll get
to that later.&lt;/p&gt;
&lt;p&gt;A design pattern will show you the way to the solution but it won&amp;#39;t give you a
piece of code ready to be plugged into the rest of your software. Think of a
pattern as a guide for writing well-designed code, but you have to come up
with the implementation. Using patterns in day-to-day coding emerged in
the late &amp;#39;80s, where Kent Beck and Ward Cunningham came up with an idea of
using a &lt;a href=&quot;http://c2.com/doc/oopsla87.html&quot;&gt;&amp;#39;pattern language&amp;#39;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The idea of pattern languages came in the late &amp;#39;70s by Christopher Alexander in his book
&lt;a href=&quot;https://www.goodreads.com/book/show/79766.A_Pattern_Language&quot;&gt;A Pattern Language&lt;/a&gt;.
You might be surprised, but the book is not about software engineering but the
architecture of buildings. The pattern language is an organized and coherent
set of patterns, each of which describes a problem and the core of a solution
that can be used in many ways. Sounds familiar? (Hint: frameworks, another
hint: Rails)&lt;/p&gt;
&lt;p&gt;Later on, design patterns in software engineering became famous with large audiences after
the legendary book &lt;a href=&quot;https://www.goodreads.com/book/show/85009.Design_Patterns&quot;&gt;Design Patterns&lt;/a&gt; by the
&lt;a href=&quot;http://wiki.c2.com/?GangOfFour&quot;&gt;Gang Of Four&lt;/a&gt; published in 1994. In the
book, there are explanations and definitions of patterns that are used nowadays
— Factory, Singleton, Decorator, just to name a few.&lt;/p&gt;
&lt;p&gt;Great, now that we got acquainted or refreshed our knowledge on design
and patterns, let&amp;#39;s find out what anti-patterns are.&lt;/p&gt;
&lt;h2 id=&quot;what-is-a-design-anti-pattern&quot;&gt;What Is a Design Anti-Pattern?&lt;/h2&gt;
&lt;p&gt;If you think of patterns as the good guys, the anti-patterns are the bad ones.
To be more precise, a software anti-pattern is a pattern that may be commonly
used but is considered ineffective or counterproductive. Typical examples of
anti-patterns are God objects that contain many functions and dependencies,
which could be extracted and separated into different objects.&lt;/p&gt;
&lt;p&gt;Common causes of anti-patterns in code are many. For example, a good one
is when the good guy (pattern) becomes the bad guy (an anti-pattern). Let&amp;#39;s say
you got used to using a particular technology at your previous company, and you
gained a high level of competence in it. For the sake of the example, let&amp;#39;s use Docker. You know how to efficiently pack applications into Docker
containers, orchestrate them in the cloud, and pull their logs down from the
cloud. Suddenly, you get a new job where you need to ship front end
applications. Since you know a lot about Docker and how to ship apps with it,
your first decision is to package everything up and deploy it to the cloud.&lt;/p&gt;
&lt;p&gt;But, little did you know, the front end apps are not that complex at your
current job, and putting them into containers might not be the most effective
solution. It first sounds like a good idea, but later down the road, it proves
as counterproductive. This anti-pattern is called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Law_of_the_instrument&quot;&gt;&amp;quot;Golden Hammer&amp;quot;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;It can be summed up with the saying, &amp;quot;If you have a hammer, everything looks
like a nail&amp;quot;. If you are really good with Docker and orchestration of services,
everything is a Docker service made to be orchestrated in the cloud.&lt;/p&gt;
&lt;p&gt;These things happen and will happen. Good guys turn to bad buys, and
vice-versa. But where do Ruby and Rails fit into this picture?&lt;/p&gt;
&lt;h2 id=&quot;ruby-first-then-rails&quot;&gt;Ruby First, Then Rails&lt;/h2&gt;
&lt;p&gt;Most folks were introduced to Ruby by using Ruby on Rails, a popular framework
for building websites quickly. I got acquainted with Ruby in the same way, nothing
wrong with that. Rails is based on this well-established software pattern
called Model-View-Controller, or MVC for short. But before we dive into details
of the MVC pattern in Rails, one big fallacy that often happens is using Rails
without learning Ruby properly.&lt;/p&gt;
&lt;p&gt;The Rails framework was one of the go-to frameworks when you had an idea and
wanted to build it fast. Nowadays, it&amp;#39;s a whole different story, Rails is still
used, but not to the extent it was in its prime. Being so easy to use and run, a lot
of beginners set out to build their web apps using rails new command. What
happened then, along the road, problems started occurring. As a beginner, you
are lured by the speed and simplicity of development with Rails, and everything
works so magically and smoothly at first. Then you see you&amp;#39;ve taken a lot of
&amp;#39;magic&amp;#39; for granted, and you don&amp;#39;t understand what is going on behind the
curtain.&lt;/p&gt;
&lt;p&gt;I had this problem, and I&amp;#39;m sure many beginners and advanced beginners are
suffering from it. You start with a framework in hand, you build on it, and
when you try to add something highly custom, you can&amp;#39;t, because you&amp;#39;ve used up
all the magic points from that framework. At that point, you have to go back to
the beginning and learn the basics. Going back is no biggie, happens to the
best of us. But the problem grows more significant if you move on without
learning the essential things, like in Ruby. One good book that can help you in
this regard is &lt;a href=&quot;https://www.goodreads.com/book/show/3892688-the-well-grounded-rubyist&quot;&gt;The Well-Grounded Rubyist&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As a beginner, you don&amp;#39;t have to read it from start to end. But keep it by your
side so you can consult it quickly. I am not saying that you should suddenly
stop whatever you were doing and read the whole book, but stop from time to
time and refresh your knowledge of the Ruby basics, it might open some new
horizons for you.&lt;/p&gt;
&lt;h2 id=&quot;mvc-rails-bread--butter&quot;&gt;MVC: Rails&amp;#39; Bread &amp;amp; Butter&lt;/h2&gt;
&lt;p&gt;OK, but what about MVC? The Model-View-Controller pattern has been around for
ages. It&amp;#39;s been adopted by many frameworks across a plethora of languages like
Ruby (Rails), Python (Django), Java (Play, Spring MVC). The idea is to have
separate components that each do their job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Model handles data and business logic.&lt;/li&gt;
&lt;li&gt;The View is for the presentation of the data and the user interface.&lt;/li&gt;
&lt;li&gt;The Controller ties the two together by getting data from the Model and showing the View to the user.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sounds great in theory, and it&amp;#39;s excellent when the logic is minimal and
your website doesn&amp;#39;t hold complex logic. That is where things get tricky, but
we&amp;#39;ll get to that in a second.&lt;/p&gt;
&lt;p&gt;MVC spread out like wildfire throughout the web development community. Even
libraries like React, which is insanely popular these days is explained as the
view layer of your web app. No other pattern has been popularized so much that
it cannot be shaken off. Rails added the
&lt;a href=&quot;https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern&quot;&gt;Publish-Subscribe&lt;/a&gt;
with ActionCable, where the concept of
&lt;a href=&quot;https://guides.rubyonrails.org/action_cable_overview.html#terminology&quot;&gt;channels is described as the controller&lt;/a&gt;
of the MVC pattern.&lt;/p&gt;
&lt;p&gt;But what are the anti-patterns there, in the so widely used pattern? Let&amp;#39;s go
over some of the most common anti-patterns for each part of the MVC pattern.&lt;/p&gt;
&lt;h3 id=&quot;model-problems&quot;&gt;Model Problems&lt;/h3&gt;
&lt;p&gt;As an application grows and business logic gets expanded, folks tend to
overcrowd their models. Constant growth can lead to an anti-pattern called the
Fat Model.&lt;/p&gt;
&lt;p&gt;The famous &amp;#39;Fat Model, Skinny Controller&amp;#39; pattern identifies as a bad guy, some
as the good guy. We will say that having any of the fat is an anti-pattern. To
better understand it, let&amp;#39;s get into an example. Imagine we have a streaming
service like Spotify or Deezer. Inside it, we have a model for songs like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Song &amp;lt; ApplicationRecord
  belongs_to :album
  belongs_to :artist
  belongs_to :publisher

  has_one :text
  has_many :downloads

  validates :artist_id, presence: true
  validates :publisher_id, presence: true

  after_update :alert_artist_followers
  after_update :alert_publisher

  def alert_artist_followers
    return if unreleased?

    artist.followers.each { |follower| follower.notify(self) }
  end

  def alert_publisher
    PublisherMailer.song_email(publisher, self).deliver_now
  end

  def includes_profanities?
    text.scan_for_profanities.any?
  end

  def user_downloaded?(user)
    user.library.has_song?(self)
  end

  def find_published_from_artist_with_albums
    ...
  end

  def find_published_with_albums
    ...
  end

  def to_wav
    ...
  end

  def to_mp3
    ...
  end

  def to_flac
    ...
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The problem with models like these is that they become a dumping ground for the
different logic that might be related to a song. This happens as methods get
added slowly one-by-one over time. The whole model then seems large and
complex, and splitting the logic into a couple of other places could prove
beneficial in the future.&lt;/p&gt;
&lt;p&gt;Right off the bat, you can see that there are some recommended practices that this
model is breaking. It is breaking the &lt;a href=&quot;https://en.wikipedia.org/wiki/Single-responsibility_principle&quot;&gt;Single Responsibility Principle&lt;/a&gt;
(SRP). It deals with notifying followers and the publisher. It checks the text
for profanities, has methods for exporting the song to different audio
formats, and so on. Having all this adds to the model&amp;#39;s complexity, and I
cannot even imagine the test file for this model.&lt;/p&gt;
&lt;p&gt;How to refactor this model majorly depends on how methods are called and used
in other places. I will present some general ideas of how we can handle these,
and you can choose the one that fits your case the best.&lt;/p&gt;
&lt;p&gt;The callbacks that notify followers and the publisher could be extracted to
jobs. The jobs will get enqueued and the logic kept out of the model,
like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class NotifyFollowers &amp;lt; ApplicationJob
  def perform(followers)
    followers.each { |follower| follower.notify }
  end
end

class NotifyPublisher &amp;lt; ApplicationJob
  def perform(publisher, song)
    PublisherMailer.song_email(publisher, self).deliver_now
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Jobs will run on their own in the separate process, away from the model. Now you
can test your job logic separately and just check whether the proper job was
enqueued from your model.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s say that checking for profanities and whether the user has downloaded the
song is all happening in the view part of our app. In that case, we could use a
&lt;a href=&quot;https://en.wikipedia.org/wiki/Decorator_pattern&quot;&gt;Decorator pattern&lt;/a&gt;. One popular solution
that can get you started quickly is &lt;a href=&quot;https://github.com/drapergem/draper&quot;&gt;Draper gem&lt;/a&gt;. With it,
you could write a decorator similar to this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class SongDecorator &amp;lt; Draper::Decorator
  delegate_all

  def includes_profanities?
    object.text.scan_for_profanities.any?
  end

  def user_downloaded?(user)
    object.user.library.has_song?(self)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, you would call &lt;code&gt;decorate&lt;/code&gt; in your controller, for example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;def show
  @song = Song.find(params[:id]).decorate
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And use it in your views like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;%= @song.includes_profanities? %&amp;gt;
&amp;lt;%= @song.user_downloaded?(user) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you don&amp;#39;t like using a dependency, you can roll your decorator,
but we&amp;#39;ll talk about this in another blog post. Now that you&amp;#39;ve got the
majority of your model concerns separated, let&amp;#39;s deal with the methods for
finding songs and converting a song. We can use modules to separate them:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;module SongFinders
  def find_published_from_artist_with_albums
    ...
  end

  def find_published_with_albums
    ...
  end
end

module SongConverter
  def to_wav
    ...
  end

  def to_mp3
    ...
  end

  def to_flac
    ...
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Song model will extend the &lt;code&gt;SongFinders&lt;/code&gt; module, so its methods are available
as class methods. The Song model will include the &lt;code&gt;SongConverter&lt;/code&gt; module, so its
methods are available on the model instances.&lt;/p&gt;
&lt;p&gt;All of this should make our Song model pretty slim and on point:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class Song &amp;lt; ApplicationRecord
  extend SongFinders
  include SongConverter

  belongs_to :album
  belongs_to :artist
  belongs_to :publisher

  has_one :text
  has_many :downloads

  validates :artist_id, presence: true
  validates :publisher_id, presence: true

  after_update :alert_artist_followers, if: :published?
  after_update :alert_publisher

  def alert_artist_followers
    NotifyFollowers.perform_later(self)
  end

  def alert_publisher
    NotifyPublisher.perform_later(publisher, self)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are many more model anti-patterns, and this is just one example of what
can go south with models. Stay tuned for another blog post in this series,
where we&amp;#39;ll go into details about more model anti-patterns. For now,
let&amp;#39;s see what can go wrong with views.&lt;/p&gt;
&lt;h2 id=&quot;view-problems&quot;&gt;View Problems&lt;/h2&gt;
&lt;p&gt;Besides model problems, Rails folks can sometimes struggle with the complexity of their views.
Back in the day, HTML and CSS were the kings of the view part of web
applications. Slowly over time, JavaScript came to reign, and almost all
aspects of the front end were written in JavaScript. Rails follows a bit
different paradigm regarding this. Instead of having everything in JavaScript
in view, you should only &amp;quot;sprinkle&amp;quot; JS onto it.&lt;/p&gt;
&lt;p&gt;In any case, having to deal
with HTML, CSS, JS, and Ruby at the same place can get messy. What&amp;#39;s tricky
with building Rails views is that the domain logic can sometimes be found
inside the view. This is a no-no since it breaks the MVC pattern, for a start.&lt;/p&gt;
&lt;p&gt;Another case could be using too much embedded Ruby in your views and partials.
Maybe some of the logic could go inside a helper or a decorator (also known as
the view model or a presenter). We will get into the examples of it in some
of the next posts in the series, so stay tuned.&lt;/p&gt;
&lt;h2 id=&quot;controller-problems&quot;&gt;Controller Problems&lt;/h2&gt;
&lt;p&gt;Rails controllers can also suffer from a variety of different problems. One of
them is a Fat Controller anti-pattern.&lt;/p&gt;
&lt;p&gt;Before, our model was fat, but it lost some weight, and now we notice that the
controller has added some extra weight in the process. Usually, this happens
when the business logic is put inside the Controller, but its actual place is
in the model or elsewhere. Some of the ideas shared in the large Model section
can still apply to the controller — extracting code to presenters, using
ActiveRecord callbacks, resorting to
&lt;a href=&quot;/2020/06/17/using-service-objects-in-ruby-on-rails.html&quot;&gt;Service objects&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Some folks even resort to using gems like
&lt;a href=&quot;https://github.com/trailblazer/trailblazer&quot;&gt;Trailblazer&lt;/a&gt; or
&lt;a href=&quot;https://dry-rb.org/gems/dry-transaction/&quot;&gt;dry-transaction&lt;/a&gt;.
The idea here is to create classes that deal with specific transactions. Moving
everything out of the controller and keeping the model skinny, you store and
test logic inside these separate classes, which some call services,
transactions, actions, and similar.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;There are many more anti-patterns and even more solutions for them. To try to
cover everything in this post will take too much space and time and it
will make our post look fat (like the model and controller we talked
about). Be sure to follow our series, where we&amp;#39;ll deep dive into every
aspect of the MVC pattern in Rails. There, you&amp;#39;ll find out how to deal with
the most famous anti-patterns. Until then, I hope you enjoyed this overview of
what patterns and anti-patterns are and the most common ones in the Ruby on Rails
framework.&lt;/p&gt;
&lt;p&gt;Until the next one, cheers!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Scaling Queue Workers Efficiently with AppSignal Metrics</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/07/08/scaling-queue-workers-efficiently-with-appsignal-metrics.html">
    <id>https://blog.appsignal.com/2020/07/08/scaling-queue-workers-efficiently-with-appsignal-metrics.html</id>
    <published>2020-07-08T00:00:00+00:00</published>
    <updated>2020-07-08T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's use some simple math and performance data to find our optimal worker count, based on the work waiting in the queue.</summary>
    <content type="html">&lt;p&gt;Most web apps can benefit from a background queue, often used to process error-prone or time-consuming side jobs.
These background jobs can vary from sending emails, to updating caches, to performing core business logic.&lt;/p&gt;
&lt;p&gt;As any background queueing system scales the number of jobs it needs to process, the pool of workers processing those jobs needs to scale as well.
In cases where the rate of jobs being enqueued varies, scaling the number of queue workers up becomes a key aspect in maintaining processing speed.
Additionally, scaling down workers during low queue throughput can provide significant savings!&lt;/p&gt;
&lt;p&gt;Unfortunately, many queueing backends don&amp;#39;t come equipped with scaling logic to turn workers on or off.
But we can use some simple math and performance data to find our optimal worker count based on the work waiting in the queue.&lt;/p&gt;
&lt;h2 id=&quot;queueing-rule-of-thumb&quot;&gt;Queueing Rule of Thumb&lt;/h2&gt;
&lt;p&gt;If jobs are enqueued at a higher rate than they are processed by the queue workers, the depth of the queue will grow and the time that each job spends in the queue will also grow.
Generally, we want the wait time (amount of time in the queue) for each job to be as low as possible — from 0 seconds up to some acceptable limit.
To estimate the number of workers required to satisfy a desired wait time, we can use the &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Queuing_Rule_of_Thumb&quot;&gt;Queueing Rule of Thumb&lt;/a&gt; (QROT).
Usually, the QROT is expressed as an inequality describing the number of servers required to service a queue of jobs, but one form can be written as:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;workers = (number_of_jobs * avg_service_time_per_job) / time_to_finish_queue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, if we want to figure out the number of workers required to service our queue in a desired time of, say, 30 seconds, we just need to know the number of jobs (size of the queue) and the average time it takes to execute each job.
For example, if we have a queue of 7500 jobs and each job takes an average of 0.3 seconds to execute, then we can finish that queue in 30 seconds with 75 workers.&lt;/p&gt;
&lt;h2 id=&quot;accessing-performance-metrics&quot;&gt;Accessing Performance Metrics&lt;/h2&gt;
&lt;p&gt;In order to estimate the average service time for jobs in the queue, we need access to performance metrics for each job class.
Luckily, &lt;a href=&quot;https://appsignal.com&quot;&gt;AppSignal&lt;/a&gt; records the performance data for common queueing backends out-of-the-box, recording metrics for each time a job has been executed.&lt;/p&gt;
&lt;p&gt;We can use the upcoming AppSignal GraphQL API to get the average duration of each job type over the last 24 hours.
This API is not fully public yet, though it is currently used for AppSignal&amp;#39;s &lt;a href=&quot;https://appsignal.com/redirect-to/app?to=performance/graphs&quot;&gt;Performance graphs&lt;/a&gt; and other data displays.
Luckily, &lt;a href=&quot;https://graphql.org&quot;&gt;GraphQL&lt;/a&gt; APIs are intended to be self-documenting, and we can use a tool like &lt;a href=&quot;https://github.com/graphql/graphiql&quot;&gt;GraphiQL&lt;/a&gt; to introspect the API and find out what data objects it exposes.&lt;/p&gt;
&lt;p&gt;The process of building a GraphQL query is outside the scope of this post, but below is an example Ruby class that connects to the AppSignal GraphQL API using the popular &lt;a href=&quot;https://lostisland.github.io/faraday/&quot;&gt;Faraday&lt;/a&gt; HTTP client library to query for a basic metrics aggregation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;require &amp;#39;json&amp;#39;
require &amp;#39;faraday&amp;#39;

class AppsignalClient
  BASE_URL = &amp;#39;https://appsignal.com/&amp;#39;
  DEFAULT_APP_ID = ENV[&amp;#39;APPSIGNAL_APP_ID&amp;#39;]
  DEFAULT_TOKEN = ENV[&amp;#39;APPSIGNAL_API_TOKEN&amp;#39;]
  # GraphQL query to fetch the &amp;quot;mean&amp;quot; metric for the selected app.
  METRICS_QUERY = &amp;lt;&amp;lt;~GRAPHQL.freeze
    query($appId: String!, $query: [MetricAggregation!]!, $timeframe: TimeframeEnum!) {
      app(id: $appId) {
        metrics {
          list(timeframe: $timeframe, query: $query) {
            start
            end
            rows {
              fields {
                key
                value
              }
            }
          }
        }
      }
    }
  GRAPHQL

  def initialize(app_id: DEFAULT_APP_ID, client_secret: DEFAULT_TOKEN)
    @app_id = app_id
    @client_secret = client_secret
  end

  # Fetch the average duration for a job class&amp;#39;s perform action
  # Default timeframe is last 24 hours
  def average_job_duration(job_class, timeframe: &amp;#39;R24H&amp;#39;)
    response =
      connection.post(
        &amp;#39;graphql&amp;#39;,
        JSON.dump(
          query: METRICS_QUERY,
          variables: {
            appId: @app_id,
            timeframe: timeframe,
            query: [
              name: &amp;#39;transaction_duration&amp;#39;,
              headerType: legacy
tags: [
                { key: &amp;#39;namespace&amp;#39;, value: &amp;#39;background&amp;#39; },
                { key: &amp;#39;action&amp;#39;, value: &amp;quot;#{job_class.name}#perform&amp;quot; },
              ],
              fields: [{ field: &amp;#39;MEAN&amp;#39;, aggregate: &amp;#39;AVG&amp;#39; }],
            ],
          }
        )
      )
    data = JSON.parse(response.body, symbolize_names: true)
    rows = data.dig(:data, :app, :metrics, :list, :rows)
    # There may be no metrics in the selected timeframe
    return 0.0 if rows.empty?

    rows.first[:fields].first[:value]
  end

  private

  def connection
    @connection ||= Faraday.new(
      url: BASE_URL,
      params: { token: @client_secret },
      headers: { &amp;#39;Content-Type&amp;#39; =&amp;gt; &amp;#39;application/json&amp;#39; },
      request: { timeout: 10 }
    ) do |faraday|
      faraday.response :raise_error
      faraday.adapter Faraday.default_adapter
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this class, we can get an average job duration for a given ActiveJob class, returned to us in milliseconds:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;AppsignalClient.new.average_job_duration(MyMailerJob)
# =&amp;gt; 233.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, this calls for the average transaction duration of the job over the last 24 hours of data.
If our job(s) are executed much more frequently than that, we may want to shorten that window, weighing recent executions more heavily in our average.
For example, if we have jobs that run hundreds of times an hour, we may want to change our &lt;code&gt;timeframe&lt;/code&gt; to one hour (&lt;code&gt;R1H&lt;/code&gt;) to better estimate the duration of one such job if executed right now.&lt;/p&gt;
&lt;p&gt;Note that this performance data is separate from our server utilization data.
This data tells us how long it&amp;#39;ll actually take to do the work required for each job.
This will be more useful to us in scaling our workers than external measurements like utilization metrics.&lt;/p&gt;
&lt;h2 id=&quot;introspecting-the-queue&quot;&gt;Introspecting the Queue&lt;/h2&gt;
&lt;p&gt;Next, we need to introspect our queue to determine the jobs to be serviced.
A common Ruby queueing backend is &lt;a href=&quot;https://github.com/resque/resque&quot;&gt;Resque&lt;/a&gt;, which also integrates nicely with ActiveJob.
We can access the enqueued jobs for a given queue in Resque and then estimate the execution time for each job based on its class, using our &lt;code&gt;AppsignalClient&lt;/code&gt; class from above.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;require &amp;#39;resque&amp;#39;

class ResqueEstimator
  def initialize(queue: &amp;#39;default&amp;#39;)
    @queue = queue
    @cache = {}
    @appsignal_client = AppsignalClient.new
  end

  def enqueued_duration_estimate
    Resque.data_store.everything_in_queue(queue).map do |job|
      estimate_job_duration decode_activejob_args(job)
    end.sum
  end

  def estimate_job_duration(job)
    @cache[job[&amp;#39;job_class&amp;#39;]] ||= @appsignal_client
                                 .average_job_duration job[&amp;#39;job_class&amp;#39;]
  end

  private

  # ActiveJob-specific method for parsing job arguments
  # for ActiveJob+Resque integration
  def decode_activejob_args(job)
    decoded_job = job
    decoded_job = Resque.decode(job) if job.is_a? String
    decoded_job[&amp;#39;args&amp;#39;].first
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this class is as simple as:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;ResqueEstimator.new(queue: &amp;#39;my_queue&amp;#39;).enqueued_duration_estimate
# =&amp;gt; 23000 (ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we use a simple memoization of the job durations in our &lt;code&gt;estimate_job_duration&lt;/code&gt; method to avoid duplicate calls to the AppSignal API.
Most likely, our queue will contain many jobs of the same class and we can reduce our overhead by only estimating the execution of each class once.&lt;/p&gt;
&lt;h2 id=&quot;using-performance-data-to-scale&quot;&gt;Using Performance Data to Scale&lt;/h2&gt;
&lt;p&gt;Pulling all this together, we can now use our recent performance data to scale our queue workers up or down based on the content of our queue!
At any moment, we can look at the jobs in our queue and get an estimate of the workers required to service it in our desired time limit.&lt;/p&gt;
&lt;p&gt;We will need to decide on a desired queueing time limit (the maximum amount of time any job should wait in the queue), e.g. 30 seconds.
We will also need to specify a minimum and maximum worker count.
It&amp;#39;s helpful to keep at least one worker running for the queue, to handle the first job(s) enqueued after the queue has been empty for a while.
We will also want a maximum worker count, to avoid over-scaling our database connections and/or server utilization costs with too many workers.&lt;/p&gt;
&lt;p&gt;We can make a class to handle this logic for us, which is basically just our implementation of the Queueing Rule of Thumb from before.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class ResqueWorkerScaler
  def initialize(queue: &amp;#39;default&amp;#39;, workers_range: 1..100, desired_wait_ms: 300_000)
    @queue = queue
    @workers_range = workers_range
    @desired_wait_ms = desired_wait_ms
    @estimator = ResqueEstimator.new(queue: @queue)
  end

  def desired_workers
    total_time_ms = @estimator.enqueued_duration_estimate
    workers_required = [(total_time_ms / desired_wait_ms).ceil, workers_range.last].min
    [workers_required, workers_range.first].max
  end

  def scale
    # using platform-specific scaling interface, scale to desired_workers
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We will want to scale our workers on a regular interval so that we are scaling up and down based on demand. We can make a Rake task that calls our &lt;code&gt;ResqueWorkerScaler&lt;/code&gt; class to scale workers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;# inside lib/tasks/resque_workers.rake

namespace :resque_workers do
  desc &amp;#39;Scale worker pool based on enqueued jobs&amp;#39;
  task :scale, [:queue] =&amp;gt; [:environment] do |_t, args|
    queue = args[:queue] || &amp;#39;default&amp;#39;
    ResqueWorkerScaler.new(queue: queue).scale
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then we can set up a cron job to run this Rake task on a regular interval:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*/5 * * * * /path/to/our/rake resque_workers:scale
# scale a non-default queue:
*/5 * * * * /path/to/our/rake resque_workers:scale[&amp;#39;my_queue&amp;#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that we set the scaling task to run every 5 minutes.
Each new worker will take some amount of time to come online and begin processing jobs — likely anywhere from 10-40 seconds, depending on the size of our codebase and the number of gems we use.
So, if we try to scale our workers every minute, we will likely be scaling up or down again before our desired changes have taken effect.
If our app is only seeing queue usage fluctuate at different times of the day, we can likely call our Rake task at an hourly interval.
But if our queue size fluctuates within the hour, we will want to introspect our queue at a more frequent interval, like the 5 minutes above.&lt;/p&gt;
&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;Such a system where actual performance data is used to scale infrastructure can be very responsive to demand and resilient to varied usage.
Especially in an environment like background processing, where host metrics like memory usage and load average are unlikely to vary, using performance metrics to scale is much more appropriate.&lt;/p&gt;
&lt;p&gt;Alternate queue scaling implementations could measure the mean wait time per job instead of introspecting the full queue, but that metric can be unrepresentative when the queue contents and size change rapidly.
If our system experiences widely variable load, with lots of jobs enqueueing at once, or widely variable job execution times, then queue introspection is much faster to respond and reliably correct.&lt;/p&gt;
&lt;p&gt;But there are some limitations to consider in our queue introspection system.
If the queue is sufficiently large, looking at each job for an execution estimate will be prohibitively slow.
In such cases, it can be better to find the total job count, then select a random representative sampling of jobs from the queue and calculate the average execution from that sample.
Alternatively, if a job class has no performance data associated with it yet, we will need to use an assumed execution time until it has been executed and recorded a few times.&lt;/p&gt;
&lt;p&gt;The system outlined above can also be improved significantly with a few tweaks.
Consider estimating the execution time for each job class in parallel, as each estimation is isolated and idempotent.
We can also update our queue introspection to include those jobs currently being executed by a worker to improve the accuracy of our total service time estimate.
For a background processing architecture with multiple queues, we can assign each queue a desired wait time, based on queue priority, and scale workers appropriately.&lt;/p&gt;
&lt;p&gt;Queueing systems tend to collect a lot of the highly variable work in any project.
With performance data on the execution of the jobs from the queue, we can effectively scale resources to service all that work in a responsive, efficient manner.&lt;/p&gt;
&lt;p&gt;Happy scaling!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Using Service Objects in Ruby on Rails</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/06/17/using-service-objects-in-ruby-on-rails.html">
    <id>https://blog.appsignal.com/2020/06/17/using-service-objects-in-ruby-on-rails.html</id>
    <published>2020-06-17T00:00:00+00:00</published>
    <updated>2020-06-17T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Find out what service objects are and why you should use them.</summary>
    <content type="html">&lt;blockquote&gt;
&lt;p&gt;This article has been modified from its original appearance in &lt;a href=&quot;https://playbookthirtynine.com/?utm_source=appsignal&amp;amp;utm_medium=cpc&amp;amp;utm_campaign=article&amp;amp;utm_content=service-objects&quot;&gt;Playbook Thirty-nine&lt;/a&gt; - &lt;em&gt;A Guide to Shipping Interactive Web Apps with Minimal Tooling&lt;/em&gt;, and tailored to fit this guest post for AppSignal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There’s a lot of functionality that your app needs to handle, but that logic doesn’t necessarily belong in the controller or even the model. Some examples include checking out with a cart, registering for the site, or starting a subscription.&lt;/p&gt;
&lt;p&gt;You could include all this logic in the controller, but you’ll keep repeating yourself, calling the same logic in all those places. You could put the logic in a model, but sometimes, you need access to things that are easily available in the controller, like an IP address, or a parameter in a URL. What you need is a service object.&lt;/p&gt;
&lt;p&gt;The job of a service object is to encapsulate functionality, execute one service, and provide a single point of failure. Using service objects also prevents developers from having to write the same code over and over again when it’s used in different parts of the application.&lt;/p&gt;
&lt;p&gt;A service object is just a Plain Old Ruby Object (&amp;quot;PORO&amp;quot;). It’s just a file that lives under a specific directory. It’s a Ruby class that returns a predictable response. What makes the response predicable is due to three key parts. All service objects should follow the same pattern.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Has an initialization method with a params argument.&lt;/li&gt;
&lt;li&gt;Has a single public method named call.&lt;/li&gt;
&lt;li&gt;Returns an OpenStruct with a success? and either a payload or an error.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;whats-an-openstruct&quot;&gt;What’s an OpenStruct?&lt;/h2&gt;
&lt;p&gt;It’s like the brainchild of a class and a hash. You can think of it as a mini-class that can receive arbitrary attributes. In our case, we’re using it as a sort of temporary data structure that handles just two attributes.&lt;/p&gt;
&lt;p&gt;If the success is &lt;code&gt;true&lt;/code&gt;, it returns a payload of data.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OpenStruct.new({success ?:true, payload: &amp;#39;some-data&amp;#39;})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If the success is &lt;code&gt;false&lt;/code&gt;, it returns an error.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OpenStruct.new({success ?:false, error: &amp;#39;some-error&amp;#39;})&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Here’s an example of a service object that reaches out and grabs data from AppSignals new &lt;a href=&quot;https://docs.appsignal.com/api/&quot;&gt;API&lt;/a&gt;, which is currently in beta.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module AppServices

  class AppSignalApiService

    require &amp;#39;httparty&amp;#39;

    def initialize(params)
      @endpoint   = params[:endpoint] || &amp;#39;markers&amp;#39;
    end

    def call
      result = HTTParty.get(&amp;quot;https://appsignal.com/api/#{appsignal_app_id}/#{@endpoint}.json?token=#{appsignal_api_key}&amp;quot;)
    rescue HTTParty::Error =&amp;gt; e
      OpenStruct.new({success?: false, error: e})
    else
      OpenStruct.new({success?: true, payload: result})
    end

    private

      def appsignal_app_id
        ENV[&amp;#39;APPSIGNAL_APP_ID&amp;#39;]
      end

      def appsignal_api_key
        ENV[&amp;#39;APPSIGNAL_API_KEY&amp;#39;]
      end

  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You would call the file above with &lt;code&gt;AppServices::AppSignalApiService.new({endpoint: &amp;#39;markers&amp;#39;}).call&lt;/code&gt;. I make liberal use of OpenStruct to return a predictable response. This is really valuable when it comes to writing tests because all of the logic’s architectural patterns are identical.&lt;/p&gt;
&lt;h2 id=&quot;whats-a-module&quot;&gt;What&amp;#39;s a Module?&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-06/module_screenshot.png&quot; alt=&quot;A screenshot of the file directory holding our service objects&quot;/&gt; Using modules provide us with name-spacing and prevents colliding with other classes. This means you can use the same method names in all the classes and they won’t clash because they’re under a specific namespace.&lt;/p&gt;
&lt;p&gt;Another key part of the module name is how files are organized in our app. Service objects are kept in a services folder in the project. The service object example above, with the module name of &lt;code&gt;AppServices&lt;/code&gt;, falls into the &lt;code&gt;AppServices&lt;/code&gt; folder in the services directory.&lt;/p&gt;
&lt;p&gt;I organize my service directory into multiple folders, each containing functionality for a specific part of the application.&lt;/p&gt;
&lt;p&gt;For example, the &lt;code&gt;CloudflareServices&lt;/code&gt; directory holds specific service objects for creating and removing subdomains on Cloudflare. The Wistia and Zapier services hold their respective service files.&lt;/p&gt;
&lt;p&gt;Organizing your service objects like this yields better predictability when it comes down to implementation, and it’s easy to see at a glance what the app is doing from a 10k-foot view.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2020-06/services_screenshot.png&quot; alt=&quot;A screenshot of the file directory holding our service objects&quot;/&gt; Let’s dig into the &lt;code&gt;StripeServices&lt;/code&gt; directory. This directory holds individual service objects for interacting with Stripes API. Again, the only thing these files do is take data from our application and send it to Stripe. If you ever need to update the API call in the &lt;code&gt;StripeService&lt;/code&gt; object that creates a subscription, you only have one place to do that.&lt;/p&gt;
&lt;p&gt;All of the logic that collects the data to be sent is done in a separate service object, living in the &lt;code&gt;AppServices&lt;/code&gt; directory. These files gather data from our application and send it off to the corresponding service directory for interfacing with the external API.&lt;/p&gt;
&lt;p&gt;Here’s a visual example: let’s assume that we have someone who is starting a new subscription. Everything originates from a controller. Here’s the &lt;code&gt;SubscriptionsController&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class SubscriptionsController &amp;lt; ApplicationController

  def create
    @subscription = Subscription.new(subscription_params)

    if @subscription.save

      result = AppServices::SubscriptionService.new({
        subscription_params: {
          subscription: @subscription,
          coupon: params[:coupon],
          token: params[:stripeToken]
        }
      }).call

      if result &amp;amp;&amp;amp; result.success?
        sign_in @subscription.user
        redirect_to subscribe_welcome_path, success: &amp;#39;Subscription was successfully created.&amp;#39;
      else
        @subscription.destroy
        redirect_to subscribe_path, danger: &amp;quot;Subscription was created, but there was a problem with the vendor.&amp;quot;
      end

    else
      redirect_to subscribe_path, danger:&amp;quot;Error creating subscription.&amp;quot;
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll first create the subscription in-app, and if it’s successful, we send that, the stripeToken, and stuff like the coupon into a file called &lt;code&gt;AppServices::SubscriptionService&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In the &lt;code&gt;AppServices::SubscriptionService&lt;/code&gt; file, there are several things that need to happen. Here’s that object, before we get into what’s happening:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module AppServices
  class SubscriptionService

    def initialize(params)
      @subscription     = params[:subscription_params][:subscription]
      @token            = params[:subscription_params][:token]
      @plan             = @subscription.subscription_plan
      @user             = @subscription.user
    end

    def call

      # create or find customer
      customer ||= AppServices::StripeCustomerService.new({customer_params: {customer:@user, token:@token}}).call

      if customer &amp;amp;&amp;amp; customer.success?

        subscription ||= StripeServices::CreateSubscription.new({subscription_params:{
          customer: customer.payload,
          items:[subscription_items],
          expand: [&amp;#39;latest_invoice.payment_intent&amp;#39;]
        }}).call

        if subscription &amp;amp;&amp;amp; subscription.success?
          @subscription.update_attributes(
            status: &amp;#39;active&amp;#39;,
            stripe_id: subscription.payload.id,
            expiration: Time.at(subscription.payload.current_period_end).to_datetime
          )
          OpenStruct.new({success?: true, payload: subscription.payload})
        else
          handle_error(subscription&amp;amp;.error)
        end

      else
        handle_error(customer&amp;amp;.error)
      end

    end

    private

      attr_reader :plan

      def subscription_items
        base_plan
      end

      def base_plan
        [{ plan: plan.stripe_id }]
      end

      def handle_error(error)
        OpenStruct.new({success?: false, error: error})
      end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;From a high-level overview, here’s what we’re looking at:&lt;/p&gt;
&lt;p&gt;We have to first get the Stripe customer ID so that we can send it to Stripe to create the subscription. That in itself is an entirely separate service object that does a number of things to make this happen.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We check to see if the &lt;code&gt;stripe_customer_id&lt;/code&gt; is saved on the user&amp;#39;s profile. If it is, we retrieve the customer from Stripe just to ensure that the customer actually exists, then return it in the payload of our OpenStruct.&lt;/li&gt;
&lt;li&gt;If the customer does not exist, we create the customer, save the stripe_customer_id, then return it in the payload of the OpenStruct.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Either way, our &lt;code&gt;CustomerService&lt;/code&gt; returns the Stripe customer ID, and it’ll do what’s necessary to make that happen. Here’s that file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module AppServices
  class CustomerService

    def initialize(params)
      @user               = params[:customer_params][:customer]
      @token              = params[:customer_params][:token]
      @account            = @user.account
    end

    def call
      if @account.stripe_customer_id.present?
        OpenStruct.new({success?: true, payload: @account.stripe_customer_id})
      else
        if find_by_email.success? &amp;amp;&amp;amp; find_by_email.payload
          OpenStruct.new({success?: true, payload: @account.stripe_customer_id})
        else
          create_customer
        end
      end
    end

    private

      attr_reader :user, :token, :account

      def find_by_email
        result ||= StripeServices::RetrieveCustomerByEmail.new({email: user.email}).call
        handle_result(result)
      end

      def create_customer
        result ||= StripeServices::CreateCustomer.new({customer_params:{email:user.email, source: token}}).call
        handle_result(result)
      end

      def handle_result(result)
        if result.success?
          account.update_column(:stripe_customer_id, result.payload.id)
          OpenStruct.new({success?: true, payload: account.stripe_customer_id})
        else
          OpenStruct.new({success?: false, error: result&amp;amp;.error})
        end
      end

  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Hopefully, you can begin to see why we structure our logic across multiple service objects. Could you imagine one giant behemoth of a file with all of this logic? No way!&lt;/p&gt;
&lt;p&gt;Back to our &lt;code&gt;AppServices::SubscriptionService&lt;/code&gt; file. We now have a customer that we can send to Stripe, which completes the data that we need in order to create the subscription on Stripe.&lt;/p&gt;
&lt;p&gt;We’re now ready to call the last service object, the &lt;code&gt;StripeServices::CreateSubscription&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;Again, &lt;code&gt;StripeServices::CreateSubscription&lt;/code&gt; service object never changes. It has a single responsibility, and that is to take data, send it to Stripe, and either return a success or return the object as a payload.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module StripeServices

  class CreateSubscription

    def initialize(params)
      @subscription_params = params[:subscription_params]
    end

    def call
      subscription = Stripe::Subscription.create(@subscription_params)
    rescue Stripe::StripeError =&amp;gt; e
      OpenStruct.new({success?: false, error: e})
    else
      OpenStruct.new({success?: true, payload: subscription})
    end

  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pretty simple right? But you’re probably thinking, this small file is overkill. Let’s look at another example of a similar file to the one above, but this time we’ve augmented it for use with a multi-tenant application via Stripe Connect.&lt;/p&gt;
&lt;p&gt;Here’s where things get interesting. We’re using &lt;a href=&quot;https://mavenseed.com&quot;&gt;Mavenseed&lt;/a&gt; as an example here, although this same logic runs on &lt;a href=&quot;https://sport-keeper.com&quot;&gt;SportKeeper&lt;/a&gt; as well. Our multi-tenant app is a single monolith, sharing tables, separated by a site_id column. Each tenant connects to Stripe via Stripe Connect, and we then get a Stripe Account ID to save on the tenant&amp;#39;s account.&lt;/p&gt;
&lt;p&gt;Using our same Stripe API calls, we can simply pass the Stripe Account of the connected account, and Stripe will perform the API call on behalf of the connected account.&lt;/p&gt;
&lt;p&gt;So in a way, our &lt;code&gt;StripeService&lt;/code&gt; object is performing double-duty, along with both the main application and the tenants, to call the same file, but send in different data.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module StripeServices

  class CreateSubscription

    def initialize(params)
      @subscription_params  = params[:subscription_params]
      @stripe_account       = params[:stripe_account]
      @stripe_secret_key    = params[:stripe_secret_key] ? params[:stripe_secret_key] : (Rails.env.production? ? ENV[&amp;#39;STRIPE_LIVE_SECRET_KEY&amp;#39;] : ENV[&amp;#39;STRIPE_TEST_SECRET_KEY&amp;#39;])
    end

    def call
      subscription = Stripe::Subscription.create(@subscription_params, account_params)
    rescue Stripe::StripeError =&amp;gt; e
      OpenStruct.new({success?: false, error: e})
    else
      OpenStruct.new({success?: true, payload: subscription})
    end

    private

      attr_reader :stripe_account, :stripe_secret_key

      def account_params
        {
          api_key: stripe_secret_key,
          stripe_account: stripe_account,
          stripe_version: ENV[&amp;#39;STRIPE_API_VERSION&amp;#39;]
        }
      end
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A few technical notes on this file: I could have shared a simpler example, but I really think it’s valuable for you to see how a proper service object is structured, including its responses.&lt;/p&gt;
&lt;p&gt;First, the “call” method has a rescue and else statement. This is the same as writing the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def call
   begin
   rescue Stripe ::StripeError  =&amp;gt; e
   else
   end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But Ruby methods automatically begin a block implicitly, so there’s no reason to add the begin and end. This statement reads as, “create the subscription, return an error if there is one, otherwise return the subscription.”&lt;/p&gt;
&lt;p&gt;Simple, succinct, and elegant. Ruby is truly a beautiful language and the use of service objects really highlights this.&lt;/p&gt;
&lt;p&gt;I hope that you can see the value that service files play in our applications. They provide a very succinct way of organizing our logic that is not only predictable but easily maintainable!&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;——&lt;/p&gt;
&lt;p&gt;Read this chapter and more by picking up my new book &lt;a href=&quot;https://playbookthirtynine.com/?utm_source=appsignal&amp;amp;utm_medium=cpc&amp;amp;utm_campaign=article&amp;amp;utm_content=service-objects&quot;&gt;Playbook Thirty-nine&lt;/a&gt; - &lt;em&gt;A Guide to Shipping Interactive Web Apps with Minimal Tooling&lt;/em&gt;. In this book, I take a top-down approach in covering common patterns and techniques, based solely on my first-hand experience as a solo-developer building and maintaining multiple high-traffic, high-revenue website applications.&lt;/p&gt;
&lt;p&gt;Use the coupon code &lt;em&gt;appsignalrocks&lt;/em&gt; and save 30%!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Dissecting Rails Migrations</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/04/14/dissecting-rails-migrationsl.html">
    <id>https://blog.appsignal.com/2020/04/14/dissecting-rails-migrationsl.html</id>
    <published>2020-04-14T00:00:00+00:00</published>
    <updated>2020-04-14T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Let's break down a migration process and find out how to write an effective migration.</summary>
    <content type="html">&lt;p&gt;In today&amp;#39;s post, we&amp;#39;ll take a deep dive into Rails migrations. We&amp;#39;ll break down the migration into different
pieces, and in the process, learn how to write an effective migration. We&amp;#39;ll learn how to write migrations
for multiple databases, as well as how to handle failed migrations and techniques of performing rollbacks.&lt;/p&gt;
&lt;p&gt;To understand the whole post, you&amp;#39;ll need to have a basic understanding of databases and Rails.&lt;/p&gt;
&lt;h2 id=&quot;migrations-101&quot;&gt;Migrations 101&lt;/h2&gt;
&lt;p&gt;Migrations in Rails allow us to evolve the database over the lifetime of an application. Migrations allow us to write plain Ruby code to alter the state of the database by providing an elegant DSL. We don&amp;#39;t have to write database-specific SQL since migrations provide abstractions to manipulate the database and take care of
nitty-gritty details of converting the DSL into database-specific SQL queries behind the scene. Migrations also get out of our way and provide ways of executing raw SQL on the database, if such need arises.&lt;/p&gt;
&lt;h2 id=&quot;twenty-thousand-leagues-into-a-rails-database-migration&quot;&gt;Twenty Thousand Leagues Into a Rails Database Migration&lt;/h2&gt;
&lt;p&gt;We can create tables, add or remove columns and add indexes on columns using the migrations.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Every Rails app has a special directory—&lt;code&gt;db/migrate&lt;/code&gt;—where all migrations are stored.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Let&amp;#39;s start with a migration that creates the table &lt;code&gt;events&lt;/code&gt; into our database.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ rails g migration CreateEvents category:string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command generates a timestamped file &lt;code&gt;20200405103635_create_events.rb&lt;/code&gt; in the &lt;code&gt;db/migrate&lt;/code&gt; directory. The contents of the file are as follows.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class CreateEvents &amp;lt; ActiveRecord::Migration[6.0]
  def change
    create_table :events do |t|
      t.string :category

      t.timestamps
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;#39;s break down this migration file.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Every migration file that Rails generates has a timestamp that is present in the filename. This timestamp is important and is used by Rails to confirm whether a migration has run or not, as we&amp;#39;ll see later.&lt;/li&gt;
&lt;li&gt;The migration contains a class that inherits from &lt;code&gt;ActiveRecord::Migration[6.0]&lt;/code&gt;. As I&amp;#39;m using Rails 6, the migration superclass has &lt;code&gt;[6.0]&lt;/code&gt;. If I was using Rails 5.2, then the superclass would be &lt;code&gt;ActiveRecord::Migration[5.2]&lt;/code&gt;. Later, we&amp;#39;ll discuss why the Rails version is part of the superclass name.&lt;/li&gt;
&lt;li&gt;The migration has a method &lt;code&gt;change&lt;/code&gt; which contains the DSL code that manipulates the database. In this case, the &lt;code&gt;change&lt;/code&gt; method is creating an &lt;code&gt;events&lt;/code&gt; table with a column &lt;code&gt;category&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The migration uses the code &lt;code&gt;t.timestamps&lt;/code&gt; to add timestamps &lt;code&gt;created_at&lt;/code&gt; and &lt;code&gt;updated_at&lt;/code&gt; to the &lt;code&gt;events&lt;/code&gt; table.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When this migration is run using the &lt;code&gt;rails db:migrate&lt;/code&gt; command, it will create an &lt;code&gt;events&lt;/code&gt; table with a &lt;code&gt;category&lt;/code&gt; column of type &lt;code&gt;string&lt;/code&gt; and timestamp columns &lt;code&gt;created_at&lt;/code&gt; and &lt;code&gt;updated_at&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The actual database column type will be varchar or text, depending on the database.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;importance-of-migration-timestamps-and-the-schema_migration-table&quot;&gt;Importance of Migration Timestamps and the schema_migration Table&lt;/h3&gt;
&lt;p&gt;Every time a migration is generated using the &lt;code&gt;rails g migration&lt;/code&gt; command, Rails generates
the migration file with a unique timestamp. The timestamp is in the
format &lt;code&gt;YYYYMMDDHHMMSS&lt;/code&gt;.
Whenever a migration is run, Rails inserts the migration timestamp into an internal table &lt;code&gt;schema_migrations&lt;/code&gt;. This table is created by Rails when we run our first migration. The table only has the column &lt;code&gt;version&lt;/code&gt;, which is also its primary key. This is the structure of the &lt;code&gt;schema_migrations&lt;/code&gt; table.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE IF NOT EXISTS &amp;quot;schema_migrations&amp;quot; (&amp;quot;version&amp;quot; varchar NOT NULL PRIMARY KEY);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have run the migration for creating the &lt;code&gt;events&lt;/code&gt; table, let&amp;#39;s see if Rails has stored a
timestamp of this migration in the &lt;code&gt;schema_migrations&lt;/code&gt; table.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;sqlite&amp;gt; select * from schema_migrations;
20200405103635
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run the migrations again, Rails will first check if an entry exists in the &lt;code&gt;schema_migrations&lt;/code&gt; table with the timestamp of the migration file, and only execute it if there is no such entry. This ensures that we can incrementally add changes to the database over time and a migration will run only once on the database.&lt;/p&gt;
&lt;h3 id=&quot;database-schema&quot;&gt;Database Schema&lt;/h3&gt;
&lt;p&gt;As we run more and more migrations, the database schema keeps evolving. Rails stores the most recent
database schema in the file &lt;code&gt;db/schema.rb&lt;/code&gt;. This file is the Ruby representation of all the migrations
run on your database over the life of the application. Because of this file, we don&amp;#39;t need to keep
old migrations files in the codebase. Rails provides tasks to &lt;code&gt;dump&lt;/code&gt; the latest schema from the database into &lt;code&gt;schema.rb&lt;/code&gt; and &lt;code&gt;load&lt;/code&gt; the schema into a database from the &lt;code&gt;schema.rb&lt;/code&gt;. So older migrations can be safely deleted from the codebase. The loading of the schema into the database is also faster compared to running each and every migration every time we set up the application.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Rails also provides a way to store database schema in SQL format. We already have an article to compare the two formats. You can read more about it &lt;a href=&quot;/2020/01/15/the-pros-and-cons-of-using-structure-sql-in-your-ruby-on-rails-application.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;rails-version-in-the-migration&quot;&gt;Rails Version in the Migration&lt;/h3&gt;
&lt;p&gt;Every migration that we generate has the Rails version as part of the superclass.
So a migration generated by a Rails 6 app has the superclass &lt;code&gt;ActiveRecord::Migration[6.0]&lt;/code&gt; whereas
a migration generated by Rails 5.2 app has the superclass &lt;code&gt;ActiveRecord::Migration[5.2]&lt;/code&gt;. If you have an
old app with Rails 4.2 or below, you&amp;#39;ll notice that there is no version in the superclass. The superclass is just &lt;code&gt;ActiveRecord::Migration&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The Rails version was added to the migration superclass in Rails 5. This basically ensures that the migration
API can evolve over time without breaking migrations generated by older versions of Rails.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s look deeper into this by looking at the same migration for creating an &lt;code&gt;events&lt;/code&gt; table in a Rails 4.2 app.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;class CreateEvents &amp;lt; ActiveRecord::Migration
  def change
    create_table :events do |t|
      t.string :category

      t.timestamps null: false
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we look at the schema of the &lt;code&gt;events&lt;/code&gt; table generated by a Rails 6 migration, we can see that
the &lt;code&gt;NOT NULL&lt;/code&gt; constraint for the timestamps columns exist.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;sqlite&amp;gt; .schema events
CREATE TABLE IF NOT EXISTS &amp;quot;events&amp;quot; (&amp;quot;id&amp;quot; integer PRIMARY KEY AUTOINCREMENT NOT NULL, &amp;quot;category&amp;quot; varchar, &amp;quot;created_at&amp;quot; datetime(6) NOT NULL, &amp;quot;updated_at&amp;quot; datetime(6) NOT NULL);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is because, starting from Rails 5 onward, the migration API automatically adds a &lt;code&gt;NOT NULL&lt;/code&gt; constraint
to the timestamp columns without a need to add it explicitly in the migration file.
The Rails version in the superclass name ensures that the migration uses the migration API of the
Rails version for which the migration was generated. This allows Rails to maintain backward
compatibility with the older migrations, at the same time evolving the migrations API.&lt;/p&gt;
&lt;h3 id=&quot;changing-the-database-schema&quot;&gt;Changing the Database Schema&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;change&lt;/code&gt; method is the primary method in a migration. When a migration gets run, it calls
the &lt;code&gt;change&lt;/code&gt; method and executes the code inside it.&lt;/p&gt;
&lt;p&gt;Along with &lt;code&gt;create_table&lt;/code&gt;, Rails also provides another powerful method—&lt;code&gt;change_table&lt;/code&gt;.
As the name suggests, it is used to alter the schema of an existing table.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;def change
  change_table :events do |t|
    t.remove :category
    t.string :event_type
    t.boolean :active, default: false
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This migration will remove the &lt;code&gt;category&lt;/code&gt; column from the &lt;code&gt;events&lt;/code&gt; table, add a new string column &lt;code&gt;events_type&lt;/code&gt; and a new boolean column &lt;code&gt;active&lt;/code&gt; with the default value of &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Rails also provides a lot of other helper methods which can be used inside a migration such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;change_column&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;add_index&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;remove_index&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rename_table&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;and many more. All the methods that can be used with change can be &lt;a href=&quot;https://guides.rubyonrails.org/active_record_migrations.html#using-the-change-method&quot;&gt;found here&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;timestamps&quot;&gt;Timestamps&lt;/h3&gt;
&lt;p&gt;We saw that &lt;code&gt;t.timestamps&lt;/code&gt; was added to the migration by Rails and it added the columns
&lt;code&gt;created_at&lt;/code&gt; and &lt;code&gt;updated_at&lt;/code&gt; to the &lt;code&gt;events&lt;/code&gt; table. These special columns are used by Rails
to keep track of when a record is created and updated.
Rails adds values to these columns when a record is created and makes sure to update them when the record
is updated. These columns help us in tracking the lifetime of a database record.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;updated_at&lt;/code&gt; column is not updated when we execute the &lt;code&gt;updated_all&lt;/code&gt; method from Rails.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;handling-failures&quot;&gt;Handling Failures&lt;/h3&gt;
&lt;p&gt;Migrations are not bulletproof. They can fail. The reason might be wrong syntax or an invalid
database query. Whatever the reason, we have to handle the failure and recover from it so that the
database doesn&amp;#39;t go into an inconsistent state. Rails solves this problem by running each
migration inside a transaction. If the migration fails, then the transaction is rolled back.
This ensures that the database does not go into an inconsistent state.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;This is only done for databases that support transactions for updating database schema. They are known as Data Definition Language(DDL) transactions. MySQL and PostgreSQL both support DDL transactions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sometimes, we don&amp;#39;t want to execute certain migrations inside a transaction. A simple example is when adding a
concurrent index in PostgreSQL. Such migrations can&amp;#39;t be executed inside a DDL transaction as PostgreSQL
tries to add the index without acquiring locks on the table so that we can add the index on a live production database without taking the database down. Rails provides a way to opt-out of transactions inside a migration in the form of &lt;code&gt;disable_ddl_transactions!&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;def change
  disable_ddl_transactions!

  add_index :events, :user_id, algorithm: :concurrently
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will not run the migration inside a transaction. If such a migration fails, we need to recover it ourselves. In this case, we can either &lt;code&gt;REINDEX&lt;/code&gt; or remove the index and try to add it again.&lt;/p&gt;
&lt;h3 id=&quot;reversible-migrations&quot;&gt;Reversible Migrations&lt;/h3&gt;
&lt;p&gt;Rails allows us to rollback changes to the database with the following command.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;rails db:rollback
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command reverts the last migration that was run on the database. If the migration added a column
&lt;code&gt;event_type&lt;/code&gt; then the rollback will remove that column. If the migration added an index, then rollback
will remove that index.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is also a command for rolling back the previous migration and running it. It is &lt;code&gt;rails db:redo&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Rails is smart enough to know how to reverse most of the migrations. But we can also provide hints to Rails
on how to revert a migration by providing &lt;code&gt;up&lt;/code&gt; and &lt;code&gt;down&lt;/code&gt; methods instead of using the &lt;code&gt;change&lt;/code&gt; method.
The &lt;code&gt;up&lt;/code&gt; method will be used when the migration is run whereas the &lt;code&gt;down&lt;/code&gt; method will be used when the migration is rolled back.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;def up
  change_table :events do |t|
    t.change :price, :string
  end
end

def down
  change_table :events do |t|
    t.change :price, :integer
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we are changing the &lt;code&gt;price&lt;/code&gt; column of &lt;code&gt;events&lt;/code&gt; from &lt;code&gt;integer&lt;/code&gt; to &lt;code&gt;string&lt;/code&gt;. We specify how it should be rolled back in the &lt;code&gt;down&lt;/code&gt; method.&lt;/p&gt;
&lt;p&gt;This same migration can also be written using the &lt;code&gt;change&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;def change
  reversible do |direction|
    change_table :events do |t|
      direction.up { t.change :price, :string }
      direction.down { t.change :price, :integer }
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rails also provides a way to revert a previous migration completely using
the &lt;code&gt;revert&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;def change
  revert CreateEvents

  create_table :events do
   ...
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;revert&lt;/code&gt; method also accepts a block to revert a migration partially.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;def change
  revert do
    reversible do |direction|
      change_table :events do |t|
        direction.up { t.remove :event_type }
        direction.down { t.string :event_type }
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;executing-it-raw&quot;&gt;Executing It Raw&lt;/h2&gt;
&lt;p&gt;Sometimes, we want to execute complex SQL inside a migration. In such cases, we can forget
the typical migration DSL and instead execute raw SQL as follows.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-rb&quot;&gt;def change
  execute &amp;lt;&amp;lt;-SQL
    ....
  SQL
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;multiple-databases-and-migrations&quot;&gt;Multiple Databases and Migrations&lt;/h2&gt;
&lt;p&gt;Rails 6 added support for using multiple databases within a single Rails application.
If we want to use multiple databases, we configure them in the &lt;code&gt;database.yml&lt;/code&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;development:
  primary:
    &amp;lt;&amp;lt;: *default
    database: db/development.sqlite3
  analytics:
    adapter: sqlite3
    database: db/analytics_dev.sqlite3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This configuration tells Rails that we want to use two databases—&lt;code&gt;primary&lt;/code&gt; and &lt;code&gt;analytics&lt;/code&gt;.
As we saw earlier, the migrations are stored in the &lt;code&gt;db/migrate&lt;/code&gt; directory by default. But in this case,
we can&amp;#39;t add migrations of both databases inside a single directory. We don&amp;#39;t want to run migrations
of the &lt;code&gt;analytics&lt;/code&gt; database on the &lt;code&gt;primary&lt;/code&gt; database and vice versa. If we are using multiple databases, we
are required to provide a path for storing migrations for the second database. This can be done by providing a &lt;code&gt;migrations_paths&lt;/code&gt; in the &lt;code&gt;database.yml&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;development:
  primary:
    &amp;lt;&amp;lt;: *default
    database: db/development.sqlite3
  analytics:
    adapter: sqlite3
    database: db/analytics_dev.sqlite3
    migrations_paths: db/analytics_migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then create migrations for the &lt;code&gt;analytics&lt;/code&gt; database as follows.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;rails generate migration AddExperiments rule:string active:boolean --db=analytics
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will create the migration inside &lt;code&gt;db/analytics_migrate&lt;/code&gt;, and we can run it as follows.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;rails db:migrate --db=analytics
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we only run the &lt;code&gt;rails db:migrate&lt;/code&gt;, it will execute migrations for all the databases.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;analytics&lt;/code&gt; database will have its own &lt;code&gt;schema_migrations&lt;/code&gt; table to keep track of which migrations are run and which are not.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;running-migrations-during-deployment&quot;&gt;Running Migrations During Deployment&lt;/h2&gt;
&lt;p&gt;Since migrations can change the state of the database, and our code might depend on those changes,
it is extremely important that the migrations are run first before the new code is applied.&lt;/p&gt;
&lt;p&gt;In Heroku based deployments, migrations can be run in the &lt;code&gt;release&lt;/code&gt; phase of the &lt;code&gt;Procfile&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# Profile
web: bin/puma -C config/puma.rb
release: bundle exec rake db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This ensures that the migrations are run before the app dynos are restarted.&lt;/p&gt;
&lt;p&gt;In Capistrano based deployments, migrations should run before the server is restarted.&lt;/p&gt;
&lt;p&gt;In docker based deployments, we can run a sidecar container to run the migrations first before the app is restarted. This is very important as otherwise, the new containers can go into an inconsistent state if they start using new code before applying the database changes for that new code.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this post, we saw various aspects of writing a database migration in Rails. We also saw what constitutes
a migration as well as how to handle failures and roll back the migrations if needed. Rails 6 allows us to use multiple databases and the migrations for each need to be added separately. Finally, we briefly saw how to run the migrations during deployment so that database changes are applied properly before any new code starts using them.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>The Citadel Architecture at AppSignal</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/04/08/the-citadel-architecture-at-appsignal.html">
    <id>https://blog.appsignal.com/2020/04/08/the-citadel-architecture-at-appsignal.html</id>
    <published>2020-04-08T00:00:00+00:00</published>
    <updated>2020-04-08T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Check out how AppSignal uses the Citadel pattern and how our system works.</summary>
    <content type="html">&lt;p&gt;DHH just coined the term &amp;quot;Citadel,&amp;quot; which finally gives us an excellent way to reference how we approach tech at AppSignal. We said, &amp;quot;Hey, this is us! Our thing has a name now&amp;quot;.&lt;/p&gt;
&lt;blockquote className=&quot;twitter-tweet&quot; data-conversation=&quot;none&quot;&gt;
  &lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;
    In addition to the Majestic Monolith, someone should write up the pattern of
    The Citadel: A single Majestic Monolith captures the majority mass of the
    app, with a few auxiliary outpost apps for highly specialized and divergent
    needs.
  &lt;/p&gt;
  &amp;mdash; DHH (@dhh) &lt;a href=&quot;https://twitter.com/dhh/status/1247522358908215296?ref_src=twsrc%5Etfw&quot;&gt;April 7, 2020&lt;/a&gt;
&lt;/blockquote&gt; &lt;script
  async
  src=&quot;https://platform.twitter.com/widgets.js&quot;
  charset=&quot;utf-8&quot;
&gt;&lt;/script&gt;

&lt;p&gt;To explain how AppSignal uses the Citadel pattern, we&amp;#39;ll share a bit on how our system works. AppSignal is a monitoring product that has a user-facing application and an API that the monitoring agent sends data to. This data is then processed and turned into graphs and insights.&lt;/p&gt;
&lt;h2 id=&quot;monolith&quot;&gt;Monolith&lt;/h2&gt;
&lt;p&gt;The application our customers interact with is a monolithic Rails app, with parts of the front-end written in React. The backend is entirely written in Ruby and talks to a few databases (we split out data from different customers to separate clusters for scaling reasons). This Rails app also handles a bunch of other tasks such as sending out alerts to external services.&lt;/p&gt;
&lt;p&gt;When we started this Rails app processed incoming data from our monitoring agent as well, we foresaw that data ingestion would turn out to be a bottleneck. So we used a Sinatra app running on a subdomain that ingested data and created Sidekiq jobs that were processed by the Rails app.&lt;/p&gt;
&lt;h2 id=&quot;growing-pains&quot;&gt;Growing Pains&lt;/h2&gt;
&lt;p&gt;This architecture worked well for years. As our business grew, it became clear that the specific task of processing incoming data from the agents was going to need special treatment. When you&amp;#39;re monitoring billions and billions of requests, you run into hard limits. The main limiting factor wasn&amp;#39;t so much that Ruby is slow (we all know that it is not 😉), but that the way we had architected things caused too much locking in our databases.&lt;/p&gt;
&lt;h2 id=&quot;an-outpost&quot;&gt;An Outpost&lt;/h2&gt;
&lt;p&gt;We looked at several possibilities and then decided Kafka was the best fit for our situation. We had some experience with Rust and thought that its speed and reliability would be a very good fit for this system. We rewrote our data ingestion and processing system in Rust, using Kafka as a combination of queue and storage system.&lt;/p&gt;
&lt;p&gt;We only moved the incoming data processing part of the Rails app to this outpost service. The rest of the systems works well in the form of a monolithic app. We understand it deeply, and we like keeping things simple. The monolith still handles most of the logic and interacts with Kafka heavily. Our wish to keep our monolith led to us writing a &lt;a href=&quot;https://github.com/appsignal/rdkafka-ruby&quot;&gt;Kafka gem&lt;/a&gt;, so the main app can communicate with the outpost easily.&lt;/p&gt;
&lt;p&gt;If you want to learn more about how Kafka works at AppSignal &lt;a href=&quot;https://www.youtube.com/watch?v=-NMDqqW1uCE&quot;&gt;check out the Railsconf talk&lt;/a&gt; I gave about this.&lt;/p&gt;
&lt;h2 id=&quot;life-at-the-citadel&quot;&gt;Life at the Citadel&lt;/h2&gt;
&lt;p&gt;This brings us to the current situation where we are very happy in our citadel. As DHH said:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A single Majestic Monolith captures the majority mass of the app with a few auxiliary outpost apps for highly specialized and divergent needs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In our case, we have a single outpost service for our highly specialized needs. If there were a RailsConf this year, we would have given DHH some extra stroopwafels as appreciation for giving it a name. 🍪&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Changing the Approach to Debugging in Ruby with TracePoint</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/04/01/changing-the-approach-to-debugging-in-ruby-with-tracepoint.html">
    <id>https://blog.appsignal.com/2020/04/01/changing-the-approach-to-debugging-in-ruby-with-tracepoint.html</id>
    <published>2020-04-01T00:00:00+00:00</published>
    <updated>2020-04-01T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Learn more about TracePoint and how it makes code tell us what it's doing.</summary>
    <content type="html">&lt;p&gt;Ruby has always been known for the productivity it brings to its developers. Alongside features such as elegant syntax, rich meta-programming support, etc. that make you productive when writing code, it also has another secret weapon called &lt;code&gt;TracePoint&lt;/code&gt; that can help you &amp;quot;debug&amp;quot; faster.&lt;/p&gt;
&lt;p&gt;In this post, I&amp;#39;ll use a simple example to show you 2 interesting facts I found out about debugging:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Most of the time, finding the bug itself isn&amp;#39;t hard, but understanding how your program works in detail is. Once you have a deep understanding of this, you can usually spot the bug right away.&lt;/li&gt;
&lt;li&gt;Observing your program down to the method call level is time-consuming, and is the major bottleneck of our debugging process.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Then, I&amp;#39;ll show you how &lt;code&gt;TracePoint&lt;/code&gt; could change the way we approach debugging by making the program &amp;quot;tell us&amp;quot; what it&amp;#39;s doing.&lt;/p&gt;
&lt;h2 id=&quot;debugging-is-about-understanding-your-program-and-its-design&quot;&gt;Debugging Is about Understanding Your Program and Its Design&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s assume we have a Ruby program called &lt;code&gt;plus_1&lt;/code&gt; and it&amp;#39;s not functioning correctly. How do we debug this?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# plus_1.rb
def plus_1(n)
  n + 2
end

input = ARGV[0].to_i
puts(plus_1(input))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;$ ruby plus_1.rb 1
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ideally, we should be able to address the bug in 3 steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Learn the expectations from the design&lt;/li&gt;
&lt;li&gt;Understand the current implementation&lt;/li&gt;
&lt;li&gt;Trace the bug&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;learning-the-expectations-from-the-design&quot;&gt;Learning the Expectations from the Design&lt;/h3&gt;
&lt;p&gt;What&amp;#39;s the expected behavior here? &lt;code&gt;plus_1&lt;/code&gt; should add &lt;code&gt;1&lt;/code&gt; to its argument, which is our input from the command line. But how do we &amp;quot;know&amp;quot; this?&lt;/p&gt;
&lt;p&gt;In a real-world case, we can understand the expectations by reading test cases, documents, mockups, asking other people for feedback, etc. Our understanding depends on how the program is &amp;quot;designed&amp;quot;.&lt;/p&gt;
&lt;p&gt;This step is the most crucial part of our debugging process. If you don&amp;#39;t understand how the program should work, you&amp;#39;ll never be able to debug it.&lt;/p&gt;
&lt;p&gt;However, there are many factors that can be part of this step, such as team coordination, development workflow, etc. &lt;code&gt;TracePoint&lt;/code&gt; won&amp;#39;t be able to help you with those, so we won&amp;#39;t dwell on these problems today.&lt;/p&gt;
&lt;h3 id=&quot;understanding-the-current-implementation&quot;&gt;Understanding the Current Implementation&lt;/h3&gt;
&lt;p&gt;Once we&amp;#39;ve understood the expected behavior of the program, we need to learn how it functions at the moment.&lt;/p&gt;
&lt;p&gt;In most cases, we need the following information to fully understand how a program works:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The methods called during the program&amp;#39;s execution&lt;/li&gt;
&lt;li&gt;The call and return order of the method calls&lt;/li&gt;
&lt;li&gt;Arguments passed to each method call&lt;/li&gt;
&lt;li&gt;Values returned from each method call&lt;/li&gt;
&lt;li&gt;Any side effects that happened during each method call, e.g. data mutation or database requests&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Let&amp;#39;s describe our example with the above information:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# plus_1.rb
def plus_1(n)
  n + 2
end

input = ARGV[0].to_i
puts(plus_1(input))
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;$ ruby plus_1.rb 1
3
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;Defines a method called &lt;code&gt;plus_1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Retrieves the input (&lt;code&gt;&amp;quot;1&amp;quot;&lt;/code&gt;) from &lt;code&gt;ARGV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;to_i&lt;/code&gt; on &lt;code&gt;&amp;quot;1&amp;quot;&lt;/code&gt;, which returns &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Assigns &lt;code&gt;1&lt;/code&gt; to local variable &lt;code&gt;input&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;plus_1&lt;/code&gt; method with &lt;code&gt;input&lt;/code&gt;(&lt;code&gt;1&lt;/code&gt;) as its argument. The parameter &lt;code&gt;n&lt;/code&gt; now carries a value of &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;+&lt;/code&gt; method on &lt;code&gt;1&lt;/code&gt; with an argument &lt;code&gt;2&lt;/code&gt;, and returns the result &lt;code&gt;3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Returns &lt;code&gt;3&lt;/code&gt; for step 5&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;puts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;to_s&lt;/code&gt; on &lt;code&gt;3&lt;/code&gt;, which returns &lt;code&gt;&amp;quot;3&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Passes &lt;code&gt; &amp;quot;3&amp;quot;&lt;/code&gt; to the &lt;code&gt;puts&lt;/code&gt; call from step 8, which triggers a side effect that prints the string to Stdout. Then it returns &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The description isn&amp;#39;t 100% accurate, but it&amp;#39;s enough for a simple explanation.&lt;/p&gt;
&lt;h3 id=&quot;addressing-the-bug&quot;&gt;Addressing the Bug&lt;/h3&gt;
&lt;p&gt;Now that we&amp;#39;ve learned how our program should work and how it actually works, we can start looking for the bug. With the information we have, we can search for the bug by following the method calls upward (start from step 10) or downward (start from step 1). In this case, we can do it by tracing back to the method that returned 3 in the first place⁠—which is the &lt;code&gt;1 + 2&lt;/code&gt; in &lt;code&gt;step 6&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;this-is-far-from-reality&quot;&gt;This Is Far from Reality!&lt;/h3&gt;
&lt;p&gt;Of course, we all know that real debugging isn&amp;#39;t as simple as the example makes it out to be. The critical difference between real-life programs and our example is the size. We used 10 steps to explain a 5-line program. How many steps would we need for a small Rails app? It&amp;#39;s basically impossible to break down a real program as detailed as we did for the example.
Without a detailed understanding of your program, you won&amp;#39;t be able to track down the bug through an obvious path, so you&amp;#39;ll need to make assumptions or guesses.&lt;/p&gt;
&lt;h2 id=&quot;information-is-expensive&quot;&gt;Information Is Expensive&lt;/h2&gt;
&lt;p&gt;As you probably already noticed, the key factor in debugging is how much information you have. But what does it take to retrieve that much information? Let&amp;#39;s see:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# plus_1_with_tracing.rb
def plus_1(n)
  puts(&amp;quot;n = #{n}&amp;quot;)
  n + 2
end

raw_input = ARGV[0]
puts(&amp;quot;raw_input: #{raw_input}&amp;quot;)
input = raw_input.to_i
puts(&amp;quot;input: #{input}&amp;quot;)

result = plus_1(input)
puts(&amp;quot;result of plus_1 #{result}&amp;quot;)

puts(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ ruby plus_1_with_tracing.rb 1
raw_input: 1
input: 1
n = 1
result of plus_1: 3
3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, we only get 2 types of information here: values of some variables and the evaluation order of our &lt;code&gt;puts&lt;/code&gt; (which implies the program&amp;#39;s execution order).&lt;/p&gt;
&lt;p&gt;How much does this information cost us?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-diff&quot;&gt; def plus_1(n)
+  puts(&amp;quot;n = #{n}&amp;quot;)
   n + 2
 end

-input = ARGV[0].to_i
-puts(plus_1(input))
+raw_input = ARGV[0]
+puts(&amp;quot;raw_input: #{raw_input}&amp;quot;)
+input = raw_input.to_i
+puts(&amp;quot;input: #{input}&amp;quot;)
+
+result = plus_1(input)
+puts(&amp;quot;result of plus_1: #{result}&amp;quot;)
+
+puts(result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not only do we need to add 4 &lt;code&gt;puts&lt;/code&gt; into the code, but, in order to print values separately, we also need to split our logic in order to access the intermediate states of some values. In this case, we got 4 additional outputs for the internal states with 8 lines of changes. That&amp;#39;s 2 lines of changes for 1 line of output, on average! And since the number of changes grows linearly with the size of the program, we can compare it to an &lt;code&gt;O(n)&lt;/code&gt; operation.&lt;/p&gt;
&lt;h3 id=&quot;why-is-debugging-expensive&quot;&gt;Why Is Debugging Expensive?&lt;/h3&gt;
&lt;p&gt;Our programs can be written with many goals in mind: maintainability, performance, simplicity, etc. but usually not for &amp;quot;Traceability&amp;quot;, meaning, getting the values for inspection, which usually requires a modification of the code, e.g. splitting chained method calls.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The more the information you get, the more additions/changes you need to make to the code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;However, once the amount of information you get reaches a certain point, you won&amp;#39;t be able to process it efficiently. So we either need to filter the information out or label it to help us understand it.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The more precise the information, the more additions/changes you need to make to the code.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Finally, because the work involves touching the codebase⁠—which can be very different between bugs (e.g. controller vs. model logic)⁠—it&amp;#39;s hard to automate it. Even if your codebase is tracing-friendly (e.g. it follows &amp;quot;Law of Demeter&amp;quot; strictly), most of the time, you&amp;#39;ll need to type different variable/method names manually.&lt;/p&gt;
&lt;p&gt;(Actually, in Ruby, there are some tricks to avoid this⁠—like &lt;code&gt;__method__&lt;/code&gt;. But let&amp;#39;s not complicate things here.)&lt;/p&gt;
&lt;h2 id=&quot;tracepoint-the-savior&quot;&gt;TracePoint: The Savior&lt;/h2&gt;
&lt;p&gt;However, Ruby provides us an exceptional tool that can largely reduce the cost: &lt;code&gt;TracePoint&lt;/code&gt;. I bet most of you have already heard of it or used it before. But in my experience, not many people use this powerful tool in daily debugging practices.&lt;/p&gt;
&lt;p&gt;Let me show you how to use it to collect information quickly. This time, we don&amp;#39;t need to touch any of our existing logic, we just need some code before it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;TracePoint.trace(:call, :return, :c_call, :c_return) do |tp|
  event = tp.event.to_s.sub(/(.+(call|return))/, &amp;#39;\2&amp;#39;).rjust(6, &amp;quot; &amp;quot;)
  message = &amp;quot;#{event} of #{tp.defined_class}##{tp.callee_id} on #{tp.self.inspect}&amp;quot;
  # if you call `return` on any non-return events, it&amp;#39;ll raise error
  message += &amp;quot; =&amp;gt; #{tp.return_value.inspect}&amp;quot; if tp.event == :return || tp.event == :c_return
  puts(message)
end

def plus_1(n)
  n + 2
end

input = ARGV[0].to_i
puts(plus_1(input))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you run the code, you&amp;#39;ll see:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return of #&amp;lt;Class:TracePoint&amp;gt;#trace on TracePoint =&amp;gt; #&amp;lt;TracePoint:c_return `trace&amp;#39;@plus_1_with_trace_point.rb:1&amp;gt;
  call of Module#method_added on Object
return of Module#method_added on Object =&amp;gt; nil
  call of String#to_i on &amp;quot;1&amp;quot;
return of String#to_i on &amp;quot;1&amp;quot; =&amp;gt; 1
  call of Object#plus_1 on main
return of Object#plus_1 on main =&amp;gt; 3
  call of Kernel#puts on main
  call of IO#puts on #&amp;lt;IO:&amp;lt;STDOUT&amp;gt;&amp;gt;
  call of Integer#to_s on 3
return of Integer#to_s on 3 =&amp;gt; &amp;quot;3&amp;quot;
  call of IO#write on #&amp;lt;IO:&amp;lt;STDOUT&amp;gt;&amp;gt;
3
return of IO#write on #&amp;lt;IO:&amp;lt;STDOUT&amp;gt;&amp;gt; =&amp;gt; 2
return of IO#puts on #&amp;lt;IO:&amp;lt;STDOUT&amp;gt;&amp;gt; =&amp;gt; nil
return of Kernel#puts on main =&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our code is much more readable now. Isn&amp;#39;t it amazing? It prints out most of the program execution with lots of details! We can even map it with my earlier execution breakdown:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Defines a method called &lt;code&gt;plus_1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Retrieves the input (&lt;code&gt;&amp;quot;1&amp;quot;&lt;/code&gt;) from &lt;code&gt;ARGV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;to_i&lt;/code&gt; on &lt;code&gt;&amp;quot;1&amp;quot;&lt;/code&gt;, which returns &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Assigns &lt;code&gt;1&lt;/code&gt; to local variable &lt;code&gt;input&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;plus_1&lt;/code&gt; method with &lt;code&gt;input&lt;/code&gt;(&lt;code&gt;1&lt;/code&gt;) as its argument. The parameter &lt;code&gt;n&lt;/code&gt; now carries a value &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;+&lt;/code&gt; method on &lt;code&gt;1&lt;/code&gt; with an argument &lt;code&gt;2&lt;/code&gt;, and returns the result &lt;code&gt;3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Returns &lt;code&gt;3&lt;/code&gt; for step 5&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;puts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Calls &lt;code&gt;to_s&lt;/code&gt; on &lt;code&gt;3&lt;/code&gt;, which returns &lt;code&gt;&amp;quot;3&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Passes &lt;code&gt; &amp;quot;3&amp;quot;&lt;/code&gt; to the &lt;code&gt;puts&lt;/code&gt; call from step 8, which triggers a side effect that prints the string to Stdout. And then it returns &lt;code&gt;nil&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# ignore this, it&amp;#39;s TracePoint tracing itself ;D
return of #&amp;lt;Class:TracePoint&amp;gt;#trace on TracePoint =&amp;gt; #&amp;lt;TracePoint:c_return `trace&amp;#39;@plus_1_with_trace_point.rb:1&amp;gt;

  call of Module#method_added on Object         # 1. Defines a method called `plus_1`.
return of Module#method_added on Object =&amp;gt; nil
  call of String#to_i on &amp;quot;1&amp;quot;                    # 3-1. Calls `to_i` on `&amp;quot;1&amp;quot;`
return of String#to_i on &amp;quot;1&amp;quot; =&amp;gt; 1               # 3-2. which returns `1`
  call of Object#plus_1 on main                 # 5. Calls `plus_1` method with `input`(`1`) as its argument.
return of Object#plus_1 on main =&amp;gt; 3            # 7. Returns `3` for step 5
  call of Kernel#puts on main                   # 8. Calls `puts`
  call of IO#puts on #&amp;lt;IO:&amp;lt;STDOUT&amp;gt;&amp;gt;
  call of Integer#to_s on 3                     # 9. Calls `to_s` on `3`, which returns `&amp;quot;3&amp;quot;`
return of Integer#to_s on 3 =&amp;gt; &amp;quot;3&amp;quot;
  call of IO#write on #&amp;lt;IO:&amp;lt;STDOUT&amp;gt;&amp;gt;            # 10-1. Passes `&amp;quot;3&amp;quot;` to the `puts` call from step 8
                                                # 10-2. which triggers a side effect that prints the string to Stdout
3 # original output
return of IO#write on #&amp;lt;IO:&amp;lt;STDOUT&amp;gt;&amp;gt; =&amp;gt; 2
return of IO#puts on #&amp;lt;IO:&amp;lt;STDOUT&amp;gt;&amp;gt; =&amp;gt; nil
return of Kernel#puts on main =&amp;gt; nil            # 10-3. And then it returns `nil`.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can even say it&amp;#39;s more detailed than what I said earlier! However, you may notice that steps 2, 4 and 6 are missing from the output. Unfortunately, they are not trackable by &lt;code&gt;TracePoint&lt;/code&gt; for the following reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Retrieves the input (&lt;code&gt;&amp;quot;1&amp;quot;&lt;/code&gt;) from &lt;code&gt;ARGV&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ARGV&lt;/code&gt; and the following &lt;code&gt;[]&lt;/code&gt; aren&amp;#39;t considered as call/c_call at the moment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;Assigns &lt;code&gt;1&lt;/code&gt; to local variable &lt;code&gt;input&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Currently, there&amp;#39;s no event for variable assignments. We can (sort of) track it with &lt;code&gt;line&lt;/code&gt; event + regex, but it won&amp;#39;t be accurate&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;6&quot;&gt;
&lt;li&gt;Calls &lt;code&gt;+&lt;/code&gt; method on &lt;code&gt;1&lt;/code&gt; with an argument &lt;code&gt;2&lt;/code&gt;, and returns the result &lt;code&gt;3&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Certain method calls like built-in &lt;code&gt;+&lt;/code&gt; or attributes accessor methods aren&amp;#39;t trackable at the moment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;from-on-to-olog-n&quot;&gt;From O(n) to O(log n)&lt;/h3&gt;
&lt;p&gt;As you can see from the previous example, with proper usage of &lt;code&gt;TracePoint&lt;/code&gt;, we can almost make the program &amp;quot;tell us&amp;quot; what it&amp;#39;s doing. Now, because of the number of lines we need, &lt;code&gt;TracePoint&lt;/code&gt; doesn&amp;#39;t grow linearly with the size of our program. I&amp;#39;d say the whole process becomes an &lt;code&gt;O(log(n))&lt;/code&gt; operation.&lt;/p&gt;
&lt;h2 id=&quot;next-steps&quot;&gt;Next Steps&lt;/h2&gt;
&lt;p&gt;In this article, I&amp;#39;ve explained the main difficulty with debugging. Hopefully, I&amp;#39;ve also convinced you of how &lt;code&gt;TracePoint&lt;/code&gt; could be a game-changer. But if you try &lt;code&gt;TracePoint&lt;/code&gt; right now, it&amp;#39;ll probably frustrate you more than help you.&lt;/p&gt;
&lt;p&gt;With the amount of information that comes from &lt;code&gt;TracePoint&lt;/code&gt;, you&amp;#39;ll soon be swamped by the noise. The new challenge is to filter out the noise, leaving valuable information. For example, in most cases, we only care about specific models or service objects. In these cases, we can filter calls by the receiver&amp;#39;s class, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;TracePoint.trace(:call) do |tp|
  next unless tp.self.is_a?(Order)
  # tracing logic
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another thing to keep in mind is that the block you define for &lt;code&gt;TracePoint&lt;/code&gt; could be evaluated tens of thousands of times. At this scale, how you implement the filtering logic can have a great impact on your app&amp;#39;s performance. For example, I don&amp;#39;t recommend this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;TracePoint.trace(:call) do |tp|
  trace = caller[0]
  next unless trace.match?(&amp;quot;app&amp;quot;)
  # tracing logic
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For these 2 problems, I&amp;#39;ve prepared another article to let you know of some tricks and gotchas I found with some useful boilerplates for typical Ruby/Rails applications.&lt;/p&gt;
&lt;p&gt;And if you find this concept interesting, I also created a gem called &lt;a href=&quot;https://github.com/st0012/tapping_device&quot;&gt;tapping_device&lt;/a&gt; that hides all the implementation hassles.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Debugger and tracing are both great tools for debugging, and we have been using them for many years. But as I&amp;#39;ve demonstrated in this article, using them requires many manual operations during the debugging process. However, with the help of &lt;code&gt;TracePoint&lt;/code&gt;, you can automate many of them and thus boost your debugging performance. I hope you can now add &lt;code&gt;TracePoint&lt;/code&gt; to your debugging toolbox and give it a try.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Facade Pattern in Rails for Performance and Maintainability</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/03/18/facade-pattern-in-rails-for-performance-and-maintainability.html">
    <id>https://blog.appsignal.com/2020/03/18/facade-pattern-in-rails-for-performance-and-maintainability.html</id>
    <published>2020-03-18T00:00:00+00:00</published>
    <updated>2020-03-18T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Find out how and why you should use a software design pattern named Facade.</summary>
    <content type="html">&lt;p&gt;In today&amp;#39;s post, we will be looking into a software design pattern called Facade. When I first adopted it, it felt a little bit awkward, but the more I used it in my Rails apps, the more I started to appreciate its usefulness. More importantly, it allowed me to test my code more thoroughly, to clean out my controllers, to reduce the logic within my views and to make me think more clearly about an application&amp;#39;s code&amp;#39;s overall structure.&lt;/p&gt;
&lt;p&gt;Being a software development pattern, facade is framework agnostic but the examples I will provide here are for Ruby on Rails. However, I encourage you to read through this article and try them out regardless of the framework you are using. I&amp;#39;m sure that once you become familiar with this pattern, you will start seeing opportunities to use it in many parts of your codebase.&lt;/p&gt;
&lt;p&gt;Without further ado, let&amp;#39;s dive right in!&lt;/p&gt;
&lt;h2 id=&quot;the-problem-with-the-mvc-pattern&quot;&gt;The Problem with the MVC Pattern&lt;/h2&gt;
&lt;p&gt;The MVC (Model-View-Controller) pattern is a software development pattern that dates back to the 1970s. It&amp;#39;s a battle-tested solution for designing software interfaces, separating programming concerns into three main groups that communicate amongst each other in a unique way.&lt;/p&gt;
&lt;p&gt;Many large web frameworks emerged in the early 2000s with the MVC pattern as their foundation. Spring (for Java), Django (for Python) and Ruby on Rails (for Ruby), were all forged with this trinity of interconnected elements at their core. Compared to the spaghetti-code resulting from software that did not make use of it, the MVC pattern was a huge achievement and turning point in the evolution of both software development and the internet.&lt;/p&gt;
&lt;p&gt;In essence, the Model-View-Controller pattern allows for the following: a user performs an action on the View. The View triggers a request to a Controller which can potentially create/read/update or delete a Model. The Model transaction responds back to the Controller, which in turn renders some change that the user will see reflected in the View.&lt;/p&gt;
&lt;p&gt;There are plenty of pros to this programming pattern. To list some:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It improves code maintainability by separating concerns&lt;/li&gt;
&lt;li&gt;It allows for greater testability (the Models, Views and Controllers can be tested in isolation)&lt;/li&gt;
&lt;li&gt;It encourages good coding practices by enforcing the Single Responsibility Principle of SOLID: &amp;quot;A class should have only one reason to change.&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;A phenomenal achievement for its time, developers soon realized that the MVC pattern was also somewhat limiting. Variants started to emerge, such as HMVC (hierarchical model–view–controller), MVA (model–view–adapter), MVP (model–view–presenter), MVVM (model–view–viewmodel) and others, which all sought to address the limitations of the MVC pattern.&lt;/p&gt;
&lt;p&gt;One of the problems that the MVC pattern introduces, and the topic of today&amp;#39;s article, is the following: who is responsible for handling complex view logic? The view should simply be concerned with presenting the data, the controller is just relaying the message it received from the model, and the model should not be concerned with any view logic.&lt;/p&gt;
&lt;p&gt;To help with this common conundrum, all Rails applications get initialized with a &lt;code&gt;helpers&lt;/code&gt; directory. The &lt;code&gt;helper&lt;/code&gt; directory can contain modules with methods that assist in complex View logic.&lt;/p&gt;
&lt;p&gt;Here is an example of a helper within a Rails application:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;app/helpers/application_helper.rb&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module ApplicationHelper
  def display_ad_type(advertisement)
    type = advertisement.ad_type
    case type
    when &amp;#39;foo&amp;#39;
      content_tag(:span, class: &amp;quot;foo ad-#{type}&amp;quot;) { type }
    when &amp;#39;bar&amp;#39;
      content_tag(:p, &amp;#39;bar advertisement&amp;#39;)
    else
      content_tag(:span, class: &amp;quot;badge ads-badge badge-pill ad-#{type}&amp;quot;) { type }
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This example is simple but demonstrates the fact that you would want to extract this kind of decision making from the template itself in order to reduce its complexity.&lt;/p&gt;
&lt;p&gt;Helpers are nice, but there is yet another pattern for handling complicated View logic that has become accepted through the years, and that is the Facade pattern.&lt;/p&gt;
&lt;h2 id=&quot;introduction-to-the-facade-pattern&quot;&gt;Introduction to the Facade Pattern&lt;/h2&gt;
&lt;p&gt;In a Ruby on Rails application, facades are usually placed within the &lt;code&gt;app/facades&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;While similar to &lt;code&gt;helpers&lt;/code&gt;, &lt;code&gt;facades&lt;/code&gt; are not a group of methods within a module. A Facade is a PORO (Plain Old Ruby Object) that is instantiated within the controller, but one that handles elaborate View business logic. As such, it allows the following benefits:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Rather than having a single module for &lt;code&gt;UsersHelper&lt;/code&gt; or &lt;code&gt;ArticlesHelper&lt;/code&gt; or &lt;code&gt;BooksHelper&lt;/code&gt;, each controller action can have its own Facade: &lt;code&gt;Users::IndexFacade&lt;/code&gt;, &lt;code&gt;Articles::ShowFacade&lt;/code&gt;, &lt;code&gt;Books::EditFacade&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;More so than modules, facades encourage good coding practices by allowing you to nest facades to ensure the Single Responsibility Principle is enforced. While you probably don&amp;#39;t want facades that are nested hundreds of levels deep, having one or two layers of nesting for improved maintainability and test coverage can be a good thing.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here is a contrived example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Books
  class IndexFacade
    attr_reader :books, :params, :user

    def initialize(user:, params:)
      @params = params
      @user   = user
      @books  = user.books
    end

    def filtered_books
      @filtered_books ||= begin
        scope = if query.present?
                  books.where(&amp;#39;name ILIKE ?&amp;#39;, &amp;quot;%#{query}%&amp;quot;)
                elsif isbn.present?
                  books.where(isbn: isbn)
                else
                  books
                end

        scope.order(created_at: :desc).page(params[:page])
      end
    end

    def recommended
      # We have a nested facade here.
      # The `Recommended Books` part of the view has a
      # single responsibility so best to extract it
      # to improve its encapsulation and testability.
      @recommended ||= Books::RecommendedFacade.new(
        books: books,
        user: user
      )
    end

    private

    def query
      @query ||= params[:query]
    end

    def isbn
      @isbn ||= params[:isbn]
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;when-not-to-use-the-facade-pattern&quot;&gt;When Not to Use the Facade Pattern&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s take a moment to also reflect on what facades are not.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Facades should not be placed in classes that live, for example, in the &lt;code&gt;lib&lt;/code&gt; directory for code that needs to be displayed in the View. The facade&amp;#39;s lifecycle should be generated in the Controller action and be used in its associated View.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Facades are not meant to be used for business logic to perform CRUD actions (there are other patterns for that, such as Services or Interactors—but that is a subject for another day.) In other words, facades should not be concerned with creating, updating or deleting. Their aim is to extract intricate presentation logic from the View or Controller and offer a single interface to access all that information.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Last but not least, Facades are not a silver bullet. They do not allow you to bypass the MVC pattern, but rather, they play along with it. If a change occurs in a Model, it will not be immediately reflected in the View. As is always the case with MVC, the controller action would have to be re-rendered in order for the Facade to display changes on the View.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;controller-benefits&quot;&gt;Controller Benefits&lt;/h2&gt;
&lt;p&gt;One of the main, obvious benefits of Facades is that they will allow you to dramatically reduce the controller logic.&lt;/p&gt;
&lt;p&gt;Your controller code will be reduced from something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class BooksController &amp;lt; ApplicationController
  def index
    @books  = if params[:query].present?
                current_user.books.where(&amp;#39;name ILIKE ?&amp;#39;, &amp;quot;%#{params[:query]}%&amp;quot;)
              elsif params[:isbn].present?
                current_user.books.where(isbn: params[:isbn])
              else
                current_user.books
              end

    @books.order(created_at: :desc).page(params[:page])
    @recommended = @books.where(some_complex_query: true)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class BooksController &amp;lt; ApplicationController
  def index
    @index_facade = Books::IndexFacade.new(user: current_user, params: params)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;view-benefits&quot;&gt;View Benefits&lt;/h2&gt;
&lt;p&gt;For the Views, there are two main benefits when using Facades:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Conditional checks, inline queries and other logic can be neatly extracted from the template itself making the code far more readable. For instance, you could use it in a form:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;%= f.label :location %&amp;gt;
&amp;lt;%= f.select :location, options_for_select(User::LOCATION_TYPES.map { |type| [type.underscore.humanize, type] }.sort.prepend([&amp;#39;All&amp;#39;, &amp;#39;all&amp;#39;])), multiple: (current_user.active_ips.size &amp;gt; 1 &amp;amp;&amp;amp; current_user.settings.use_multiple_locations?) %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Could just become:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;&amp;lt;%= f.label :location %&amp;gt;
&amp;lt;%= f.select :location, options_for_select(@form_facade.user_locations), multiple: @form_facade.multiple_locations? %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;Variables that get called multiple times can be cached. This can offer significant performance improvements to your app and help remove pesky N+1 queries:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;// Somewhere in the view, a query is performed.
&amp;lt;% current_user.books.where(isbn: params[:isbn]).each do |book| %&amp;gt;
  // Do things
&amp;lt;% end %&amp;gt;

// Somewhere else in the view, the same query is performed again.
&amp;lt;% current_user.books.where(isbn: params[:isbn]).each do |book| %&amp;gt;
  // Do things
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;would become:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;// Somewhere in the view, a query is performed.
&amp;lt;% @index_facade.filtered_books.each do |book| %&amp;gt;
  // Do things
&amp;lt;% end %&amp;gt;

// Somewhere else in the view.
// Second query is not performed due to instance variable caching.
&amp;lt;% @index_facade.filtered_books.each do |book| %&amp;gt;
  // Do things
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;testing-benefits&quot;&gt;Testing Benefits&lt;/h2&gt;
&lt;p&gt;A major benefit of Facades is that they allow you to test singular bits of business logic without having to write an entire controller test, or worse, without having to write an integration test that goes through a flow and reaches a page just to ensure that the data presentation is as expected.&lt;/p&gt;
&lt;p&gt;As you will be testing single POROs, this will help maintain a fast test suite.&lt;/p&gt;
&lt;p&gt;Here is a simple example of a test written in Minitest for demonstration purposes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;test_helper&amp;#39;

module Books
  class IndexFacadeTest &amp;lt; ActiveSupport::TestCase
    attr_reader :user, :params

    setup do
      @user = User.create(first_name: &amp;#39;Bob&amp;#39;, last_name: &amp;#39;Dylan&amp;#39;)
      @params = {}
    end

    test &amp;quot;#filtered_books returns all user&amp;#39;s books when params are empty&amp;quot;
      index_facade = Books::IndexFacade.new(user: user, params: params)

      expectation = user.books.order(created_at: :desc).page(params[:page])

      # Without writing an entire controller test or
      # integration test, we can check whether using the facade with
      # empty parameters will return the correct results
      # to the user.
      assert_equal expectation, index_facade.filtered_books
    end

    test &amp;quot;#filtered_books returns books matching a query&amp;quot;
      @params = { query: &amp;#39;Lord of the Rings&amp;#39; }
      index_facade = Books::IndexFacade.new(user: user, params: params)

      expectation = user
        .books
        .where(&amp;#39;name ILIKE ?&amp;#39;, &amp;quot;%#{params[:query]}%&amp;quot;)
        .order(created_at: :desc)
        .page(params[:page])

      assert_equal expectation, index_facade.filtered_books
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unit testing facades considerably improves test suite performance, and every large company will eventually encounter slow test suites unless problems like these aren’t addressed with some level of seriousness.&lt;/p&gt;
&lt;h2 id=&quot;one-facade-two-facades-three-facades-more&quot;&gt;One Facade, Two Facades, Three Facades, More?&lt;/h2&gt;
&lt;p&gt;You might encounter a scenario where a View renders a partial that outputs some data. In that case, you have the option of either using the parent facade or using a nested facade. That largely depends on how much logic is involved, whether you want to test it separately and whether it makes sense to extract the functionality.&lt;/p&gt;
&lt;p&gt;There is no golden rule for how many facades to use or how many facades to nest within each other. That is to the developer&amp;#39;s discretion. I generally prefer to have a single facade for the controller action and I limit nesting to a single level to make the code easier to follow.&lt;/p&gt;
&lt;p&gt;Here are some general questions you can ask yourself during development:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Does the facade encapsulate the logic I am trying to present on the view?&lt;/li&gt;
&lt;li&gt;Does the method within the facade make sense in this context?&lt;/li&gt;
&lt;li&gt;Is the code easier to follow now, or harder to follow?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;When in doubt, always strive to make your code as easy to follow as possible.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In conclusion, facades are a fantastic pattern to keep your controllers and views lean, while improving code maintainability, performance and testability.&lt;/p&gt;
&lt;p&gt;However, like any programming paradigm, there is no silver bullet. Even the multitude of patterns that have emerged in more recent years (HMVC, MVVM, etc.) are not be-all-end-all solutions to the complications of software development.&lt;/p&gt;
&lt;p&gt;Similar to the second law of thermodynamics, which states that the state of entropy in a closed system will always increase, so too in any software project does the complexity increase and evolve over time. In the long run, the goal is to write code that is as easy to read, test, maintain and follow as possible; facades offer exactly this.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Building a Rails App With Multiple Subdomains</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/03/04/building-a-rails-app-with-multiple-subdomains.html">
    <id>https://blog.appsignal.com/2020/03/04/building-a-rails-app-with-multiple-subdomains.html</id>
    <published>2020-03-04T00:00:00+00:00</published>
    <updated>2020-03-04T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Learn how to build a Rails app that can support multiple subdomains.</summary>
    <content type="html">&lt;p&gt;In today&amp;#39;s post, we&amp;#39;ll learn how to build a Rails app that can support multiple
subdomains. Let&amp;#39;s assume that we have a gaming website &lt;code&gt;funkygames.co&lt;/code&gt; and we want to support multiple subdomains such as &lt;code&gt;app.funkygames.co&lt;/code&gt;, &lt;code&gt;api.funkygames.co&lt;/code&gt;, and &lt;code&gt;dev.funkygames.co&lt;/code&gt; with a single Rails application. We want to ensure that proper authentication is performed for all subdomains and that there are no duplicate routes.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ll use Rails&amp;#39; powerful routing constructs to support multiple subdomains in our application. We&amp;#39;ll also set up subdomains locally and write tests for multiple subdomains.&lt;/p&gt;
&lt;h2 id=&quot;prerequisites&quot;&gt;Prerequisites&lt;/h2&gt;
&lt;p&gt;For the purpose of this post, I&amp;#39;m assuming that you have set up appropriate DNS records for all the subdomains to point to the Rails app. We&amp;#39;ll only deal with the Rails side of things in this post.&lt;/p&gt;
&lt;h2 id=&quot;handling-multiple-subdomains&quot;&gt;Handling Multiple Subdomains&lt;/h2&gt;
&lt;p&gt;Rails uses &lt;code&gt;routes.rb&lt;/code&gt; file to handle incoming requests and map them to
specific controller actions. In a trivial app, every mapping in &lt;code&gt;routes.rb&lt;/code&gt;
maps a route to a controller action as follows:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  get &amp;#39;/games/:id&amp;#39;, to: &amp;#39;games#show&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this approach, all the endpoints defined in our &lt;code&gt;routes.rb&lt;/code&gt; file
are applicable to all the subdomains. So &lt;code&gt;app.funkygames.co/games/1&lt;/code&gt; as well as &lt;code&gt;api.funkygames.co/games/1&lt;/code&gt; will be handled by this route. However, we only want the request coming from &lt;code&gt;app&lt;/code&gt; subdomain to be handled by this route. The &lt;code&gt;api&lt;/code&gt; subdomain is only to be used for API routes. We&amp;#39;ll add some rules to the routes so that they are handled only if a specific rule is met for the incoming request.&lt;/p&gt;
&lt;p&gt;Rails routing provides a &lt;code&gt;constraints&lt;/code&gt; helper method which can specify additional rules for the given route.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  get &amp;#39;/games/:id&amp;#39;, to: &amp;#39;games#show&amp;#39;, constraints: { subdomain: &amp;#39;app&amp;#39; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will ensure that if the request is coming from &lt;code&gt;app.funkygames.co/games/1&lt;/code&gt;, it will be handled by &lt;code&gt;GamesController&amp;#39;s&lt;/code&gt; show action. Any request from other subdomains apart from &lt;code&gt;app&lt;/code&gt; will not be handled by this route.&lt;/p&gt;
&lt;p&gt;It will become very cumbersome to define &lt;code&gt;constraints&lt;/code&gt; like this for each and every route.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  get &amp;#39;/games/:id&amp;#39;, to: &amp;#39;games#show&amp;#39;, constraints: { subdomain: &amp;#39;app&amp;#39; }
  get &amp;#39;/games/list&amp;#39;, to: &amp;#39;games#list&amp;#39;, constraints: { subdomain: &amp;#39;app&amp;#39; }
  post &amp;#39;/games/start&amp;#39;, to: &amp;#39;games#start&amp;#39;, constraints: { subdomain: &amp;#39;app&amp;#39; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use the block form of the &lt;code&gt;constraints&lt;/code&gt; helper to define multiple
routes for a single subdomain.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  constraints subdomain: &amp;#39;app&amp;#39; do
    get &amp;#39;/games/:id&amp;#39;, to: &amp;#39;games#show&amp;#39;
    get &amp;#39;/games/list&amp;#39;, to: &amp;#39;games#list&amp;#39;
    post &amp;#39;/games/start&amp;#39;, to: &amp;#39;games#start&amp;#39;
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To define routes for multiple subdomains, we just have to add multiple &lt;code&gt;constraints&lt;/code&gt; blocks in our &lt;code&gt;routes.rb&lt;/code&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;constraints subdomain: &amp;#39;app&amp;#39; do
  ...
end

constraints subdomain: &amp;#39;api&amp;#39; do
  ...
end

constraints subdomain: &amp;#39;dev&amp;#39; do
  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;under-the-hood&quot;&gt;Under the Hood&lt;/h3&gt;
&lt;p&gt;Rails routing provides request constraints and segment constraints. Segment constraints add rules on the request path whereas request constraints add conditions on the incoming request. The hash key in a request constraint needs to be a method on the &lt;code&gt;Request&lt;/code&gt; object that returns a string and the value needs to be the expected value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;constraints subdomain: &amp;#39;app&amp;#39; do
  ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above case, we are using the &lt;code&gt;subdomain&lt;/code&gt; method on the &lt;code&gt;Request&lt;/code&gt; object and matching it with a string like &lt;code&gt;app&lt;/code&gt;, &lt;code&gt;api&lt;/code&gt; or &lt;code&gt;dev&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For more details, consult the &lt;a href=&quot;https://guides.rubyonrails.org/routing.html&quot;&gt;Rails routing guide&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;handling-multi-level-subdomains&quot;&gt;Handling Multi-level Subdomains&lt;/h3&gt;
&lt;p&gt;Let&amp;#39;s say we are using &lt;code&gt;app.staging.funkygames.co&lt;/code&gt; for our staging environment. If we have the setup above, we will quickly notice that all the requests that are supposed to hit the &lt;code&gt;app&lt;/code&gt; subdomain are returning a 404. If we debug things further, we will notice that our constraint for the subdomain is failing.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;request.subdomain #=&amp;gt; app.staging
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We expected the subdomain to return &lt;code&gt;app&lt;/code&gt;, but instead, it returns &lt;code&gt;app.staging&lt;/code&gt;. Of course, we want to solve this without adding environment-specific code! The parsing of request&amp;#39;s subdomain is managed by &lt;code&gt;config.action_dispatch.tld_length&lt;/code&gt; option. The default value of this configuration is 1, which basically supports one level of subdomains. As we have two level subdomains, we need to set the value for &lt;code&gt;config.action_dispatch.tld_length&lt;/code&gt; to 2.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# config/application.rb
config.action_dispatch.tld_length = Integer(ENV[&amp;#39;TLD_LENGTH&amp;#39;] || 1)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can set it using an environment variable so that we can use the same code in the staging as well as in the production environment. Now, our routing setup will work for &lt;code&gt;app.staging.funkygames.co&lt;/code&gt; as well.&lt;/p&gt;
&lt;h2 id=&quot;session-management&quot;&gt;Session Management&lt;/h2&gt;
&lt;p&gt;Now that routes are defined to handle requests coming from multiple subdomains,
we need to take care of authentication for all the subdomains. We can do this in two ways—we can either allow the same user session to be used across all subdomains, or we can have separate sessions for separate subdomains.&lt;/p&gt;
&lt;h3 id=&quot;authentication-in-a-nutshell&quot;&gt;Authentication in a Nutshell&lt;/h3&gt;
&lt;p&gt;Rails uses cookies to store user session key by default. Once the user logs in, the user&amp;#39;s session information is stored in the session store of our choice and the session key is stored as a cookie in the browser. So the next time the user visits our website, the same session cookie is sent from the browser to the server and the server decides whether the user is logged in or not based on whether the session exists for the incoming session cookie.&lt;/p&gt;
&lt;p&gt;The default configuration for the session looks like this in the Rails app:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Rails.application.config.session_store :cookie_store, key: &amp;quot;_funkygames_session&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The key &lt;code&gt;_funkygames_session&lt;/code&gt; will be used as the name of the session cookie and its value will be the session id.&lt;/p&gt;
&lt;h3 id=&quot;cookies-primer&quot;&gt;Cookies Primer&lt;/h3&gt;
&lt;p&gt;By default, cookies are set by the browser on the request&amp;#39;s domain. So if we are hitting our application from &lt;code&gt;app.funkygames.co&lt;/code&gt; then the session cookie will be set against &lt;code&gt;app.funkygames.co&lt;/code&gt;. Each subdomain will set its own session cookies, therefore the user session will not be shared across subdomains by default.&lt;/p&gt;
&lt;h3 id=&quot;sharing-session-between-different-subdomains&quot;&gt;Sharing Session between Different Subdomains&lt;/h3&gt;
&lt;p&gt;If we want to share the user session across subdomains, we&amp;#39;ll need to set the session cookie on the &lt;code&gt;funkygames.co&lt;/code&gt; domain itself so that all subdomains can access it. This can be achieved by passing the &lt;code&gt;domain&lt;/code&gt; option to the session store settings.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Rails.application.config.session_store :cookie_store, key: &amp;quot;_funkygames_session&amp;quot;, domain: :all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By passing &lt;code&gt;domain&lt;/code&gt; as &lt;code&gt;:all&lt;/code&gt;, we are basically telling Rails to set the session cookie on the top-level domain of the application such as &lt;code&gt;funkygames.co&lt;/code&gt; instead of on the request host which may include the individual subdomains. Once we do this, the session can be shared between different subdomains.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We can also pass a list of domains to the &lt;code&gt;domains&lt;/code&gt; option in an array format to support multiple domains.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There is one more option that needs to be configured to properly set the cookies for all subdomains. It is the &lt;code&gt;tld_length&lt;/code&gt; option. When using &lt;code&gt;domain: :all&lt;/code&gt;, this option can specify how to parse the domain to interpret the TLD of the domain. In our case, for &lt;code&gt;app.funkygames.co&lt;/code&gt;, we should set &lt;code&gt;tld_length&lt;/code&gt; to 2 for Rails to interpret the TLD as &lt;code&gt;funkygames.co&lt;/code&gt; when setting up the cookies. So the final session store configuration for multiple subdomains looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Rails.application.config.session_store :cookie_store,
                                       key: &amp;quot;_funkygames_session&amp;quot;,
                                       domain: :all,
                                       tld_length: 2
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;tld_length&lt;/code&gt; option from the session store is different from the &lt;code&gt;config.action_dispatch.tld_length&lt;/code&gt; discussed earlier.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;writing-tests-for-multiple-subdomains&quot;&gt;Writing Tests for Multiple Subdomains&lt;/h2&gt;
&lt;p&gt;As the routes are subdomain specific, the request specs or integration tests result in 404 errors if the test request does not have a proper subdomain. Rails integration tests provide a &lt;code&gt;host!&lt;/code&gt; helper which can set the proper subdomain for all requests made within a test file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Configuring subdomain in Rails integration tests
setup do
  host! &amp;#39;dev.example.com&amp;#39;
end

# # Configuring subdomain in RSpec request specs
before do
 host! &amp;#39;dev.example.com&amp;#39;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After this, the requests will be correctly routed to the controller actions as per subdomain routing in &lt;code&gt;routes.rb&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;Note that the domain does not matter here, only the proper subdomain based in the code we are testing matters.&lt;/p&gt;
&lt;h2 id=&quot;setting-up-multiple-subdomains-locally-for-development&quot;&gt;Setting up Multiple Subdomains Locally for Development&lt;/h2&gt;
&lt;p&gt;There are multiple ways to set up subdomains locally. The simplest is editing the &lt;code&gt;/etc/hosts&lt;/code&gt; file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;127.0.0.1 dev.funkygames.local
127.0.0.1 app.funkygames.local
127.0.0.1 api.funkygames.local
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This ensures that the subdomains setup will work in a local environment. We can also use tools such as &lt;a href=&quot;http://pow.cx/&quot;&gt;pow&lt;/a&gt; for managing subdomains locally.&lt;/p&gt;
&lt;h2 id=&quot;gotchas-with-constraints-based-subdomain-routing&quot;&gt;Gotchas with Constraints Based Subdomain Routing&lt;/h2&gt;
&lt;p&gt;Though the constraints based subdomain routing works in most cases, it can be a pain in certain situations.&lt;/p&gt;
&lt;h3 id=&quot;dealing-with-external-apis&quot;&gt;Dealing with External APIs&lt;/h3&gt;
&lt;p&gt;When we are working with third-party APIs and building integrations, the local development TLDs such as &lt;code&gt;.local&lt;/code&gt; or &lt;code&gt;.dev&lt;/code&gt; are not allowed. We have to use tools such as &lt;a href=&quot;https://ngrok.com/&quot;&gt;ngrok&lt;/a&gt;. The subdomain based routing does not work in such cases and we have to whitelist certain routes so that they are accessible via ngrok as well.&lt;/p&gt;
&lt;h3 id=&quot;routes-outside-of-subdomains-constraints&quot;&gt;Routes Outside of Subdomains Constraints&lt;/h3&gt;
&lt;p&gt;Certain routes can&amp;#39;t be placed inside the subdomain constraints. A typical example is &lt;code&gt;healthcheck&lt;/code&gt; or &lt;code&gt;ping&lt;/code&gt; endpoints. If we are using a load balancer in front of our Rails app, the load balancer needs to periodically check if the app is up or not. The &lt;code&gt;healthcheck&lt;/code&gt; endpoint used in such cases can&amp;#39;t be under subdomain constraints as the load balancer most probably won&amp;#39;t have knowledge of the request host.&lt;/p&gt;
&lt;h3 id=&quot;absence-of-root-route&quot;&gt;Absence of root Route&lt;/h3&gt;
&lt;p&gt;Rails has a special &lt;code&gt;root&lt;/code&gt; route which is basically the default route of the application. If none of the other routes are matched with the request, then the &lt;code&gt;root&lt;/code&gt; route is used. When we have all of our routes under any one of the subdomains, then there can be situations where we don&amp;#39;t have any &lt;code&gt;root&lt;/code&gt; route defined at all.
Certain gems might depend on the presence of a &lt;code&gt;root&lt;/code&gt; route and we need to add checks and balances accordingly.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this post, we set up a Rails app with multiple subdomains with very few lines of configuration. We also saw how to set up the subdomains locally as well as with different environments, with tips on writing effective tests for multiple subdomains. With the plumbing provided by Rails, it becomes easy to set up and test a Rails app with multiple subdomains.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Getting Started With System Tests in Rails With Minitest</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/02/12/getting-started-with-system-tests-in-ruby-with-minitest.html">
    <id>https://blog.appsignal.com/2020/02/12/getting-started-with-system-tests-in-ruby-with-minitest.html</id>
    <published>2020-02-12T00:00:00+00:00</published>
    <updated>2020-02-12T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Dive into instances when generic methods are worth replacing with specific alternatives, illustrated by cleaning up strings.</summary>
    <content type="html">&lt;p&gt;In today&amp;#39;s post, we&amp;#39;ll look at system tests in Rails 6. System tests are meant to auto-test the way users interact with your application, including the Javascript in your user interface. Minitest, being the default testing framework in Rails, is a great match for system testing. With all the configuration that Rails handles for us, there are just a few steps needed before we have our first tests up and running.&lt;/p&gt;
&lt;p&gt;System tests were added to the Rails stack in Rails 5.1. When I sat down to start using them, I found it hard to gather relevant, up to date information that is not about RSpec. Here’s all the latest and greatest that I collected on working with the system tests with Minitest.&lt;/p&gt;
&lt;h2 id=&quot;introduction-to-system-tests&quot;&gt;Introduction to System Tests&lt;/h2&gt;
&lt;p&gt;In Rails jargon, system testing refers to &amp;quot;testing an application as a whole system&amp;quot;. That is done by using a browser in the tests. Instead of testing separate parts, with system tests, we can test a whole &amp;#39;workflow&amp;#39;, just like what a user goes through while interacting with our app, including the JavaScript parts. In practice, it means that we don&amp;#39;t want a system test to check &lt;em&gt;if&lt;/em&gt; a record is created in the database when a user clicks a button; we just test if that new record appears on their screen. These kinds of user interaction tests are also called feature tests or acceptance tests. They are different from integration tests: integration tests are for testing the behavior, especially of all the parts of the app together, but not via the user interface.&lt;/p&gt;
&lt;h2 id=&quot;configuration&quot;&gt;Configuration&lt;/h2&gt;
&lt;p&gt;The configuration is so simple, it&amp;#39;s almost confusing.&lt;/p&gt;
&lt;p&gt;The Capybara gem is used for interacting with the browser. It&amp;#39;s through Capybara that we can make the tests visit pages, fill in forms, click on links and buttons. If you&amp;#39;ve worked with Capybara before, you&amp;#39;re aware of all the things you have to coordinate to make it work with a database cleaning strategy and the browser configuration. Hooray for the Rails system test set up: it takes care of all the configuration that is needed to work with Capybara out-of-the-box. So we can focus on the actual test writing. It uses the Selenium driver by default.&lt;/p&gt;
&lt;p&gt;From the docs: “By default, ActionDispatch::SystemTestCase is driven by the Selenium driver, with the Chrome browser, and a browser size of 1400x1400.” The Selenium driver is different from Capybara&amp;#39;s default and is chosen because it works with Javascript.&lt;/p&gt;
&lt;p&gt;All the settings are available through &lt;code&gt;application_system_test_case.rb&lt;/code&gt;. The only thing you need to do is require this in each test file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;#application_system_test_case.rb (default)


require &amp;quot;test_helper&amp;quot;

class ApplicationSystemTestCase &amp;lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :chrome, screen_size: [1400, 1400]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you generated a new app with Rails 6, this is really all you need. Meaning: you can skip all the advice on how to set up the Selenium driver that the Internet shows for user interface tests or RSpec&amp;#39;s feature tests.&lt;/p&gt;
&lt;p&gt;In existing apps, generating a scaffold will automatically generate the &lt;code&gt;application_system_test_case.rb&lt;/code&gt; and everything you need for the system tests.&lt;/p&gt;
&lt;p&gt;When Eileen Uchitelle &lt;a href=&quot;https://www.youtube.com/watch?v=sSn4B8orX70&quot;&gt;introduced system tests&lt;/a&gt;, Chrome was chosen over Firefox because at the time FF didn&amp;#39;t play nicely with Selenium. That is fixed in later versions of Firefox. So I replace Chrome with FF, like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;#application_system_test_case.rb (change driver to Firefox)

require &amp;quot;test_helper&amp;quot;

class ApplicationSystemTestCase &amp;lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :firefox, screen_size: [1400, 1400]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Initially, I ran &lt;code&gt;$ rails db:test:prepare after&lt;/code&gt; switching drivers to ensure a clean start, BUT the new test runner takes care of that too: invoking test will autorun &lt;code&gt;:prepare.&lt;/code&gt;)&lt;/p&gt;
&lt;h2 id=&quot;new-in-rails-6&quot;&gt;New in Rails 6&lt;/h2&gt;
&lt;p&gt;Since the introduction of system tests in 5.1, the chromedriver-helper gem has been deprecated. In new Rails 6 apps, it is replaced with the webdrivers gem. In Rails 5 apps, you should replace the chromedriver-helper with the webdrivers gem if you haven&amp;#39;t done that yet. With the webdrivers gem in place, you don&amp;#39;t even need the selenium-webdriver gem; webdrivers takes care of that one too. Fun fact: Rails 6 gives us both the selenium-webdriver gem and the webdrivers gem.&lt;/p&gt;
&lt;h2 id=&quot;sanity-check-what-you-dont-need-anymore&quot;&gt;Sanity Check: What You Don&amp;#39;t Need Anymore&lt;/h2&gt;
&lt;p&gt;Setting up Capybara used to be a pain. It wasn&amp;#39;t clear what you needed to set it up from scratch, including finding the correct database cleaning strategy, the dependencies of the capybara-webkit gem and all kinds of unexpected requirements that you needed to figure out before you could start writing tests. Now that Rails provides everything we need, I found the only confusing part to be all the information available in guides and documentation that is obsolete now. Here are some things that we can ignore now.&lt;/p&gt;
&lt;p&gt;First, the precooked Rails setup means that we can omit more gems that are often mentioned in regards to testing, like minitest-rails-capybara, or the extras for Minitest: like-colored output, fast failing tests and running one line/test. These Minitest features are in the &lt;a href=&quot;https://guides.rubyonrails.org/5_0_release_notes.html#test-runner&quot;&gt;test runner introduced in Rails 5.0&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There&amp;#39;s no need for the database_cleaner gem anymore; Rails does the cleanup for us (&amp;#39;transactional tests&amp;#39;).&lt;/p&gt;
&lt;p&gt;Since Rails uses Selenium instead of the Capybara default, we don&amp;#39;t need capybara-webkit and we don&amp;#39;t need to do any extras to include testing of Javascript elements.&lt;/p&gt;
&lt;p&gt;You don&amp;#39;t even need to use Capybara&amp;#39;s &lt;code&gt;save_and_open_screenshot&lt;/code&gt;, because Rails provides a &lt;code&gt;take_screenshot&lt;/code&gt; method. It saves a screenshot in &lt;code&gt;/tmp&lt;/code&gt; and provides a link in the test output for easy access.&lt;/p&gt;
&lt;h2 id=&quot;choosing-between-a-real-browser-and-headless-browser&quot;&gt;Choosing Between a Real Browser and Headless Browser&lt;/h2&gt;
&lt;p&gt;I can&amp;#39;t get enough of watching the system tests running in the browser and see how all the links are clicked, forms are filled in, etc. But, it is slow. To speed up the test run, you can use a &amp;#39;headless&amp;#39; browser: that is a browser that has the same access to your app as a regular browser, but without the graphical user interface. Meaning: it works the same but you don&amp;#39;t actually see the tests doing their work since a headless driver doesn&amp;#39;t open an actual browser window.&lt;/p&gt;
&lt;p&gt;If you do want to go headless, there&amp;#39;s &lt;code&gt;headless_chrome&lt;/code&gt; and &lt;code&gt;headless_firefox&lt;/code&gt;. To use them, there&amp;#39;s one small change needed:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# To change driver to headless_*
#application_system_test_case.rb (change driver to headless_*:)

require &amp;quot;test_helper&amp;quot;

class ApplicationSystemTestCase &amp;lt; ActionDispatch::SystemTestCase
  driven_by :selenium, using: :headless_firefox
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note: In the Rails documentation and in several articles I found, Poltergeist was named as an option for the driver. It used to be popular as the - headless - PhantomJS driver for Capybara. PhantomJS has been abandoned. So, no need to dive into the particulars—the reason I mention it here is because Poltergeist and PhantomJS are still mentioned in the Rails docs.&lt;/p&gt;
&lt;p&gt;There&amp;#39;s more customization you can do, but to get started, this is really all you need.&lt;/p&gt;
&lt;h2 id=&quot;running-the-tests&quot;&gt;Running the Tests&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;$ rails test&lt;/code&gt; will run all the tests except the system tests. You need to explicitly run &lt;code&gt;$ rails test:system&lt;/code&gt;. (Fun fact: the &lt;code&gt;$ rails&lt;/code&gt; command will always run through bin/rails. No need to type &lt;code&gt;$ bin/rails&lt;/code&gt; anymore.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Run all the system tests:
&lt;code&gt;$ rails test:system&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Run test in a specific file (here: users_test.rb)
&lt;code&gt;$ rails test/system/users_test&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;... or one specific test:
&lt;code&gt;$ rails test test/system/users_test.rb:21&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;To run all the tests: run the system tests first:
&lt;code&gt;$ rails test:system test&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Note: the options flags don&amp;#39;t work with &lt;code&gt;test:system&lt;/code&gt;; if you want to use flags like &lt;code&gt;-f&lt;/code&gt; (for fail fast) or &lt;code&gt;-v&lt;/code&gt; (for verbose), use &lt;code&gt;$ rails test test/system -v -f&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;what-not-to-test&quot;&gt;What (Not) to Test&lt;/h2&gt;
&lt;p&gt;System tests are complementary to unit tests, not a substitute. It will do to test a happy path, plus maybe one path with an error message or redirect. System tests are not meant to test all the edge cases in the browser; just cover the main features.&lt;/p&gt;
&lt;p&gt;When choosing my test subject, I try to find an entity to test that reflects how the user uses the app. For the naming of my tests, I borrowed GitLab&amp;#39;s naming convention of ROLE_ACTION_test.rb, which fits this approach well. For instance: &lt;code&gt;user_shares_card_test.rb&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;general-tips-and-tricks&quot;&gt;General Tips and Tricks&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;If you use Devise for authentication, you can use the Devise integration helpers to log in and log out test users. Add &lt;code&gt;include Devise::Test::IntegrationHelpers&lt;/code&gt; to a test class, or add it in the &lt;code&gt;test_helper.rb&lt;/code&gt; file to make them available in all tests. Now you can create a user and &lt;code&gt;sign_in(@user)&lt;/code&gt;. If you put that in a &lt;code&gt;setup&lt;/code&gt; method, you don’t need to log out the user in a teardown. Rails takes care of cleaning up what&amp;#39;s in the setup method.&lt;/li&gt;
&lt;li&gt;Working with forms, it&amp;#39;s tempting to reference the ids that Rails creates automatically from model name + field name and the button types for &lt;code&gt;click_on&lt;/code&gt;s. ( &lt;code&gt;fill_in &amp;quot;user_email&amp;quot;&lt;/code&gt;, &lt;code&gt;click_on :commit&lt;/code&gt;). But since systems tests are about what a user would actually &lt;em&gt;see&lt;/em&gt; on their screen, it makes sense to use visible elements, i.e. texts. A reasonable option would be to have reference keys in i18n locale files and use those keys instead of the ever-changing literal texts. (&lt;code&gt;fill_in :user_email&lt;/code&gt;). Capybara finds the text only with the full I18n syntax: &lt;code&gt;assert_selector &amp;quot;h1&amp;quot;, text: I18n.t(&amp;quot;activerecord.models.things&amp;quot;)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The path helpers are included by default. For some libraries you need to include the helpers in the test class, for instance &lt;code&gt;include ActionMailer::TestHelper&lt;/code&gt;, to use the &lt;code&gt;assert_emails&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Create custom classes to run the tests on different screen sizes. &lt;a href=&quot;https://guides.rubyonrails.org/testing.html#testing-for-multiple-screen-sizes&quot;&gt;Check out the guides&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The screenshot feature can also be used to take screenshots for your documentation and promotional materials. If you make it a screencast and slow down the playback speed, you have a product video in minutes!&lt;/li&gt;
&lt;li&gt;Rails provides a generator for system tests.&lt;/li&gt;
&lt;li&gt;Minitest in Rails is slightly different than Minitest itself, and also adds Rails specific methods and assertions. Check the Rails docs first before the Minitest docs.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I had good fun with the system tests, and that was, for the most part, thanks to how easy it was to use it out-of-the-box.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;In this post, we looked at what configuration Rails delivers out-of-the-box and what minimal customizations we may want to add. Minitest is great for writing System tests. A few tips and tricks should help to get your first system tests up and running. Watch them do their magic in the browser!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Pros and Cons of Using structure.sql in Your Ruby on Rails Application</title>
    <link rel="alternate" href="https://blog.appsignal.com/2020/01/15/the-pros-and-cons-of-using-structure-sql-in-your-ruby-on-rails-application.html">
    <id>https://blog.appsignal.com/2020/01/15/the-pros-and-cons-of-using-structure-sql-in-your-ruby-on-rails-application.html</id>
    <published>2020-01-15T00:00:00+00:00</published>
    <updated>2020-01-15T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Discover the major differences and benefits of using structure.sql vs schema.rb in your Ruby on Rails application.</summary>
    <content type="html">&lt;p&gt;In today&amp;#39;s post, we&amp;#39;ll cover the significant differences and benefits of using &lt;code&gt;structure.sql&lt;/code&gt; versus the default &lt;code&gt;schema.rb&lt;/code&gt; schema formats in your Ruby on Rails application. In a data-driven world, knowing how to exploit all of your database&amp;#39;s rich features can make the difference between a successful and unsuccessful enterprise.&lt;/p&gt;
&lt;p&gt;After evincing the main differences between the two formats, we&amp;#39;ll outline how to switch to &lt;code&gt;structure.sql&lt;/code&gt; and demonstrate how it can help with ensuring data integrity as well as database functionality that you might otherwise not be able to preserve.&lt;/p&gt;
&lt;p&gt;In the post, I&amp;#39;ll give examples of a Rails app that makes use of &lt;code&gt;structure.sql&lt;/code&gt; with a PostgreSQL database, but the underlying concepts can be transposed to other databases as well. No real-world web application is truly complete without a reliable database to support it.&lt;/p&gt;
&lt;p&gt;Without further ado, let&amp;#39;s dive right in!&lt;/p&gt;
&lt;h2 id=&quot;the-difference-between-schemarb-and-structuresql&quot;&gt;The Difference Between schema.rb and structure.sql&lt;/h2&gt;
&lt;p&gt;One of the first things you need to do when starting a Ruby on Rails project is to run database migrations. If you generate a User model, for instance, Rails will inevitably ask you to run migrations, which will create a &lt;code&gt;schema.rb&lt;/code&gt; file accordingly:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails g model User first_name:string last_name:string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Rails will generate the following migration:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class CreateUsers &amp;lt; ActiveRecord::Migration[6.0]
  def change
    create_table :users do |t|
      t.string :first_name
      t.string :last_name

      t.timestamps
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the migration is executed, you will find that Rails generated a &lt;code&gt;schema.rb&lt;/code&gt; file for you:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ActiveRecord::Schema.define(version: 2019_12_14_074018) do

  # These are extensions that must be enabled in order to support this database
  enable_extension &amp;quot;plpgsql&amp;quot;

  create_table &amp;quot;users&amp;quot;, force: :cascade do |t|
    t.string &amp;quot;first_name&amp;quot;
    t.string &amp;quot;last_name&amp;quot;
    t.datetime &amp;quot;created_at&amp;quot;, precision: 6, null: false
    t.datetime &amp;quot;updated_at&amp;quot;, precision: 6, null: false
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;code&gt;schema.rb&lt;/code&gt; file is fantastic for relatively basic applications and use cases.&lt;/p&gt;
&lt;p&gt;There are two main things to notice here:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;It is a Ruby representation of your database; &lt;code&gt;schema.rb&lt;/code&gt; is created by inspecting the database and expressing its structure using Ruby.&lt;/li&gt;
&lt;li&gt;It is database-agnostic (i.e. whether you use SQLite, PostgreSQL, MySQL or any other database that Rails supports, the syntax and structure will remain largely the same)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;However, there may come a time when this strategy becomes too limiting for your growing app.&lt;/p&gt;
&lt;p&gt;Say, for instance, you have hundreds or thousands of migration files.&lt;/p&gt;
&lt;p&gt;If you need to rapidly spin up a new production system, you might encounter a scenario where running them all in sequence takes too long. Or you might face a situation where some migrations contain code that was meant to be executed on an older version of your database, but that is no longer executable on the current version. You might have a situation where migrations were written with certain data assumptions that are no longer valid, which would cause the migrations to fail.&lt;/p&gt;
&lt;p&gt;All these scenarios prevent efficiently setting up a new instance of your application⁠—be it in production or for a new team member⁠—with a simple &lt;code&gt;rails db:create db:migrate&lt;/code&gt; command. If this were the case, how would you go about getting up to speed with a correct database schema?&lt;/p&gt;
&lt;p&gt;Certainly, one way would be to go back and fix all the broken migrations. That&amp;#39;s never a bad idea!&lt;/p&gt;
&lt;p&gt;If going back and fixing a bunch of migrations is too costly, another way would be to run the &lt;code&gt;rails db:setup&lt;/code&gt; task. This task will generate a database schema from your &lt;code&gt;schema.rb&lt;/code&gt; file. However, what if your database contained complex logic that is not represented in the &lt;code&gt;schema.rb&lt;/code&gt; representation of your database?&lt;/p&gt;
&lt;p&gt;Luckily, Rails offers an alternative: &lt;code&gt;structure.sql&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;structure.sql&lt;/code&gt; differs from &lt;code&gt;schema.rb&lt;/code&gt; in the following ways:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It allows for an exact copy of the database structure. This is important when working with a team, as well as if you need to rapidly generate a new database in production from a &lt;code&gt;rails db:setup&lt;/code&gt; task.&lt;/li&gt;
&lt;li&gt;It allows preserving information of advanced database features. For example, if you are using PostgreSQL, it enables the use of views, materialized views, functions, constraints and so on.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once an application reaches a certain maturity level, we have to use every trick in the book to boost efficiency, preserve data correctness, and ensure blazing-fast performance. Using &lt;code&gt;structure.sql&lt;/code&gt; to manage the Rails database&amp;#39;s behavior allows users to do so.&lt;/p&gt;
&lt;h2 id=&quot;switching-from-schemarb-to-structuresql&quot;&gt;Switching From &lt;code&gt;schema.rb&lt;/code&gt; to &lt;code&gt;structure.sql&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Making the change from &lt;code&gt;schema.rb&lt;/code&gt; to &lt;code&gt;structure.sql&lt;/code&gt; is a relatively straightforward process. All you need to do is set the following line in &lt;code&gt;config/application.rb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module YourApp
  class Application &amp;lt; Rails::Application
    config.load_defaults 6.0

    # Add this line:
    config.active_record.schema_format = :sql
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, run &lt;code&gt;rails db:migrate&lt;/code&gt; and you should see the file in &lt;code&gt;db/structure.sql&lt;/code&gt;. Voilà! Rails will dump the database structure using the tool specific to the database you are using (in PostgreSQL&amp;#39;s case, that tool is &lt;code&gt;pg_dump&lt;/code&gt;, for MySQL or MariaDB, it will contain the output of &lt;code&gt;SHOW CREATE TABLE&lt;/code&gt; for each table, etc). It is advisable to ensure this file is under version control so that the rest of your team will have the same database structure.&lt;/p&gt;
&lt;p&gt;A first glance at that file may be daunting: the &lt;code&gt;schema.rb&lt;/code&gt; file was only 25 lines, whereas the &lt;code&gt;structure.sql&lt;/code&gt; file is a &lt;a href=&quot;https://gist.github.com/tombruijn/8ec144daed3e4993d73226bb24f035c6&quot;&gt;whopping 109 lines&lt;/a&gt;! What benefits could such a large file add to the app development?&lt;/p&gt;
&lt;h2 id=&quot;adding-database-level-constraints&quot;&gt;Adding Database-level Constraints&lt;/h2&gt;
&lt;p&gt;ActiveRecord is one of my favorite parts of using Rails. It allows you to query the database in a way that feels natural, almost like in a spoken language. For instance, if you want to find all a company&amp;#39;s users named Dan, then ActiveRecord allows you to simply run a query like the following:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;company = Company.find(name: &amp;#39;Some Company&amp;#39;)

# Reads just like in a natural language!
company.users.where(first_name: &amp;#39;Dan&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are some cases in which ActiveRecord falls short though. For instance, say you have the following validation on your User model:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User &amp;lt; ApplicationRecord
  validate :name_cannot_start_with_d

  private

  def name_cannot_start_with_d
    if first_name.present? &amp;amp;&amp;amp; first_name[0].downcase == &amp;#39;d&amp;#39;
      errors.add(:first_name, &amp;quot;cannot start with the letter &amp;#39;D&amp;#39;&amp;quot;)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If you try to create a user with the name &amp;#39;Dan&amp;#39;, you should see an error when the validation runs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;User.create!(first_name: &amp;#39;Dan&amp;#39;)
Traceback (most recent call last):
ActiveRecord::RecordInvalid (Validation failed: First name cannot start with the letter &amp;#39;D&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is fine, but suppose you or one of your team members changed the data by bypassing ActiveRecord&amp;#39;s validation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;u = User.create(first_name: &amp;#39;Pan&amp;#39;)

# The update_attribute method bypasses ActiveRecord validations
u.update_attribute :first_name, &amp;#39;Dan&amp;#39;
u.first_name
=&amp;gt; &amp;quot;Dan&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As demonstrated, it is very easy to bypass the validation.&lt;/p&gt;
&lt;p&gt;This can have disastrous consequences for our application. ActiveRecord can be a blessing as well as a curse⁠—while it has a very clean and natural DSL that makes it a pleasure to work with, it is often overly permissive when enforcing model-level validations. The solution, as you may already know, is to add database-level constraints.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails g migration AddFirstNameConstraintToUser
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will generate a file that you can edit with the logic to disallow first names that start with the letter &amp;#39;D&amp;#39;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class AddFirstNameConstraintToUser &amp;lt; ActiveRecord::Migration[6.0]
  def up
    execute &amp;quot;ALTER TABLE users ADD CONSTRAINT name_cannot_start_with_d CHECK (first_name !~* &amp;#39;^d&amp;#39;)&amp;quot;
  end

  def down
    execute &amp;quot;ALTER TABLE users DROP CONSTRAINT IF EXISTS name_cannot_start_with_d&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note that it is &lt;em&gt;very&lt;/em&gt; important to add code that successfully reverts the migration. In the above example, I have &lt;code&gt;up&lt;/code&gt; and &lt;code&gt;down&lt;/code&gt; directives. The &lt;code&gt;up&lt;/code&gt; method gets executed when the migration runs, &lt;code&gt;down&lt;/code&gt; gets executed when the migration is rolled back. Without properly reverting your database structure, you may have to do some manual house-cleaning later. I&amp;#39;d recommend always having a migration file that can be executed both &lt;code&gt;up&lt;/code&gt; and &lt;code&gt;down&lt;/code&gt; to avoid future headaches.&lt;/p&gt;
&lt;p&gt;Now, run the migration and check whether you can bypass that constraint:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;rails db:migrate
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;user = User.create first_name: &amp;#39;Pan&amp;#39;
user.update_attribute :first_name, &amp;#39;Dan&amp;#39;

ActiveRecord::StatementInvalid (PG::CheckViolation: ERROR:  new row for relation &amp;quot;users&amp;quot; violates check constraint &amp;quot;name_cannot_start_with_d&amp;quot;)
DETAIL:  Failing row contains (2, Dan, null, 2019-12-14 09:40:11.809358, 2019-12-14 09:40:41.658974).
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Perfect! Our constraint is working as intended. Even if, for whatever reason, we bypass ActiveRecord&amp;#39;s validation, we can still rely on the database⁠—our ultimate goalkeeper⁠—to preserve our data integrity.&lt;/p&gt;
&lt;p&gt;What does this have to do with &lt;code&gt;structure.sql&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;If you take a look at it, you&amp;#39;ll see that the following was added:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE public.users (
    id bigint NOT NULL,
    first_name character varying,
    last_name character varying,
    created_at timestamp(6) without time zone NOT NULL,
    updated_at timestamp(6) without time zone NOT NULL,
    CONSTRAINT name_cannot_start_with_d CHECK (((first_name)::text !~* &amp;#39;^d&amp;#39;::text)));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Your constraint is within the schema itself!&lt;/p&gt;
&lt;p&gt;While &lt;code&gt;schema.rb&lt;/code&gt; also supports database-level constraints, it is important to remember that it does not express everything your database may support such as triggers, sequences, stored procedures or check constraints. For example, this is what would happen to your schema file with the same exact migration (&lt;code&gt;AddFirstNameConstraintToUser&lt;/code&gt;) if you were just to use &lt;code&gt;schema.rb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ActiveRecord::Schema.define(version: 2019_12_14_074018) do

  # These are extensions that must be enabled in order to support this database
  enable_extension &amp;quot;plpgsql&amp;quot;

  create_table &amp;quot;users&amp;quot;, force: :cascade do |t|
    t.string &amp;quot;first_name&amp;quot;
    t.string &amp;quot;last_name&amp;quot;
    t.datetime &amp;quot;created_at&amp;quot;, precision: 6, null: false
    t.datetime &amp;quot;updated_at&amp;quot;, precision: 6, null: false
  end

end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The file has not changed! The constraint was not added.&lt;/p&gt;
&lt;p&gt;If you were to onboard a new developer to work on your project, you could potentially be operating under different database regulations.&lt;/p&gt;
&lt;p&gt;Committing &lt;code&gt;structure.sql&lt;/code&gt; to version control would help ensure that your team is on the same page. If you were to run &lt;code&gt;rails db:setup&lt;/code&gt; having a &lt;code&gt;structure.sql&lt;/code&gt; file, your database&amp;#39;s structure will contain the above constraint. With &lt;code&gt;schema.rb&lt;/code&gt; there is no such guarantee.&lt;/p&gt;
&lt;p&gt;The same can be said about a production system. If you needed to rapidly spin up a new instance of your application with a fresh database⁠—and running all migrations sequentially takes a long time⁠—setting up the database from the &lt;code&gt;structure.sql&lt;/code&gt; file would be a lot quicker. We can rest assured that the &lt;code&gt;structure.sql&lt;/code&gt; will create our database with the exact same structure as in other instances.&lt;/p&gt;
&lt;h2 id=&quot;growing-pains&quot;&gt;Growing Pains&lt;/h2&gt;
&lt;p&gt;Managing the concise &lt;code&gt;schema.rb&lt;/code&gt; file across a team is a far easier task than managing the verbose &lt;code&gt;structure.sql&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;One of the biggest growing pains when migrating to &lt;code&gt;structure.sql&lt;/code&gt; is ensuring that only the required changes get committed to that file, which can sometimes be difficult to do.&lt;/p&gt;
&lt;p&gt;Say, for instance, you pull someone&amp;#39;s branch and run the migrations specific to that branch. Your &lt;code&gt;structure.sql&lt;/code&gt; will now contain some changes. You then go back to working on your own branch and generate a new migration. Your &lt;code&gt;structure.sql&lt;/code&gt; file will now contain both your branch&amp;#39;s and the other branch&amp;#39;s changes. This can be a bit of a hassle to deal with, and there is undoubtedly a bit of a learning curve when it comes to managing these conflicts.&lt;/p&gt;
&lt;p&gt;By using this approach, we&amp;#39;re making a tradeoff. We have to deal with a bit of code complexity upfront that allows us to preserve our database&amp;#39;s advanced functionality. In turn, we also have to deal with a simpler schema representation as well as not having all the power of the database at our fingertips, e.g. if we want to set a backup from a &lt;code&gt;db:setup&lt;/code&gt; task. I posit that it&amp;#39;s best to put up with a bit of version-control hassle than to suffer through fixing corrupt/incorrect data in a production system, or to not be able to make use of all the advanced functionality that your database offers.&lt;/p&gt;
&lt;p&gt;Generally speaking, there are two strategies I&amp;#39;ve used to ensure my &lt;code&gt;structure.sql&lt;/code&gt; file only contains the necessary changes to a specific branch:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Once you are done working on a branch that contains migrations, make sure you run &lt;code&gt;rails db:rollback STEP=n&lt;/code&gt; where &lt;code&gt;n&lt;/code&gt; is the number of migrations in that branch. This will ensure your database structure reverts to its original state.&lt;/li&gt;
&lt;li&gt;You might forget to rollback after working on a branch. In that case, when working on a new branch, make sure you pull a pristine &lt;code&gt;structure.sql&lt;/code&gt; file from master before creating any new migrations.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;As a rule of thumb, your &lt;code&gt;structure.sql&lt;/code&gt; file should only contain the changes relevant to your branch before being merged into master.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Generally speaking, when Rails applications are small or don&amp;#39;t need some of the more advanced features that a database offers then it&amp;#39;s safe to use &lt;code&gt;schema.rb&lt;/code&gt;, which is very readable, concise and easy to manage.&lt;/p&gt;
&lt;p&gt;However, as an application grows in size and complexity, an accurate reflection of the database structure is of the essence. It will allow a team to maintain the right constraints, database modules, functions and operators that otherwise wouldn&amp;#39;t be possible. Learning to use Rails with a well-maintained &lt;code&gt;structure.sql&lt;/code&gt; file will offer an edge that the simpler &lt;code&gt;schema.rb&lt;/code&gt; simply cannot.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Top 10 AppSignal Blog Posts in 2019</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/12/17/top-10-appsigna-blog-posts-in-2019.html">
    <id>https://blog.appsignal.com/2019/12/17/top-10-appsigna-blog-posts-in-2019.html</id>
    <published>2019-12-17T00:00:00+00:00</published>
    <updated>2019-12-17T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Check out the most appreciated posts on our blog in 2019.</summary>
    <content type="html">&lt;p&gt;Hi there stroopwafel fans 👋&lt;/p&gt;
&lt;p&gt;As we&amp;#39;re looking forward to publishing more Ruby, Elixir, and JavaScript posts in the coming 2020, we decided to take a look back at the blog posts that you gave the most hearts on Twitter, reads on the blog, and that we got the most appreciation for in 2019.&lt;/p&gt;
&lt;h2 id=&quot;1-javascript-errors-an-exceptional-history-✨&quot;&gt;1. &lt;a href=&quot;/2019/10/17/javascript-errors-an-exceptional-history.html&quot;&gt;JavaScript Errors: An Exceptional History&lt;/a&gt; ✨&lt;/h2&gt;
&lt;p&gt;Join us as we go through the origins and turbulent years of growth of JavaScript and see it grow into the language it is today.&lt;/p&gt;
&lt;h2 id=&quot;2-building-and-playing-the-go-game-with-phoenix-liveview-⚗️&quot;&gt;2. &lt;a href=&quot;/2019/06/18/elixir-alchemy-building-go-with-phoenix-live-view.html&quot;&gt;Building and Playing the Go Game with Phoenix LiveView&lt;/a&gt; ⚗️&lt;/h2&gt;
&lt;p&gt;In this Elixir series, we built and played the Go game. The first part is all about implementing Go in Phoenix LiveView, and in the second part - &lt;a href=&quot;/2019/07/04/elixir-alchemy-building-go-in-elixir-time-travel-and-the-ko-rule.html&quot;&gt;Time Travel and the Ko Rule&lt;/a&gt;, we&amp;#39;ve added the ability to undo and redo moves and implement Go&amp;#39;s ko rule.&lt;/p&gt;
&lt;h2 id=&quot;3-object-marshalling-in-ruby-💎&quot;&gt;3. &lt;a href=&quot;/2019/03/26/object-marshalling-in-ruby.html&quot;&gt;Object Marshalling in Ruby&lt;/a&gt; 💎&lt;/h2&gt;
&lt;p&gt;In this article, we took a deep dive into object marshalling. Find out what it is, look at the Marshall module, and then go through an example. Then, go a step deeper and compare the &lt;code&gt;_dump&lt;/code&gt; and &lt;code&gt;self._load&lt;/code&gt; methods.&lt;/p&gt;
&lt;h2 id=&quot;4-rubys-hidden-gems-delegator-and-forwardable-💎&quot;&gt;4. &lt;a href=&quot;/2019/04/30/ruby-magic-hidden-gems-delegator-forwardable.html&quot;&gt;Ruby&amp;#39;s Hidden Gems: Delegator and Forwardable&lt;/a&gt; 💎&lt;/h2&gt;
&lt;p&gt;In this exploration of Ruby&amp;#39;s standard library, we&amp;#39;ve looked at delegation through Ruby&amp;#39;s Delegator and Forwardable classes.&lt;/p&gt;
&lt;h2 id=&quot;5-learning-by-building-a-background-processing-system-in-ruby-💎&quot;&gt;5. &lt;a href=&quot;/2019/04/02/background-processing-system-in-ruby.html&quot;&gt;Learning by Building a Background Processing System in Ruby&lt;/a&gt; 💎&lt;/h2&gt;
&lt;p&gt;We implemented a naive background processing system for fun! Learn some things along the way as a peek into the internals of popular background processing systems like Sidekiq.&lt;/p&gt;
&lt;h2 id=&quot;6-serving-plug-building-an-elixir-http-server-from-scratch-⚗️&quot;&gt;6. &lt;a href=&quot;/2019/01/22/serving-plug-building-an-elixir-http-server.html&quot;&gt;Serving Plug: Building an Elixir HTTP Server From Scratch&lt;/a&gt; ⚗️&lt;/h2&gt;
&lt;p&gt;As we&amp;#39;re on a continuous quest to find out what’s happening under the hood, we took a deep dive into HTTP servers in Elixir.&lt;/p&gt;
&lt;h2 id=&quot;7-routing-in-phoenix-umbrella-apps-⚗️&quot;&gt;7. &lt;a href=&quot;/2019/04/16/elixir-alchemy-routing-phoenix-umbrella-apps.html&quot;&gt;Routing in Phoenix Umbrella Apps&lt;/a&gt; ⚗️&lt;/h2&gt;
&lt;p&gt;Umbrella apps are an awesome way to structure Elixir projects. Behind the curtains, they are a very thin layer that just compiles everything to a single package. Instead of building a single large monolith, you can structure your code with multiple isolated contexts...&lt;/p&gt;
&lt;h2 id=&quot;8-bindings-and-lexical-scope-in-ruby-💎&quot;&gt;8. &lt;a href=&quot;/2019/01/08/ruby-magic-bindings-and-lexical-scope.html&quot;&gt;Bindings and Lexical Scope in Ruby&lt;/a&gt; 💎&lt;/h2&gt;
&lt;p&gt;In this winter episode, we’ll went into bindings and scopes. So put on your skis and follow us deep into the woods.&lt;/p&gt;
&lt;h2 id=&quot;9-unraveling-classes-instances-and-metaclasses-in-ruby-💎&quot;&gt;9. &lt;a href=&quot;/2019/02/05/ruby-magic-classes-instances-and-metaclasses.html&quot;&gt;Unraveling Classes, Instances and Metaclasses in Ruby&lt;/a&gt; 💎&lt;/h2&gt;
&lt;p&gt;Through examining metaclasses, learn how class and instance methods work in Ruby. Along the way, discover the difference between defining a method by passing an explicit “definee” and using &lt;code&gt;class &amp;lt;&amp;lt; self&lt;/code&gt; or &lt;code&gt;instance_eval&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;10-productive-procrastination-for-programmers---works-for-ruby-and-elixir-💎⚗️✨&quot;&gt;10. &lt;a href=&quot;/2019/07/09/productive-procrastination-for-programmers.html&quot;&gt;Productive Procrastination for Programmers - works for Ruby and Elixir&lt;/a&gt; 💎⚗️✨&lt;/h2&gt;
&lt;p&gt;We pushed this post until the very end of this list in a true procrastination fashion. This is a partly-ironic, not-so-serious post on productivity, but increased productivity might actually result from reading it. It is all about the sweetness of procrastination, of pushing away that task you dread, the proverbial frog you need to eat. Take it with a grain of salt.&lt;/p&gt;
&lt;h2 id=&quot;holiday-season-is-approaching-🎊🎉🎄❄️&quot;&gt;Holiday Season is Approaching 🎊🎉🎄❄️&lt;/h2&gt;
&lt;p&gt;That was all for this roundup of favorite articles of 2019! The whole AppSignal team wishes you all the best for the coming year, with little errors, many amazing insights and even more amazing articles ☃️&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. Don&amp;#39;t forget to subscribe to our &lt;a href=&quot;/ruby-magic&quot;&gt;Ruby Magic&lt;/a&gt;, &lt;a href=&quot;/elixir-alchemy&quot;&gt;Elixir Alchemy&lt;/a&gt;, and &lt;a href=&quot;/javascript-sorcery&quot;&gt;JavaScript Sorcery&lt;/a&gt; newsletters!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Configurable Ruby Modules: The Module Builder Pattern</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/11/29/configurable-ruby-modules-the-module-builder-pattern.html">
    <id>https://blog.appsignal.com/2019/11/29/configurable-ruby-modules-the-module-builder-pattern.html</id>
    <published>2019-11-29T00:00:00+00:00</published>
    <updated>2019-11-29T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Explore how to implement configurable modules in Ruby — a technique sometimes referred to as the Module Builder Pattern.</summary>
    <content type="html">&lt;p&gt;In this post, we&amp;#39;ll explore how to create Ruby modules that are configurable by users of our code — a pattern that allows gem authors to add more flexibility to their libraries.&lt;/p&gt;
&lt;p&gt;Most Ruby developers are familiar with using modules to share behavior. After all, this is one of their main use cases, according to the documentation:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Modules serve two purposes in Ruby, namespacing and mixin functionality.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Rails added some syntactic sugar in the form of &lt;a href=&quot;https://api.rubyonrails.org/classes/ActiveSupport/Concern.html&quot;&gt;&lt;code&gt;ActiveSupport::Concern&lt;/code&gt;&lt;/a&gt;, but the general principle remains the same.&lt;/p&gt;
&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;Using modules to provide mixin functionality is usually straightforward. All we have to do is bundle up some methods and include our module elsewhere:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module HelloWorld
  def hello
    &amp;quot;Hello, world!&amp;quot;
  end
end
class Test
  include HelloWorld
end
Test.new.hello
#=&amp;gt; &amp;quot;Hello, world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is a pretty static mechanism, though Ruby&amp;#39;s &lt;code&gt;inherited&lt;/code&gt; and &lt;code&gt;extended&lt;/code&gt; hook methods allow for some varying behavior based on the including class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module HelloWorld
  def self.included(base)
    define_method :hello do
      &amp;quot;Hello, world from #{base}!&amp;quot;
    end
  end
end
class Test
  include HelloWorld
end
Test.new.hello
#=&amp;gt; &amp;quot;Hello, world from Test!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is somewhat more dynamic but still doesn&amp;#39;t allow our code users to, for instance, rename the &lt;code&gt;hello&lt;/code&gt; method at module inclusion time.&lt;/p&gt;
&lt;h2 id=&quot;the-solution-configurable-ruby-modules&quot;&gt;The Solution: Configurable Ruby Modules&lt;/h2&gt;
&lt;p&gt;Over the past few years, a new pattern has emerged that solves this problem, which people sometimes refer to as the &amp;quot;module builder pattern&amp;quot;. This technique relies on two primary features of Ruby:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Modules are just like any other objects—they can be created on the fly, assigned to variables, dynamically modified, as well as passed to or returned from methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def make_module
  # create a module on the fly and assign it to variable
  mod = Module.new

  # modify module
  mod.module_eval do
    def hello
      &amp;quot;Hello, AppSignal world!&amp;quot;
    end
  end

  # explicitly return it
  mod
end
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The argument to &lt;code&gt;include&lt;/code&gt; or &lt;code&gt;extend&lt;/code&gt; calls doesn&amp;#39;t have to be a module, it can also be an expression returning one, e.g. a method call.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Test
  # include the module returned by make_module
  include make_module
end

Test.new.hello
#=&amp;gt; &amp;quot;Hello, AppSignal world!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;module-builder-in-action&quot;&gt;Module Builder in Action&lt;/h2&gt;
&lt;p&gt;We will now use this knowledge to build a simple module called &lt;code&gt;Wrapper&lt;/code&gt;, which implements the following behavior:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A class including &lt;code&gt;Wrapper&lt;/code&gt; can only wrap objects of a specific type. The constructor will verify the argument type and raise an error if the type doesn&amp;#39;t match what&amp;#39;s expected.&lt;/li&gt;
&lt;li&gt;The wrapped object will be available through an instance method called &lt;code&gt;original_&amp;lt;class&amp;gt;&lt;/code&gt;, e.g. &lt;code&gt;original_integer&lt;/code&gt; or &lt;code&gt;original_string&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;It will allow consumers of our code to specify an alternative name for this accessor method, for example, &lt;code&gt;the_string&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Let&amp;#39;s take a look at how we want our code to behave:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# 1
class IntWrapper
 # 2
 include Wrapper.for(Integer)
end

# 3
i = IntWrapper.new(42)
i.original_integer
#=&amp;gt; 42

# 4
i = IntWrapper.new(&amp;quot;42&amp;quot;)
#=&amp;gt; TypeError (not a Integer)

# 5
class StringWrapper
 include Wrapper.for(String, accessor_name: :the_string)
end

s = StringWrapper.new(&amp;quot;Hello, World!&amp;quot;)
# 6
s.the_string
#=&amp;gt; &amp;quot;Hello, World!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In step 1, we define a new class called &lt;code&gt;IntWrapper&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In step 2, we ensure that this class doesn&amp;#39;t simply include a module by name but instead, mixes in the result of a call to &lt;code&gt;Wrapper.for(Integer)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In step 3, we instantiate an object of our new class and assign it to &lt;code&gt;i&lt;/code&gt;. As specified, this object has a method called &lt;code&gt;original_integer&lt;/code&gt;, that satisfies one of our requirements.&lt;/p&gt;
&lt;p&gt;In step 4, if we try to pass in an argument of the wrong type, like a string, a helpful &lt;code&gt;TypeError&lt;/code&gt; will be raised. Finally, let&amp;#39;s verify that users are able to specify custom accessor names.&lt;/p&gt;
&lt;p&gt;For this, we define a new class called &lt;code&gt;StringWrapper&lt;/code&gt; in step 5 and pass &lt;code&gt;the_string&lt;/code&gt; as the keyword argument &lt;code&gt;accessor_name&lt;/code&gt;, which we see in action in step 6.&lt;/p&gt;
&lt;p&gt;While this is admittedly a somewhat contrived example, it has just enough varying behavior to show off the module builder pattern and how it is used.&lt;/p&gt;
&lt;h3 id=&quot;first-attempt&quot;&gt;First Attempt&lt;/h3&gt;
&lt;p&gt;Based on the requirements and usage example, we can now begin the implementation. We already know that we need a module named &lt;code&gt;Wrapper&lt;/code&gt; with a module-level method called &lt;code&gt;for&lt;/code&gt;, which takes a class as an optional keyword argument:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Wrapper
 def self.for(klass, accessor_name: nil)
 end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since the return value of this method becomes the argument to &lt;code&gt;include&lt;/code&gt;, it needs to be a module. Thus, we can create a new anonymous one with &lt;code&gt;Module.new&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Module.new do
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As per our requirements, this needs to define a constructor which verifies the type of the passed-in object, as well as an appropriately named accessor method. Let&amp;#39;s start with the constructor:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;define_method :initialize do |object|
 raise TypeError, &amp;quot;not a #{klass}&amp;quot; unless object.is_a?(klass)
 @object = object
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This piece of code uses &lt;a href=&quot;https://ruby-doc.org/core-2.6.5/Module.html#method-i-define_method&quot;&gt;&lt;code&gt;define_method&lt;/code&gt;&lt;/a&gt; to dynamically add an instance method to the receiver. Since the block acts as a closure, it can use the &lt;code&gt;klass&lt;/code&gt; object from the outer scope to perform the required type check.&lt;/p&gt;
&lt;p&gt;Adding an appropriately named accessor method is not that much harder:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# 1
method_name = accessor_name || begin
 klass_name = klass.to_s.gsub(/(.)([A-Z])/,&amp;#39;\1_\2&amp;#39;).downcase
 &amp;quot;original_#{klass_name}&amp;quot;
end

# 2
define_method(method_name) { @object }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we need to see if the caller of our code passed in an &lt;code&gt;accessor_name&lt;/code&gt;. If so, we just assign it to &lt;code&gt;method_name&lt;/code&gt; and are then done. Otherwise, we take the class and convert it to an underscored string, for instance, &lt;code&gt;Integer&lt;/code&gt; turns into &lt;code&gt;integer&lt;/code&gt; or &lt;code&gt;OpenStruct&lt;/code&gt; into &lt;code&gt;open_struct&lt;/code&gt;. This &lt;code&gt;klass_name&lt;/code&gt; variable is then prefixed with &lt;code&gt;original_&lt;/code&gt; to generate the final accessor name. Once we know the method’s name, we again use &lt;code&gt;define_method&lt;/code&gt; to add it to our module, as shown in step 2.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s the complete code up to this point. Less than 20 lines for a flexible and configurable Ruby module; not too bad.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Wrapper
  def self.for(klass, accessor_name: nil)
    Module.new do
      define_method :initialize do |object|
        raise TypeError, &amp;quot;not a #{klass}&amp;quot; unless object.is_a?(klass)
        @object = object
      end

      method_name = accessor_name || begin
        klass_name = klass.to_s.gsub(/(.)([A-Z])/,&amp;#39;\1_\2&amp;#39;).downcase
        &amp;quot;original_#{klass_name}&amp;quot;
      end

      define_method(method_name) { @object }
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Observant readers might remember that &lt;code&gt;Wrapper.for&lt;/code&gt; returns an anonymous module. This isn&amp;#39;t a problem, but can get a bit confusing when examining an object&amp;#39;s inheritance chain:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;StringWrapper.ancestors
#=&amp;gt; [StringWrapper, #&amp;lt;Module:0x0000000107283680&amp;gt;, Object, Kernel, BasicObject]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here &lt;code&gt;#&amp;lt;Module:0x0000000107283680&amp;gt;&lt;/code&gt; (the name will vary if you are following along) refers to our anonymous module.&lt;/p&gt;
&lt;h3 id=&quot;improved-version&quot;&gt;Improved Version&lt;/h3&gt;
&lt;p&gt;Let&amp;#39;s make life easier for our users by returning a named module instead of an anonymous one. The code for this is very similar to what we had before, with some minor changes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Wrapper
  def self.for(klass, accessor_name: nil)
    # 1
    mod = const_set(&amp;quot;#{klass}InstanceMethods&amp;quot;, Module.new)

    # 2
    mod.module_eval do
      define_method :initialize do |object|
        raise TypeError, &amp;quot;not a #{klass}&amp;quot; unless object.is_a?(klass)
        @object = object
      end

      method_name = accessor_name || begin
        klass_name = klass.to_s.gsub(/(.)([A-Z])/, &amp;#39;\1_\2&amp;#39;).downcase
        &amp;quot;original_#{klass_name}&amp;quot;
      end

      define_method(method_name) { @object }
    end

    # 3
    mod
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the first step, we create a nested module called &lt;code&gt;&amp;quot;#{klass}InstanceMethods&amp;quot;&lt;/code&gt; (for example &lt;code&gt;IntegerInstanceMethods&lt;/code&gt;), that is just an “empty” module.&lt;/p&gt;
&lt;p&gt;As shown in step 2, we use &lt;a href=&quot;https://ruby-doc.org/core-2.6.5/Module.html#method-i-module_eval&quot;&gt;&lt;code&gt;module_eval&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;for&lt;/code&gt; method, which evaluates a block of code in the context of the module it’s called on. This way, we can add behavior to the module before returning it in step 3.&lt;/p&gt;
&lt;p&gt;If we now examine the ancestors of a class including &lt;code&gt;Wrapper&lt;/code&gt;, the output will include a properly named module, which is much more meaningful and easier to debug than the previous anonymous module.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;StringWrapper.ancestors
#=&amp;gt; [StringWrapper, Wrapper::StringInstanceMethods, Object, Kernel, BasicObject]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;the-module-builder-pattern-in-the-wild&quot;&gt;The Module Builder Pattern in the Wild&lt;/h2&gt;
&lt;p&gt;Apart from this post, where else can we find the module builder pattern or similar techniques?&lt;/p&gt;
&lt;p&gt;One example is the &lt;a href=&quot;https://dry-rb.org/&quot;&gt;&lt;code&gt;dry-rb&lt;/code&gt;&lt;/a&gt; family of gems, where, for example, &lt;a href=&quot;https://dry-rb.org/gems/dry-effects&quot;&gt;&lt;code&gt;dry-effects&lt;/code&gt;&lt;/a&gt; uses module builders to pass configuration options to the various effect handlers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# This adds a `counter` effect provider. It will handle (eliminate) effects
include Dry::Effects::Handler.State(:counter)

# Providing scope is required
# All cache values will be scoped with this key
include Dry::Effects::Handler.Cache(:blog)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can find similar usage in the excellent &lt;a href=&quot;https://shrinerb.com/&quot;&gt;Shrine&lt;/a&gt; gem, which provides a file upload toolkit for Ruby applications:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Photo &amp;lt; Sequel::Model
  include Shrine::Attachment(:image)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This pattern is still relatively new, but I expect we&amp;#39;ll see more of it in the future, especially in gems that focus more on pure Ruby applications than Rails ones.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;In this post, we explored how to implement configurable modules in Ruby, a technique sometimes referred to as the module builder pattern. Like other metaprogramming techniques, this comes at the cost of increased complexity and therefore shouldn&amp;#39;t be used without good reason. However, in the rare cases where such flexibility is needed, Ruby&amp;#39;s object model once again allows for an elegant and concise solution. The module builder pattern isn&amp;#39;t something most Ruby developers will need often, but it&amp;#39;s a great tool to have in one&amp;#39;s toolkit, especially for library authors.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;P.S. If you&amp;#39;d like to read Ruby Magic posts as soon as they get off the press, &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to our Ruby Magic newsletter and never miss a single post&lt;/a&gt;!&lt;/strong&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Ruby Templating: Baking an Interpreter</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/09/24/ruby-magic-baking-an-interpreter.html">
    <id>https://blog.appsignal.com/2019/09/24/ruby-magic-baking-an-interpreter.html</id>
    <published>2019-09-24T00:00:00+00:00</published>
    <updated>2019-09-24T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In this post, we'll bake our own Interpreter, bringing the Templating series together with a lot of sticky stroop.</summary>
    <content type="html">&lt;p&gt;We hope you’ve got your stroopwafels warmed on top of your coffee because today we’re gluing things up with sticky stroop (the syrup that makes the two halves of a stroopwafel stick together). In the first two parts of our series, we baked a &lt;a href=&quot;/2019/07/02/ruby-magic-brewing-our-own-template-lexer-in-ruby.html&quot;&gt;Lexer&lt;/a&gt; and a &lt;a href=&quot;/2019/07/30/ruby-magic-ruby-templating-the-parser.html&quot;&gt;Parser&lt;/a&gt; and now, we’re adding the Interpreter and gluing things together by pouring stroop over them.&lt;/p&gt;
&lt;h2 id=&quot;ingredients&quot;&gt;Ingredients&lt;/h2&gt;
&lt;p&gt;Alright! Let’s get the kitchen ready for baking and put our ingredients on the table. Our interpreter needs two ingredients or pieces of information to do its job: the previously generated Abstract Syntax Tree (AST) and the data we want to embed into the template. We’ll call this data the &lt;code&gt;environment&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To traverse the AST, we’ll implement the interpreter using the &lt;a href=&quot;https://en.wikipedia.org/wiki/Visitor_pattern&quot;&gt;visitor pattern&lt;/a&gt;. A visitor (and therefore our interpreter) implements a generic visit method that accepts a node as a parameter, processes this node and potentially calls the &lt;code&gt;visit&lt;/code&gt; method again with some (or all) of the node’s children, depending on what makes sense for the current node.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magicbars
  class Interpreter
    attr_reader :root, :environment

    def self.render(root, environment = {})
      new(root, environment).render
    end

    def initialize(root, environment = {})
      @root = root
      @environment = environment
    end

    def render
      visit(root)
    end

    def visit(node)
      # Process node
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Before continuing, let’s also create a small &lt;code&gt;Magicbars.render&lt;/code&gt; method that accepts a template and an environment and outputs the rendered template.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magicbars
  def self.render(template, environment = {})
    tokens = Lexer.tokenize(template)
    ast = Parser.parse(tokens)
    Interpreter.render(ast, environment)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With this in place, we’ll be able to test the interpreter without having to construct the AST by hand.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars.render(&amp;#39;Welcome to {{name}}&amp;#39;, name: &amp;#39;Ruby Magic&amp;#39;)
# =&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To no surprise, it currently doesn’t return anything. So let’s start implementing the &lt;code&gt;visit&lt;/code&gt; method. As a quick reminder, here’s what the AST for this template looks like.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2019-09/simple-ast.svg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;For this template, we’ll have to process four different node types: &lt;code&gt;Template&lt;/code&gt;, &lt;code&gt;Content&lt;/code&gt;, &lt;code&gt;Expression&lt;/code&gt;, and &lt;code&gt;Identifier&lt;/code&gt;. To do this, we could just put a huge &lt;code&gt;case&lt;/code&gt; statement inside our &lt;code&gt;visit&lt;/code&gt; method. However, this will become unreadable pretty quickly. Instead, let’s make use of Ruby’s metaprogramming capabilities to keep our code a bit more organized and readable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magicbars
  class Interpreter
    # ...

    def visit(node)
      short_name = node.class.to_s.split(&amp;#39;::&amp;#39;).last
      send(&amp;quot;visit_#{short_name}&amp;quot;, node)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method accepts a node, gets its class name, and removes any modules from it (check out our article on &lt;a href=&quot;/2019/08/20/clean-up-strings.html&quot;&gt;cleaning strings&lt;/a&gt; if you’re interested in different ways of doing this). Afterward, we use &lt;code&gt;send&lt;/code&gt; to call a method that handles this specific type of node. The method name for each type is made up of the demodulized class name and the &lt;code&gt;visit_&lt;/code&gt; prefix. It’s a bit unusual to have capital letters in method names, but it makes the method’s intent pretty clear.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magicbars
  class Interpreter
    # ...

    def visit_Template(node)
      # Process template nodes
    end

    def visit_Content(node)
      # Process content nodes
    end

    def visit_Expression(node)
      # Process expression nodes
    end

    def visit_Identifier(node)
      # Process identifier nodes
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s start by implementing the &lt;code&gt;visit_Template&lt;/code&gt; method. It should just process all the &lt;code&gt;statements&lt;/code&gt; of the node and join the results.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def visit_Template(node)
  node.statements.map { |statement| visit(statement) }.join
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, let’s look at the &lt;code&gt;visit_Content&lt;/code&gt; method. As a content node just wraps a string, the method is as simple as it gets.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def visit_Content(node)
  node.content
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, let’s move on to the &lt;code&gt;visit_Expression&lt;/code&gt; method where the substitution of the placeholder with the real value happens.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def visit_Expression(node)
  key = visit(node.identifier)
  environment.fetch(key, &amp;#39;&amp;#39;)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And finally, for the &lt;code&gt;visit_Expression&lt;/code&gt; method to know what key to fetch from the environment, let’s implement the &lt;code&gt;visit_Identifier&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def visit_Identifier(node)
  node.value
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With these four methods in place, we get the desired result when we try to render the template again.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars.render(&amp;#39;Welcome to {{name}}&amp;#39;, name: &amp;#39;Ruby Magic&amp;#39;)
# =&amp;gt; Welcome to Ruby Magic
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;interpreting-block-expressions&quot;&gt;Interpreting Block Expressions&lt;/h2&gt;
&lt;p&gt;We wrote a lot of code to implement what a simple &lt;code&gt;gsub&lt;/code&gt; could do. So let’s move on to a more complex example.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Welcome to {{name}}!

{{#if subscribed}}
  Thank you for subscribing to our mailing list.
{{else}}
  Please sign up for our mailing list to be notified about new articles!
{{/if}}

Your friends at {{company_name}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a reminder, here’s what the corresponding AST looks like.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2019-09/complex-ast.svg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;There’s only one node type that we don’t yet handle. It’s the &lt;code&gt;visit_BlockExpression&lt;/code&gt; node. In a way, it is similar to the &lt;code&gt;visit_Expression&lt;/code&gt; node, but depending on the value it either continues to process the &lt;code&gt;statements&lt;/code&gt; or the &lt;code&gt;inverse_statements&lt;/code&gt; of the &lt;code&gt;BlockExpression&lt;/code&gt; node.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def visit_BlockExpression(node)
  key = visit(node.identifier)

  if environment[key]
    node.statements.map { |statement| visit(statement) }.join
  else
    node.inverse_statements.map { |statement| visit(statement) }.join
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at the method, we notice that the two branches are very similar, and they also look similar to the &lt;code&gt;visit_Template&lt;/code&gt; method. They all handle the visiting of all nodes of an &lt;code&gt;Array&lt;/code&gt;, so let’s extract a &lt;code&gt;visit_Array&lt;/code&gt; method to clean things up a bit.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def visit_Array(nodes)
  nodes.map { |node| visit(node) }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the new method in place, we can remove some code from the &lt;code&gt;visit_Template&lt;/code&gt; and &lt;code&gt;visit_BlockExpression&lt;/code&gt; methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def visit_Template(node)
  visit(node.statements).join
end

def visit_BlockExpression(node)
  key = visit(node.identifier)

  if environment[key]
    visit(node.statements).join
  else
    visit(node.inverse_statements).join
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that our interpreter handles all node types, let’s try and render the complex template.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars.render(template, { name: &amp;#39;Ruby Magic&amp;#39;, subscribed: true, company_name: &amp;#39;AppSignal&amp;#39; })
# =&amp;gt; Welcome to Ruby Magic!
#
#
#  Please sign up for our mailing list to be notified about new articles!
#
#
# Your friends at AppSignal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That &lt;em&gt;almost&lt;/em&gt; looks right. But on a closer look, we notice that the message is prompting us to sign up for the mailing list, even though we provided &lt;code&gt;subscribed: true&lt;/code&gt; in the environment. That doesn’t seem right…&lt;/p&gt;
&lt;h2 id=&quot;adding-support-for-helper-methods&quot;&gt;Adding Support for Helper Methods&lt;/h2&gt;
&lt;p&gt;Looking back at the template, we notice that there’s an &lt;code&gt;if&lt;/code&gt; in the block expression. Instead of looking up the value of &lt;code&gt;subscribed&lt;/code&gt; in the environment, the &lt;code&gt;visit_BlockExpression&lt;/code&gt; is looking up the value of &lt;code&gt;if&lt;/code&gt;. As it is not present in the environment, the call returns &lt;code&gt;nil&lt;/code&gt;, which is false.&lt;/p&gt;
&lt;p&gt;We could stop here and declare that we’re not trying to imitate &lt;a href=&quot;https://handlebarsjs.com&quot;&gt;Handlebars&lt;/a&gt; but &lt;a href=&quot;https://mustache.github.io&quot;&gt;Mustache&lt;/a&gt;, and get rid of the &lt;code&gt;if&lt;/code&gt; in the template, which will give us the desired result.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Welcome to {{name}}!

{{#subscribed}}
  Thank you for subscribing to our mailing list.
{{else}}
  Please sign up for our mailing list to be notified about new articles!
{{/subscribed}}

Your friends at {{company_name}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But why stop when we are having fun? Let’s go the extra mile and implement helper methods. They might come in handy for other things as well.&lt;/p&gt;
&lt;p&gt;Let’s start by adding a helper method support to simple expressions. We’ll add a &lt;code&gt;reverse&lt;/code&gt; helper, that reverses strings passed to it. In addition, we’ll add a &lt;code&gt;debug&lt;/code&gt; method that tells us the class name of a given value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def helpers
  @helpers ||= {
    reverse: -&amp;gt;(value) { value.to_s.reverse },
    debug: -&amp;gt;(value) { value.class }
  }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use simple lambdas to implement these helpers and store them in a hash so that we can look them up by their name.&lt;/p&gt;
&lt;p&gt;Next, let’s modify &lt;code&gt;visit_Expression&lt;/code&gt; to perform a helper lookup before trying a value lookup in the environment.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def visit_Expression(node)
  key = visit(node.identifier)

  if helper = helpers[key]
    arguments = visit(node.arguments).map { |k| environment[k] }

    return helper.call(*arguments)
  end

  environment[key]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If there is a helper matching the given identifier, the method will visit all the arguments and try to lookup values for them. Afterward, it will call the method and pass all the values as arguments.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars.render(&amp;#39;Welcome to {{reverse name}}&amp;#39;, name: &amp;#39;Ruby Magic&amp;#39;)
# =&amp;gt; Welcome to cigaM ybuR

Magicbars.render(&amp;#39;Welcome to {{debug name}}&amp;#39;, name: &amp;#39;Ruby Magic&amp;#39;)
# =&amp;gt; Welcome to String
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that in place, let’s finally implement an &lt;code&gt;if&lt;/code&gt; and an &lt;code&gt;unless&lt;/code&gt; helper. In addition to the arguments, we’ll pass two lambdas to them so that they can decide if we should continue interpreting the node’s &lt;code&gt;statements&lt;/code&gt; or &lt;code&gt;inverse_statements&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def helpers
  @helpers ||= {
    if: -&amp;gt;(value, block:, inverse_block:) { value ? block.call : inverse_block.call },
    unless: -&amp;gt;(value, block:, inverse_block:) { value ? inverse_block.call : block.call },
    # ...
  }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The necessary changes to &lt;code&gt;visit_BlockExpression&lt;/code&gt; are similar to what we did with &lt;code&gt;visit_Expression&lt;/code&gt;, only this time, we also pass the two lambdas.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def visit_BlockExpression(node)
  key = visit(node.identifier)

  if helper = helpers[key]
    arguments = visit(node.arguments).map { |k| environment[k] }

    return helper.call(
      *arguments,
      block: -&amp;gt; { visit(node.statements).join },
      inverse_block: -&amp;gt; { visit(node.inverse_statements).join }
    )
  end

  if environment[key]
    visit(node.statements).join
  else
    visit(node.inverse_statements).join
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And with this, our baking is done! We can render the complex template that started this journey into the world of lexers, parsers, and interpreters.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars.render(template, { name: &amp;#39;Ruby Magic&amp;#39;, subscribed: true, company_name: &amp;#39;AppSignal&amp;#39; })
# =&amp;gt; Welcome to Ruby Magic!
#
#
#  Thank you for subscribing to our mailing list.
#
#
# Your friends at AppSignal
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;only-scratching-the-surface&quot;&gt;Only Scratching the Surface&lt;/h2&gt;
&lt;p&gt;In this three-part series, we covered the basics of creating a templating language. These concepts can also be used to create interpreted programming languages (like Ruby). Admittedly, we glossed over a couple of things (like proper error handling 🙀) and only scratched the surface of the underpinnings of today’s programming languages.&lt;/p&gt;
&lt;p&gt;We hope you enjoyed the series and if you want more of that, &lt;a href=&quot;/ruby-magic&quot;&gt;subsribe to the Ruby Magic list&lt;/a&gt;. If you are now hungry for stroopwafels, &lt;a href=&quot;mailto:support@appsignal.com?subject=I%20would%20like%20some%20stroopwafels&amp;amp;body=Hi%20there,%20AppSignal%20rocks!%20Can%20you%20send%20some%20stroopwafels%20to...&quot;&gt;drop us a line&lt;/a&gt; and we might be able to fuel you with those as well!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Type Checking in Ruby — Check Yo Self Before You Wreck Yo Self</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/08/27/ruby-magic-type-checking-in-ruby.html">
    <id>https://blog.appsignal.com/2019/08/27/ruby-magic-type-checking-in-ruby.html</id>
    <published>2019-08-27T00:00:00+00:00</published>
    <updated>2019-08-27T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">A splash into Duck Typing, gradual typing and enjoying Sorbet on a typical summer day</summary>
    <content type="html">&lt;p&gt;Let&amp;#39;s start this post with a fun little guessing game: what do you think is the most common error tracked by AppSignal in Ruby applications?&lt;/p&gt;
&lt;p&gt;It&amp;#39;s fair to assume that many of you answered this question with &lt;code&gt;NoMethodError&lt;/code&gt;, an exception that is caused by calling a non-existent method on an object. Occasionally, this may be caused by a typo in the method name, but more often it&amp;#39;s the result of calling a method on an object of the wrong type, which often happens to be an unexpected &lt;code&gt;nil&lt;/code&gt;. Is there something we can do as Ruby developers to reduce the frequency of such errors?&lt;/p&gt;
&lt;h2 id=&quot;types-to-the-rescue&quot;&gt;Types to the Rescue?&lt;/h2&gt;
&lt;p&gt;Except for the choice of text editor or programming language, few topics can spiral into heated debates faster than discussions of type systems. We won&amp;#39;t have time to go into details here, but Chris Smith&amp;#39;s post &lt;a href=&quot;https://blog.steveklabnik.com/posts/2010-07-17-what-to-know-before-debating-type-systems&quot;&gt;&amp;quot;What To Know Before Debating Type Systems&amp;quot;&lt;/a&gt; does an excellent job at that.&lt;/p&gt;
&lt;p&gt;In the broadest terms, type systems can be divided into two main categories—static and dynamic. While the former happens ahead of time (either via the compiler or a separate tool), dynamic type checking occurs during runtime, where it may lead to exceptions if the actual types don&amp;#39;t align with the developer&amp;#39;s expectations.&lt;/p&gt;
&lt;p&gt;Proponents of both philosophies have strong opinions, but alas, there are also many misconceptions floating around: static typing does not require copious type annotations—many modern compilers can figure out the types on their own, a process known as &amp;quot;type inference&amp;quot;. On the other hand, dynamically typed languages don&amp;#39;t seem to exhibit significantly higher defect rates than their statically typed counterparts.&lt;/p&gt;
&lt;h3 id=&quot;duck-typing&quot;&gt;Duck Typing&lt;/h3&gt;
&lt;p&gt;Ruby itself is a dynamically type-checked language and follows a &amp;quot;duck typing&amp;quot; approach:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If it walks like a duck and it quacks like a duck, then it must be a duck.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;What this means is that Ruby developers generally don&amp;#39;t worry too much about an object&amp;#39;s type, but whether it responds to certain &amp;quot;messages&amp;quot; (or methods).&lt;/p&gt;
&lt;p&gt;So why bother with static typing in Ruby then, you may ask? While it certainly is no panacea that will make your code magically bug free, it does provide certain benefits:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Correctness: static typing is good at preventing &lt;strong&gt;certain classes&lt;/strong&gt; of bugs, like the aforementioned &lt;code&gt;NoMethodError&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Tooling: oftentimes, having static type information available during development leads to better tooling options (e.g. refactoring support in IDEs, etc.)&lt;/li&gt;
&lt;li&gt;Documentation: many statically typed languages have great built-in documentation tools. Haskell&amp;#39;s &lt;a href=&quot;https://hoogle.haskell.org/&quot;&gt;Hoogle&lt;/a&gt; uses this to great effect by offering a search engine where functions can be looked up by their type signatures.&lt;/li&gt;
&lt;li&gt;Performance: the more the information available to the compiler, the more the performance optimizations that can potentially be applied.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This list is not exhaustive, and one can find counterexamples for most of these points, but there&amp;#39;s certainly a core of truth to them.&lt;/p&gt;
&lt;h3 id=&quot;gradual-type-checking&quot;&gt;Gradual Type Checking&lt;/h3&gt;
&lt;p&gt;In recent years an approach commonly referred to as &amp;quot;gradual type checking&amp;quot; has made inroads into various dynamically type-checked languages: from &lt;a href=&quot;https://www.typescriptlang.org/&quot;&gt;TypeScript&lt;/a&gt; for JS to &lt;a href=&quot;https://hacklang.org/&quot;&gt;Hack&lt;/a&gt; for PHP and &lt;a href=&quot;http://mypy-lang.org/&quot;&gt;mypy&lt;/a&gt; for Python. What these approaches have in common is that they don&amp;#39;t require an all-or-nothing approach, but instead, allow developers to gradually add type information to variables and expressions as they see fit. This is especially useful for existing large codebases, where one can statically check the most critical parts of the system while still leaving the rest untyped and checked at runtime. All the type checking solutions for Ruby that we&amp;#39;ll explore in the rest of this article follow the same approach.&lt;/p&gt;
&lt;h2 id=&quot;options&quot;&gt;Options&lt;/h2&gt;
&lt;p&gt;After looking at why Ruby developers may want to add static type checking to their development workflows, it&amp;#39;s time to explore some of the currently popular options for doing so. However, it&amp;#39;s important to note that the idea of adding static type checking to Ruby isn&amp;#39;t new. Researchers from the University of Maryland worked on a Ruby extension named Diamondback Ruby (Druby) as early as 2009 and the Tufts University Programming Language Group released a paper called &lt;a href=&quot;https://www.cs.tufts.edu/~jfoster/papers/oops13.pdf&quot;&gt;The Ruby Type Checker&lt;/a&gt; in 2013, which eventually led to the &lt;a href=&quot;https://github.com/tupl-tufts/rdl&quot;&gt;RDL project&lt;/a&gt;, which offers type checking and design-by-contract capabilities as a library.&lt;/p&gt;
&lt;h3 id=&quot;sorbet&quot;&gt;Sorbet&lt;/h3&gt;
&lt;p&gt;Developed by Stripe, &lt;a href=&quot;https://sorbet.org/&quot;&gt;Sorbet&lt;/a&gt; is currently the most talked-about type checking solution for Ruby, not least because big companies like Shopify, GitLab, Kickstarter and Coinbase were early adopters during its closed beta phase. It was originally &lt;a href=&quot;https://twitter.com/darkdimius/status/1002049138366730240&quot;&gt;announced&lt;/a&gt; during last year&amp;#39;s Ruby Kaigi and saw its first public release on June 20th of this year. Sorbet is written in modern C++ and despite &lt;a href=&quot;https://twitter.com/amrabdelwahab/status/1141981078984548353&quot;&gt;Matz&amp;#39;s preferences&lt;/a&gt; (quote: &amp;quot;I hate type annotations&amp;quot;), opted for an approach based on type annotations. One particularly interesting thing about Sorbet is that it opts for a combination of static and dynamic type checking since Ruby&amp;#39;s extremely dynamic nature and metaprogramming capabilities are challenging for static type systems.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# typed: true
class Test
  extend T::Sig

  sig {params(x: Integer).returns(String)}
  def to_s(x)
    x.to_s
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To enable type checking, we first need to add the &lt;code&gt;# typed: true&lt;/code&gt; magic comment and extend our class with the &lt;code&gt;T::Sig&lt;/code&gt; module. The actual type annotation is specified with the &lt;code&gt;sig&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;sig {params(x: Integer).returns(String)}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which specifies that this method takes a single argument named &lt;code&gt;x&lt;/code&gt; that is of type &lt;code&gt;Integer&lt;/code&gt; and returns a &lt;code&gt;String&lt;/code&gt;. Trying to call this method with the wrong argument type will lead to an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Test.new.to_s(&amp;quot;42&amp;quot;)
# Expected Integer but found String(&amp;quot;42&amp;quot;) for argument x
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Apart from these basic checks, Sorbet has quite a few more tricks up its sleeve. For example, it can save us from the dreaded &lt;code&gt;NoMethodError&lt;/code&gt; on &lt;code&gt;nil&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;users = T::Array[User].new
user = users.first
user.username

# Method username does not exist on NilClass component of T.nilable(User)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The snippet above defines an empty array of &lt;code&gt;User&lt;/code&gt; objects and when we try to access the first element (which will return &lt;code&gt;nil&lt;/code&gt;) Sorbet correctly warns us that no method named &lt;code&gt;username&lt;/code&gt; is available on &lt;code&gt;NilClass&lt;/code&gt;. However, if we are sure that a certain value can never be &lt;code&gt;nil&lt;/code&gt;, we can use &lt;code&gt;T.must&lt;/code&gt; to let Sorbet know this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;users = T::Array[User].new
user = T.must(users.first)
user.username
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While the above code will now type check, it could lead to a runtime exception, so use this feature with care.&lt;/p&gt;
&lt;p&gt;There&amp;#39;s a lot more that Sorbet can do for us: &lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aif%20Random.rand%0A%20%20%20%20foo%20%3D%201%0Aelse%0A%20%20%20%20foo%20%3D%202%0Aend&quot;&gt;dead code detection&lt;/a&gt;, &lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Aa%20%3D%205%0Aa%20%3D%20%3Asym%0A%0Ab%20%3D%20T.let(&amp;#39;str&amp;#39;%2C%20String)%20%23%20Pinned%20to%20a%20String%0Ab%20%3D%20%3Asym&quot;&gt;type pinning&lt;/a&gt; (essentially committing a variable to a certain type, for example, once it has been assigned a string, it can never be assigned an integer), or the ability to define &lt;a href=&quot;https://sorbet.run/#%23%20typed%3A%20true%0Amodule%20Fooable%0A%20%20extend%20T%3A%3ASig%0A%20%20extend%20T%3A%3AHelpers%0A%20%20abstract!%0A%20%20sig%20%7Babstract.void%7D%0A%20%20def%20foo%0A%20%20end%0Aend%0A%0Aclass%20GoodFooable%0A%20%20include%20Fooable%0A%0A%20%20def%20foo%0A%20%20end%0Aend%0A%0Aclass%20BadFooable%0A%20%20include%20Fooable%0Aend&quot;&gt;interfaces&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Additionally, Sorbet can also work with &amp;quot;Ruby Interface&amp;quot; files (&lt;code&gt;rbi&lt;/code&gt;) which it keeps in a &lt;code&gt;sorbet/&lt;/code&gt; folder in your current working directory. This allows us to generate interface definitions for all the gems a project uses, which can help us with finding even more type errors.&lt;/p&gt;
&lt;p&gt;There&amp;#39;s much more to Sorbet than we can cover in a single article (e.g. the varying strictness levels or metaprogramming plugins), but its &lt;a href=&quot;https://sorbet.org/docs/overview&quot;&gt;documentation&lt;/a&gt; is pretty good already and open for PRs.&lt;/p&gt;
&lt;h3 id=&quot;steep&quot;&gt;Steep&lt;/h3&gt;
&lt;p&gt;The most widely known alternative to Sorbet is &lt;a href=&quot;https://github.com/soutaro/steep&quot;&gt;Steep&lt;/a&gt; by Soutaro Matsumoto. It does not use annotations and doesn&amp;#39;t do any type inference on its own. Instead, it completely relies on &lt;code&gt;.rbi&lt;/code&gt; files in the &lt;code&gt;sig&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s start from the following simple Ruby class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User
  attr_reader :first_name, :last_name, :address

  def initialize(first_name, last_name, address)
    @first_name = first_name
    @last_name = last_name
    @address = address
  end

  def full_name
    &amp;quot;#{first_name} #{last_name}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now scaffold an initial &lt;code&gt;user.rbi&lt;/code&gt; file with the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;$ steep scaffold user.rb &amp;gt; sig/user.rbi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This results in the following file which is intended as a starting point (illustrated by the fact that all types have been specified as &lt;code&gt;any&lt;/code&gt;, which provides no safety):&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User
  @first_name: any
  @last_name: any
  @address: any
  def initialize: (any, any, any) -&amp;gt; any
  def full_name: () -&amp;gt; String
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, if we try to type check at this point, we&amp;#39;ll encounter some errors:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ steep check
user.rb:11:7: NoMethodError: type=::User, method=first_name (first_name)
user.rb:11:21: NoMethodError: type=::User, method=last_name (last_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason we&amp;#39;re seeing these is that Steep needs a special comment to know what methods have been defined through &lt;code&gt;attr_reader&lt;/code&gt;s, so let&amp;#39;s add that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# @dynamic first_name, last_name, address
attr_reader :first_name, :last_name, :address
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Additionally, we need to add definitions for the methods to the generated &lt;code&gt;.rbi&lt;/code&gt; file. While we are at it, let&amp;#39;s also change the signatures from &lt;code&gt;any&lt;/code&gt; to the actual types:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class User
  @first_name: String
  @last_name: String
  @address: Address
  def initialize: (String, String, Address) -&amp;gt; any
  def first_name: () -&amp;gt; String
  def last_name: () -&amp;gt; String
  def address: () -&amp;gt; Address
  def full_name: () -&amp;gt; String
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, everything works as expected and &lt;code&gt;steep check&lt;/code&gt; doesn&amp;#39;t return any errors.&lt;/p&gt;
&lt;p&gt;On top of what we&amp;#39;ve seen so far, Steep also supports generics (e.g. &lt;code&gt;Hash&amp;lt;Symbol, String&amp;gt;&lt;/code&gt;) and union types, which represent an either-or choice between several types. For example, a user&amp;#39;s &lt;code&gt;top_post&lt;/code&gt; method could return the highest-ranked post written by the user, or &lt;code&gt;nil&lt;/code&gt; if they haven&amp;#39;t contributed anything yet. This is represented through the union type &lt;code&gt;(Post | nil)&lt;/code&gt;, and the corresponding signature would look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def top_post: () -&amp;gt; (Post | nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While Steep certainly has fewer features than Sorbet, it&amp;#39;s still a helpful tool and seems to be more in line with what Matz envisioned type checking in Ruby 3 to look like.&lt;/p&gt;
&lt;h3 id=&quot;ruby-type-profiler&quot;&gt;Ruby Type Profiler&lt;/h3&gt;
&lt;p&gt;Yusuke Endoh (better known as &amp;quot;mame&amp;quot; in Ruby developer circles) from Cookpad is working on a so-called level 1 type checker called &lt;a href=&quot;https://github.com/mame/ruby-type-profiler&quot;&gt;Ruby Type Profiler&lt;/a&gt;. Unlike the other solutions presented here, it doesn&amp;#39;t need signature files or type annotations but instead tries to infer as much as possible about a Ruby program while parsing it. Although it catches a lot less potential problems than either Steep or Sorbet, it comes at no extra cost to the developer.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;While nobody can predict the future, it seems like type checking in Ruby is something that&amp;#39;s here to stay. Currently, there are efforts underway to standardize on a &amp;quot;Ruby Signature Language&amp;quot; for use in &lt;code&gt;.rbi&lt;/code&gt; files (potentially scaffolded by Ruby Type Profiler), so developers can use whichever tool they prefer. Steep already allows library authors to ship type information with their gems, and Sorbet has a similar mechanism in the form of &lt;a href=&quot;https://github.com/sorbet/sorbet-typed&quot;&gt;sorbet-typed&lt;/a&gt;, which was inspired by the DefinitelyTyped repository for TypeScript definitions. If you&amp;#39;re interested in helping shape the future of type checking in Ruby, now is a great time to get involved!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Digging Deeper into Ruby Templating: The Parser</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/07/30/ruby-magic-ruby-templating-the-parser.html">
    <id>https://blog.appsignal.com/2019/07/30/ruby-magic-ruby-templating-the-parser.html</id>
    <published>2019-07-30T00:00:00+00:00</published>
    <updated>2019-07-30T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">With the lexer in place, let’s move on to the next step: The parser.</summary>
    <content type="html">&lt;p&gt;Today, we continue our journey into Ruby Templating. With the lexer in place, let’s move on to the next step: The parser.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2019/07/02/ruby-magic-brewing-our-own-template-lexer-in-ruby.html&quot;&gt;Last time&lt;/a&gt;, we looked at string interpolation and subsequently, dived into creating our own templating language. We started by implementing a lexer that reads a template and converts it into a stream of tokens. Today, we’ll implement the accompanying parser. We will also dip our toes into a bit of language theory.&lt;/p&gt;
&lt;p&gt;Here we go!&lt;/p&gt;
&lt;h2 id=&quot;abstract-syntax-trees&quot;&gt;Abstract Syntax Trees&lt;/h2&gt;
&lt;p&gt;Let’s look back to our simple example template for &lt;code&gt;Welcome to {{name}}&lt;/code&gt;. After using the lexer to tokenize the string, we get a list of tokens like this.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars::Lexer.tokenize(&amp;quot;Welcome to {{name}}&amp;quot;)
# =&amp;gt; [[:CONTENT, &amp;quot;Welcome to &amp;quot;], [:OPEN_EXPRESSION], [:IDENTIFIER, &amp;quot;name&amp;quot;], [:CLOSE]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ultimately, we want to evaluate the template and replace the expression with real values. To make things a bit more challenging, we also want to evaluate complex block expressions, allowing for repetition and conditionals.&lt;/p&gt;
&lt;p&gt;To do this, we have to generate an abstract syntax tree (AST) that describes the logical structure of the template. The tree consists of nodes that may reference other nodes or store additional data from the tokens.&lt;/p&gt;
&lt;p&gt;For our simple example, the desired abstract syntax tree looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2019-07/simple-ast.svg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;defining-a-grammar&quot;&gt;Defining a Grammar&lt;/h2&gt;
&lt;p&gt;To define the grammar, let&amp;#39;s start with the theoretical basis of a language. Like other programming languages, our templating language is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Context-free_language&quot;&gt;context-free language&lt;/a&gt; and therefore can be described by a &lt;a href=&quot;https://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;context-free grammar&lt;/a&gt;. &lt;em&gt;(Don’t let the mathematical notations in the detailed Wikipedia descriptions scare you away. The concept is pretty straight forward, and there are more developer-friendly ways to notate a grammar.)&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A context-free grammar is a set of rules that describe how all possible strings of a language are constructed. Let’s look at the grammar for our templating language in &lt;a href=&quot;https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form&quot;&gt;EBNF notation&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;template = statements;
statements = { statement };
statement = CONTENT | expression | block_expression;
expression = OPEN_EXPRESSION, IDENTIFIER, arguments, CLOSE;
block_expression = OPEN_BLOCK, IDENTIFIER, arguments, CLOSE, statements, [ OPEN_INVERSE, CLOSE, statements ], OPEN_END_BLOCK, IDENTIFIER, CLOSE;
arguments = { IDENTIFIER };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Each assignment defines a rule. The rule’s name is on the left and a bunch of other rules (lower case) or tokens (upper case) from our lexer are on the right. Rules and tokens can be concatenated using commas &lt;code&gt;,&lt;/code&gt; or alternated using the pipe &lt;code&gt;|&lt;/code&gt; symbol. Rules and tokens inside of curly braces &lt;code&gt;{ ... }&lt;/code&gt; might be repeated several times. When they are inside of brackets &lt;code&gt;[ ... ]&lt;/code&gt;, they are considered optional.&lt;/p&gt;
&lt;p&gt;The above grammar is a concise way to describe that a template consists of statements. A statement is either a &lt;code&gt;CONTENT&lt;/code&gt; token, an expression, or a block expression. An expression is an &lt;code&gt;OPEN_EXPRESSION&lt;/code&gt; token, followed by an &lt;code&gt;IDENTIFIER&lt;/code&gt; token, followed by arguments, followed by a &lt;code&gt;CLOSE&lt;/code&gt; token. And a block expression is the perfect example of why it’s better to use a notation like the one above instead of trying to describe it with a natural language.&lt;/p&gt;
&lt;p&gt;There are tools that &lt;a href=&quot;https://en.wikipedia.org/wiki/Comparison_of_parser_generators&quot;&gt;automatically generate parsers&lt;/a&gt; from grammar definitions like the one above. But in true Ruby Magic tradition, let&amp;#39;s have some fun and build the parser ourselves, hopefully learning a thing or two in the process.&lt;/p&gt;
&lt;h2 id=&quot;building-the-parser&quot;&gt;Building the Parser&lt;/h2&gt;
&lt;p&gt;With the language theory aside, let’s jump into actually building the parser. Let’s start with an even more minimal, but still valid, template: &lt;code&gt;Welcome to Ruby Magic&lt;/code&gt;. This template doesn’t have any expressions and the list of tokens consists of just one element. Here’s what it looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;[[:CONTENT, &amp;quot;Welcome to Ruby Magic&amp;quot;]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we set up our parser class. It looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magicbars
  class Parser
    def self.parse(tokens)
      new(tokens).parse
    end

    attr_reader :tokens

    def initialize(tokens)
      @tokens = tokens
    end

    def parse
      # Parsing starts here
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The class takes an array of tokens and stores it. It only has one public method called &lt;code&gt;parse&lt;/code&gt; that converts the tokens into an AST.&lt;/p&gt;
&lt;p&gt;Looking back at our grammar, the top-most rule is &lt;code&gt;template&lt;/code&gt;. That implies that &lt;code&gt;parse&lt;/code&gt;, at the start of the parsing process, will return a &lt;code&gt;Template&lt;/code&gt; node.&lt;/p&gt;
&lt;p&gt;Nodes are simple classes with no behavior of their own. They just connect other nodes or store some values from the tokens. Here’s what the &lt;code&gt;Template&lt;/code&gt; node looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magicbars
  module Nodes
    class Template
      attr_reader :statements

      def initialize(statements)
        @statements = statements
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To make our example work, we also need a &lt;code&gt;Content&lt;/code&gt; node. It just stores the text content (&lt;code&gt;&amp;quot;Welcome to Ruby Magic&amp;quot;&lt;/code&gt;) from the token.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magicbars
  module Nodes
    class Content
      attr_reader :content

      def initialize(content)
        @content = content
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, let’s implement the parse method to create an instance of &lt;code&gt;Template&lt;/code&gt; and an instance of &lt;code&gt;Content&lt;/code&gt; and connect them up correctly.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def parse
  Magicbars::Nodes::Template.new(parse_content)
end

def parse_content
  return unless tokens[0][0] == :CONTENT

  Magicbars::Nodes::Content.new(tokens[0][1])
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we run the parser, we get the correct result:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars::Parser.parse(tokens)
# =&amp;gt; #&amp;lt;Magicbars::Nodes::Template:0x00007fe90e939410 @statements=#&amp;lt;Magicbars::Nodes::Content:0x00007fe90e939578 @content=&amp;quot;Welcome to Ruby Magic&amp;quot;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Admittedly, this only works for our simple example that only has one content node. Let’s switch to a more complex example that actually includes an expression: &lt;code&gt;Welcome to {{name}}&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars::Lexer.tokenize(&amp;quot;Welcome to {{name}}&amp;quot;)
# =&amp;gt; [[:CONTENT, &amp;quot;Welcome to &amp;quot;], [:OPEN_EXPRESSION], [:IDENTIFIER, &amp;quot;name&amp;quot;], [:CLOSE]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For this, we need an &lt;code&gt;Expression&lt;/code&gt; node and an &lt;code&gt;Identifier&lt;/code&gt; node. The &lt;code&gt;Expression&lt;/code&gt; node stores the identifier as well as any arguments (which, according to the grammar, are an array of zero or more &lt;code&gt;Identifier&lt;/code&gt; nodes). As with the other nodes, there’s not much to see here.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magicbars
  module Nodes
    class Expression
      attr_reader :identifier, :arguments

      def initialize(identifier, arguments)
        @identifier = identifier
        @arguments = arguments
      end
    end
  end
end

module Magicbars
  module Nodes
    class Identifier
      attr_reader :value

      def initialize(value)
        @value = value.to_sym
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With the new nodes in place, let’s modify the &lt;code&gt;parse&lt;/code&gt; method to handle both regular content as well as expressions. We do that by introducing a &lt;code&gt;parse_statements&lt;/code&gt; method that just keeps on calling &lt;code&gt;parse_statement&lt;/code&gt; as long as it returns a value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def parse
  Magicbars::Nodes::Template.new(parse_statements)
end

def parse_statements
  results = []

  while result = parse_statement
    results &amp;lt;&amp;lt; result
  end

  results
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;parse_statement&lt;/code&gt; itself first calls &lt;code&gt;parse_content&lt;/code&gt; and if that doesn’t return any value, it calls &lt;code&gt;parse_expression&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def parse_statement
  parse_content || parse_expression
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Have you noticed that the &lt;code&gt;parse_statement&lt;/code&gt; method is starting to look very similar to the &lt;code&gt;statement&lt;/code&gt; rule in the grammar? This is where taking the time to explicitly write up the grammar beforehand helps a lot to ensure that we’re on the right path.&lt;/p&gt;
&lt;p&gt;Next, let’s modify the &lt;code&gt;parse_content&lt;/code&gt; method so that it doesn’t only look at the first token. We do this by introducing an additional &lt;code&gt;@position&lt;/code&gt; instance variable in the initializer and use it to fetch the current token.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;attr_reader :tokens, :position

def initialize(tokens)
  @tokens = tokens
  @position = 0
end

# ...

def parse_content
  return unless token = tokens[position]
  return unless token[0] == :CONTENT

  @position += 1

  Magicbars::Nodes::Content.new(token[1])
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;parse_content&lt;/code&gt; method now looks at the current token and checks its type. If it’s a &lt;code&gt;CONTENT&lt;/code&gt; token, it increments the position (because the current token was successfully parsed) and uses the token’s content to create the &lt;code&gt;Content&lt;/code&gt; node. If there is no current token (because we’re at the end of the tokens) or the type doesn’t match, the method exits early and returns &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With the improved &lt;code&gt;parse_content&lt;/code&gt; method in place, let’s tackle the new &lt;code&gt;parse_expression&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def parse_expression
  return unless token = tokens[position]
  return unless token[0] == :OPEN_EXPRESSION

  @position += 1

  identifier = parse_identifier
  arguments = parse_arguments

  if !tokens[position] || tokens[position][0] != :CLOSE
    raise &amp;quot;Unexpected token #{tokens[position][0]}. Expected :CLOSE.&amp;quot;
  end

  @position += 1

  Magicbars::Nodes::Expression.new(identifier, arguments)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we check that there is a current token and that its type is &lt;code&gt;OPEN_EXPRESSION&lt;/code&gt;. If that’s the case, we advance to the next token and parse the identifier as well as the arguments by calling &lt;code&gt;parse_identifier&lt;/code&gt; and &lt;code&gt;parse_arguments&lt;/code&gt;, respectively. Both methods will return the respective nodes and advance the current token. When that’s done, we ensure that the current token exists and is a &lt;code&gt;:CLOSE&lt;/code&gt; token. If it is not, we raise an error. Otherwise, we advance the position one last time, before returning the newly created &lt;code&gt;Expression&lt;/code&gt; node.&lt;/p&gt;
&lt;p&gt;At this point, we see some patterns emerge. We’re advancing to the next token several times and we’re also checking that there is a current token and its type. Because the code for that is a bit cumbersome, let’s introduce two helper methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def expect(*expected_tokens)
  upcoming = tokens[position, expected_tokens.size]

  if upcoming.map(&amp;amp;:first) == expected_tokens
    advance(expected_tokens.size)
    upcoming
  end
end

def advance(offset = 1)
  @position += offset
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;expect&lt;/code&gt; method takes a variable number of token types and checks them against the next tokens in the token stream. If they all match, it advances past the matching tokens and returns them. The &lt;code&gt;advance&lt;/code&gt; method just increments the &lt;code&gt;@position&lt;/code&gt; instance variable by the given offset.&lt;/p&gt;
&lt;p&gt;For cases where there&amp;#39;s no flexibility regarding the next expected token, we also introduce a method that raises a nice error message when the token doesn’t match.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def need(*required_tokens)
  upcoming = tokens[position, required_tokens.size]
  expect(*required_tokens) or raise &amp;quot;Unexpected tokens. Expected #{required_tokens.inspect} but got #{upcoming.inspect}&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By using these helper methods, &lt;code&gt;parse_content&lt;/code&gt; and &lt;code&gt;parse_expression&lt;/code&gt; are now cleaner and more readable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def parse_content
  if content = expect(:CONTENT)
    Magicbars::Nodes::Content.new(content[0][1])
  end
end

def parse_expression
  return unless expect(:OPEN_EXPRESSION)

  identifier = parse_identifier
  arguments = parse_arguments

  need(:CLOSE)

  Magicbars::Nodes::Expression.new(identifier, arguments)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, let’s also look at &lt;code&gt;parse_identifier&lt;/code&gt; and &lt;code&gt;parse_arguments&lt;/code&gt;. Thanks to the helper methods, the &lt;code&gt;parse_identifier&lt;/code&gt; method is as simple as the &lt;code&gt;parse_content&lt;/code&gt; method. The only difference is that it returns another node type.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def parse_identifier
  if identifier = expect(:IDENTIFIER)
    Magicbars::Nodes::Identifier.new(identifier[0][1])
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When implementing the &lt;code&gt;parse_arguments&lt;/code&gt; method, we noticed that it’s almost identical to the &lt;code&gt;parse_statements&lt;/code&gt; method. The only difference is that it calls &lt;code&gt;parse_identifier&lt;/code&gt; instead of &lt;code&gt;parse_statement&lt;/code&gt;. We can get rid of the duplicated logic by introducing another helper method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def repeat(method)
  results = []

  while result = send(method)
    results &amp;lt;&amp;lt; result
  end

  results
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;repeat&lt;/code&gt; method uses &lt;code&gt;send&lt;/code&gt; to call the given method name until it no longer returns a node. Once that happens, the collected results (or just an empty array) are returned. With this helper in place, both &lt;code&gt;parse_statements&lt;/code&gt; and &lt;code&gt;parse_arguments&lt;/code&gt; become one-line methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def parse_statements
  repeat(:parse_statement)
end

def parse_arguments
  repeat(:parse_identifier)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With all these changes in place, let’s try and parse the token stream:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars::Parser.parse(tokens)
# =&amp;gt; #&amp;lt;Magicbars::Nodes::Template:0x00007f91a602f910
#     @statements=
#      [#&amp;lt;Magicbars::Nodes::Content:0x00007f91a58802c8 @content=&amp;quot;Welcome to &amp;quot;&amp;gt;,
#       #&amp;lt;Magicbars::Nodes::Expression:0x00007f91a602fcd0
#        @arguments=[],
#        @identifier=
#         #&amp;lt;Magicbars::Nodes::Identifier:0x00007f91a5880138 @value=:name&amp;gt;  &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s a bit hard to read but it’s, in fact, the correct abstract syntax tree. The &lt;code&gt;Template&lt;/code&gt; node has a &lt;code&gt;Content&lt;/code&gt; and an &lt;code&gt;Expression&lt;/code&gt; statement. The &lt;code&gt;Content&lt;/code&gt; node’s value is &lt;code&gt;&amp;quot;Welcome to &amp;quot;&lt;/code&gt; and the &lt;code&gt;Expression&lt;/code&gt; node’s identifier is the &lt;code&gt;Identifier&lt;/code&gt; node with &lt;code&gt;:name&lt;/code&gt; as its value.&lt;/p&gt;
&lt;h2 id=&quot;parsing-block-expressions&quot;&gt;Parsing Block Expressions&lt;/h2&gt;
&lt;p&gt;To complete our parser implementation, we still have to implement parsing of block expressions. As a reminder, here’s the template we want to parse:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Welcome to {{name}}!

{{#if subscribed}}
  Thank you for subscribing to our mailing list.
{{else}}
  Please sign up for our mailing list to be notified about new articles!
{{/if}}

Your friends at {{company_name}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To do this, let’s first introduce a &lt;code&gt;BlockExpression&lt;/code&gt; node. While this node stores a bit more data, it doesn’t do anything else and therefore isn’t very exciting.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magicbars
  module Nodes
    class BlockExpression
      attr_reader :identifier, :arguments, :statements, :inverse_statements

      def initialize(identifier, arguments, statements, inverse_statements)
        @identifier = identifier
        @arguments = arguments
        @statements = statements
        @inverse_statements = inverse_statements
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Like the &lt;code&gt;Expression&lt;/code&gt; node, it stores the identifier as well as any arguments. Additionally, it also stores the statements of the block and of the inverse block.&lt;/p&gt;
&lt;p&gt;Looking back at the grammar, we notice that to parse block expressions, we have to amend the &lt;code&gt;parse_statements&lt;/code&gt; method with a call to &lt;code&gt;parse_block_expression&lt;/code&gt;. It now looks just like the rule in the grammar.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def parse_statement
  parse_content || parse_expression || parse_block_expression
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;parse_block_expression&lt;/code&gt; method itself is a bit more complex. But thanks to our helper methods, it’s still quite readable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def parse_block_expression
  return unless expect(:OPEN_BLOCK)

  identifier = parse_identifier
  arguments = parse_arguments

  need(:CLOSE)

  statements = parse_statements

  if expect(:OPEN_INVERSE, :CLOSE)
    inverse_statements = parse_statements
  end

  need(:OPEN_END_BLOCK)

  if identifier.value != parse_identifier.value
    raise(&amp;quot;Error. Identifier in closing expression does not match identifier in opening expression&amp;quot;)
  end

  need(:CLOSE)

  Magicbars::Nodes::BlockExpression.new(identifier, arguments, statements, inverse_statements)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first part is very similar to the &lt;code&gt;parse_expression&lt;/code&gt; method. It parses the opening block expression with the identifier and the arguments. Afterward, it calls &lt;code&gt;parse_statements&lt;/code&gt; to parse the inside of the block.&lt;/p&gt;
&lt;p&gt;Once that’s done, we check for an &lt;code&gt;{{else}}&lt;/code&gt; expression, identified by an &lt;code&gt;OPEN_INVERSE&lt;/code&gt; token followed by a &lt;code&gt;CLOSE&lt;/code&gt; token. If both tokens are found, we call &lt;code&gt;parse_statements&lt;/code&gt; again to parse the inverse block. Otherwise, we just skip that part entirely.&lt;/p&gt;
&lt;p&gt;As a final thing, we ensure that there is an end block expression using the same identifier as the open block expression. If the identifiers don’t match, we raise an error. Otherwise, we create a new &lt;code&gt;BlockExpression&lt;/code&gt; node and return it.&lt;/p&gt;
&lt;p&gt;Calling the parser with the tokens of the advanced block expression template will return the AST for the template. I’ll not include the example output here, as it’s barely readable. Instead, here’s a visual representation of the generated AST.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2019-07/complex-ast.svg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Because we’re calling &lt;code&gt;parse_statements&lt;/code&gt; inside of &lt;code&gt;parse_block_expression&lt;/code&gt;, both the block and the inverse block may include more expressions, block expressions, as well as regular content.&lt;/p&gt;
&lt;h2 id=&quot;the-journey-continues&quot;&gt;The Journey Continues…&lt;/h2&gt;
&lt;p&gt;We made decent progress with our journey towards implementing our own templating language. After a short dip into language theory, we defined a grammar for our templating language and used it to implement a parser for it from scratch.&lt;/p&gt;
&lt;p&gt;With both the lexer and the parser in place, we’re only missing an interpreter to generate the interpolated string from our template. We’ll cover this part in an upcoming edition of RubyMagic. Subscribe to &lt;a href=&quot;/ruby-magic/&quot;&gt;the Ruby Magic mailinglist&lt;/a&gt;, to get alerted when it comes out.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Brewing our own Template Lexer in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/07/02/ruby-magic-brewing-our-own-template-lexer-in-ruby.html">
    <id>https://blog.appsignal.com/2019/07/02/ruby-magic-brewing-our-own-template-lexer-in-ruby.html</id>
    <published>2019-07-02T00:00:00+00:00</published>
    <updated>2019-07-02T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">For our dive into templating, we end up writing our own lexer.</summary>
    <content type="html">&lt;p&gt;Put on your scuba diving suite and pack your stencils, we&amp;#39;re diving into Templates today!&lt;/p&gt;
&lt;p&gt;Most software that renders web pages or generates emails uses templating to embed variable data into text documents. The main structure of the document is often set up in a static template with placeholders for the data. The variable data, like user names or web page contents, replace the placeholders while rendering the page.&lt;/p&gt;
&lt;p&gt;For our dive into templating, we&amp;#39;ll implement a subset of &lt;a href=&quot;https://github.com/mustache/mustache&quot;&gt;Mustache&lt;/a&gt;, a templating language that&amp;#39;s available in many programming languages. In this episode, we&amp;#39;ll investigate different ways of templating. We&amp;#39;ll start out looking at string concatenation, and end up writing our own lexer to allow for more complex templates.&lt;/p&gt;
&lt;h2 id=&quot;using-native-string-interpolation&quot;&gt;Using Native String Interpolation&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s start with a minimal example. Our application needs a welcome message that happens to include a project name. The quickest way to do this is by using Ruby&amp;#39;s built-in string interpolation feature.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;name = &amp;quot;Ruby Magic&amp;quot;
template = &amp;quot;Welcome to #{name}&amp;quot;
# =&amp;gt; Welcome to Ruby Magic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great! That was doable. However, what if we want to reuse the template for multiple occasions, or allow our users to update the template?&lt;/p&gt;
&lt;p&gt;The interpolation evaluates immediately. We can&amp;#39;t reuse the template (unless we redefine it—in a loop, for instance) and we can&amp;#39;t store the &lt;code&gt;Welcome to #{name}&lt;/code&gt; template in a database and populate it later without using the potentially dangerous &lt;code&gt;eval&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;Luckily, Ruby has a different way of interpolating strings: &lt;code&gt;Kernel#sprintf&lt;/code&gt; or &lt;code&gt;String#%&lt;/code&gt;. These methods allow us to get an interpolated string without changing the template itself. This way, we can reuse the same template multiple times. It also doesn&amp;#39;t allow execution of arbitrary Ruby code. Let&amp;#39;s use it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;name = &amp;quot;Ruby Magic&amp;quot;
template = &amp;quot;Welcome to %{name}&amp;quot;

sprintf(template, name: name)
# =&amp;gt; &amp;quot;Welcome to Ruby Magic&amp;quot;

template % { name: name }
# =&amp;gt; &amp;quot;Welcome to Ruby Magic&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;the-regexp-approach-to-templating&quot;&gt;The &lt;code&gt;Regexp&lt;/code&gt; Approach to Templating&lt;/h2&gt;
&lt;p&gt;While the above solution works, it&amp;#39;s not fool-proof, and it exposes more functionality than we usually want to. Let&amp;#39;s look at an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;name = &amp;quot;Ruby Magic&amp;quot;
template = &amp;quot;Welcome to %d&amp;quot;

sprintf(template, name: name)
# =&amp;gt; TypeError (can&amp;#39;t convert Hash into Integer)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both &lt;code&gt;Kernel#sprintf&lt;/code&gt; and &lt;code&gt;String#%&lt;/code&gt; allow special syntax to handle different types of data. Not all of them are compatible with the data we pass. In this example, the template expects to format a number but gets passed a Hash, producing a &lt;code&gt;TypeError&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But we have more power tools in our shed: we can implement our own interpolation using regular expressions. Using regular expressions allows us to define a custom syntax, like a &lt;a href=&quot;https://mustache.github.io&quot;&gt;Mustache&lt;/a&gt;/&lt;a href=&quot;https://handlebarsjs.com&quot;&gt;Handlebars&lt;/a&gt; inspired style.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;name = &amp;quot;Ruby Magic&amp;quot;
template = &amp;quot;Welcome to {{name}}&amp;quot;
assigns = { &amp;quot;name&amp;quot; =&amp;gt; name }

template.gsub(/{{(\w+)}}/) { assigns[$1] }
# =&amp;gt; Welcome to Ruby Magic
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use &lt;code&gt;String#gsub&lt;/code&gt; to replace all placeholders (words in double curly braces) with their value in the &lt;code&gt;assigns&lt;/code&gt; hash. If there is no corresponding value, this method removes the placeholder without inserting anything.&lt;/p&gt;
&lt;p&gt;Replacing placeholders in a string like this is a viable solution for a string with a couple of placeholders. However, once things get a bit more complicated, we quickly run into problems.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s say we need to have conditionals in the template. The result should be different based on the value of a variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-handlebars&quot;&gt;Welcome to
{{name}}!

{{#if subscribed}}
  Thank you for subscribing to our mailing list.
{{else}}
  Please sign up for our mailing list to be notified about new articles!
{{/if}}

Your friends at
{{company_name}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Regular expressions can&amp;#39;t smoothly handle this use case. If you try hard enough, you can probably still hack something together, but at this point, it&amp;#39;s better to build a proper templating language.&lt;/p&gt;
&lt;h2 id=&quot;building-a-templating-language&quot;&gt;Building a Templating Language&lt;/h2&gt;
&lt;p&gt;Implementing a templating language is similar to implementing other programming languages. Just like a scripting language, a template language needs three components: A lexer, a parser, and an interpreter. We&amp;#39;ll look at these, one by one.&lt;/p&gt;
&lt;h1 id=&quot;lexer&quot;&gt;Lexer&lt;/h1&gt;
&lt;p&gt;The first task we need to tackle is called tokenization, or lexical analysis. The process is very similar to identifying word categories in natural languages.&lt;/p&gt;
&lt;p&gt;Take an example like &lt;code&gt;Ruby is a lovely language&lt;/code&gt;. The sentence consists of five words of different categories. To identify what category they are, you&amp;#39;d take a dictionary and look up every word&amp;#39;s category, which would result in a list like this: &lt;em&gt;Noun&lt;/em&gt;, &lt;em&gt;Verb&lt;/em&gt;, &lt;em&gt;Article&lt;/em&gt;, &lt;em&gt;Adjective&lt;/em&gt;, &lt;em&gt;Noun&lt;/em&gt;. Natural language processing calls these &amp;quot;Parts of Speech&amp;quot;. In formal languages--like programming languages-- they&amp;#39;re called &lt;em&gt;tokens&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;A lexer works by reading the template and matching the stream of text with a set of regular expressions for each category in a given order. The first one that matches defines the category of the token and attaches relevant data to it.&lt;/p&gt;
&lt;p&gt;With this little bit of theory out of the way, let&amp;#39;s implement a lexer for our template language. To make things a little bit easier, we use &lt;code&gt;StringScanner&lt;/code&gt; by requiring &lt;code&gt;strscan&lt;/code&gt; from Ruby&amp;#39;s standard library. (By the way, we&amp;#39;ve got an excellent intro to &lt;code&gt;StringScanner&lt;/code&gt; in &lt;a href=&quot;/2019/03/05/stringscanner.html&quot;&gt;one of our previous editions&lt;/a&gt;.) As a first step, let&amp;#39;s build a minimal version that identifies everything as &lt;code&gt;CONTENT&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We do this by creating a new &lt;code&gt;StringScanner&lt;/code&gt; instance and letting it do its job using an &lt;code&gt;until&lt;/code&gt; loop that only stops when the scanner reaches the end of the string.&lt;/p&gt;
&lt;p&gt;For now, we just let it match every character (&lt;code&gt;.*&lt;/code&gt;) across multiple lines (the &lt;code&gt;m&lt;/code&gt; modifier) and return one &lt;code&gt;CONTENT&lt;/code&gt; token for all of it. We represent a token as an array with the token name as the first element and any data as the second element. Our very basic lexer looks something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;strscan&amp;#39;

module Magicbars
  class Lexer
    def self.tokenize(code)
      new.tokenize(code)
    end

    def tokenize(code)
      scanner = StringScanner.new(code)
      tokens = []

      until scanner.eos?
        tokens &amp;lt;&amp;lt; [:CONTENT, scanner.scan(/.*?/m)]
      end

      tokens
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When running this code with &lt;code&gt;Welcome to {{name}}&lt;/code&gt; we get back a list of precisely one &lt;code&gt;CONTENT&lt;/code&gt; token with all of the code attached to it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars::Lexer.tokenize(&amp;quot;Welcome to {{name}}&amp;quot;)
=&amp;gt; [[:CONTENT, &amp;quot;Welcome to {{name}}&amp;quot;]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, let&amp;#39;s detect the expression. To do so, we modify the code inside the loop, so it matches &lt;code&gt;{{&lt;/code&gt; and &lt;code&gt;}}&lt;/code&gt; as &lt;code&gt;OPEN_EXPRESSION&lt;/code&gt; and &lt;code&gt;CLOSE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We do this by adding a conditional that checks for the different cases.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;until scanner.eos?
  if scanner.scan(/{{/)
    tokens &amp;lt;&amp;lt; [:OPEN_EXPRESSION]
  elsif scanner.scan(/}}/)
    tokens &amp;lt;&amp;lt; [:CLOSE]
  elsif scanner.scan(/.*?/m)
    tokens &amp;lt;&amp;lt; [:CONTENT, scanner.matched]
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There&amp;#39;s no added value in attaching the curly braces to the &lt;code&gt;OPEN_EXPRESSION&lt;/code&gt; and &lt;code&gt;CLOSE&lt;/code&gt; tokens, so we drop them. As the &lt;code&gt;scan&lt;/code&gt; calls are now part of the condition, we use &lt;code&gt;scanner.matched&lt;/code&gt; to attach the result of the last match to the &lt;code&gt;CONTENT&lt;/code&gt; token.&lt;/p&gt;
&lt;p&gt;Unfortunately, when rerunning the lexer, we still get only one &lt;code&gt;CONTENT&lt;/code&gt; token like before. We still have to modify the last expression to match everything up to the open expression. We do this by using &lt;code&gt;scan_until&lt;/code&gt; with a positive lookahead anchor for double curly braces that stops the scanner right before them. Our code inside the loop now looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;until scanner.eos?
  if scanner.scan(/{{/)
    tokens &amp;lt;&amp;lt; [:OPEN_EXPRESSION]
  elsif scanner.scan(/}}/)
    tokens &amp;lt;&amp;lt; [:CLOSE]
  elsif scanner.scan_until(/.*?(?={{|}})/m)
    tokens &amp;lt;&amp;lt; [:CONTENT, scanner.matched]
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Running the lexer again, now results in four tokens:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars::Lexer.tokenize(&amp;quot;Welcome to {{name}}&amp;quot;)
=&amp;gt; [[:CONTENT, &amp;quot;Welcome to &amp;quot;], [:OPEN_EXPRESSION], [:CONTENT, &amp;quot;name&amp;quot;], [:CLOSE]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our lexer looks pretty close to the result we want. However, &lt;code&gt;name&lt;/code&gt; isn&amp;#39;t regular content; it&amp;#39;s an identifier! Strings between double curly braces should be treated differently than strings outside.&lt;/p&gt;
&lt;h2 id=&quot;a-state-machine&quot;&gt;A State Machine&lt;/h2&gt;
&lt;p&gt;To do this, we turn the lexer into a state machine with two distinct states. It starts in the &lt;code&gt;default&lt;/code&gt; state. When it hit&amp;#39;s an &lt;code&gt;OPEN_EXPRESSION&lt;/code&gt; token, it moves to the &lt;code&gt;expression&lt;/code&gt; state and stays there until it comes across a &lt;code&gt;CLOSE&lt;/code&gt; token which makes it transition back to the &lt;code&gt;default&lt;/code&gt; state.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2019-07/state-machine.svg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We implement the state machine by adding a few methods that use an array to manage the current state.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def stack
  @stack ||= []
end

def state
  stack.last || :default
end

def push_state(state)
  stack.push(state)
end

def pop_state
  stack.pop
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;state&lt;/code&gt; method will either return the current state or &lt;code&gt;default&lt;/code&gt;. &lt;code&gt;push_state&lt;/code&gt; moves the lexer into a new state by adding it to the stack. &lt;code&gt;pop_state&lt;/code&gt; moves the lexer back to the previous state.&lt;/p&gt;
&lt;p&gt;Next, we split up the conditional within the loop and wrap it by a conditional that checks for the current state. While in the &lt;code&gt;default&lt;/code&gt; state, we handle both &lt;code&gt;OPEN_EXPRESSION&lt;/code&gt; and &lt;code&gt;CONTENT&lt;/code&gt; tokens. This also means that the regular expression for &lt;code&gt;CONTENT&lt;/code&gt; doesn&amp;#39;t need the &lt;code&gt;}}&lt;/code&gt; lookahead anymore, so we drop it. In the &lt;code&gt;expression&lt;/code&gt; state, we handle the &lt;code&gt;CLOSE&lt;/code&gt; token and add a new regular expression for &lt;code&gt;IDENTIFIER&lt;/code&gt;. Of course, we also implement the state transitions by adding a &lt;code&gt;push_state&lt;/code&gt; call to &lt;code&gt;OPEN_EXPRESSION&lt;/code&gt; and a &lt;code&gt;pop_state&lt;/code&gt; call to &lt;code&gt;CLOSE&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;if state == :default
  if scanner.scan(/{{/)
    tokens &amp;lt;&amp;lt; [:OPEN_EXPRESSION]
    push_state :expression
  elsif scanner.scan_until(/.*?(?={{)/m)
    tokens &amp;lt;&amp;lt; [:CONTENT, scanner.matched]
  end
elsif state == :expression
  if scanner.scan(/}}/)
    tokens &amp;lt;&amp;lt; [:CLOSE]
    pop_state
  elsif scanner.scan(/[\w\-]+/)
    tokens &amp;lt;&amp;lt; [:IDENTIFIER, scanner.matched]
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With these changes in place, the lexer now properly tokenizes our example.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magicbars::Lexer.tokenize(&amp;quot;Welcome to {{name}}&amp;quot;)
# =&amp;gt; [[:CONTENT, &amp;quot;Welcome to &amp;quot;], [:OPEN_EXPRESSION], [:IDENTIFIER, &amp;quot;name&amp;quot;], [:CLOSE]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;making-it-harder-for-ourselves&quot;&gt;Making it harder for ourselves&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s move on to a more advanced example. This one uses multiple expressions, as well as a block.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Welcome to {{name}}!

{{#if subscribed}}
  Thank you for subscribing to our mailing list.
{{else}}
  Please sign up for our mailing list to be notified about new articles!
{{/if}}

Your friends at {{company_name}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;#39;s no surprise that our lexer fails to parse this example. To make it work, we have to add the missing tokens and make it handle the content after the last expression. The code inside the loop looks something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;if state == :default
  if scanner.scan(/{{#/)
    tokens &amp;lt;&amp;lt; [:OPEN_BLOCK]
    push_state :expression
  elsif scanner.scan(/{{\//)
    tokens &amp;lt;&amp;lt; [:OPEN_END_BLOCK]
    push_state :expression
  elsif scanner.scan(/{{else/)
    tokens &amp;lt;&amp;lt; [:OPEN_INVERSE]
    push_state :expression
  elsif scanner.scan(/{{/)
    tokens &amp;lt;&amp;lt; [:OPEN_EXPRESSION]
    push_state :expression
  elsif scanner.scan_until(/.*?(?={{)/m)
    tokens &amp;lt;&amp;lt; [:CONTENT, scanner.matched]
  else
    tokens &amp;lt;&amp;lt; [:CONTENT, scanner.rest]
    scanner.terminate
  end
elsif state == :expression
  if scanner.scan(/\s+/)
    # Ignore whitespace
  elsif scanner.scan(/}}/)
    tokens &amp;lt;&amp;lt; [:CLOSE]
    pop_state
  elsif scanner.scan(/[\w\-]+/)
    tokens &amp;lt;&amp;lt; [:IDENTIFIER, scanner.matched]
  else
    scanner.terminate
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Please keep in mind that the order of the conditions is important to some extent. The first regular expression that matches is assigned. Thus, more specific expressions have to come before more generic ones. The prime example of this is the collection of specialized open tokens for blocks.&lt;/p&gt;
&lt;p&gt;Using the final version of the lexer, the example now tokenizes into this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;[
  [:CONTENT, &amp;quot;Welcome to &amp;quot;],
  [:OPEN_EXPRESSION],
  [:IDENTIFIER, &amp;quot;name&amp;quot;],
  [:CLOSE],
  [:CONTENT, &amp;quot;!\n\n&amp;quot;],
  [:OPEN_BLOCK],
  [:IDENTIFIER, &amp;quot;if&amp;quot;],
  [:IDENTIFIER, &amp;quot;subscribed&amp;quot;],
  [:CLOSE],
  [:CONTENT, &amp;quot;\n  Thank you for subscribing to our mailing list.\n&amp;quot;],
  [:OPEN_INVERSE],
  [:CLOSE],
  [:CONTENT, &amp;quot;\n  Please sign up for our mailing list to be notified about new articles!\n&amp;quot;],
  [:OPEN_END_BLOCK],
  [:IDENTIFIER, &amp;quot;if&amp;quot;],
  [:CLOSE],
  [:CONTENT, &amp;quot;\n\nYour friends at &amp;quot;],
  [:OPEN_EXPRESSION],
  [:IDENTIFIER, &amp;quot;company_name&amp;quot;],
  [:CLOSE],
  [:CONTENT, &amp;quot;\n&amp;quot;]
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we&amp;#39;re finished, we&amp;#39;ve identified seven different types of tokens:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Token&lt;/th&gt;
&lt;th&gt;Example&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;&lt;code&gt;OPEN_BLOCK&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{{#&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;OPEN_END_BLOCK&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{{/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;OPEN_INVERSE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{{else&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;OPEN_EXPRESSION&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;{{&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CONTENT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Anything outside of expressions (normal HTML or Text)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;CLOSE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;}}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;IDENTIFIER&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Identifiers consist of Word characters, numbers, &lt;code&gt;_&lt;/code&gt;, and &lt;code&gt;-&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;The next step is to implement a parser that tries to figure out the structure of the token stream and translates it into an abstract syntax tree, but that&amp;#39;s for another time.&lt;/p&gt;
&lt;h2 id=&quot;the-road-ahead&quot;&gt;The Road Ahead&lt;/h2&gt;
&lt;p&gt;We started our journey towards our own templating language by looking at different ways to implement a basic templating system using string interpolation. When we hit the limits of the first approaches, we started implementing a proper templating system.&lt;/p&gt;
&lt;p&gt;For now, we implemented a lexer that analyses the template and figures out the different types of tokens. In an upcoming edition of Ruby Magic, we&amp;#39;ll continue the journey by implementing a parser as well as an interpreter to generate an interpolated string.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Inside Enumeration in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/05/28/ruby-magic-enumeration.html">
    <id>https://blog.appsignal.com/2019/05/28/ruby-magic-enumeration.html</id>
    <published>2019-05-28T00:00:00+00:00</published>
    <updated>2019-05-28T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">We dive even deeper into enumeration by looking at the internal implementation and implementing our own versions of the `Enumerable` module and the `Enumerator` class.</summary>
    <content type="html">&lt;p&gt;Welcome back to another edition of Ruby Magic! A year ago, we learned about &lt;a href=&quot;/2018/05/29/ruby-magic-enumerable-and-enumerator.html&quot;&gt;Ruby’s &lt;code&gt;Enumerable&lt;/code&gt; module&lt;/a&gt;, which provides the methods you use when working with enumerable objects like arrays, ranges, and hashes.&lt;/p&gt;
&lt;p&gt;Back then, we created a &lt;code&gt;LinkedList&lt;/code&gt; class to show how to make an object enumerable by implementing the &lt;code&gt;#each&lt;/code&gt; method on it. By including the &lt;code&gt;Enumerable&lt;/code&gt; module, we were able to call methods like &lt;code&gt;#count&lt;/code&gt;, &lt;code&gt;#map&lt;/code&gt; and &lt;code&gt;#select&lt;/code&gt; on any linked list without having to implement them ourselves.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ve learned how to use enumerables, but how do they work? Part of the magic in enumerables in Ruby comes from their internal implementation, which is all based on the single &lt;code&gt;#each&lt;/code&gt; method, and even allows chaining enumerators.&lt;/p&gt;
&lt;p&gt;Today, we’ll learn how the methods in the &lt;code&gt;Enumerable&lt;/code&gt; class are implemented and how &lt;code&gt;Enumerator&lt;/code&gt; objects allow chaining enumeration methods.&lt;/p&gt;
&lt;p&gt;As you&amp;#39;ve become accustomed to, we&amp;#39;ll dive in deep by implementing our own versions of the &lt;code&gt;Enumerable&lt;/code&gt; module and &lt;code&gt;Enumerator&lt;/code&gt; class. So, put on your over-engineering helmet and let&amp;#39;s go!&lt;/p&gt;
&lt;h2 id=&quot;linked-lists&quot;&gt;Linked Lists&lt;/h2&gt;
&lt;p&gt;Before we begin, let’s start with a new version of the linked list class we wrote previously.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class LinkedList
  def initialize(head = nil, *rest)
    @head = head

    if rest.first.is_a?(LinkedList)
      @tail = rest.first
    elsif rest.any?
      @tail = LinkedList.new(*rest)
    end
  end

  def &amp;lt;&amp;lt;(head)
    @head ? LinkedList.new(head, self) : LinkedList.new(head)
  end

  def inspect
    [@head, @tail].compact
  end

  def each(&amp;amp;block)
    yield @head if @head
    @tail.each(&amp;amp;block) if @tail
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unlike the previous version, this implementation allows empty lists to be created, as well as lists with more than two items. This version also allows passing a linked list as the tail when initializing another.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;irb&amp;gt; LinkedList.new
=&amp;gt; []
irb&amp;gt; LinkedList.new(1)
=&amp;gt; [1]
irb&amp;gt; LinkedList.new(1, 2)
=&amp;gt; [1,[2]]
irb&amp;gt; LinkedList.new(1, 2, 3)
=&amp;gt; [1,[2,[3]]]
irb&amp;gt; LinkedList.new(1, LinkedList.new(2, 3))
=&amp;gt; [1,[2,[3]]]
irb&amp;gt; LinkedList.new(1, 2, LinkedList.new(3))
=&amp;gt; [1,[2,[3]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Previously, our &lt;code&gt;LinkedLIst&lt;/code&gt; class included &lt;a href=&quot;http://ruby-doc.org/core-2.6.3/Enumerable.html&quot;&gt;the &lt;code&gt;Enumerable&lt;/code&gt; module&lt;/a&gt;. When mapping over an object using one of &lt;code&gt;Enumerable&lt;/code&gt;&amp;#39;s methods, the result are stored in an array. This time, we&amp;#39;ll implement our own version to make sure our methods return new linked lists instead.&lt;/p&gt;
&lt;h2 id=&quot;enumerable-methods&quot;&gt;Enumerable Methods&lt;/h2&gt;
&lt;p&gt;Ruby&amp;#39;s &lt;code&gt;Enumerable&lt;/code&gt; module comes with enumeration methods like &lt;code&gt;#map&lt;/code&gt;, &lt;code&gt;#count&lt;/code&gt;, and &lt;code&gt;#select&lt;/code&gt;. By implementing the &lt;code&gt;#each&lt;/code&gt; method and including the &lt;code&gt;Enumerable&lt;/code&gt; module in our class, we&amp;#39;d be able to use those methods directly on our linked lists.&lt;/p&gt;
&lt;p&gt;Instead, we&amp;#39;ll implement &lt;code&gt;DIYEnumerable&lt;/code&gt; and import that instead of Ruby&amp;#39;s version. This isn&amp;#39;t something you&amp;#39;d typically do, but it will give us a clear insight into how enumeration works internally.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s start with &lt;code&gt;#count&lt;/code&gt;. Each of the importable methods in the &lt;code&gt;Enumerable&lt;/code&gt; class uses the &lt;code&gt;#each&lt;/code&gt; method we implemented in our &lt;code&gt;LinkedList&lt;/code&gt; class to loop over the object to calculate their results.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module DIYEnumerable
  def count
    result = 0
    each { |element| result += 1 }
    result
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we&amp;#39;ve implemented the &lt;code&gt;#count&lt;/code&gt; method on a new &lt;code&gt;DIYEnumerable&lt;/code&gt; module that we’ll include in our linked list. It starts a counter at zero and calls the &lt;code&gt;#each&lt;/code&gt; method to add one to the counter for every loop. After looping over all elements, the method returns the resulting counter.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module DIYEnumerable
  # ...

  def map
    result = LinkedList.new
    each { |element| result = result &amp;lt;&amp;lt; yield(element) }
    result
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;#map&lt;/code&gt; method is implemented similarly. Instead of keeping a counter, it uses an accumulator, which starts as an empty list. We&amp;#39;ll loop over all elements in the list, and yield the passed block on each element. The result of each yield is appended to the accumulator list.&lt;/p&gt;
&lt;p&gt;The method returns the accumulator after looping over all of the elements in the input list.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class LinkedList
  include DIYEnumerable

  #...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After including the &lt;code&gt;DIYEnumerable&lt;/code&gt; in our &lt;code&gt;LinkedList&lt;/code&gt;, we can test our newly added &lt;code&gt;#count&lt;/code&gt; and &lt;code&gt;#map&lt;/code&gt; methods.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;irb&amp;gt; list = LinkedList.new(73, 12, 42)
=&amp;gt; [73, [12, [42]]]
irb&amp;gt; list.count
=&amp;gt; 3
irb&amp;gt; list.map { |element| element * 10 }
=&amp;gt; [420, [120, [730]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Both methods work! The &lt;code&gt;#count&lt;/code&gt; method correctly counts the items in the list, and the &lt;code&gt;#map&lt;/code&gt; method runs a block for each item and returns an updated list.&lt;/p&gt;
&lt;h2 id=&quot;reversed-lists&quot;&gt;Reversed lists&lt;/h2&gt;
&lt;p&gt;However, the &lt;code&gt;#map&lt;/code&gt; method seems to have reverted the list. That’s understandable, as the &lt;code&gt;#&amp;lt;&amp;lt;&lt;/code&gt; method on our linked list class prepends items to the list instead of appending them, which is a feature of the recursive nature of linked lists.&lt;/p&gt;
&lt;p&gt;For situations where it’s essential that the order of the list is retained, we need a way to reverse the list when mapping over it. Ruby implements &lt;code&gt;Enumerable#reverse_each&lt;/code&gt;, which loops over an object in reverse. That which sounds like an excellent solution to our problem. Sadly, we can’t use an approach like that because our list is nested. We don’t know how long the list is until we loop over it entirely.&lt;/p&gt;
&lt;p&gt;Instead of running the block over the list in reverse, we’ll add a version of &lt;code&gt;#reverse_each&lt;/code&gt; that does this two steps. It first loops over the list to reverse it by creating a new list. After that, it runs the block over the reversed list.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module DIYEnumerable
  # ...

  def reverse_each(&amp;amp;block)
    list = LinkedList.new
    each { |element| list = list &amp;lt;&amp;lt; element }
    list.each(&amp;amp;block)
  end

  def map
    result = LinkedList.new
    reverse_each { |element| result = result &amp;lt;&amp;lt; yield(element) }
    result
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we&amp;#39;ll use &lt;code&gt;#reverse_each&lt;/code&gt; in our &lt;code&gt;#map&lt;/code&gt; method, to make sure it&amp;#39;s returned in the correct order.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;irb&amp;gt; list = LinkedList.new(73, 12, 42)
=&amp;gt; [73, [12, [42]]]
irb&amp;gt; list.map { |element| element * 10 }
=&amp;gt; [730, [120, [420]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It works! Whenever we call our &lt;code&gt;#map&lt;/code&gt; method on a linked list, we&amp;#39;ll get a new list back in the same order as the original.&lt;/p&gt;
&lt;h2 id=&quot;chaining-enumeration-with-enumerators&quot;&gt;Chaining Enumeration with Enumerators&lt;/h2&gt;
&lt;p&gt;Through the &lt;code&gt;#each&lt;/code&gt; method implemented on our linked list class and the included &lt;code&gt;DIYEnumerator&lt;/code&gt;, we can now loop both ways and map over linked lists.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;irb&amp;gt; list.each { |x| p x }
73
12
42
irb&amp;gt; list.reverse_each { |x| p x }
42
12
73
irb&amp;gt; list.reverse_each.map { |x| x * 10 }
=&amp;gt; [730, [120, [420]]]
=&amp;gt; [420, [120, [730]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, what if we need to &lt;em&gt;map&lt;/em&gt; over a list in reverse? Since we now reverse the list before mapping over it, it always returns in the same order as the original list. We&amp;#39;ve already implemented both &lt;code&gt;#reverse_each&lt;/code&gt; and &lt;code&gt;#map&lt;/code&gt;, so we should be able to chain them together to be able to map backwards. Luckily, Ruby&amp;#39;s &lt;code&gt;Enumerator&lt;/code&gt; class can help with that.&lt;/p&gt;
&lt;p&gt;Last time, we made sure to call &lt;code&gt;Kernel#to_enum&lt;/code&gt; if the &lt;code&gt;LinkedList#each&lt;/code&gt; method was called without a block. This allowed for chaining enumerable methods by returning an &lt;code&gt;Enumerator&lt;/code&gt; object. To find out how &lt;a href=&quot;http://ruby-doc.org/core-2.6.3/Enumerator.html&quot;&gt;the &lt;code&gt;Enumerator&lt;/code&gt; class&lt;/a&gt; works, we’ll implement our own version.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class DIYEnumerator
  include DIYEnumerable

  def initialize(object, method)
    @object = object
    @method = method
  end

  def each(&amp;amp;block)
    @object.send(@method, &amp;amp;block)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Like Ruby&amp;#39;s &lt;code&gt;Enumerator&lt;/code&gt;, our enumerator class is a wrapper around a method on an object. By bubbling up to the wrapped object, we can chain enumeration methods.&lt;/p&gt;
&lt;p&gt;This works because a &lt;code&gt;DIYEnumerator&lt;/code&gt; instance is enumerable itself. It implements &lt;code&gt;#each&lt;/code&gt; by calling the wrapped object, and includes the &lt;code&gt;DIYEnumerable&lt;/code&gt; module so all enumerable methods can be called on it.&lt;/p&gt;
&lt;p&gt;We’ll return an instance of our &lt;code&gt;DIYEnumerator&lt;/code&gt; class if no block is passed to the &lt;code&gt;LinkedList#each&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class LinkedList
  # ...

  def each(&amp;amp;block)
    if block_given?
      yield @head
      @tail.each(&amp;amp;block) if @tail
    else
      DIYEnumerator.new(self, :each)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using our own enumerator, we can now chain enumeration to get the result in the original order without having to pass an empty block to the &lt;code&gt;#reverse_each&lt;/code&gt; method call.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;irb&amp;gt; list = LinkedList.new(73, 12, 42)
=&amp;gt; [73, [12, [42]]]
irb&amp;gt; list.map { |element| element * 10 }
=&amp;gt; [420, [120, [730]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;eager-and-lazy-enumeration&quot;&gt;Eager and lazy enumeration&lt;/h2&gt;
&lt;p&gt;This concludes our peek into the implementation of the &lt;code&gt;Enumerable&lt;/code&gt; module and the &lt;code&gt;Enumerator&lt;/code&gt; class for now. We&amp;#39;ve learned how some of the enumerable methods work and how an enumerator helps chaining enumeration by wrapping an enumerable object.&lt;/p&gt;
&lt;p&gt;There are some issues with our approach, though. By its nature, enumeration is &lt;em&gt;eager&lt;/em&gt;, meaning it loops over the list as soon as one of the enumerable methods is called on it. While that&amp;#39;s fine in most cases, mapping over a list in reverse reverses the list twice, which should be unnecessary.&lt;/p&gt;
&lt;p&gt;To lower the number of loops, we could employ &lt;a href=&quot;http://ruby-doc.org/core-2.6.3/Enumerator/Lazy.html&quot;&gt;&lt;code&gt;Enumerator::Lazy&lt;/code&gt;&lt;/a&gt; to delay looping to the last moment, and have duplicate list reversing cancel itself out.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ll have to save that for a future episode, though. Don&amp;#39;t want to miss that, and further expeditions into Ruby&amp;#39;s magical inner workings? Subscribe to the &lt;a href=&quot;/ruby-magic&quot;&gt;Ruby Magic e-mail newsletter&lt;/a&gt;, to get new articles delivered to your inbox as soon as they&amp;#39;re published.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Ruby's Hidden Gems -Delegator and Forwardable</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/04/30/ruby-magic-hidden-gems-delegator-forwardable.html">
    <id>https://blog.appsignal.com/2019/04/30/ruby-magic-hidden-gems-delegator-forwardable.html</id>
    <published>2019-04-30T00:00:00+00:00</published>
    <updated>2019-04-30T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In today's exploration of Ruby's standard library, we're going to look at delegation through Ruby's Delegator and Forwardable classes.</summary>
    <content type="html">&lt;p&gt;In today&amp;#39;s exploration of the hidden gems in Ruby&amp;#39;s standard library, we&amp;#39;re going to look at delegation.&lt;/p&gt;
&lt;p&gt;Unfortunately, this term—like so many others—has become somewhat muddled over the years and means different things to different people. According to &lt;a href=&quot;https://en.wikipedia.org/wiki/Delegation_(object-oriented_programming)&quot;&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Delegation refers to evaluating a member (property or method) of one object (the receiver) in the context of another original object (the sender). Delegation can be done explicitly, by passing the sending object to the receiving object, which can be done in any object-oriented language; or implicitly, by the member lookup rules of the language, which requires language support for the feature.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;However, more often than not, people also use the term to describe an object calling the corresponding method of another object without passing itself as an argument, which can more precisely be referred to as &amp;quot;forwarding&amp;quot;.&lt;/p&gt;
&lt;p&gt;With that out of the way, we&amp;#39;ll use &amp;quot;delegation&amp;quot; to describe both of these patterns for the rest of the article.&lt;/p&gt;
&lt;h2 id=&quot;delegator&quot;&gt;Delegator&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s start our exploration of delegation in Ruby by looking at the standard library&amp;#39;s &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.2/libdoc/delegate/rdoc/Delegator.html&quot;&gt;&lt;code&gt;Delegator&lt;/code&gt;&lt;/a&gt; class which provides several delegation patterns.&lt;/p&gt;
&lt;h3 id=&quot;simpledelegator&quot;&gt;SimpleDelegator&lt;/h3&gt;
&lt;p&gt;The easiest of these, and the one I&amp;#39;ve encountered most in the wild, is &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.2/libdoc/delegate/rdoc/SimpleDelegator.html&quot;&gt;&lt;code&gt;SimpleDelegator&lt;/code&gt;&lt;/a&gt;, which wraps an object provided via the initializer and then delegates all missing methods to it. Let&amp;#39;s see this in action:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;delegate&amp;#39;

User = Struct.new(:first_name, :last_name)

class UserDecorator &amp;lt; SimpleDelegator
  def full_name
    &amp;quot;#{first_name} #{last_name}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First, we needed to &lt;code&gt;require &amp;#39;delegate&amp;#39;&lt;/code&gt; to make &lt;code&gt;SimpleDelegator&lt;/code&gt; available to our code. We also used a &lt;a href=&quot;https://ruby-doc.org/core-2.6.2/Struct.html&quot;&gt;&lt;code&gt;Struct&lt;/code&gt;&lt;/a&gt; to create a simple &lt;code&gt;User&lt;/code&gt; class with &lt;code&gt;first_name&lt;/code&gt; and &lt;code&gt;last_name&lt;/code&gt; accessors. We then added &lt;code&gt;UserDecorator&lt;/code&gt; which defines a &lt;code&gt;full_name&lt;/code&gt; method combining the individual name parts into a single string. This is where &lt;code&gt;SimpleDelegator&lt;/code&gt; comes into play: since neither &lt;code&gt;first_name&lt;/code&gt; nor &lt;code&gt;last_name&lt;/code&gt; are defined on the current class, they will instead be called on the wrapped object:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;decorated_user = UserDecorator.new(User.new(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;))
decorated_user.full_name
#=&amp;gt; &amp;quot;John Doe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SimpleDelegator&lt;/code&gt; also lets us override delegated methods with &lt;code&gt;super&lt;/code&gt;, calling the corresponding method on the wrapped object. We can use this in our example to only show the initial instead of the full first name:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class UserDecorator &amp;lt; SimpleDelegator
  def first_name
    &amp;quot;#{super[0]}.&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;decorated_user.first_name
#=&amp;gt; &amp;quot;J.&amp;quot;
decorated_user.full_name
#=&amp;gt; &amp;quot;J. Doe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;delegator-1&quot;&gt;Delegator&lt;/h3&gt;
&lt;p&gt;While reading the above examples, did you wonder how our &lt;code&gt;UserDecorator&lt;/code&gt; knew which object to delegate to? The answer to that lies in &lt;code&gt;SimpleDelegator&lt;/code&gt;&amp;#39;s parent class—&lt;code&gt;Delegator&lt;/code&gt;. This is an abstract base class for defining custom delegation schemes by providing implementations for &lt;code&gt;__getobj__&lt;/code&gt; and &lt;code&gt;__setobj__&lt;/code&gt; to get and set the delegation target respectively. Using this knowledge, we can easily build our own version of &lt;code&gt;SimpleDelegator&lt;/code&gt; for demonstration purposes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MyDelegator &amp;lt; Delegator
  attr_accessor :wrapped
  alias_method :__getobj__, :wrapped

  def initialize(obj)
    @wrapped = obj
  end
end

class UserDecorator &amp;lt; MyDelegator
  def full_name
    &amp;quot;#{first_name} #{last_name}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This differs slightly from &lt;code&gt;SimpleDelegator&lt;/code&gt;&amp;#39;s real implementation which calls &lt;code&gt;__setobj__&lt;/code&gt; in its &lt;code&gt;initialize&lt;/code&gt; method. Since our custom delegator class has no need for it, we completely left out that method.&lt;/p&gt;
&lt;p&gt;This should work exactly like our previous example; and indeed it does:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;UserDecorator.superclass
#=&amp;gt; MyDelegator &amp;lt; Delegator
decorated_user = UserDecorator.new(User.new(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;))
decorated_user.full_name
#=&amp;gt; &amp;quot;John Doe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;delegatemethod&quot;&gt;DelegateMethod&lt;/h3&gt;
&lt;p&gt;The last delegation pattern &lt;code&gt;Delegate&lt;/code&gt; provides for us is the somewhat oddly named &lt;code&gt;Object.DelegateClass&lt;/code&gt; method. This generates and returns a delegator class for a specific class, which we can then inherit from:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;  class MyClass &amp;lt; DelegateClass(ClassToDelegateTo)
    def initialize
      super(obj_of_ClassToDelegateTo)
    end
  end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this may look confusing at first—especially the fact that the right-hand side of inheritance can contain arbitrary Ruby code—it actually follows the patterns we explored previously, i.e. it&amp;#39;s similar to inheriting from &lt;code&gt;SimpleDelegator&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ruby&amp;#39;s standard library uses this feature to define its &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.2/libdoc/tempfile/rdoc/Tempfile.html&quot;&gt;&lt;code&gt;Tempfile&lt;/code&gt;&lt;/a&gt; class which delegates much of its work to the &lt;a href=&quot;https://ruby-doc.org/core-2.6.2/File.html&quot;&gt;&lt;code&gt;File&lt;/code&gt;&lt;/a&gt; class while setting up some special rules regarding storage location and file deletion. We could use the same mechanism to set up a custom &lt;code&gt;Logfile&lt;/code&gt; class like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Logfile &amp;lt; DelegateClass(File)
  MODE = File::WRONLY|File::CREAT|File::APPEND

  def initialize(basename, logdir = &amp;#39;/var/log&amp;#39;)
    # Create logfile in location specified by logdir
    path = File.join(logdir, basename)
    logfile = File.open(path, MODE, 0644)

    # This will call Delegator&amp;#39;s initialize method, so below this point
    # we can call any method from File on our Logfile instances.
    super(logfile)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;forwardable&quot;&gt;Forwardable&lt;/h2&gt;
&lt;p&gt;Interestingly enough, Ruby&amp;#39;s standard library provides us with another library for delegation in the form of the &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.2/libdoc/forwardable/rdoc/Forwardable.html&quot;&gt;&lt;code&gt;Forwardable&lt;/code&gt;&lt;/a&gt; module and its &lt;code&gt;def_delegator&lt;/code&gt; and &lt;code&gt;def_delegators&lt;/code&gt; methods.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s rewrite our original &lt;code&gt;UserDecorator&lt;/code&gt; example with &lt;code&gt;Forwardable&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;forwardable&amp;#39;

User = Struct.new(:first_name, :last_name)

class UserDecorator
  extend Forwardable
  def_delegators :@user, :first_name, :last_name

  def initialize(user)
    @user = user
  end

  def full_name
    &amp;quot;#{first_name} #{last_name}&amp;quot;
  end
end

decorated_user = UserDecorator.new(User.new(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;))
decorated_user.full_name
#=&amp;gt; &amp;quot;John Doe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The most noticeable difference is that delegation isn&amp;#39;t automatically provided via &lt;code&gt;method_missing&lt;/code&gt;, but instead, needs to be explicitly declared for each method we want to forward. This allows us to &amp;quot;hide&amp;quot; any methods of the wrapped object we don&amp;#39;t want to expose to our clients, which gives us more control over our public interface and is the main reason I generally prefer &lt;code&gt;Forwardable&lt;/code&gt; over &lt;code&gt;SimpleDelegator&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Another nice feature of &lt;code&gt;Forwardable&lt;/code&gt; is the ability to rename delegated methods via &lt;code&gt;def_delegator&lt;/code&gt;, which accepts an optional third argument that specifies the desired alias:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class UserDecorator
  extend Forwardable
  def_delegator :@user, :first_name, :personal_name
  def_delegator :@user, :last_name, :family_name

  def initialize(user)
    @user = user
  end

  def full_name
    &amp;quot;#{personal_name} #{family_name}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The above &lt;code&gt;UserDecorator&lt;/code&gt; only exposes the aliased &lt;code&gt;personal_name&lt;/code&gt; and &lt;code&gt;family_name&lt;/code&gt; methods, while still forwarding to the &lt;code&gt;first_name&lt;/code&gt; and &lt;code&gt;last_name&lt;/code&gt; of the wrapped &lt;code&gt;User&lt;/code&gt; object:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;decorated_user = UserDecorator.new(User.new(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;))
decorated_user.first_name
#=&amp;gt; NoMethodError: undefined method `first_name&amp;#39; for #&amp;lt;UserDecorator:0x000000010f995cb8&amp;gt;
decorated_user.personal_name
#=&amp;gt; &amp;quot;John&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This feature can come in quite handy at times. I&amp;#39;ve successfully used it in the past for things like migrating code between libraries with similar interfaces but different expectations regarding method names.&lt;/p&gt;
&lt;h2 id=&quot;outside-the-standard-library&quot;&gt;Outside the Standard Library&lt;/h2&gt;
&lt;p&gt;Despite the existing delegation solutions in the standard library, the Ruby community has developed several alternatives over the years and we&amp;#39;ll explore two of them next.&lt;/p&gt;
&lt;h3 id=&quot;delegate&quot;&gt;delegate&lt;/h3&gt;
&lt;p&gt;Considering Rails&amp;#39; popularity, its &lt;a href=&quot;https://apidock.com/rails/Module/delegate&quot;&gt;&lt;code&gt;delegate&lt;/code&gt;&lt;/a&gt; method may well be the most commonly used form of delegation used by Ruby developers. Here&amp;#39;s how we could use it to rewrite our trusty old &lt;code&gt;UserDecorator&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# In a real Rails app this would most likely be a subclass of ApplicationRecord
User = Struct.new(:first_name, :last_name)

class UserDecorator
  attr_reader :user
  delegate :first_name, :last_name, to: :user

  def initialize(user)
    @user = user
  end

  def full_name
    &amp;quot;#{first_name} #{last_name}&amp;quot;
  end
end

decorated_user = UserDecorator.new(User.new(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;))
decorated_user.full_name
#=&amp;gt; &amp;quot;John Doe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is quite similar to &lt;code&gt;Forwardable&lt;/code&gt;, but we don&amp;#39;t need to use &lt;code&gt;extend&lt;/code&gt; since &lt;code&gt;delegate&lt;/code&gt; is directly defined on &lt;code&gt;Module&lt;/code&gt; and therefore available in every class or module body (for better or worse, you decide). However, &lt;code&gt;delegate&lt;/code&gt; has a few neat tricks up its sleeve. First, there&amp;#39;s the &lt;code&gt;:prefix&lt;/code&gt; option which will prefix the delegated method names with the name of the object we&amp;#39;re delegating to. So,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;delegate :first_name, :last_name, to: :user, prefix: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;will generate &lt;code&gt;user_first_name&lt;/code&gt; and &lt;code&gt;user_last_name&lt;/code&gt; methods. Alternatively we can provide a custom prefix:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delegate :first_name, :last_name, to: :user, prefix: :account
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now access the different parts of the user&amp;#39;s name as &lt;code&gt;account_first_name&lt;/code&gt; and &lt;code&gt;account_last_name&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Another interesting option of &lt;code&gt;delegate&lt;/code&gt; is its &lt;code&gt;:allow_nil&lt;/code&gt; option. If the object we delegate to is currently &lt;code&gt;nil&lt;/code&gt;—for example because of an unset &lt;code&gt;ActiveRecord&lt;/code&gt; relation—we would usually end up with a &lt;code&gt;NoMethodError&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;decorated_user = UserDecorator.new(nil)
decorated_user.first_name
#=&amp;gt; Module::DelegationError: UserDecorator#first_name delegated to @user.first_name, but @user is nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, with the &lt;code&gt;:allow_nil&lt;/code&gt; option, this call will succeed and return &lt;code&gt;nil&lt;/code&gt; instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class UserDecorator
  delegate :first_name, :last_name, to: :user, allow_nil: true

  ...
end

decorated_user = UserDecorator.new(nil)
decorated_user.first_name
#=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;casting&quot;&gt;Casting&lt;/h3&gt;
&lt;p&gt;The last delegation option we&amp;#39;ll be looking at is Jim Gay&amp;#39;s &lt;a href=&quot;https://github.com/saturnflyer/casting&quot;&gt;&lt;code&gt;Casting&lt;/code&gt;&lt;/a&gt; gem, which allows developers to &amp;quot;delegate methods in Ruby and preserve self&amp;quot;. This is probably the closest to the strict definition of delegation, as it uses Ruby&amp;#39;s dynamic nature to temporarily rebind the receiver of a method call, akin to this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;UserDecorator.instance_method(:full_name).bind(user).call
#=&amp;gt; &amp;quot;John Doe&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The most interesting aspect of this is that developers can add behavior to objects, without changing their superclass hierarchies.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;casting&amp;#39;

User = Struct.new(:first_name, :last_name)

module UserDecorator
  def full_name
    &amp;quot;#{first_name} #{last_name}&amp;quot;
  end
end

user = User.new(&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;)
user.extend(Casting::Client)
user.delegate(:full_name, UserDecorator)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we extended &lt;code&gt;user&lt;/code&gt; with &lt;code&gt;Casting::Client&lt;/code&gt;, which gives us access to the &lt;code&gt;delegate&lt;/code&gt; method. Alternatively, we could have used &lt;code&gt;include Casting::Client&lt;/code&gt; inside the &lt;code&gt;User&lt;/code&gt; class to give this ability to all instances.&lt;/p&gt;
&lt;p&gt;Additionally, &lt;code&gt;Casting&lt;/code&gt; provides options for temporarily adding behaviors for the lifetime of a block or until manually removed again. For this to work, we first need to enable delegation of missing methods:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;user.delegate_missing_methods
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To add behavior for the duration of a single block, we can then use &lt;code&gt;Casting&lt;/code&gt;&amp;#39;s &lt;code&gt;delegating&lt;/code&gt; class method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Casting.delegating(user =&amp;gt; UserDecorator) do
  user.full_name #=&amp;gt; &amp;quot;John Doe&amp;quot;
end

user.full_name
#NoMethodError: undefined method `full_name&amp;#39; for #&amp;lt;struct User first_name=&amp;quot;John&amp;quot;, last_name=&amp;quot;Doe&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alternatively, we can add behavior until we explicitly call &lt;code&gt;uncast&lt;/code&gt; again:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;user.cast_as(UserDecorator)
user.full_name
#=&amp;gt; &amp;quot;John Doe&amp;quot;
user.uncast
NoMethodError: undefined method `full_name&amp;#39; for #&amp;lt;struct User first_name=&amp;quot;John&amp;quot;, last_name=&amp;quot;Doe&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While slightly more complex than the other presented solutions, &lt;code&gt;Casting&lt;/code&gt; provides a lot of control and Jim demonstrates its various uses and more in his &lt;a href=&quot;http://www.clean-ruby.com/&quot;&gt;Clean Ruby&lt;/a&gt; book.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Delegation and method forwarding are useful patterns for dividing responsibilities between related objects. In plain Ruby projects, both &lt;code&gt;Delegator&lt;/code&gt; and &lt;code&gt;Forwardable&lt;/code&gt; can be used, whereas Rails code tends to gravitate towards its &lt;code&gt;delegate&lt;/code&gt; method. For maximum control on what is delegated, the &lt;code&gt;Casting&lt;/code&gt; gem is an excellent choice, though it&amp;#39;s slightly more complex than the other solutions.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Guest Author &lt;a href=&quot;https://citizen428.net/&quot;&gt;Michael Kohl’s&lt;/a&gt; love affair with Ruby started around 2003. He also enjoys writing and speaking about the language and co-organizes &lt;a href=&quot;https://www.meetup.com/bangkok-rb/members/&quot;&gt;Bangkok.rb&lt;/a&gt; and &lt;a href=&quot;https://rubyconfth.com/&quot;&gt;RubyConf Thailand&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Learning by building, a Background Processing System in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/04/02/background-processing-system-in-ruby.html">
    <id>https://blog.appsignal.com/2019/04/02/background-processing-system-in-ruby.html</id>
    <published>2019-04-02T00:00:00+00:00</published>
    <updated>2019-04-02T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In this edition of Ruby Magic, we'll implement our very own background processing system to offload potentially slow tasks as a peek into background job libraries like Sidekiq.</summary>
    <content type="html">&lt;p&gt;In today&amp;#39;s post, we are going to implement a naive background processing system for fun! We might learn some things along the way as a peek into the internals of popular background processing systems like &lt;a href=&quot;http://sidekiq.org&quot;&gt;Sidekiq&lt;/a&gt;. The product of this fun is by no means intended for production use.&lt;/p&gt;
&lt;p&gt;Let’s imagine we have a task in our application that loads one or more websites and extracts their titles. As we don’t have any influence on the performance of these websites, we’d like to perform the task outside our main thread (or the current request—if we’re building a web application), but in the background.&lt;/p&gt;
&lt;h2 id=&quot;encapsulating-a-task&quot;&gt;Encapsulating a Task&lt;/h2&gt;
&lt;p&gt;Before we get into background processing, let’s build a service object to perform the task at hand. We’ll use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.2/libdoc/open-uri/rdoc/OpenURI.html&quot;&gt;OpenURI&lt;/a&gt; and &lt;a href=&quot;https://nokogiri.org&quot;&gt;Nokogiri&lt;/a&gt; to extract the contents of the title tag.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;open-uri&amp;#39;
require &amp;#39;nokogiri&amp;#39;

class TitleExtractorService
  def call(url)
    document = Nokogiri::HTML(open(url))
    title = document.css(&amp;#39;html &amp;gt; head &amp;gt; title&amp;#39;).first.content
    puts title.gsub(/[[:space:]]+/, &amp;#39; &amp;#39;).strip
  rescue
    puts &amp;quot;Unable to find a title for #{url}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the service prints the title of the given URL.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;TitleExtractorService.new.call(&amp;#39;https://appsignal.com&amp;#39;)
# AppSignal: Application Performance Monitoring for Ruby on Rails and Elixir
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This works as expected, but let’s see if we can improve the syntax a little to make it look and feel a bit more like other background processing systems. By creating a &lt;code&gt;Magique::Worker&lt;/code&gt; module, we can add some syntactic sugar to the service object.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magique
  module Worker
    def self.included(base)
      base.extend(ClassMethods)
    end

    module ClassMethods
      def perform_now(*args)
        new.perform(*args)
      end
    end

    def perform(*)
      raise NotImplementedError
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The module adds a &lt;code&gt;perform&lt;/code&gt; method to the worker instance and a &lt;code&gt;perform_now&lt;/code&gt; method to the worker class to make the invocation a bit better.&lt;/p&gt;
&lt;p&gt;Let’s include the module into our service object. While we’re at it, let’s also rename it to &lt;code&gt;TitleExtractorWorker&lt;/code&gt; and change the &lt;code&gt;call&lt;/code&gt; method to &lt;code&gt;perform&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class TitleExtractorWorker
  include Magique::Worker

  def perform(url)
    document = Nokogiri::HTML(open(url))
    title = document.css(&amp;#39;html &amp;gt; head &amp;gt; title&amp;#39;).first.content
    puts title.gsub(/[[:space:]]+/, &amp;#39; &amp;#39;).strip
  rescue
    puts &amp;quot;Unable to find a title for #{url}&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The invocation still has the same result, but it’s a bit clearer what&amp;#39;s going on.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;TitleExtractorWorker.perform_now(&amp;#39;https://appsignal.com&amp;#39;)
# AppSignal: Application Performance Monitoring for Ruby on Rails and Elixir
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;implementing-asynchronous-processing&quot;&gt;Implementing Asynchronous Processing&lt;/h2&gt;
&lt;p&gt;Now that we have the title extraction working, we can grab all titles from past Ruby Magic articles. To do this, let’s assume we have a &lt;code&gt;RUBYMAGIC&lt;/code&gt; constant with a list of all the URLs of past articles.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;RUBYMAGIC.each do |url|
  TitleExtractorWorker.perform_now(url)
end

# Unraveling Classes, Instances and Metaclasses in Ruby | AppSignal Blog
# Bindings and Lexical Scope in Ruby | AppSignal Blog
# Building a Ruby C Extension From Scratch | AppSignal Blog
# Closures in Ruby: Blocks, Procs and Lambdas | AppSignal Blog
# ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get the titles of past articles, but it takes a while to extract them all. That’s because we wait until each request is completed before moving on to the next one.&lt;/p&gt;
&lt;p&gt;Let’s improve that by introducing a &lt;code&gt;perform_async&lt;/code&gt; method to our worker module. To speed things up, it creates a new thread for each URL.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magique
  module Worker
    module ClassMethods
      def perform_async(*args)
        Thread.new { new.perform(*args) }
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After changing the invocation to &lt;code&gt;TitleExtractorWorker.perform_async(url)&lt;/code&gt;, we get all the titles almost at once. However, this also means that we’re opening more than 20 connections to the Ruby Magic blog at once. (&lt;em&gt;Sorry for messing with your blog, folks!&lt;/em&gt; 😅)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If you’re following along with your own implementation and testing this outside of a long-running process (like a web server), don’t forget to add something like &lt;code&gt;loop { sleep 1 }&lt;/code&gt; to the end of your script to make sure the process doesn’t immediately terminate.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;queueing-up-tasks&quot;&gt;Queueing up Tasks&lt;/h2&gt;
&lt;p&gt;With the approach of creating a new thread for every invocation, we’ll eventually hit resource limits (both on our side and on the websites we are accessing). As we’d like to be nice citizens, let’s change the implementation to something that is asynchronous but doesn’t feel like a denial-of-service attack.&lt;/p&gt;
&lt;p&gt;A common way to solve this problem is to use the producer/consumer pattern. One or more producers push tasks onto a queue while one or more consumers take tasks from the queue and process them.&lt;/p&gt;
&lt;p&gt;A queue is basically a list of elements. In theory, a simple array would do the job. However, as we’re dealing with concurrency, we need to make sure that only one producer or consumer can access the queue at a time. If we aren’t careful about this, things will end in chaos—just like two people trying to squeeze through a door at once.&lt;/p&gt;
&lt;p&gt;This problem is known as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem&quot;&gt;producer-consumer problem&lt;/a&gt; and there are multiple solutions to it. Luckily, it is a very common problem and Ruby ships with a proper &lt;code&gt;Queue&lt;/code&gt; implementation that we can use without having to worry about thread synchronization.&lt;/p&gt;
&lt;p&gt;To use it, let’s make sure both producers and consumers can access the queue. We do this by adding a class method to our &lt;code&gt;Magique&lt;/code&gt; module and assigning an instance of &lt;code&gt;Queue&lt;/code&gt; to it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magique
  def self.backend
    @backend
  end

  def self.backend=(backend)
    @backend = backend
  end
end

Magique.backend = Queue.new
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we change our &lt;code&gt;perform_async&lt;/code&gt; implementation to push a task onto the queue instead of creating its own new thread. A task is represented as a hash including a reference to the worker class as well as the arguments passed to the &lt;code&gt;perform_async&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magique
  module Worker
    module ClassMethods
      def perform_async(*args)
        Magique.backend.push(worker: self, args: args)
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that, we’re done with the producer side of things. Next, let’s take a look at the consumer side.&lt;/p&gt;
&lt;p&gt;Each consumer is a separate thread that takes tasks from the queue and performs them. Instead of stopping after one task, like the thread, the consumer then takes another task from the queue and performs it, and so on. Here’s a basic implementation of a consumer called &lt;code&gt;Magique::Processor&lt;/code&gt;. Each processor creates a new thread that loops infinitely. For every iteration, it tries to grab a new task from the queue, creates a new instance of the worker class, and calls its &lt;code&gt;perform&lt;/code&gt; method with the given arguments.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Magique
  class Processor
    def self.start(concurrency = 1)
      concurrency.times { |n| new(&amp;quot;Processor #{n}&amp;quot;) }
    end

    def initialize(name)
      thread = Thread.new do
        loop do
          payload = Magique.backend.pop
          worker_class = payload[:worker]
          worker_class.new.perform(*payload[:args])
        end
      end

      thread.name = name
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In addition to the processing loop, we add a convenience method called &lt;code&gt;Magique::Processor.start&lt;/code&gt;. This allows us to spin up multiple processors at once. While naming the thread isn’t really necessary, it will allow us to see if things are actually working as expected.&lt;/p&gt;
&lt;p&gt;Let’s adjust the output of our &lt;code&gt;TitleExtractorWorker&lt;/code&gt; to include the name of the current thread.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;puts &amp;quot;[#{Thread.current.name}] #{title.gsub(/[[:space:]]+/, &amp;#39; &amp;#39;).strip}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To test our background processing setup, we first need to spin up a set of processors before enqueueing our tasks.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Magique.backend = Queue.new
Magique::Processor.start(5)

RUBYMAGIC.each do |url|
  TitleExtractorWorker.perform_async(url)
end

# [Processor 3] Bindings and Lexical Scope in Ruby | AppSignal Blog
# [Processor 4] Building a Ruby C Extension From Scratch | AppSignal Blog
# [Processor 1] Unraveling Classes, Instances and Metaclasses in Ruby | AppSignal Blog
# [Processor 0] Ruby&amp;#39;s Hidden Gems, StringScanner | AppSignal Blog
# [Processor 2] Fibers and Enumerators in Ruby: Turning Blocks Inside Out | AppSignal Blog
# [Processor 4] Closures in Ruby: Blocks, Procs and Lambdas | AppSignal Blog
# ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When this is run, we still get the titles of all articles. While it’s not as fast as just using a separate thread for every task, it’s still faster than the initial implementation that had no background processing. Thanks to the added processor names, we can also confirm that all processors are working through the queue. By tweaking the number of concurrent processors, it’s possible to find a balance between processing speed and existing resource limitations.&lt;/p&gt;
&lt;h2 id=&quot;expanding-to-multiple-processes-and-machines&quot;&gt;Expanding to Multiple Processes and Machines&lt;/h2&gt;
&lt;p&gt;So far, the current implementation of our background processing system works well enough. It’s still limited to the same process, though. Resource-hungry tasks will still affect the performance of the entire process. As a final step, let’s look at distributing the workload across multiple processes and maybe even multiple machines.&lt;/p&gt;
&lt;p&gt;The queue is the only connection between producers and consumers. Right now, it’s using an in-memory implementation. Let’s take more inspiration from Sidekiq and implement a queue using &lt;a href=&quot;http://redis.org&quot;&gt;Redis&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Redis has support for lists that allow us to push and fetch tasks from. Additionally, the Redis Ruby gem is thread-safe and the Redis commands to modify lists are &lt;a href=&quot;https://en.wikipedia.org/wiki/Linearizability&quot;&gt;atomic&lt;/a&gt;. These properties make it possible to use it for our asynchronous background processing system without running into synchronization problems.&lt;/p&gt;
&lt;p&gt;Let’s create a Redis backed queue that implements the &lt;code&gt;push&lt;/code&gt; and &lt;code&gt;shift&lt;/code&gt; methods just like the &lt;code&gt;Queue&lt;/code&gt; we used previously.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;json&amp;#39;
require &amp;#39;redis&amp;#39;

module Magique
  module Backend
    class Redis
      def initialize(connection = ::Redis.new)
        @connection = connection
      end

      def push(job)
        @connection.lpush(&amp;#39;magique:queue&amp;#39;, JSON.dump(job))
      end

      def shift
        _queue, job = @connection.brpop(&amp;#39;magique:queue&amp;#39;)
        payload = JSON.parse(job, symbolize_names: true)
        payload[:worker] = Object.const_get(payload[:worker])
        payload
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As Redis doesn’t know anything about Ruby objects, we have to serialize our tasks into JSON before storing them in the database using the &lt;code&gt;lpush&lt;/code&gt; command that adds an element to the front of the list.&lt;/p&gt;
&lt;p&gt;To fetch a task from the queue, we’re using the &lt;code&gt;brpop&lt;/code&gt; command, which gets the last element from a list. If the list is empty, it’ll block until a new element is available. This is a nice way to pause our processors when no tasks are available. Finally, after getting a task out of Redis, we have to look up the real Ruby class based on the name of the worker using &lt;code&gt;Object.const_get&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;As a final step, let’s split things up into multiple processes. On the producer side of things, the only thing we have to do is change the backend to our newly implemented Redis queue.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# ...

Magique.backend = Magique::Backend::Redis.new

RUBYMAGIC.each do |url|
  TitleExtractorWorker.perform_async(url)
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On the consumer side of things, we can get away with a few lines like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# ...

Magique.backend = Magique::Backend::Redis.new
Magique::Processor.start(5)

loop { sleep 1 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When executed, the consumer process will wait for new work to arrive in the queue. Once we start the producer process that pushes tasks into the queue, we can see that they get processed immediately.&lt;/p&gt;
&lt;h2 id=&quot;enjoy-responsibly-and-dont-use-this-in-production&quot;&gt;Enjoy Responsibly and Don’t Use This in Production&lt;/h2&gt;
&lt;p&gt;While we kept it far from a real world setup you would use in production (so don&amp;#39;t!), we took a few steps in building a background processor. We started by making a process run as a background service. Then we made it async and used &lt;code&gt;Queue&lt;/code&gt; to solve the producer-consumer problem. Then we expanded the process to multiple processes or machines using Redis rather then an in-memory implementation.&lt;/p&gt;
&lt;p&gt;As mentioned before, this is a simplified implementation of a background processing system. There are a lot of things missing and not explicitly dealt with. These include (but are not limited to) error handling, multiple queues, scheduling, connection pooling, and signal handling.&lt;/p&gt;
&lt;p&gt;Nonetheless, we had fun writing this and hope you enjoyed a peek under the hood of a background processing system. Perhaps you even took away a thing or two.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Ruby's Hidden Gems, StringScanner</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/03/05/stringscanner.html">
    <id>https://blog.appsignal.com/2019/03/05/stringscanner.html</id>
    <published>2019-03-05T00:00:00+00:00</published>
    <updated>2019-03-05T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Ruby comes with an excellent standard library. Parts of which are unknown, almost hidden gems, like today's subject Stringscanner</summary>
    <content type="html">&lt;p&gt;Ruby is not only a fun language, it also comes with an excellent standard library. Some of which are not that known, and are almost hidden Gems. Today guest writer Michael Kohl highlights a favorite: Stringscanner.&lt;/p&gt;
&lt;h1 id=&quot;rubys-hidden-gems-stringscanner&quot;&gt;Ruby&amp;#39;s hidden Gems: StringScanner&lt;/h1&gt;
&lt;p&gt;One can get quite far without having to resort to installing third party gems, from data structures like &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/ostruct/rdoc/OpenStruct.html&quot;&gt;OpenStruct&lt;/a&gt; and &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/set/rdoc/Set.html&quot;&gt;Set&lt;/a&gt; over &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/csv/rdoc/CSV.html&quot;&gt;CSV parsing&lt;/a&gt; to &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/benchmark/rdoc/Benchmark.html&quot;&gt;benchmarking&lt;/a&gt;. However, there are some less well-known libraries available in Ruby&amp;#39;s standard installation that can be very useful, one of which is &lt;code&gt;StringScanner&lt;/code&gt; which according to the &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html&quot;&gt;documentation&lt;/a&gt; &lt;em&gt;&amp;quot;provides lexical scanning operations on a string&amp;quot;&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;scanning-and-parsing&quot;&gt;Scanning and parsing&lt;/h2&gt;
&lt;p&gt;So what does &amp;quot;lexical scanning&amp;quot; mean exactly? Essentially it describes the process of taking an input string and extracting meaningful bits of information from it, following certain rules. For example, this can be seen at the first stage of a compiler which takes an expression like &lt;code&gt;2 + 1&lt;/code&gt; as input and turns it into the following sequence of tokens:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[{ number: &amp;quot;1&amp;quot; }, {operator: &amp;quot;+&amp;quot;}, { number: &amp;quot;1&amp;quot;}]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Lexical scanners are usually implemented as &lt;a href=&quot;https://en.wikipedia.org/wiki/Finite-state_machine&quot;&gt;finite-state automata&lt;/a&gt; and there are several well-known tools available that can generate them for us (e.g. &lt;a href=&quot;https://www.antlr.org/&quot;&gt;ANTLR&lt;/a&gt; or &lt;a href=&quot;https://www.colm.net/open-source/ragel/&quot;&gt;Ragel&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;However, sometimes our parsing needs aren&amp;#39;t that elaborate, and a simpler library like the &lt;a href=&quot;https://en.wikipedia.org/wiki/Regular_expression&quot;&gt;regular expression&lt;/a&gt; based &lt;code&gt;StringScanner&lt;/code&gt; can come in very handy in such situations. It works by remembering the location of a so-called &lt;em&gt;scan pointer&lt;/em&gt; which is nothing more than an index into the string. The scanning process then tries to match the code right after the scan pointer with the provided expression. Apart from matching operations, &lt;code&gt;StringScanner&lt;/code&gt; also provides methods for moving the scan pointer (moving forwards or backwards through the string), looking ahead (seeing what&amp;#39;s next without modifying the scan pointer just yet) as well as finding out where in the string we currently are (is it the beginning or end of a line/the entire string etc).&lt;/p&gt;
&lt;h2 id=&quot;parsing-rails-logs&quot;&gt;Parsing Rails Logs&lt;/h2&gt;
&lt;p&gt;Enough theory, let&amp;#39;s see &lt;code&gt;StringScanner&lt;/code&gt; in action. The following example will take a Rails&amp;#39; log entry like the one below,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;log_entry = &amp;lt;&amp;lt;EOS
Started GET &amp;quot;/&amp;quot; for 127.0.0.1 at 2017-08-20 20:53:10 +0900
Processing by HomeController#index as HTML
  Rendered text template within layouts/application (0.0ms)
  Rendered layouts/_assets.html.erb (2.0ms)
  Rendered layouts/_top.html.erb (2.6ms)
  Rendered layouts/_about.html.erb (0.3ms)
  Rendered layouts/_google_analytics.html.erb (0.4ms)
Completed 200 OK in 79ms (Views: 78.8ms | ActiveRecord: 0.0ms)
EOS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and parse it into the following hash:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;{
  method: &amp;quot;GET&amp;quot;,
  path: &amp;quot;/&amp;quot;
  ip: &amp;quot;127.0.0.1&amp;quot;,
  timestamp: &amp;quot;2017-08-20 20:53:10 +0900&amp;quot;,
  success: true,
  response_code: &amp;quot;200&amp;quot;,
  duration: &amp;quot;79ms&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;NB: While this makes for a good example for &lt;code&gt;StringScanner&lt;/code&gt; a real application would be better off using &lt;a href=&quot;https://github.com/roidrage/lograge&quot;&gt;Lograge&lt;/a&gt; and its JSON log formatter.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In order to use &lt;code&gt;StringScanner&lt;/code&gt; we first need to require it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;strscan&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After this we can initialize a new instance by passing the log entry as an argument to the constructor. At the same time we&amp;#39;ll also define an empty hash to hold the result of our parsing efforts:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;scanner = StringScanner.new(log_entry)
log = {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now use the scanner&amp;#39;s &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html#method-i-pos&quot;&gt;pos&lt;/a&gt; method to get the current location of our scan pointer. As expected, the result is &lt;code&gt;0&lt;/code&gt;, the first character of the string:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;scanner.pos #=&amp;gt; 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;#39;s visualize this so the process will be easier to follow along:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/&amp;quot; for 127.0.0.1 at 2017-08-20 20:53:10 +0900
^
...
Completed 200 OK in 79ms (Views: 78.8ms | ActiveRecord: 0.0ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For further introspection of the scanner&amp;#39;s state we can use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html#method-i-beginning_of_line-3F&quot;&gt;&lt;code&gt;beginning_of_line?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html#method-i-eos-3F&quot;&gt;&lt;code&gt;eos?&lt;/code&gt;&lt;/a&gt; to confirm that the scan pointer currently is at the beginning of a line and that we have not yet fully consumed our input:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;scanner.beginning_of_line? #=&amp;gt; true
scanner.eos? #=&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first bit of information we want to extract is the HTTP request method, which can be found right after the word &amp;quot;Started&amp;quot; followed by a space. We can use the scanner&amp;#39;s appropriately named &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html#method-i-skip&quot;&gt;skip&lt;/a&gt; method to advance the scan pointer, which will return the number of ignored characters, which in our case is 8. Additionally we can use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html#method-i-matched-3F&quot;&gt;matched?&lt;/a&gt; to confirm that everything worked as expected:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;scanner.skip(/Started /) #=&amp;gt; 8
scanner.matched? #=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The scan pointer is now right before the request method:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/&amp;quot; for 127.0.0.1 at 2017-08-20 20:53:10 +0900
       ^
...
Completed 200 OK in 79ms (Views: 78.8ms | ActiveRecord: 0.0ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html#method-i-scan_until&quot;&gt;scan_until&lt;/a&gt; to extract the actual value, which returns the entire regular expression match. Since the request method is all in uppercase, we can use a simple character class and the &lt;code&gt;+&lt;/code&gt; operator which matches one or characters:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;log[:method] = scanner.scan_until(/[A-Z]+/) #=&amp;gt; &amp;quot;GET&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After this operation the scan pointer will be at the final &amp;quot;T&amp;quot; of the word &amp;quot;GET&amp;quot;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/&amp;quot; for 127.0.0.1 at 2017-08-20 20:53:10 +0900
          ^
...
Completed 200 OK in 79ms (Views: 78.8ms | ActiveRecord: 0.0ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To extract the requested path, we will therefore need to skip one space and then extract everything enclosed in double quotes. There are several ways to achieve this, one of them is via a capture group (the part of the Regular expression included in parenthesis, i.e. &lt;code&gt;(.+)&lt;/code&gt;) which matches one or more of any character:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;scanner.scan(/\s&amp;quot;(.+)&amp;quot;/) #=&amp;gt; &amp;quot; \&amp;quot;/\&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, we will not be using the return value of this &lt;code&gt;scan&lt;/code&gt; operation directly, but instead use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html#method-i-captures&quot;&gt;captures&lt;/a&gt; to get the value of the first capture group instead:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;log[:path] =  scanner.captures.first #=&amp;gt; &amp;quot;/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We successfully extracted the path and the scan pointer is now at the closing double quote:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/&amp;quot; for 127.0.0.1 at 2017-08-20 20:53:10 +0900
              ^
...
Completed 200 OK in 79ms (Views: 78.8ms | ActiveRecord: 0.0ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To parse the IP address from the log, we once again use &lt;code&gt;skip&lt;/code&gt; to ignore the string &amp;quot;for&amp;quot; surrounded by spaces and then use &lt;code&gt;scan_until&lt;/code&gt; to match one or more non whitespace characters (&lt;code&gt;\s&lt;/code&gt; is the character class representing whitespace and &lt;code&gt;[^\s]&lt;/code&gt; is its negation):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;scanner.skip(/ for /) #=&amp;gt; 5
log[:ip] = scanner.scan_until(/[^\s]+/) #=&amp;gt; &amp;quot;127.0.0.1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Can you tell where the scan pointer will be now? Think about it for a moment and then compare your answer to the solution:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/&amp;quot; for 127.0.0.1 at 2017-08-20 20:53:10 +0900
                            ^
...
Completed 200 OK in 79ms (Views: 78.8ms | ActiveRecord: 0.0ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Parsing the timestamp should feel very familiar by now. First we use trusty old &lt;code&gt;skip&lt;/code&gt; to ignore the literal string &lt;code&gt;&amp;quot; at &amp;quot;&lt;/code&gt; and then use &lt;code&gt;scan_until&lt;/code&gt; to read until the end of the current line, which is represented by &lt;code&gt;$&lt;/code&gt; in regular expressions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;scanner.skip(/ at /) #=&amp;gt; 4
log[:timestamp] = scanner.scan_until(/$/) #=&amp;gt; &amp;quot;2017-08-20 20:53:10 +0900&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The next piece of information we&amp;#39;re interested in is the HTTP status code on the last line, so we&amp;#39;ll use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html#method-i-skip_until&quot;&gt;skip_until&lt;/a&gt; to take us all the way to the space after the word &amp;quot;Completed&amp;quot;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;scanner.skip_until(/Completed /) #=&amp;gt; 296
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As the name suggests this works similarly to &lt;code&gt;scan_until&lt;/code&gt; but instead of returning the matched string it returns the number of skipped over characters. This puts the scan pointer right in front of the HTTP status code we&amp;#39;re interested in.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/&amp;quot; for 127.0.0.1 at 2017-08-20 20:53:10 +0900
...
Completed 200 OK in 79ms (Views: 78.8ms | ActiveRecord: 0.0ms)
         ^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now before we scan the actual HTTP response code, wouldn&amp;#39;t it be nice if we could tell if the HTTP response code denotes a success (for the sake of this example any code in the 2xx range) or failure (all other ranges)? To achieve this we will make use of &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html#method-i-peek&quot;&gt;peek&lt;/a&gt; to look at the next character, without actually moving the scan pointer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;log[:success] = scanner.peek(1) == &amp;quot;2&amp;quot; #=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.6.1/libdoc/strscan/rdoc/StringScanner.html#method-i-scan&quot;&gt;scan&lt;/a&gt; to read the next three characters, represented by the regular expression &lt;code&gt;/\d{3}/&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;log[:response_code] = scanner.scan(/\d{3}/) #=&amp;gt; &amp;quot;200&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once again the scan pointer will be right at the end of the previously matched regular expression:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/&amp;quot; for 127.0.0.1 at 2017-08-20 20:53:10 +0900
...
Completed 200 OK in 79ms (Views: 78.8ms | ActiveRecord: 0.0ms)
            ^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The last bit of information we want to extract from our log entry is the execution time in milliseconds, which can be achieved by &lt;code&gt;skip&lt;/code&gt;ping over the string &lt;code&gt;&amp;quot; OK in &amp;quot;&lt;/code&gt; and then reading everything up to and including the literal string &lt;code&gt;&amp;quot;ms&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;scanner.skip(/ OK in /) #=&amp;gt; 7
log[:duration] = scanner.scan_until(/ms/) #=&amp;gt; &amp;quot;79ms&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And with that last bit in there, we have the hash we wanted.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;{
  method: &amp;quot;GET&amp;quot;,
  path: &amp;quot;/&amp;quot;
  ip: &amp;quot;127.0.0.1&amp;quot;,
  timestamp: &amp;quot;2017-08-20 20:53:10 +0900&amp;quot;,
  success: true,
  response_code: &amp;quot;200&amp;quot;,
  duration: &amp;quot;79ms&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;
&lt;p&gt;Ruby&amp;#39;s &lt;code&gt;StringScanner&lt;/code&gt; occupies a nice middle ground between simple regular expressions and a full-blown lexer. It isn&amp;#39;t the best choice for complex scanning and parsing needs. But it&amp;#39;s straightforward nature makes it easy for everyone with basic regular expression knowledge to extract information from input strings and I&amp;#39;ve used those successfully in production code in the past. We hope you&amp;#39;ll discover this hidden Gem.&lt;/p&gt;
&lt;p&gt;PS: Let us know what you think are hidden Gems we should highlight next!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Unraveling Classes, Instances and Metaclasses in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/02/05/ruby-magic-classes-instances-and-metaclasses.html">
    <id>https://blog.appsignal.com/2019/02/05/ruby-magic-classes-instances-and-metaclasses.html</id>
    <published>2019-02-05T00:00:00+00:00</published>
    <updated>2019-02-05T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Through examining metaclasses, we'll learn how class and instance methods work in Ruby.</summary>
    <content type="html">&lt;p&gt;Welcome to a new episode of Ruby Magic! This month&amp;#39;s edition is all about metaclasses, a subject sparked by a discussion between two developers (Hi Maud!).&lt;/p&gt;
&lt;p&gt;Through examining metaclasses, we&amp;#39;ll learn how class and instance methods work in Ruby. Along the way, discover the difference between defining a method by passing an explicit &amp;quot;definee&amp;quot; and using &lt;code&gt;class &amp;lt;&amp;lt; self&lt;/code&gt; or &lt;code&gt;instance_eval&lt;/code&gt;. Let&amp;#39;s go!&lt;/p&gt;
&lt;h2 id=&quot;class-instances-and-instance-methods&quot;&gt;Class Instances and Instance Methods&lt;/h2&gt;
&lt;p&gt;To understand why metaclasses are used in Ruby, we&amp;#39;ll start by examining what the differences are between instance- and class methods.&lt;/p&gt;
&lt;p&gt;In Ruby, a &lt;em&gt;class&lt;/em&gt; is an object that defines a blueprint to create other objects. Classes define which methods are available on any instance of that class.&lt;/p&gt;
&lt;p&gt;Defining a method inside a class creates an &lt;em&gt;instance method&lt;/em&gt; on that class. Any future instance of that class will have that method available.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User
  def initialize(name)
    @name = name
  end

  def name
    @name
  end
end

user = User.new(&amp;#39;Thijs&amp;#39;)
user.name # =&amp;gt; &amp;quot;Thijs&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we create a class named &lt;code&gt;User&lt;/code&gt;, with an &lt;em&gt;instance method&lt;/em&gt; named &lt;code&gt;#name&lt;/code&gt; that returns the user&amp;#39;s name. Using the class, we then create a &lt;em&gt;class instance&lt;/em&gt; and store it in a variable named &lt;code&gt;user&lt;/code&gt;. Since &lt;code&gt;user&lt;/code&gt; is an instance of the &lt;code&gt;User&lt;/code&gt; class, it has the &lt;code&gt;#name&lt;/code&gt; method available.&lt;/p&gt;
&lt;p&gt;A class stores its instance methods in its &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Virtual_method_table&quot;&gt;method table&lt;/a&gt;&lt;/em&gt;. Any instance of that class refers to its class’ method table to get access to its instance methods.&lt;/p&gt;
&lt;h2 id=&quot;class-objects&quot;&gt;Class Objects&lt;/h2&gt;
&lt;p&gt;A &lt;em&gt;class method&lt;/em&gt; is a method that can be called directly on the class without having to create an instance first. A class method is created by prefixing its name with &lt;code&gt;self.&lt;/code&gt; when defining it.&lt;/p&gt;
&lt;p&gt;A class is itself an object. A constant refers to the class object, so class methods defined on it can be called from anywhere in the application.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User
  # ...

  def self.all
    [new(&amp;quot;Thijs&amp;quot;), new(&amp;quot;Robert&amp;quot;), new(&amp;quot;Tom&amp;quot;)]
  end
end

User.all # =&amp;gt; [#&amp;lt;User:0x00007fb01701efb8 @name=&amp;quot;Thijs&amp;quot;&amp;gt;, #&amp;lt;User:0x00007fb01701ef68 @name=&amp;quot;Robert&amp;quot;&amp;gt;, #&amp;lt;User:0x00007fb01701ef18 @name=&amp;quot;Tom&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Methods defined with a &lt;code&gt;self.&lt;/code&gt;-prefix aren’t added to the class’s method table. They’re instead added to the class’ metaclass.&lt;/p&gt;
&lt;h2 id=&quot;metaclasses&quot;&gt;Metaclasses&lt;/h2&gt;
&lt;p&gt;Aside from a class, each object in Ruby has a hidden metaclass. Metaclasses are singletons, meaning they belong to a single object. If you create multiple instances of a class, they’ll share the same class, but they’ll all have separate metaclasses.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;thijs, robert, tom = User.all

thijs.class # =&amp;gt; User
robert.class # =&amp;gt; User
tom.class # =&amp;gt; User

thijs.singleton_class  # =&amp;gt; #&amp;lt;Class:#&amp;lt;User:0x00007fb71a9a2cb0&amp;gt;&amp;gt;
robert.singleton_class # =&amp;gt; #&amp;lt;Class:#&amp;lt;User:0x00007fb71a9a2c60&amp;gt;&amp;gt;
tom.singleton_class    # =&amp;gt; #&amp;lt;Class:#&amp;lt;User:0x00007fb71a9a2c10&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we see that although each of the objects has the class &lt;code&gt;User&lt;/code&gt;, their singleton classes have different object IDs, meaning they’re separate objects.&lt;/p&gt;
&lt;p&gt;By having access to a metaclass, Ruby allows adding methods directly to existing objects. Doing so won’t add a new method to the object’s class.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;robert = User.new(&amp;quot;Robert&amp;quot;)

def robert.last_name
  &amp;quot;Beekman&amp;quot;
end

robert.last_name # =&amp;gt; &amp;quot;Beekman&amp;quot;
User.new(&amp;quot;Tom&amp;quot;).last_name # =&amp;gt; NoMethodError (undefined method `last_name&amp;#39; for #&amp;lt;User:0x00007fe1cb116408&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we add a &lt;code&gt;#last_name&lt;/code&gt; to the user stored in the &lt;code&gt;robert&lt;/code&gt; variable. Although &lt;code&gt;robert&lt;/code&gt; is an instance of &lt;code&gt;User&lt;/code&gt;, any newly created instances of &lt;code&gt;User&lt;/code&gt; won’t have access to the &lt;code&gt;#last_name&lt;/code&gt; method, as it only exists on &lt;code&gt;robert&lt;/code&gt;’s metaclass.&lt;/p&gt;
&lt;h2 id=&quot;what-is-self&quot;&gt;What Is &lt;code&gt;self&lt;/code&gt;?&lt;/h2&gt;
&lt;p&gt;When defining a method and passing a receiver, the new method is added to the receiver’s metaclass, instead of adding it to the class’ method table.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;tom = User.new(&amp;quot;Tom&amp;quot;)

def tom.last_name
  &amp;quot;de Bruijn&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above, we&amp;#39;ve added &lt;code&gt;#last_name&lt;/code&gt; directly on the &lt;code&gt;tom&lt;/code&gt; object, by passing &lt;code&gt;tom&lt;/code&gt; as the receiver when defining the method.&lt;/p&gt;
&lt;p&gt;This is also how it works for class methods.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User
  # ...

  def self.all
    [new(&amp;quot;Thijs&amp;quot;), new(&amp;quot;Robert&amp;quot;), new(&amp;quot;Tom&amp;quot;)]
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we explicitly pass &lt;code&gt;self&lt;/code&gt; as a receiver when creating the &lt;code&gt;.all&lt;/code&gt; method. In a class definition, &lt;code&gt;self&lt;/code&gt; refers to the class (&lt;code&gt;User&lt;/code&gt; in this case), so the &lt;code&gt;.all&lt;/code&gt; method gets added to &lt;code&gt;User&lt;/code&gt;&amp;#39;s metaclass.&lt;/p&gt;
&lt;p&gt;Because &lt;code&gt;User&lt;/code&gt; is an object stored in a constant, we’ll access the same object—and the same metaclass—whenever we reference it.&lt;/p&gt;
&lt;h2 id=&quot;opening-the-metaclass&quot;&gt;Opening the Metaclass&lt;/h2&gt;
&lt;p&gt;We’ve learned that class methods are methods in the class object’s metaclass. Knowing this, we’ll look at some other techniques of creating class methods that you might have seen before.&lt;/p&gt;
&lt;h3 id=&quot;class--self&quot;&gt;&lt;code&gt;class &amp;lt;&amp;lt; self&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Although it has gone out of style a bit, some libraries use &lt;code&gt;class &amp;lt;&amp;lt; self&lt;/code&gt; to define class methods. This syntax trick opens up the current class&amp;#39;s metaclass and interacts with it directly.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User
  class &amp;lt;&amp;lt; self
    self # =&amp;gt; #&amp;lt;Class:User&amp;gt;

    def all
      [new(&amp;quot;Thijs&amp;quot;), new(&amp;quot;Robert&amp;quot;), new(&amp;quot;Tom&amp;quot;)]
    end
  end
end

User.all # =&amp;gt; [#&amp;lt;User:0x00007fb01701efb8 @name=&amp;quot;Thijs&amp;quot;&amp;gt;, #&amp;lt;User:0x00007fb01701ef68 @name=&amp;quot;Robert&amp;quot;&amp;gt;, #&amp;lt;User:0x00007fb01701ef18 @name=&amp;quot;Tom&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This example creates a class method named &lt;code&gt;User.all&lt;/code&gt; by adding a method to &lt;code&gt;User&lt;/code&gt;&amp;#39;s metaclass. Instead of explicitly passing a receiver for the method as we saw previously, we set &lt;code&gt;self&lt;/code&gt; to &lt;code&gt;User&lt;/code&gt;&amp;#39;s metaclass instead of &lt;code&gt;User&lt;/code&gt; itself.&lt;/p&gt;
&lt;p&gt;As we learned before, any method definition without an explicit receiver gets added as an instance method of the current class. Inside the block, the current class is &lt;code&gt;User&lt;/code&gt;&amp;#39;s metaclass (&lt;code&gt;#&amp;lt;Class:User&amp;gt;&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id=&quot;instance_eval&quot;&gt;&lt;code&gt;instance_eval&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Another option is by using &lt;code&gt;instance_eval&lt;/code&gt;, which does the same thing with one major difference. Although the class&amp;#39;s metaclass receives the methods defined in the block, &lt;code&gt;self&lt;/code&gt; remains a reference to the main class.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class User
  instance_eval do
    self # =&amp;gt; User

    def all
      [new(&amp;quot;Thijs&amp;quot;), new(&amp;quot;Robert&amp;quot;), new(&amp;quot;Tom&amp;quot;)]
    end
  end
end

User.all # =&amp;gt; [#&amp;lt;User:0x00007fb01701efb8 @name=&amp;quot;Thijs&amp;quot;&amp;gt;, #&amp;lt;User:0x00007fb01701ef68 @name=&amp;quot;Robert&amp;quot;&amp;gt;, #&amp;lt;User:0x00007fb01701ef18 @name=&amp;quot;Tom&amp;quot;&amp;gt;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we define an instance method on &lt;code&gt;User&lt;/code&gt;&amp;#39;s metaclass just like before, but &lt;code&gt;self&lt;/code&gt; still points to &lt;code&gt;User&lt;/code&gt;. Although it usually points to the same object, the &amp;quot;default definee&amp;quot; and &lt;code&gt;self&lt;/code&gt; can point to different objects.&lt;/p&gt;
&lt;h2 id=&quot;what-weve-learned&quot;&gt;What We&amp;#39;ve Learned&lt;/h2&gt;
&lt;p&gt;We&amp;#39;ve learned that classes are the only objects that can have methods, and that instance methods are actually methods on an object&amp;#39;s metaclass. We know that &lt;code&gt;class &amp;lt;&amp;lt; self&lt;/code&gt; simply swaps &lt;code&gt;self&lt;/code&gt; around to allow you to define methods on the metaclass, and we know that &lt;code&gt;instance_eval&lt;/code&gt; does mostly the same thing (but without touching &lt;code&gt;self&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Although you won&amp;#39;t explicitly work with metaclasses, Ruby uses them extensively under the hood. Knowing what happens when you define a method can help you understand why Ruby behaves like it does (and why you have to prefix class methods with &lt;code&gt;self.&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Thanks for reading. If you liked what you read, you might like to &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to Ruby Magic&lt;/a&gt; to receive an e-mail when we publish a new article about once a month.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Bindings and Lexical Scope in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2019/01/08/ruby-magic-bindings-and-lexical-scope.html">
    <id>https://blog.appsignal.com/2019/01/08/ruby-magic-bindings-and-lexical-scope.html</id>
    <published>2019-01-08T00:00:00+00:00</published>
    <updated>2019-01-08T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In this edition of Ruby Magic, we’ll show how scope works in Ruby’s methods and closures. We’ll also take a peek at how ERB uses the binding object to render templates.</summary>
    <content type="html">&lt;p&gt;Happy new year, and welcome back to Ruby Magic! In this winter episode, we&amp;#39;ll dive into bindings and scopes. So put on your skis and follow us deep into the woods.&lt;/p&gt;
&lt;p&gt;Last time, we looked at &lt;a href=&quot;/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html&quot;&gt;closures in Ruby&lt;/a&gt; by comparing blocks, procs and lambdas. Aside from the differences between the three types, we touched on what defines a &lt;em&gt;closure&lt;/em&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A closure is a first-class function with an environment. The environment is a mapping to the variables that existed when the closure was created. The closure retains its access to these variables, even if they’re defined in another scope.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We&amp;#39;ve explored Ruby&amp;#39;s equivalent to first-class functions, but we conveniently skipped over &lt;em&gt;environments&lt;/em&gt;. In this episode, we’ll look at how that environment works for closures, classes and class instances by examining how Ruby handles &lt;em&gt;lexical scope&lt;/em&gt; through its &lt;em&gt;bindings&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;lexical-scope&quot;&gt;Lexical Scope&lt;/h2&gt;
&lt;p&gt;In programming, scope refers to the &lt;em&gt;bindings&lt;/em&gt; available at a specific part of the code. A binding, or &lt;em&gt;name binding&lt;/em&gt;, binds a name to a memory reference, like a variable&amp;#39;s name to its value. The scope defines what &lt;code&gt;self&lt;/code&gt; means, the methods that can be called, and the variables that are available.&lt;/p&gt;
&lt;p&gt;Ruby, like most modern programming languages, uses a static scope, often called &lt;em&gt;lexical scope&lt;/em&gt; (as opposed to &lt;a href=&quot;https://en.wikipedia.org/wiki/Scope_(computer_science)#Lexical_scope_vs._dynamic_scope&quot;&gt;dynamic scope&lt;/a&gt;). The current scope is based on the structure of the code and determines the variables available at specific parts of the code. This means that the scope changes when code jumps between methods, blocks and classes—as they can all have different local variables, for example.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def bar
  foo = 1
  foo
end

bar #  =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this method, we create a &lt;em&gt;local variable&lt;/em&gt; inside a method and print it to the console. The variable is &lt;em&gt;in scope&lt;/em&gt; inside the method, as it’s created there.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;foo = 1

def bar
  foo
end

bar # =&amp;gt; NameError (undefined local variable or method `foo&amp;#39; for main:Object)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we create the variable outside the method. When we call the variable inside a method, we get an error, as the variable is &lt;em&gt;out of scope&lt;/em&gt;. Local variables are tightly scoped, meaning a method can’t access a variable outside itself unless it’s passed as an argument.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;@foo = 1

def bar
  @foo
end

bar #  =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While local variables are available locally, &lt;em&gt;instance variables&lt;/em&gt; are available to all methods of a class instance.&lt;/p&gt;
&lt;h2 id=&quot;inherited-scopes-and-proc-bindings&quot;&gt;Inherited Scopes and Proc Bindings&lt;/h2&gt;
&lt;p&gt;As we&amp;#39;ve seen in the previous examples, the scope is based on the location in the code. A local variable defined outside a method is not in scope inside the method but can be made available by turning it into an instance variable. Methods can&amp;#39;t access local variables defined outside of them because methods have their own scope, with their own bindings.&lt;/p&gt;
&lt;p&gt;Procs (including blocks and lambda&amp;#39;s, by extension) are different. Whenever a proc is instantiated, a binding is created which inherits references to the local variables in the context the block was created.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;foo = 1
Proc.new { foo }.call # =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we set a variable named &lt;code&gt;foo&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt;. Internally, the Proc object created on the second line creates a new binding. When calling the proc, we can ask for the value of the variable.&lt;/p&gt;
&lt;p&gt;Since the binding is created when the proc is initialized, we can’t create the proc before defining the variable, even if the block isn&amp;#39;t called until after the variable is defined.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;proc = Proc.new { foo }
foo = 1
proc.call # =&amp;gt; NameError (undefined local variable or method `foo&amp;#39; for main:Object)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling the proc will produce a &lt;code&gt;NameError&lt;/code&gt; as the variable isn’t defined in the proc’s bindings. Thus, any variables accessed in a proc should be defined before the proc is created or passed as an argument.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;foo = 1
proc = Proc.new { foo }
foo = 2
proc.call # =&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can, however, change the variable after it has been defined in the main context since the proc’s binding holds a reference to it instead of copying it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;foo = 1
Proc.new { foo = 2 }.call
foo #=&amp;gt; 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we can see that the &lt;code&gt;foo&lt;/code&gt; variable points to the same object when in the proc as outside of it. We can update it inside the proc to have the variable outside of it updated as well.&lt;/p&gt;
&lt;h2 id=&quot;bindings&quot;&gt;Bindings&lt;/h2&gt;
&lt;p&gt;To keep track of the current scope, Ruby uses &lt;em&gt;bindings&lt;/em&gt;, which encapsulate the execution context at each position in the code. The &lt;code&gt;binding&lt;/code&gt; method returns a &lt;code&gt;Binding&lt;/code&gt; object which describes the bindings at the current position.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;foo = 1
binding.local_variables # =&amp;gt; [:foo]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The binding object has a method named &lt;code&gt;#local_variables&lt;/code&gt; which returns the names of all local variables available in the current scope.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;foo = 1
binding.eval(&amp;quot;foo&amp;quot;) # =&amp;gt; 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Code can be evaluated on the binding by using the &lt;code&gt;#eval&lt;/code&gt; method. The example above isn&amp;#39;t very useful, as simply calling &lt;code&gt;foo&lt;/code&gt; would have the same result. However, since a binding is an object that can be passed around, it can be used for some more interesting things. Let&amp;#39;s look at an example.&lt;/p&gt;
&lt;h3 id=&quot;a-real-life-example&quot;&gt;A Real-Life Example&lt;/h3&gt;
&lt;p&gt;Now that we&amp;#39;ve learned about bindings in the safety of our garage, like take them out on to the slopes and play around in the snow. Aside from Ruby&amp;#39;s internal use of bindings throughout the language, there are some situations where binding objects are used explicitly. A good example is ERB—Ruby&amp;#39;s templating system.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;erb&amp;#39;

x = 1

def y
  2
end

template = ERB.new(&amp;quot;x is &amp;lt;%= x %&amp;gt;, y() returns &amp;lt;%= y %&amp;gt;, self is `&amp;lt;%= self %&amp;gt;`&amp;quot;)
template.result(binding) # =&amp;gt; &amp;quot;x is 1, y() returns 2, self is `main`&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we create a variable named &lt;code&gt;x&lt;/code&gt;, a method called &lt;code&gt;y&lt;/code&gt;, and an ERB template that references both. We then pass the current binding to &lt;code&gt;ERB#result&lt;/code&gt;, which evaluates the ERB tags in the template and returns a string with the variables filled in.&lt;/p&gt;
&lt;p&gt;Under the hood, ERB uses &lt;code&gt;Binding#eval&lt;/code&gt; to evaluate each ERB tag&amp;#39;s contents in the scope of the passed binding. A simplified implementation that works for the example above could look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class DiyErb
  def initialize(template)
    @template = template
  end

  def result(binding)
    @template.gsub(/&amp;lt;%=(.+?)%&amp;gt;/) do
      binding.eval($1)
    end
  end
end

x = 1

def y
  2
end

template = DiyErb.new(&amp;quot;x is &amp;lt;%= x %&amp;gt;, y() returns &amp;lt;%= y %&amp;gt;, self is `&amp;lt;%= self %&amp;gt;`&amp;quot;)
template.result(binding) # =&amp;gt; &amp;quot;x is 1, y() returns 2, self is `main`&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;DiyErb&lt;/code&gt; class takes a template string on initialization. Its &lt;code&gt;#result&lt;/code&gt; method finds all ERB tags and replaces them with the result of evaluating their contents. To do that, it calls &lt;code&gt;Binding#eval&lt;/code&gt; on the passed binding, with the contents of the ERB tags.&lt;/p&gt;
&lt;p&gt;By passing the current binding when calling the &lt;code&gt;#result&lt;/code&gt; method, the &lt;code&gt;eval&lt;/code&gt; calls can access the variables defined outside of the method, and even outside of the class, without having to pass them explicitly.&lt;/p&gt;
&lt;h2 id=&quot;did-we-lose-you-in-the-woods&quot;&gt;Did we lose you in the woods?&lt;/h2&gt;
&lt;p&gt;We hope you enjoyed our ski trip into the woods. We went deeper into scopes and closures, after glossing over them. We hope we haven&amp;#39;t lost you in the woods. Please let us know if you&amp;#39;d like to learn more about bindings, or have any other Ruby topic you&amp;#39;d like to dive into.&lt;/p&gt;
&lt;p&gt;Thanks for following us and please kick the snow off your bindings before leaving them for the next developer. If you like these magical trips, you might like to &lt;a href=&quot;/ruby-magic&quot;&gt;subscribe to Ruby Magic&lt;/a&gt; to receive an e-mail when we publish a new article about once a month.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Fibers and Enumerators in Ruby - Turning Blocks Inside Out</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/11/27/ruby-magic-fibers-and-enumerators-in-ruby.html">
    <id>https://blog.appsignal.com/2018/11/27/ruby-magic-fibers-and-enumerators-in-ruby.html</id>
    <published>2018-11-27T00:00:00+00:00</published>
    <updated>2018-11-27T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In this edition of Ruby Magic, we shine a light on Enumerable and Fiber to explain flow controlling enumerables and turning blocks inside out.</summary>
    <content type="html">&lt;p&gt;Ruby has various ways of performing iteration—loops, blocks and enumerators. Most Ruby programmers are at least familiar with loops and blocks but &lt;code&gt;Enumerator&lt;/code&gt; and &lt;code&gt;Fiber&lt;/code&gt; often stay in the dark. In this edition of Ruby Magic, guest author Julik shines a light on &lt;code&gt;Enumerable&lt;/code&gt; and &lt;code&gt;Fiber&lt;/code&gt; to explain flow controlling enumerables and turning blocks inside out.&lt;/p&gt;
&lt;h2 id=&quot;suspending-blocks-and-chained-iteration&quot;&gt;Suspending Blocks and Chained Iteration&lt;/h2&gt;
&lt;p&gt;We&amp;#39;ve discussed &lt;a href=&quot;/2018/05/29/ruby-magic-enumerable-and-enumerator.html&quot;&gt;Enumerator&lt;/a&gt; in a previous edition of Ruby Magic, where we described how to return an &lt;code&gt;Enumerator&lt;/code&gt; from your own &lt;code&gt;#each&lt;/code&gt; method and what it can be used for. An even broader use case for &lt;code&gt;Enumerator&lt;/code&gt; and &lt;code&gt;Fiber&lt;/code&gt; is that they can &amp;quot;suspend a block&amp;quot; mid-flight. Not just the block given to &lt;code&gt;#each&lt;/code&gt; or the entire call to &lt;code&gt;#each&lt;/code&gt;, but any block!&lt;/p&gt;
&lt;p&gt;This is a very powerful construct, which can be used to implement shims for methods that work by using blocks as a bridge to callers that expect sequential calls instead of taking a block. For example, imagine we want to open a database handle and read each item that we have retrieved:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;db.with_each_row_of_result(sql_stmt) do |row|
  yield row
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The block API is great since it will potentially perform all kinds of cleanup for us when the block is terminated. However, some consumers might want to work with the database in this way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;@cursor = cursor

# later:
row = @cursor.next_row
send_row_to_event_stream(row)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In practice, it means we want to &amp;quot;suspend&amp;quot; the execution of the block &amp;quot;just for now&amp;quot; and carry on later within the block. Thus, the caller takes over the flow control instead of it being in the hands of the callee (the method performing the block).&lt;/p&gt;
&lt;h2 id=&quot;chaining-iterators&quot;&gt;Chaining Iterators&lt;/h2&gt;
&lt;p&gt;One of the most common uses of this pattern is chaining multiple iterators together. When we do so, the methods we are used to for iteration (like &lt;code&gt;#each&lt;/code&gt;), return an Enumerator object instead, which we can use to &amp;quot;grab&amp;quot; the values that the block sends us using the &lt;code&gt;yield&lt;/code&gt; statement:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;range = 1..8
each_enum = range.each # =&amp;gt; &amp;lt;Enumerator...&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The enumerators can then be &lt;em&gt;chained&lt;/em&gt; which allows us to perform operations like &amp;quot;any iteration but with the index&amp;quot;. In this example, we&amp;#39;re calling &lt;code&gt;#map&lt;/code&gt; on a range to get an &lt;code&gt;Enumerable&lt;/code&gt; object. We then chain &lt;code&gt;#with_index&lt;/code&gt; to iterate over the range with an index:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;(1..3).map.with_index {|element_n, index| [element_n, index] }
#=&amp;gt; [[1, 0], [2, 1], [3, 2]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This can be very useful, especially if your system uses events. Ruby provides a built-in method for wrapping any method with an Enumerator generator, which allows us to accomplish exactly this. Imagine we want to &amp;quot;pull&amp;quot; rows one by one from our &lt;code&gt;with_each_row_of_result&lt;/code&gt;, instead of the method yielding them to us.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;@cursor = db.to_enum(:with_each_row_of_result, sql_stmt)
schedule_for_later do
  begin
    row = @cursor.next
    send_row_to_event_stream(row)
  rescue StopIteration # the block has ended and the cursor is empty, the cleanup has taken place
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we were to implement this ourselves, this is how it would likely come about:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;cursor = Enumerator.new do |yielder|
  db.with_each_row_of_result(sql_stmt) do |row|
    yielder.yield row
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;turning-blocks-inside-out&quot;&gt;Turning Blocks Inside Out&lt;/h2&gt;
&lt;p&gt;Rails allows us to assign the response body to also be an Enumerator. It will call &lt;code&gt;next&lt;/code&gt; on the Enumerator we assign as the response body and expect the returned value to be a string—which will be written out into the Rack response. For example, we can return a call to the &lt;code&gt;#each&lt;/code&gt; method of a Range as a Rails response body:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MyController &amp;lt; ApplicationController
  def index
    response.body = (&amp;#39;a&amp;#39;..&amp;#39;z&amp;#39;).each
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is what I call &lt;em&gt;turning a block inside out.&lt;/em&gt; In essence, it is a control flow helper that allows us to &amp;quot;freeze time&amp;quot; in a block (or a loop, which is also a block in Ruby) mid-flight.&lt;/p&gt;
&lt;p&gt;However, Enumerators have a limiting property that makes them slightly less useful. Imagine we want to do something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;File.open(&amp;#39;output.tmp&amp;#39;, &amp;#39;wb&amp;#39;) do |f|
  # Yield file for writing, continuously
  loop { yield(f) }
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;#39;s wrap it with an enumerator, and write into it&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;writer_enum = File.to_enum(:open, &amp;#39;output.tmp&amp;#39;, &amp;#39;wb&amp;#39;)
file = en.next
file &amp;lt;&amp;lt; data
file &amp;lt;&amp;lt; more_data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Everything works great. However, there is a hitch—how do we tell the enumerator that we are done writing, so that it can &amp;quot;finish&amp;quot; the block, close the file and exit? This will perform a number of important steps—for example, resource cleanup (the file will be closed), as well as ensuring all the buffered writes are flushed to disk. We do have access to the &lt;code&gt;File&lt;/code&gt; object, and we can close it ourselves, but we would like the enumerator to manage the closing for us; we have to let the enumerator proceed past the block.&lt;/p&gt;
&lt;p&gt;Another hurdle is that sometimes we want to pass arguments of what is happening within the suspended block. Imagine we have a block-accepting method with the following semantics:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;write_file_through_encryptor(file_name) do |writable|
  writable &amp;lt;&amp;lt; &amp;quot;Some data&amp;quot;
  writable &amp;lt;&amp;lt; &amp;quot;Some more data&amp;quot;
  writable &amp;lt;&amp;lt; &amp;quot;Even more data&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;but in our calling code we want to use it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;writable = write_file_through_encryptor(file_name)
writable &amp;lt;&amp;lt; &amp;quot;Some data&amp;quot;
# ...later on
writable &amp;lt;&amp;lt; &amp;quot;Some more data&amp;quot;
writable.finish
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ideally, we would wrap our method call into some structure that would permit us the following trick:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;write_file_through_encryptor(file_name) do |writable|
  loop do
    yield_and_wait_for_next_call(writable)
    # Then we somehow break out of this loop to let the block complete
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What if we were to wrap our writes like this?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;deferred_writable = write_file_through_encryptor(file_name)
deferred_writable.next(&amp;quot;Some data&amp;quot;)
deferred_writable.next(&amp;quot;Some more data&amp;quot;)
deferred_writable.next(&amp;quot;Even more data&amp;quot;)
deferred_writable.next(:terminate)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, we will use the &lt;code&gt;:terminate&lt;/code&gt; as a magic value that will tell our method that it can finish the block and return. &lt;strong&gt;This&lt;/strong&gt; is where &lt;code&gt;Enumerator&lt;/code&gt; won&amp;#39;t really help us because we can&amp;#39;t pass any arguments to &lt;code&gt;Enumerator#next&lt;/code&gt;. If we could, we would be able to do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;deferred_writable = write_file_through_encryptor(file_name)
deferred_writable.next(&amp;quot;Some data&amp;quot;)
...
deferred_writable.next(:terminate)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;enter-rubys-fibers&quot;&gt;Enter Ruby&amp;#39;s Fibers&lt;/h2&gt;
&lt;p&gt;This is exactly what Fibers permit. A Fiber allows you to &lt;em&gt;accept arguments on each reentry&lt;/em&gt;, so we can implement our wrapper like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;deferred_writable = Fiber.new do |data_to_write_or_termination|
  write_file_through_encryptor(filename) do |f|
     # Here we enter the block context of the fiber, reentry will be to the start of this block
    loop do
      # When we call Fiber.yield our fiber will be suspended—we won&amp;#39;t reach the
      # &amp;quot;data_to_write_or_termination = &amp;quot; assignment before our fiber gets resumed
      data_to_write_or_termination = Fiber.yield
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This is how it works: When you first call &lt;code&gt;.resume&lt;/code&gt; on your &lt;code&gt;deferred_writable&lt;/code&gt;, it enters the fiber and goes all the way to the first &lt;code&gt;Fiber.yield&lt;/code&gt; statement or to the end of the outermost Fiber block, whichever comes first. When you call &lt;code&gt;Fiber.yield&lt;/code&gt;, it gives you back control. Remember the Enumerator? The block is going to be &lt;em&gt;suspended&lt;/em&gt;, and the next time you call &lt;code&gt;.resume&lt;/code&gt;, the argument to &lt;code&gt;resume&lt;/code&gt; becomes the new &lt;code&gt;data_to_write&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;deferred_writes = Fiber.new do |data_to_write|
  loop do
    $stderr.puts &amp;quot;Received #{data_to_write} to work with&amp;quot;
    data_to_write = Fiber.yield
  end
end
# =&amp;gt; #&amp;lt;Fiber:0x007f9f531783e8&amp;gt;
deferred_writes.resume(&amp;quot;Hello&amp;quot;) #=&amp;gt; Received Hello to work with
deferred_writes.resume(&amp;quot;Goodbye&amp;quot;) #=&amp;gt; Received Goodbye to work with
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, within the Fiber, the code flow is &lt;em&gt;started&lt;/em&gt; on the first call to &lt;code&gt;Fiber#resume&lt;/code&gt;, suspended at the first call to &lt;code&gt;Fiber.yield&lt;/code&gt;, and then &lt;em&gt;continued&lt;/em&gt; on subsequent calls to &lt;code&gt;Fiber#resume&lt;/code&gt;, with the return value of &lt;code&gt;Fiber.yield&lt;/code&gt; being the arguments to &lt;code&gt;resume&lt;/code&gt;. The code continues running from the point where &lt;code&gt;Fiber.yield&lt;/code&gt; was last called.&lt;/p&gt;
&lt;p&gt;This is a bit of a quirk of Fibers in that the initial arguments to the fiber will be passed to you as the block arguments, not via the return value of &lt;code&gt;Fiber.yield&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With that in mind, we know that by passing a special argument to &lt;code&gt;resume&lt;/code&gt;, we can decide within the Fiber whether we should stop or not. Let&amp;#39;s try that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;deferred_writes = Fiber.new do |data_to_write|
  loop do
    $stderr.puts &amp;quot;Received #{data_to_write} to work with&amp;quot;
    break if data_to_write == :terminate # Break out of the loop, or...
    write_to_output(data_to_write)       # ...write to the output
    data_to_write = Fiber.yield          # suspend ourselves and wait for the next `resume`
  end
  # We end up here if we break out of the loop above. There is no Fiber.yield
  # statement anywhere, so the Fiber will terminate and become &amp;quot;dead&amp;quot;.
end

deferred_writes.resume(&amp;quot;Hello&amp;quot;) #=&amp;gt; Received Hello to work with
deferred_writes.resume(&amp;quot;Goodbye&amp;quot;) #=&amp;gt; Received Goodbye to work with
deferred_writes.resume(:terminate)
deferred_writes.resume(&amp;quot;Some more data after close&amp;quot;) # FiberError: dead fiber called
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are a number of situations where these facilities can be very useful. Since a Fiber contains a suspended block of code that can be manually resumed, Fibers can be used for implementing event reactors and for dealing with concurrent operations within a single thread. They are lightweight, so you can implement a server using Fibers by assigning a single client to a single Fiber and switching between these Fiber objects as necessary.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;client_fiber = Fiber.new do |socket|
   loop do
     received_from_client = socket.read_nonblock(10)
     sent_to_client = socket.write_nonblock(&amp;quot;OK&amp;quot;)
     Fiber.yield # Return control back to the caller and wait for it to call &amp;#39;resume&amp;#39; on us
   end
end

client_fibers &amp;lt;&amp;lt; client_fiber

# and then in your main webserver loop
client_fibers.each do |client_fiber|
  client_fiber.resume # Receive data from the client if any, and send it an OK
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ruby has an additional standard library called &lt;code&gt;fiber&lt;/code&gt; which allows you to explicitly transfer control from one fiber to another, which can be a bonus facility for these uses.&lt;/p&gt;
&lt;h2 id=&quot;controlling-data-emission-rates&quot;&gt;Controlling Data Emission Rates&lt;/h2&gt;
&lt;p&gt;Another great use for fibers and enumerators can arise when you want to be able to control the rate at which a Ruby block emits data. For example, in &lt;a href=&quot;https://github.com/WeTransfer/zip_tricks&quot;&gt;zip_tricks&lt;/a&gt; we support the following block use as the primary way of using the library:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ZipTricks::Streamer.open(output_io) do |z|
  z.write_deflated_file(&amp;quot;big.csv&amp;quot;) do |destination|
   columns.each do |col|
     destination &amp;lt;&amp;lt; column
   end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We therefore allow &amp;quot;push&amp;quot; control on the part of the code that creates the ZIP archive, and it is impossible to control how much data it outputs and how often. If we want to write our ZIP in chunks of, say, 5 MB—which would be a limitation on AWS S3 object storage—we would have to create a custom &lt;code&gt;output_io&lt;/code&gt; object which would somehow &amp;quot;refuse&amp;quot; to accept &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; method calls when the segment needs to be split off into an S3 multipart part. We can, however, invert the control and make it &amp;quot;pull&amp;quot;. We will still use the same block for writing our big CSV file, but we will be resuming and halting it based on the output it provides. We therefore make the following use possible:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;output_enum = ZipTricks::Streamer.output_enum do |z|
  z.write_deflated_file(&amp;quot;big.csv&amp;quot;) do |destination|
   columns.each do |col|
     destination &amp;lt;&amp;lt; column
   end
  end
end

# At this point nothing has been generated or written yet
enum = output_enum.each # Create an Enumerator
bin_str = enum.next # Let the block generate some binary data and then suspend it
output.write(bin_str) # Our block is suspended and waiting for the next invocation of `next`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This allows us to control at which rate our ZIP file generator emits data.&lt;/p&gt;
&lt;p&gt;Enumerator and Fiber are, therefore, a &lt;strong&gt;control flow mechanism&lt;/strong&gt; for turning &amp;quot;push&amp;quot; blocks into &amp;quot;pull&amp;quot; objects that accept method calls.&lt;/p&gt;
&lt;p&gt;There is only one pitfall with Fibers and Enumerators—if you have something like &lt;code&gt;ensure&lt;/code&gt; in your block, or something that needs to be done after the block completes, it is now up to the caller to call you enough times. In a way, it is comparable to the constraints you have when using Promises in JavaScript.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This concludes our look into flow-controlled enumerables in Ruby. Along the way, Julik shone light on the similarities and differences between the &lt;code&gt;Enumerable&lt;/code&gt; and &lt;code&gt;Fiber&lt;/code&gt; classes, and dove into examples where caller determined the flow of data. We’ve also learned about &lt;code&gt;Fiber&lt;/code&gt;’s additional magic to allow passing arguments on each block reentry. Happy flow-controlling!&lt;/p&gt;
&lt;p&gt;To get a steady dose of magic, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe&lt;/a&gt; to Ruby Magic and we&amp;#39;ll deliver our monthly edition straight to your inbox.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Building a Ruby C Extension From Scratch</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/10/30/ruby-magic-building-a-ruby-c-extension-from-scratch.html">
    <id>https://blog.appsignal.com/2018/10/30/ruby-magic-building-a-ruby-c-extension-from-scratch.html</id>
    <published>2018-10-30T00:00:00+00:00</published>
    <updated>2018-10-30T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In this edition of Ruby Magic, we'll show you how to use code written in C from Ruby.</summary>
    <content type="html">&lt;p&gt;In this edition of Ruby Magic, we&amp;#39;ll show you how to use code written in C from Ruby. This can be used to optimize performance sensitive parts of your code or to create an interface between a C library and Ruby. This is done by creating extensions that wrap libraries written in C.&lt;/p&gt;
&lt;p&gt;There are a lot of mature and performant libraries written in C. Instead of reinventing the wheel by porting them we can also leverage these libraries from Ruby. In this way, we get to code in our favorite language, while using C libraries in areas where Ruby isn&amp;#39;t traditionally strong. At AppSignal, we&amp;#39;ve used this approach in developing the &lt;a href=&quot;https://github.com/appsignal/rdkafka-ruby&quot;&gt;rdkafka gem&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;So let&amp;#39;s see how one can approach this. If you want to follow along and experiment yourself, check out the &lt;a href=&quot;https://github.com/appsignal/c_from_ruby_example&quot;&gt;example code&lt;/a&gt;. To start off, let&amp;#39;s take this piece of Ruby code with a string, a number and a boolean (you&amp;#39;ll C why, pun intended) and port it to a C library:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module CFromRubyExample
  class Helpers
    def self.string(value)
      &amp;quot;String: &amp;#39;#{value}&amp;#39;&amp;quot;
    end

    def self.number(value)
      value + 1
    end

    def self.boolean(value)
      !value
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order, the methods shown concatenate a string, increase a number by one and return the opposite of a boolean, respectively.&lt;/p&gt;
&lt;h2 id=&quot;our-library-ported-to-c&quot;&gt;Our Library Ported to C&lt;/h2&gt;
&lt;p&gt;Below, you can see the code ported to C. The C Standard Library and the IO Library are included so that we can use string formatting. We use &lt;code&gt;char*&lt;/code&gt; instead of a Ruby &lt;code&gt;String&lt;/code&gt;. &lt;code&gt;char*&lt;/code&gt; points to the location of a buffer of characters somewhere in memory.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;# include &amp;lt;stdlib.h&amp;gt;
# include &amp;lt;stdio.h&amp;gt;

char* string_from_library(char* value) {
  char* out = (char*)malloc(256 * sizeof(char));
  sprintf(out, &amp;quot;String: &amp;#39;%s&amp;#39;&amp;quot;, value);
  return out;
}

int number_from_library(int value) {
  return value + 1;
}

int boolean_from_library(int value) {
  if (value == 0) {
    return 1;
  } else {
    return 0;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, you have to jump through some hoops to do simple string formatting. To concatenate a string, we first have to allocate a buffer. With this done, the &lt;code&gt;sprintf&lt;/code&gt; function can then write the formatted result to it. Finally, we can return the buffer.&lt;/p&gt;
&lt;p&gt;With the code above, we already introduced a possible crash or security issue. If the incoming string is longer than 245 bytes, the dreaded buffer overflow will occur. You should definitely be careful when writing C, it&amp;#39;s easy to shoot yourself in the foot.&lt;/p&gt;
&lt;p&gt;Next up is a header file:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;char* string_from_library(char*);
int number_from_library(int);
int boolean_from_library(int);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This file describes the public API of our C library. Other programs use it to know which functions in the library can be called.&lt;/p&gt;
&lt;h2 id=&quot;the-2018-way-use-the-ffi-gem&quot;&gt;The 2018 Way: Use the &lt;code&gt;ffi&lt;/code&gt; Gem&lt;/h2&gt;
&lt;p&gt;So, we now have a C library that we want to use from Ruby. There are two ways to wrap this C code in a gem. The modern way involves using the &lt;code&gt;ffi&lt;/code&gt; gem. It automates many of the hoops we have to jump through. Using &lt;code&gt;ffi&lt;/code&gt; with the C code we just wrote looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module CFromRubyExample
  class Helpers
    extend FFI::Library

    ffi_lib File.join(File.dirname(__FILE__), &amp;quot;../../ext/library.so&amp;quot;)

    attach_function :string, [:string], :string
    attach_function :number, [:int], :int
    attach_function :boolean, [:int], :int
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the purpose of this article, we&amp;#39;re also going to explain how to wrap the C code with a C extension. This will give us much more insight into how it all works under the hood in Ruby.&lt;/p&gt;
&lt;h2 id=&quot;wrapping-our-library-in-a-c-extension&quot;&gt;Wrapping our Library in a C Extension&lt;/h2&gt;
&lt;p&gt;So we now have a C library we want to use from Ruby. The next step is to create a gem that compiles and wraps it. After creating the gem, we first add &lt;code&gt;ext&lt;/code&gt; to the &lt;code&gt;require_paths&lt;/code&gt; in the gemspec:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Gem::Specification.new do |spec|
  spec.name          = &amp;quot;c_from_ruby_example&amp;quot;
  # ...
  spec.require_paths = [&amp;quot;lib&amp;quot;, &amp;quot;ext&amp;quot;]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This informs Rubygems that there is a native extension that needs to be built. It will look for a file called &lt;code&gt;extconf.rb&lt;/code&gt; or a &lt;code&gt;Rakefile&lt;/code&gt;. In this case, we added &lt;code&gt;extconf.rb&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;quot;mkmf&amp;quot;

create_makefile &amp;quot;extension&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We require &lt;code&gt;mkmf&lt;/code&gt;, which stands for &amp;quot;Make Makefile&amp;quot;. It&amp;#39;s a set of helpers included with Ruby that eliminates the finicky part of getting a C build set up. We call &lt;code&gt;create_makefile&lt;/code&gt; and set a name for the extension. This creates a &lt;code&gt;Makefile&lt;/code&gt; which contains all the configuration and commands to build the C code.&lt;/p&gt;
&lt;p&gt;Next, we need to write some C code to connect the library to Ruby. We&amp;#39;ll create some functions that convert C types such as &lt;code&gt;char*&lt;/code&gt; to Ruby types such as &lt;code&gt;String&lt;/code&gt;. Then we&amp;#39;ll create a Ruby class with C code.&lt;/p&gt;
&lt;p&gt;First off, we include some header files from Ruby. These will import the functions we need to do type conversion. We also include the &lt;code&gt;library.h&lt;/code&gt; header file that we created earlier so that we can call our library.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;quot;ruby/ruby.h&amp;quot;
#include &amp;quot;ruby/encoding.h&amp;quot;
#include &amp;quot;library.h&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We then create a function to wrap each function in our library. This is the one for string:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static VALUE string(VALUE self, VALUE value) {
  Check_Type(value, T_STRING);

  char* pointer_in = RSTRING_PTR(value);
  char* pointer_out = string_from_library(pointer_in);
  return rb_str_new2(pointer_out);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We first check if the Ruby value coming in is a string, since processing a non-string value might cause all sorts of bugs. We then convert the Ruby &lt;code&gt;String&lt;/code&gt; to a &lt;code&gt;char*&lt;/code&gt; with the &lt;code&gt;RSTRING_PTR&lt;/code&gt; helper macro that Ruby provides. We can now call our C library. To convert the returned &lt;code&gt;char*&lt;/code&gt;, we use the includes &lt;code&gt;rb_str_new2&lt;/code&gt; function. We&amp;#39;ll add similar wrapping functions for number and boolean.&lt;/p&gt;
&lt;p&gt;For numbers, we do something similar using the &lt;code&gt;NUM2INT&lt;/code&gt; and &lt;code&gt;INT2NUM&lt;/code&gt; helpers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static VALUE number(VALUE self, VALUE value) {
  Check_Type(value, T_FIXNUM);

  int number_in = NUM2INT(value);
  int number_out = number_from_library(number_in);
  return INT2NUM(number_out);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The boolean version is also similar. Note that C doesn&amp;#39;t actually have a boolean type. The convention is to instead use 0 and 1.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static VALUE boolean(VALUE self, VALUE value) {
  int boolean_in = RTEST(value);
  int boolean_out = boolean_from_library(boolean_in);
  if (boolean_out == 1) {
    return Qtrue;
  } else {
    return Qfalse;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we can wire up everything so that we can call it from Ruby:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;void Init_extension(void) {
  VALUE CFromRubyExample = rb_define_module(&amp;quot;CFromRubyExample&amp;quot;);
  VALUE NativeHelpers = rb_define_class_under(CFromRubyExample, &amp;quot;NativeHelpers&amp;quot;, rb_cObject);

  rb_define_singleton_method(NativeHelpers, &amp;quot;string&amp;quot;, string, 1);
  rb_define_singleton_method(NativeHelpers, &amp;quot;number&amp;quot;, number, 1);
  rb_define_singleton_method(NativeHelpers, &amp;quot;boolean&amp;quot;, boolean, 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Yes, you read that right: we can create Ruby modules, classes and methods in C. We set up our class here. We then add Ruby methods to the class. We have to provide the name of the Ruby method, the name of the C wrapper function that will be called and indicate the number of arguments.&lt;/p&gt;
&lt;p&gt;After all that work, we can finally call our C code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;CFromRubyExample::NativeHelpers.string(&amp;quot;a string&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;We jumped through hoops, didn&amp;#39;t crash and got our C extension to work. Writing C extensions is not for the faint of heart. Even when using the &lt;code&gt;ffi&lt;/code&gt; gem you can still quite easily crash your Ruby process. But it is doable and can open up a world of performant and stable C libraries for you!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>The Magic of Class-level Instance Variables</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/10/02/ruby-magic-class-level-instance-variables.html">
    <id>https://blog.appsignal.com/2018/10/02/ruby-magic-class-level-instance-variables.html</id>
    <published>2018-10-02T00:00:00+00:00</published>
    <updated>2018-10-02T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Even classes are objects in Ruby. In this edition of Ruby Magic, we'll look at class-level instance variables by creating a module for wrapping an object's methods.</summary>
    <content type="html">&lt;p&gt;In &lt;a href=&quot;/2018/08/07/ruby-magic-changing-the-way-ruby-creates-objects.html&quot;&gt;a previous Ruby Magic&lt;/a&gt;, we figured out how to reliably inject modules into classes by overwriting its &lt;code&gt;.new&lt;/code&gt; method, allowing us to wrap methods with additional behavior.&lt;/p&gt;
&lt;p&gt;This time, we&amp;#39;re taking it one step further by extracting that behaviour into a module of its own so we can reuse it. We&amp;#39;ll build a &lt;code&gt;Wrappable&lt;/code&gt; module that handles the class extension for us, and we&amp;#39;ll learn all about class-level instance variables along the way. Let&amp;#39;s dive right in!&lt;/p&gt;
&lt;h2 id=&quot;introducing-the-wrappable-module&quot;&gt;Introducing the &lt;code&gt;Wrappable&lt;/code&gt; Module&lt;/h2&gt;
&lt;p&gt;In order to wrap objects with modules when they are initialized, we have to let the class know what wrapping models to use. Let’s start by creating a simple &lt;code&gt;Wrappable&lt;/code&gt; module that provides a &lt;code&gt;wrap&lt;/code&gt; method which pushes the given module into an array defined as a class attribute. Additionally, we redefine the &lt;code&gt;new&lt;/code&gt; method as discussed in the previous post.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Wrappable
  @@wrappers = []

  def wrap(mod)
    @@wrappers &amp;lt;&amp;lt; mod
  end

  def new(*arguments, &amp;amp;block)
    instance = allocate
    @@wrappers.each { |mod| instance.singleton_class.include(mod) }
    instance.send(:initialize, *arguments, &amp;amp;block)
    instance
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To add the new behavior to a class, we use &lt;code&gt;extend&lt;/code&gt;. The &lt;code&gt;extend&lt;/code&gt; method adds the given module to the class. The methods then become class methods. To add a module to wrap instances of this class with, we can now call the &lt;code&gt;wrap&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Logging
  def make_noise
    puts &amp;quot;Started making noise&amp;quot;
    super
    puts &amp;quot;Finished making noise&amp;quot;
  end
end

class Bird
  extend Wrappable

  wrap Logging

  def make_noise
    puts &amp;quot;Chirp, chirp!&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s give this a try by creating a new instance of &lt;code&gt;Bird&lt;/code&gt; and calling the &lt;code&gt;make_noise&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;bird = Bird.new
bird.make_noise
# Started making noise
# Chirp, chirp!
# Finished making noise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great! It works as expected. However, things start to behave a bit strange once we extend a second class with the &lt;code&gt;Wrappable&lt;/code&gt; module.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Powered
  def make_noise
    puts &amp;quot;Powering up&amp;quot;
    super
    puts &amp;quot;Shutting down&amp;quot;
  end
end

class Machine
  extend Wrappable

  wrap Powered

  def make_noise
    puts &amp;quot;Buzzzzzz&amp;quot;
  end
end

machine = Machine.new
machine.make_noise
# Powering up
# Started making noise
# Buzzzzzz
# Finished making noise
# Shutting down

bird = Bird.new
bird.make_noise
# Powering up
# Started making noise
# Chirp, chirp!
# Finished making noise
# Shutting down
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Even though &lt;code&gt;Machine&lt;/code&gt; hasn&amp;#39;t been wrapped with the &lt;code&gt;Logging&lt;/code&gt; module, it still outputs logging information. What’s worse - even the bird is now powering up and down. That can’t be right, can it?&lt;/p&gt;
&lt;p&gt;The root of this problem lies in the way we are storing the modules. The class variable &lt;code&gt;@@wrappables&lt;/code&gt; is defined on the &lt;code&gt;Wrappable&lt;/code&gt; module and used whenever we add a new module, regardless of the class that &lt;code&gt;wrap&lt;/code&gt; is used in.&lt;/p&gt;
&lt;p&gt;This get’s more obvious when looking at the class variables defined on the &lt;code&gt;Wrappable&lt;/code&gt; module and the &lt;code&gt;Bird&lt;/code&gt; and &lt;code&gt;Machine&lt;/code&gt; classes. While &lt;code&gt;Wrappable&lt;/code&gt; has a class method defined, the two classes don&amp;#39;t.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Wrappable.class_variables # =&amp;gt; [:@@wrappers]
Bird.class_variables # =&amp;gt; []
Machine.class_variables # =&amp;gt; []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To fix this, we have to modify the implementation so that it uses instance variables. However, these aren&amp;#39;t variables on the instances of &lt;code&gt;Bird&lt;/code&gt; or &lt;code&gt;Machine&lt;/code&gt;, but instance variables on the classes themselves.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;In Ruby, classes are just objects&lt;/h2&gt;
  &lt;p&gt;
    This is definitely a bit mind boggling at first, but still a very important
    concept to understand. Classes are instances of &lt;code&gt;Class&lt;/code&gt; and
    writing &lt;code&gt;class Bird; end&lt;/code&gt; is equivalent to writing{&quot; &quot;}
    &lt;code&gt;Bird = Class.new&lt;/code&gt;. To make things even more confusing{&quot; &quot;}
    &lt;code&gt;Class&lt;/code&gt; inherits from &lt;code&gt;Module&lt;/code&gt; which inherits from{&quot; &quot;}
    &lt;code&gt;Object&lt;/code&gt;. As a result, classes and modules have the same methods
    as any other object. Most of the methods we use on classes (like the{&quot; &quot;}
    &lt;code&gt;attr_accessor&lt;/code&gt; macro) are actually instance methods of{&quot; &quot;}
    &lt;code&gt;Module&lt;/code&gt;.
  &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;using-instance-variables-on-classes&quot;&gt;Using Instance Variables on Classes&lt;/h2&gt;
&lt;p&gt;Let’s change the &lt;code&gt;Wrappable&lt;/code&gt; implementation to use instance variables. To keep things a bit cleaner, we introduce a &lt;code&gt;wrappers&lt;/code&gt; method that either sets up the array or returns the existing one when the instance variable already exists. We also modify the &lt;code&gt;wrap&lt;/code&gt; and &lt;code&gt;new&lt;/code&gt; methods so that they utilize that new method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Wrappable
  def wrap(mod)
    wrappers &amp;lt;&amp;lt; mod
  end

  def wrappers
    @wrappers ||= []
  end

  def new(*arguments, &amp;amp;block)
    instance = allocate
    wrappers.each { |mod| instance.singleton_class.include(mod) }
    instance.send(:initialize, *arguments, &amp;amp;block)
    instance
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When we check the instance variables on the module and on the two classes, we can see that both &lt;code&gt;Bird&lt;/code&gt; and &lt;code&gt;Machine&lt;/code&gt; now maintain their own collection of wrapping modules.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Wrappable.instance_variables #=&amp;gt; []
Bird.instance_variables #=&amp;gt; [:@wrappers]
Machine.instance_variables #=&amp;gt; [:@wrappers]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Not surprisingly, this also fixes the problem we observed earlier - now, both classes are wrapped with their own individual modules.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;bird = Bird.new
bird.make_noise
# Started making noise
# Chirp, chirp!
# Finished making noise

machine = Machine.new
machine.make_noise
# Powering up
# Buzzzzzz
# Shutting down
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;supporting-inheritance&quot;&gt;Supporting Inheritance&lt;/h2&gt;
&lt;p&gt;This all works great until inheritance is introduced. We would expect that classes would inherit the wrapping modules from the superclass. Let’s check if that&amp;#39;s the case.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Flying
  def make_noise
    super
    puts &amp;quot;Is flying away&amp;quot;
  end
end

class Pigeon &amp;lt; Bird
  wrap Flying

  def make_noise
    puts &amp;quot;Coo!&amp;quot;
  end
end

pigeon = Pigeon.new
pigeon.make_noise
# Coo!
# Is flying away
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As you can see, it doesn’t work as expected, because &lt;code&gt;Pigeon&lt;/code&gt; is also maintaining its own collection of wrapping modules. While it makes sense that wrapping modules defined for &lt;code&gt;Pigeon&lt;/code&gt; aren’t defined on &lt;code&gt;Bird&lt;/code&gt;, it’s not exactly what we want. Let’s figure out a way to get all wrappers from the entire inheritance chain.&lt;/p&gt;
&lt;p&gt;Lucky for us, Ruby provides the &lt;code&gt;Module#ancestors&lt;/code&gt; method to list all the classes and modules a class (or module) inherits from.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Pigeon.ancestors # =&amp;gt; [Pigeon, Bird, Object, Kernel, BasicObject]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By adding a &lt;code&gt;grep&lt;/code&gt; call, we can pick the ones that are actually extended with &lt;code&gt;Wrappable&lt;/code&gt;. As we want to wrap the instances with wrappers from higher up the chain first, we call &lt;code&gt;.reverse&lt;/code&gt; to flip the order.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Pigeon.ancestors.grep(Wrappable).reverse # =&amp;gt; [Bird, Pigeon]
&lt;/code&gt;&lt;/pre&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;
    Ruby’s &lt;code&gt;#===&lt;/code&gt; method
  &lt;/h2&gt;
  &lt;p&gt;
    Some of Ruby’s magic comes down to the &lt;code&gt;#===&lt;/code&gt; (or{&quot; &quot;}
    &lt;em&gt;case equality&lt;/em&gt;) method. By default, it behaves just like the{&quot; &quot;}
    &lt;code&gt;#==&lt;/code&gt; (or &lt;em&gt;equality&lt;/em&gt;) method. However, several classes
    override the &lt;code&gt;#===&lt;/code&gt; method to provide different behavior in{&quot; &quot;}
    &lt;code&gt;case&lt;/code&gt; statements. This is how you can use regular expressions (
    &lt;code&gt;#===&lt;/code&gt; is equivalent to &lt;code&gt;#match?&lt;/code&gt;), or classes (
    &lt;code&gt;#===&lt;/code&gt; is equivalent to &lt;code&gt;#kind_of?&lt;/code&gt;) in those
    statements. Methods like &lt;code&gt;Enumerable#grep&lt;/code&gt;,{&quot; &quot;}
    &lt;code&gt;Enumerable#all?&lt;/code&gt;, or &lt;code&gt;Enumerable#any?&lt;/code&gt; also rely on
    the case equality method.
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Now we can call &lt;code&gt;flat_map(&amp;amp;:wrappers)&lt;/code&gt; to get a list of all wrappers defined in the inheritance chain as a single array.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;Pigeon.ancestors.grep(Wrappable).reverse.flat_map(&amp;amp;:wrappers) # =&amp;gt; [Logging]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All that&amp;#39;s left is packing that into an &lt;code&gt;inherited_wrappers&lt;/code&gt; module and slightly modifying the new method so that it uses that instead of the &lt;code&gt;wrappers&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Wrappable
  def inherited_wrappers
    ancestors
      .grep(Wrappable)
      .reverse
      .flat_map(&amp;amp;:wrappers)
  end

  def new(*arguments, &amp;amp;block)
    instance = allocate
    inherited_wrappers.each { |mod|instance.singleton_class.include(mod) }
    instance.send(:initialize, *arguments, &amp;amp;block)
    instance
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A final test run confirms that everything is now working as expected. The wrapping modules are only applied to the class (and its subclasses) they are applied on.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;bird = Bird.new
bird.make_noise
# Started making noise
# Chirp, chirp!
# Finished making noise

machine = Machine.new
machine.make_noise
# Powering up
# Buzzzzz
# Shutting down

pigeon = Pigeon.new
pigeon.make_noise
# Started making noise
# Coo!
# Finished making noise
# Is flying away
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;thats-a-wrap&quot;&gt;That&amp;#39;s a wrap!&lt;/h2&gt;
&lt;p&gt;Admittedly, these noisy birds are a bit of a theoretic example (tweet, tweet). But inheritable class instance variables are not just cool to understand how classes work. They are a great example that classes are just objects in Ruby.&lt;/p&gt;
&lt;p&gt;And we&amp;#39;ll admit that inheritable class instance variables might even be quite useful in real life. For example, think about defining attributes and relationships on a model with the ability to introspect them later. For us the magic is to play around with this and get a better understanding of how things work. And open your mind for a next level of solutions. 🧙🏼‍♀️&lt;/p&gt;
&lt;p&gt;As always, we’re looking forward to hearing what you build using this or similar patterns. Just chirp to &lt;a href=&quot;http://twitter.com/AppSignal&quot;&gt;@AppSignal&lt;/a&gt; on Twitter.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Closures in Ruby: Blocks, Procs and Lambdas
</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html">
    <id>https://blog.appsignal.com/2018/09/04/ruby-magic-closures-in-ruby-blocks-procs-and-lambdas.html</id>
    <published>2018-09-04T00:00:00+00:00</published>
    <updated>2018-09-04T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In Ruby Magic we love to dive into the magic behind the things we use every day to understand how they work. In this edition, we’ll explore the differences between blocks, procs and lambdas.</summary>
    <content type="html">&lt;p&gt;In Ruby Magic we love to dive into the magic behind the things we use every day to understand how they work. In this edition, we’ll explore the differences between blocks, procs and lambdas.&lt;/p&gt;
&lt;p&gt;In programming languages with first-class functions, functions can be stored in variables and passed as arguments to other functions. Functions can even use other functions as their return values.&lt;/p&gt;
&lt;p&gt;A closure is a first-class function with an environment. The environment is a mapping to the variables that existed when the closure was created. The closure will retain its access to these variables, even if they’re defined in another scope.&lt;/p&gt;
&lt;p&gt;Ruby doesn’t have first-class functions, but it does have closures in the form of blocks, procs and lambdas. Blocks are used for passing blocks of code to methods, and procs and lambda’s allow storing blocks of code in variables.&lt;/p&gt;
&lt;h2 id=&quot;blocks&quot;&gt;Blocks&lt;/h2&gt;
&lt;p&gt;In Ruby, &lt;em&gt;blocks&lt;/em&gt; are snippets of code that can be created to be executed later. Blocks are passed to methods that yield them within the &lt;code&gt;do&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; keywords. One of the many examples is the &lt;code&gt;#each&lt;/code&gt; method, which loops over &lt;a href=&quot;/2018/05/29/ruby-magic-enumerable-and-enumerator.html&quot;&gt;enumerable&lt;/a&gt; objects.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;[1,2,3].each do |n|
  puts &amp;quot;#{n}!&amp;quot;
end

[1,2,3].each { |n| puts &amp;quot;#{n}!&amp;quot; } # the one-line equivalent.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, a block is passed to the &lt;code&gt;Array#each&lt;/code&gt; method, which runs the block for each item in the array and prints it to the console.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def each
  i = 0
  while i &amp;lt; size
    yield at(i)
    i += 1
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this simplified example of &lt;code&gt;Array#each&lt;/code&gt;, in the &lt;code&gt;while&lt;/code&gt; loop, &lt;code&gt;yield&lt;/code&gt; is called to execute the passed block for every item in the array. Note that this method has no arguments, as the block is passed to the method implicitly.&lt;/p&gt;
&lt;h3 id=&quot;implicit-blocks-and-the-yield-keyword&quot;&gt;Implicit Blocks and the &lt;code&gt;yield&lt;/code&gt; Keyword&lt;/h3&gt;
&lt;p&gt;In Ruby, methods can take blocks implicitly and explicitly. Implicit block passing works by calling the &lt;code&gt;yield&lt;/code&gt; keyword in a method. The &lt;code&gt;yield&lt;/code&gt; keyword is special. It finds and calls a passed block, so you don&amp;#39;t have to add the block to the list of arguments the method accepts.&lt;/p&gt;
&lt;p&gt;Because Ruby allows implicit block passing, you can call all methods with a block. If it doesn’t call &lt;code&gt;yield&lt;/code&gt;, the block is ignored.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; &amp;quot;foo bar baz&amp;quot;.split { p &amp;quot;block!&amp;quot; }
=&amp;gt; [&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;baz&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If the called method &lt;em&gt;does&lt;/em&gt; yield, the passed block is found and called with any arguments that were passed to the &lt;code&gt;yield&lt;/code&gt; keyword.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def each
  return to_enum(:each) unless block_given?

  i = 0
  while i &amp;lt; size
    yield at(i)
    i += 1
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This example &lt;a href=&quot;/2018/05/29/ruby-magic-enumerable-and-enumerator.html&quot;&gt;returns an instance of &lt;code&gt;Enumerator&lt;/code&gt;&lt;/a&gt; unless a block is given.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;block_given?&lt;/code&gt; keywords find the block in the current scope. This allows passing blocks implicitly, but prevents the code from accessing the block directly as it&amp;#39;s not stored in a variable.&lt;/p&gt;
&lt;h3 id=&quot;explicitly-passing-blocks&quot;&gt;Explicitly Passing Blocks&lt;/h3&gt;
&lt;p&gt;We can explicitly accept a block in a method by adding it as an argument using an ampersand parameter (usually called &lt;code&gt;&amp;amp;block&lt;/code&gt;). Since the block is now explicit, we can use the &lt;code&gt;#call&lt;/code&gt; method directly on the resulting object instead of relying on &lt;code&gt;yield&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;&amp;amp;block&lt;/code&gt; argument is not a proper argument, so calling this method with anything else than a block will produce an &lt;code&gt;ArgumentError&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def each_explicit(&amp;amp;block)
  return to_enum(:each) unless block

  i = 0
  while i &amp;lt; size
    block.call at(i)
    i += 1
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When a block is passed like this and stored in a variable, it is automatically converted to a &lt;em&gt;proc&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;procs&quot;&gt;Procs&lt;/h2&gt;
&lt;p&gt;A &amp;quot;proc&amp;quot; is an instance of the &lt;code&gt;Proc&lt;/code&gt; class, which holds a code block to be executed, and can be stored in a variable. To create a proc, you call &lt;code&gt;Proc.new&lt;/code&gt; and pass it a block.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;proc = Proc.new { |n| puts &amp;quot;#{n}!&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Since a proc can be stored in a variable, it can also be passed to a method just like a normal argument. In that case, we don&amp;#39;t use the ampersand, as the proc is passed explicitly.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def run_proc_with_random_number(proc)
  proc.call(random)
end

proc = Proc.new { |n| puts &amp;quot;#{n}!&amp;quot; }
run_proc_with_random_number(proc)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead of creating a proc and passing that to the method, you can use Ruby’s ampersand parameter syntax that we saw earlier and use a block instead.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def run_proc_with_random_number(&amp;amp;proc)
  proc.call(random)
end

run_proc_with_random_number { |n| puts &amp;quot;#{n}!&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Note the added ampersand to the argument in the method. This will convert a passed block to a proc object and store it in a variable in the method scope.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tip&lt;/em&gt;: While it&amp;#39;s useful to have the proc in the method in some situations, the conversion of a block to a proc produces a performance hit. Whenever possible, use implicit blocks instead.&lt;/p&gt;
&lt;h3 id=&quot;to_proc&quot;&gt;&lt;code&gt;#to_proc&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Symbols, hashes and methods can be converted to procs using their &lt;code&gt;#to_proc&lt;/code&gt; methods. A frequently seen use of this is passing a proc created from a symbol to a method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;[1,2,3].map(&amp;amp;:to_s)
[1,2,3].map {|i| i.to_s }
[1,2,3].map {|i| i.send(:to_s) }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This example shows three equivalent ways of calling &lt;code&gt;#to_s&lt;/code&gt; on each element of the array. In the first one, a symbol, prefixed with an ampersand, is passed, which automatically converts it to a proc by calling its &lt;code&gt;#to_proc&lt;/code&gt; method. The last two show what that proc could look like.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Symbol
  def to_proc
    Proc.new { |i| i.send(self) }
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Although this is a simplified example, the implementation of &lt;code&gt;Symbol#to_proc&lt;/code&gt; shows what’s happening under the hood. The method returns a proc which takes one argument and sends &lt;code&gt;self&lt;/code&gt; to it. Since &lt;code&gt;self&lt;/code&gt; is the symbol in this context, it calls the &lt;code&gt;Integer#to_s&lt;/code&gt; method.&lt;/p&gt;
&lt;h2 id=&quot;lambdas&quot;&gt;Lambdas&lt;/h2&gt;
&lt;p&gt;Lambdas are essentially procs with some distinguishing factors. They are more like &amp;quot;regular&amp;quot; methods in two ways: they enforce the number of arguments passed when they&amp;#39;re called and they use &amp;quot;normal&amp;quot; returns.&lt;/p&gt;
&lt;p&gt;When calling a lambda that expects an argument without one, or if you pass an argument to a lambda that doesn&amp;#39;t expect it, Ruby raises an &lt;code&gt;ArgumentError&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; lambda (a) { a }.call
ArgumentError: wrong number of arguments (given 0, expected 1)
        from (irb):8:in `block in irb_binding&amp;#39;
        from (irb):8
        from /Users/jeff/.asdf/installs/ruby/2.3.0/bin/irb:11:in `&amp;lt;main&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also, a lambda treats the return keyword the same way a method does. When calling a proc, the program yields control to the code block in the proc. So, if the proc returns, the current scope returns. If a proc is called inside a function and calls &lt;code&gt;return&lt;/code&gt;, the function immediately returns as well.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def return_from_proc
  a = Proc.new { return 10 }.call
  puts &amp;quot;This will never be printed.&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This function will yield control to the proc, so when it returns, the function returns. Calling the function in this example will never print the output and return 10.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def return_from_lambda
  a = lambda { return 10 }.call
  puts &amp;quot;The lambda returned #{a}, and this will be printed.&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When using a lambda, it &lt;em&gt;will&lt;/em&gt; be printed. Calling &lt;code&gt;return&lt;/code&gt; in the lambda will behave like calling &lt;code&gt;return&lt;/code&gt; in a method, so the &lt;code&gt;a&lt;/code&gt; variable is populated with &lt;code&gt;10&lt;/code&gt; and the line is printed to the console.&lt;/p&gt;
&lt;h2 id=&quot;blocks-procs-and-lambdas&quot;&gt;Blocks, procs and lambdas&lt;/h2&gt;
&lt;p&gt;Now that we’ve gone all the way into both blocks, procs and lambdas, let’s zoom back out and summarize the comparison.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Blocks are used extensively in Ruby for passing bits of code to functions. By using the &lt;code&gt;yield&lt;/code&gt; keyword, a block can be implicitly passed without having to convert it to a proc.&lt;/li&gt;
&lt;li&gt;When using parameters prefixed with ampersands, passing a block to a method results in a proc in the method&amp;#39;s context. Procs behave like blocks, but they can be stored in a variable.&lt;/li&gt;
&lt;li&gt;Lambdas are procs that behave like methods, meaning they enforce arity and return as methods instead of in their parent scope.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This concludes our look into closures in Ruby. There&amp;#39;s more to learn about closures like lexical scopes and bindings, but we&amp;#39;ll keep that for a future episode. In the meantime, please let us know what you&amp;#39;d like to read about in a future installment of Ruby Magic, closures or otherwise at &lt;a href=&quot;https://twitter.com/appsignal&quot;&gt;@AppSignal&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Changing the Way Ruby Creates Objects</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/08/07/ruby-magic-changing-the-way-ruby-creates-objects.html">
    <id>https://blog.appsignal.com/2018/08/07/ruby-magic-changing-the-way-ruby-creates-objects.html</id>
    <published>2018-08-07T00:00:00+00:00</published>
    <updated>2018-08-07T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In this edition of Ruby Magic, we'll look at how Ruby creates and initializes objects and how we can modify the default behavior.</summary>
    <content type="html">&lt;p&gt;One of the things that makes Ruby great is that we can customize almost anything to our needs. This is both useful and dangerous. It&amp;#39;s easy to shoot ourselves in the foot, but when used carefully, this can result in pretty powerful solutions.&lt;/p&gt;
&lt;p&gt;At Ruby Magic, we think useful and dangerous is an excellent combination. Let&amp;#39;s look at how Ruby creates and initializes objects and how we can modify the default behavior.&lt;/p&gt;
&lt;h2 id=&quot;the-basics-of-creating-new-objects-from-classes&quot;&gt;The Basics of Creating New Objects from Classes&lt;/h2&gt;
&lt;p&gt;To get started, let&amp;#39;s see how to create objects in Ruby. To create a new &lt;em&gt;object&lt;/em&gt; (or &lt;em&gt;instance&lt;/em&gt;), we call &lt;code&gt;new&lt;/code&gt; on the class. Unlike other languages, &lt;code&gt;new&lt;/code&gt; isn&amp;#39;t a keyword of the language itself, but a method that gets called just like any other.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Dog
end

object = Dog.new
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to customize the newly created object, it is possible to pass arguments to the &lt;code&gt;new&lt;/code&gt; method. Whatever is passed as arguments, will get passed to the initializer.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Dog
  def initialize(name)
    @name = name
  end
end

object = Dog.new(&amp;#39;Good boy&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, unlike other languages, the initializer in Ruby is also just a method instead of some special syntax or keyword.&lt;/p&gt;
&lt;p&gt;With that in mind, shouldn&amp;#39;t it be possible to mess around with those methods, just like it is possible with any other Ruby method? Of course it is!&lt;/p&gt;
&lt;h2 id=&quot;modifying-the-behavior-of-a-single-object&quot;&gt;Modifying the Behavior of a Single Object&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s say we want to ensure that all objects of a particular class will always print log statements, even if the method is overridden in subclasses. One way to do this is to add a module to the object&amp;#39;s singleton class.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Logging
  def make_noise
    puts &amp;quot;Started making noise&amp;quot;
    super
    puts &amp;quot;Finished making noise&amp;quot;
  end
end

class Bird
  def make_noise
    puts &amp;quot;Chirp, chirp!&amp;quot;
  end
end

object = Bird.new
object.singleton_class.include(Logging)
object.make_noise
# Started making noise
# Chirp, chirp!
# Finished making noise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, a &lt;code&gt;Bird&lt;/code&gt; object is created using &lt;code&gt;Bird.new&lt;/code&gt;, and the &lt;code&gt;Logging&lt;/code&gt; module is included in the resulting object using its singleton class.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;What's a Singleton Class?&lt;/h2&gt;
  &lt;p&gt;
    Ruby allows methods that are unique to a single object. To support this,
    Ruby adds an anonymous class between the object and its actual class. When
    methods are called, the ones defined on the singleton class get precedence
    over the methods in the actual class. These singleton classes are unique to
    every object, so adding methods to them doesn't affect any other objects of
    the actual class.{&quot; &quot;}
    &lt;a href=&quot;https://ruby-doc.com/docs/ProgrammingRuby/html/classes.html&quot;&gt;
      Learn more about classes and objects in the Programming Ruby guide.
    &lt;/a&gt;
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;It&amp;#39;s a bit cumbersome to modify the singleton class of each object whenever it is created. So let&amp;#39;s move the inclusion of the &lt;code&gt;Logging&lt;/code&gt; class to the initializer to add it for every created object.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;module Logging
  def make_noise
    puts &amp;quot;Started making noise&amp;quot;
    super
    puts &amp;quot;Finished making noise&amp;quot;
  end
end

class Bird
  def initialize
    singleton_class.include(Logging)
  end

  def make_noise
    puts &amp;quot;Chirp, chirp!&amp;quot;
  end
end

object = Bird.new
object.make_noise
# Started making noise
# Chirp, chirp!
# Finished making noise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While this works well, if we create a subclass of &lt;code&gt;Bird&lt;/code&gt;, like &lt;code&gt;Duck&lt;/code&gt;, its initializer needs to call &lt;code&gt;super&lt;/code&gt; to retain the &lt;code&gt;Logging&lt;/code&gt; behavior. While one can argue that it&amp;#39;s always a good idea to properly call &lt;code&gt;super&lt;/code&gt; whenever a method is overridden, let&amp;#39;s try to find a way that doesn&amp;#39;t &lt;em&gt;require&lt;/em&gt; it.&lt;/p&gt;
&lt;p&gt;If we don&amp;#39;t call &lt;code&gt;super&lt;/code&gt; from the subclass, we lose the inclusion of the &lt;code&gt;Logger&lt;/code&gt; class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Duck &amp;lt; Bird
  def initialize(name)
    @name = name
  end

  def make_noise
    puts &amp;quot;#{@name}: Quack, quack!&amp;quot;
  end
end

object = Duck.new(&amp;#39;Felix&amp;#39;)
object.make_noise
# Felix: Quack, quack!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instead, Let&amp;#39;s override &lt;code&gt;Bird.new&lt;/code&gt;. As mentioned before, &lt;code&gt;new&lt;/code&gt; is just a method implemented on classes. So we can override it, call super, and modify the newly created object to our needs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Bird
  def self.new(*arguments, &amp;amp;block)
    instance = super
    instance.singleton_class.include(Logging)
    instance
  end
end

object = Duck.new(&amp;#39;Felix&amp;#39;)
object.make_noise
# Started making noise
# Felix: Quack, quack!
# Finished making noise
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But, what happens when we call &lt;code&gt;make_noise&lt;/code&gt; in the initializer? Unfortunately, because the singleton class doesn&amp;#39;t include the &lt;code&gt;Logging&lt;/code&gt; module yet, we won&amp;#39;t get the desired output.&lt;/p&gt;
&lt;p&gt;Luckily, there&amp;#39;s a solution: It&amp;#39;s possible to create the default &lt;code&gt;.new&lt;/code&gt; behavior from scratch by calling &lt;code&gt;allocate&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Bird
  def self.new(*arguments, &amp;amp;block)
    instance = allocate
    instance.singleton_class.include(Logging)
    instance.send(:initialize, *arguments, &amp;amp;block)
    instance
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calling &lt;code&gt;allocate&lt;/code&gt; returns a new, uninitialized object of the class. So afterward, we can include the additional behavior and only then, call the &lt;code&gt;initialize&lt;/code&gt; method on that object. (Because &lt;code&gt;initialize&lt;/code&gt; is private by default, we have to resort to using &lt;code&gt;send&lt;/code&gt; for this).&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;
    The Truth About &lt;code&gt;Class#allocate&lt;/code&gt;
  &lt;/h2&gt;
  &lt;p&gt;
    Unlike other methods, it's not possible to override &lt;code&gt;allocate&lt;/code&gt;.
    Ruby doesn't use the conventional way of dispatching methods for{&quot; &quot;}
    &lt;code&gt;allocate&lt;/code&gt; internally. As a result, just overriding{&quot; &quot;}
    &lt;code&gt;allocate&lt;/code&gt; without also overriding &lt;code&gt;new&lt;/code&gt; doesn't work.
    However, if we're calling &lt;code&gt;allocate&lt;/code&gt; directly, Ruby will call the
    redefined method.{&quot; &quot;}
    &lt;a href=&quot;https://ruby-doc.org/core-2.5.0/Class.html#method-i-allocate&quot;&gt;
      Learn more about &lt;code&gt;Class#new&lt;/code&gt; and &lt;code&gt;Class#allocate&lt;/code&gt; in
      Ruby's documentation.
    &lt;/a&gt;
  &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;why-would-we-do-this&quot;&gt;Why Would We Do This?&lt;/h2&gt;
&lt;p&gt;As with a lot of things, modifying the way Ruby creates objects from classes can be dangerous and things might break in unexpected ways.&lt;/p&gt;
&lt;p&gt;Nonetheless, there are valid use cases for changing the object creation. For instance, ActiveRecord uses &lt;code&gt;allocate&lt;/code&gt; with a different &lt;code&gt;init_from_db&lt;/code&gt; method to change the initialization process when creating objects from the database as opposed to building unsaved objects. It also uses &lt;code&gt;allocate&lt;/code&gt; to convert records between different &lt;a href=&quot;https://en.wikipedia.org/wiki/Single_Table_Inheritance&quot;&gt;single-table inheritance&lt;/a&gt; types with &lt;code&gt;becomes&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Most important, by playing around with object creation, you get a deeper insight into how it works in Ruby and open your mind to different solutions. We hope you enjoyed the article.&lt;/p&gt;
&lt;p&gt;We&amp;#39;d love to hear about the things you implemented by changing Ruby&amp;#39;s default way of creating objects. Please don&amp;#39;t hesitate to tweet your thoughts to &lt;a href=&quot;http://twitter.com/AppSignal&quot;&gt;@AppSignal&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Ruby Magic Summer Special: The Best of AppSignal Academy
</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/07/26/ruby-magic-summer-special-best-of-appsignal-academy.html">
    <id>https://blog.appsignal.com/2018/07/26/ruby-magic-summer-special-best-of-appsignal-academy.html</id>
    <published>2018-07-26T00:00:00+00:00</published>
    <updated>2018-07-26T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">The best of AppSignal Academy: 5 of our favorite Ruby articles
</summary>
    <content type="html">&lt;p&gt;Remember when you were a kid, and you bought those omnibus double edition comics? How magical reading them was? We won&amp;#39;t pretend this will be as unforgettable, but we do think we&amp;#39;ve put together a nice extra-chunky Best-of &lt;a href=&quot;/category/academy.html&quot;&gt;AppSignal Academy&lt;/a&gt; selection for you to read at the beach, the park, or just on a lazy Sunday, that will absolutely make your day.&lt;/p&gt;
&lt;p&gt;Here are our top 5 hammock reads:&lt;/p&gt;
&lt;h2 id=&quot;custom-exceptions-in-ruby&quot;&gt;&lt;a href=&quot;/2018/07/03/custom-exceptions-in-ruby.html&quot;&gt;Custom Exceptions in Ruby&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Almost everything in Ruby is an object and errors are no exception. #dadjokes&lt;/p&gt;
&lt;h2 id=&quot;ensuring-execution-retrying-failures-and-re-raising-exceptions-in-ruby&quot;&gt;&lt;a href=&quot;/2018/05/16/ensure-retry-and-reraise-exceptions-in-ruby.html&quot;&gt;Ensuring Execution, Retrying Failures and Re-raising Exceptions in Ruby&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Besides &lt;code&gt;rescue&lt;/code&gt;, Ruby has more ways to handle exceptions. We&amp;#39;ll use the &lt;code&gt;retry&lt;/code&gt; and &lt;code&gt;ensure&lt;/code&gt; keywords as well as reraised exceptions to build a resilient web API client.&lt;/p&gt;
&lt;h2 id=&quot;rubys-redo-retry-and-next-keywords&quot;&gt;&lt;a href=&quot;/2018/06/05/redo-retry-next.html&quot;&gt;Ruby&amp;#39;s Redo, Retry and Next Keywords&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The post about &lt;code&gt;retry&lt;/code&gt; was super popular last holiday. Its little-known counterpart &lt;code&gt;redo&lt;/code&gt; works similarly, but reruns loop iterations instead of whole blocks.&lt;/p&gt;
&lt;h2 id=&quot;activerecord-performance-the-n1-queries-anti-pattern&quot;&gt;&lt;a href=&quot;/2018/04/24/active-record-performance-the-n-1-queries-antipattern.html&quot;&gt;ActiveRecord Performance: The N+1 Queries Anti-Pattern&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Like squirrels in a summer forest, the N+1 queries problem is a common, but usually easy to spot nuisance, ehm, performance anti-pattern that&amp;#39;s sometimes caused by lazy loading associations.&lt;/p&gt;
&lt;h2 id=&quot;russian-doll-caching-in-rails&quot;&gt;&lt;a href=&quot;/2018/04/03/russian-doll-caching-in-rails.html&quot;&gt;Russian Doll Caching in Rails&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;By nesting cache fragments, views are almost never rendered completely. Even when data changes, most of the rendered pages are served straight from the cache.&lt;/p&gt;
&lt;p&gt;Enjoy!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Under the Hood: “Slurping” and Streaming Files in Ruby
</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/07/10/ruby-magic-slurping-and-streaming-files.html">
    <id>https://blog.appsignal.com/2018/07/10/ruby-magic-slurping-and-streaming-files.html</id>
    <published>2018-07-10T00:00:00+00:00</published>
    <updated>2018-07-10T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Streaming files line by line is often preferred over “slurping” the whole content at once. In this edition of Ruby Magic, we'll learn how streaming files and other I/O streams works in Ruby.</summary>
    <content type="html">&lt;p&gt;In this edition of Ruby Magic, we&amp;#39;ll learn about streaming files in Ruby, how the &lt;code&gt;IO&lt;/code&gt; class handles reading files without completely loading them into memory, and how it reads files per line by buffering read bytes. Let&amp;#39;s dive right in!&lt;/p&gt;
&lt;h2 id=&quot;slurping-and-streaming-files&quot;&gt;“Slurping” and Streaming Files&lt;/h2&gt;
&lt;p&gt;Ruby&amp;#39;s &lt;code&gt;File.read&lt;/code&gt; method reads a file and returns its full content.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; content = File.read(&amp;quot;log/production.log&amp;quot;)
=&amp;gt; &amp;quot;I, [2018-06-27T16:45:02.843719 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Started GET \&amp;quot;/articles\&amp;quot; for 127.0.0.1 at 2018-06-27 16:45:02 +0200\nI, [2018-06-27T16:45:02.846719 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Processing by ArticlesController#index as HTML\nI, [2018-06-27T16:45:02.848212 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22]   Rendering articles/index.html.erb within layouts/application\nD, [2018-06-27T16:45:02.850020 #9098] DEBUG -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22]   Article Load (0.3ms)  SELECT \&amp;quot;articles\&amp;quot;.* FROM \&amp;quot;articles\&amp;quot;\nI, [2018-06-27T16:45:02.850901 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22]   Rendered articles/index.html.erb within layouts/application (1.7ms)\nI, [2018-06-27T16:45:02.851633 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Completed 200 OK in 5ms (Views: 3.4ms | ActiveRecord: 0.3ms)\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Internally, this opens the file, reads its content, closes the file, and returns the content as a single string. By &amp;quot;slurping&amp;quot; the file&amp;#39;s content at once, it&amp;#39;s kept in memory until it’s cleaned up by Ruby’s garbage collector.&lt;/p&gt;
&lt;p&gt;As an example, let&amp;#39;s say we&amp;#39;d like to uppercase all characters in a file and write it to another file. Using &lt;code&gt;File.read&lt;/code&gt;, we can get the content, call &lt;code&gt;String#upcase&lt;/code&gt; on the resulting string, and pass the uppercased string to &lt;code&gt;File.write&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; upcased = File.read(&amp;quot;log/production.log&amp;quot;).upcase
=&amp;gt; &amp;quot;I, [2018-06-27T16:45:02.843719 #9098]  INFO -- : [86A5D18C-19DD-4CBF-9D7A-461C79E98C22] STARTED GET \&amp;quot;/ARTICLES\&amp;quot; FOR 127.0.0.1 AT 2018-06-27 16:45:02 +0200\nI, [2018-06-27T16:45:02.846719 #9098]  INFO -- : [86A5D18C-19DD-4CBF-9D7A-461C79E98C22] PROCESSING BY ARTICLESCONTROLLER#INDEX AS HTML\nI, [2018-06-27T16:45:02.848212 #9098]  INFO -- : [86A5D18C-19DD-4CBF-9D7A-461C79E98C22]   RENDERING ARTICLES/INDEX.HTML.ERB WITHIN LAYOUTS/APPLICATION\nD, [2018-06-27T16:45:02.850020 #9098] DEBUG -- : [86A5D18C-19DD-4CBF-9D7A-461C79E98C22]   ARTICLE LOAD (0.3MS)  SELECT \&amp;quot;ARTICLES\&amp;quot;.* FROM \&amp;quot;ARTICLES\&amp;quot;\nI, [2018-06-27T16:45:02.850901 #9098]  INFO -- : [86A5D18C-19DD-4CBF-9D7A-461C79E98C22]   RENDERED ARTICLES/INDEX.HTML.ERB WITHIN LAYOUTS/APPLICATION (1.7MS)\nI, [2018-06-27T16:45:02.851633 #9098]  INFO -- : [86A5D18C-19DD-4CBF-9D7A-461C79E98C22] COMPLETED 200 OK IN 5MS (VIEWS: 3.4MS | ACTIVERECORD: 0.3MS)\n&amp;quot;
irb&amp;gt; File.write(&amp;quot;log/upcased.log&amp;quot;, upcased)
=&amp;gt; 896
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While that works for small files, reading the whole file into memory might be problematic when dealing with larger files. For instance, when parsing a 14-gigabyte log file, reading the whole file at once would be an expensive operation. The content of the file is kept in memory, so the app&amp;#39;s memory footprint grows considerably. This can eventually lead to memory swapping and the OS killing the app&amp;#39;s process.&lt;/p&gt;
&lt;p&gt;Luckily, Ruby allows reading files line by line using &lt;code&gt;File.foreach&lt;/code&gt;. Instead of reading the file&amp;#39;s full content at once, it will execute a passed block for each line.&lt;/p&gt;
&lt;p&gt;Its result is &lt;a href=&quot;/2018/05/29/ruby-magic-enumerable-and-enumerator.html&quot;&gt;enumerable&lt;/a&gt;, therefore it either yields a block for each line, or returns an Enumerator object if no block is passed. This enables the reading of bigger files without having to load all their content into memory at once.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; File.foreach(&amp;quot;log/production.log&amp;quot;) { |line| p line }
&amp;quot;I, [2018-06-27T16:45:02.843719 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Started GET \&amp;quot;/articles\&amp;quot; for 127.0.0.1 at 2018-06-27 16:45:02 +0200\n&amp;quot;
&amp;quot;I, [2018-06-27T16:45:02.846719 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Processing by ArticlesController#index as HTML\n&amp;quot;
&amp;quot;I, [2018-06-27T16:45:02.848212 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22]   Rendering articles/index.html.erb within layouts/application\n&amp;quot;
&amp;quot;D, [2018-06-27T16:45:02.850020 #9098] DEBUG -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22]   Article Load (0.3ms)  SELECT \&amp;quot;articles\&amp;quot;.* FROM \&amp;quot;articles\&amp;quot;\n&amp;quot;
&amp;quot;I, [2018-06-27T16:45:02.850901 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22]   Rendered articles/index.html.erb within layouts/application (1.7ms)\n&amp;quot;
&amp;quot;I, [2018-06-27T16:45:02.851633 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Completed 200 OK in 5ms (Views: 3.4ms | ActiveRecord: 0.3ms)\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To uppercase a whole file, we read from the input file line by line, uppercase it, and append it to the output file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; File.open(&amp;quot;upcased.log&amp;quot;, &amp;quot;a&amp;quot;) do |output|
irb*   File.foreach(&amp;quot;production.log&amp;quot;) { |line| output.write(line.upcase) }
irb&amp;gt; end
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, how does reading a file line by line work without having to first read the whole file? To understand that, we’ll have to peel back some of the layers around reading files. Let&amp;#39;s take a closer look at Ruby&amp;#39;s &lt;code&gt;IO&lt;/code&gt; class.&lt;/p&gt;
&lt;h2 id=&quot;io-and-rubys-io-class&quot;&gt;I/O and Ruby&amp;#39;s &lt;code&gt;IO&lt;/code&gt; Class&lt;/h2&gt;
&lt;p&gt;Even though &lt;code&gt;File.read&lt;/code&gt; and &lt;code&gt;File.foreach&lt;/code&gt; exist, the &lt;a href=&quot;https://ruby-doc.org/core-2.5.1/File.html&quot;&gt;documentation for the &lt;code&gt;File&lt;/code&gt; class&lt;/a&gt; doesn’t list them. In fact, you won’t find any of the file reading or writing methods in the &lt;code&gt;File&lt;/code&gt; class documentation, because they are inherited from the parent &lt;code&gt;IO&lt;/code&gt; class.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;I/O&lt;/h2&gt;
&lt;p&gt;An &lt;em&gt;I/O device&lt;/em&gt; is a device that transfers data to or from a computer, for example keyboards, displays and hard drives. It performs &lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Input/output&quot;&gt;Input/Output&lt;/a&gt;&lt;/em&gt;, or &lt;em&gt;I/O&lt;/em&gt;, by reading or producing streams of data. &lt;/p&gt;

&lt;p&gt;Reading and writing files from the hard drive is the most common I/O you’ll encounter. Other types of I/O include socket communication, logging output to your terminal and input from your keyboard.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;IO&lt;/code&gt; class in Ruby handles all input and output like reading and writing to files. Because reading files isn&amp;#39;t different than reading from any other I/O stream, the &lt;code&gt;File&lt;/code&gt; class directly inherits methods like &lt;code&gt;IO.read&lt;/code&gt; and &lt;code&gt;IO.foreach&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; IO.foreach(&amp;quot;log/production.log&amp;quot;) { |line| p line }
&amp;quot;I, [2018-06-27T16:45:02.843719 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Started GET \&amp;quot;/articles\&amp;quot; for 127.0.0.1 at 2018-06-27 16:45:02 +0200\n&amp;quot;
&amp;quot;I, [2018-06-27T16:45:02.846719 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Processing by ArticlesController#index as HTML\n&amp;quot;
&amp;quot;I, [2018-06-27T16:45:02.848212 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22]   Rendering articles/index.html.erb within layouts/application\n&amp;quot;
&amp;quot;D, [2018-06-27T16:45:02.850020 #9098] DEBUG -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22]   Article Load (0.3ms)  SELECT \&amp;quot;articles\&amp;quot;.* FROM \&amp;quot;articles\&amp;quot;\n&amp;quot;
&amp;quot;I, [2018-06-27T16:45:02.850901 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22]   Rendered articles/index.html.erb within layouts/application (1.7ms)\n&amp;quot;
&amp;quot;I, [2018-06-27T16:45:02.851633 #9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Completed 200 OK in 5ms (Views: 3.4ms | ActiveRecord: 0.3ms)\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;File.foreach&lt;/code&gt; is equivalent to &lt;code&gt;IO.foreach&lt;/code&gt;, so the &lt;code&gt;IO&lt;/code&gt; class version can be used to get the same result we did previously.&lt;/p&gt;
&lt;h2 id=&quot;reading-io-streams-via-the-kernel&quot;&gt;Reading I/O Streams Via the Kernel&lt;/h2&gt;
&lt;p&gt;Internally, Ruby&amp;#39;s &lt;code&gt;IO&lt;/code&gt; class&amp;#39; reading and writing abilities are based on abstractions around &lt;a href=&quot;https://en.wikipedia.org/wiki/System_call&quot;&gt;kernel system calls&lt;/a&gt;. The operating system&amp;#39;s &lt;a href=&quot;https://en.wikipedia.org/wiki/Kernel_(operating_system)&quot;&gt;kernel&lt;/a&gt; takes care of reading from and writing to I/O devices.&lt;/p&gt;
&lt;h3 id=&quot;opening-files&quot;&gt;Opening Files&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IO.sysopen&lt;/code&gt; opens a file by asking the kernel to put a reference to the file in the file table and creating a file descriptor in the process&amp;#39; file descriptor table.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;File Descriptors and the File Table&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Open_(system_call)&quot;&gt;Opening&lt;/a&gt; a file returns a &lt;a href=&quot;https://en.wikipedia.org/wiki/File_descriptor&quot;&gt;file descriptor&lt;/a&gt; — an integer used to access the I/O resource.&lt;/p&gt;

&lt;p&gt;
  Each process has its own file descriptor table to keep the file descriptors in
  memory, and each descriptor points to an entry in the system-wide{&quot; &quot;}
  &lt;em&gt;file table&lt;/em&gt;.{&quot; &quot;}
&lt;/p&gt;

&lt;p&gt;To read from or write to an I/O resource, the process passes the file descriptor to the kernel through a system call. The kernel then accesses the file on behalf of the process, as processes don’t have access to the file table.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Opening files will &lt;em&gt;not&lt;/em&gt; keep their content in memory, but the file descriptor table can get filled up, so it’s a good practice to always close files after opening them. Methods that wrap &lt;code&gt;File.open&lt;/code&gt; like &lt;code&gt;File.read&lt;/code&gt; do this automatically, as well as the ones taking a block.&lt;/p&gt;
&lt;p&gt;In this example, we&amp;#39;ll go one step further by calling the &lt;code&gt;IO.sysopen&lt;/code&gt; method directly. By passing a filename, the method creates a file descriptor we can use to reference the open file later.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; IO.sysopen(&amp;quot;log/production.log&amp;quot;)
=&amp;gt; 9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To create an &lt;code&gt;IO&lt;/code&gt; instance for Ruby to read from and write to, we pass the file descriptor to &lt;code&gt;IO.new&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; file_descriptor = IO.sysopen(&amp;quot;log/production.log&amp;quot;)
=&amp;gt; 9
irb&amp;gt; io = IO.new(file_descriptor)
=&amp;gt; #&amp;lt;IO:fd 9&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To close an I/O stream and remove the reference to the file from the files table, we call &lt;code&gt;IO#close&lt;/code&gt; on the &lt;code&gt;IO&lt;/code&gt; instance.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;irb&amp;gt; io.close
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;reading-bytes-and-moving-cursors&quot;&gt;Reading Bytes and Moving Cursors&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IO#sysread&lt;/code&gt; reads a number of bytes from an &lt;code&gt;IO&lt;/code&gt; object.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; io.sysread(64)
=&amp;gt; &amp;quot; [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Started GET \&amp;quot;/articles\&amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This example uses the &lt;code&gt;IO&lt;/code&gt; instance we created previously by passing the file descriptor integer to &lt;code&gt;IO.new&lt;/code&gt;. It reads and returns the first 64 bytes from the file by calling &lt;code&gt;IO#sysread&lt;/code&gt; with 64 as its argument.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; io.sysread(64)
=&amp;gt; &amp;quot;for 127.0.0.1 at 2018-06-27 16:45:02 +0200\nI, [2018-06-27T16:45:&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first time we requested bytes from the file, the cursor was moved automatically, so calling &lt;code&gt;IO#sysread&lt;/code&gt; on the same instance again will produce the next 64 bytes of the file.&lt;/p&gt;
&lt;h3 id=&quot;moving-the-cursor&quot;&gt;Moving the Cursor&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;IO.sysseek&lt;/code&gt; manually moves the cursor to a location in the file.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; io.sysseek(32)
=&amp;gt; 32
irb&amp;gt; io.sysread(64)
=&amp;gt; &amp;quot;9098]  INFO -- : [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Started &amp;quot;
irb&amp;gt; io.sysseek(0)
=&amp;gt; 0
irb&amp;gt; io.sysread(64)
=&amp;gt; &amp;quot; [86a5d18c-19dd-4cbf-9d7a-461c79e98c22] Started GET \&amp;quot;/articles\&amp;quot; &amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we move to position 32, then read 64 bytes using &lt;code&gt;IO#sysread&lt;/code&gt;. By calling &lt;code&gt;IO.sysseek&lt;/code&gt; again with 0, we jump back to the beginning of the file, allowing us to read the first 64 bytes again.&lt;/p&gt;
&lt;h2 id=&quot;reading-files-line-by-line&quot;&gt;Reading Files Line by Line&lt;/h2&gt;
&lt;p&gt;Now, we know how the &lt;code&gt;IO&lt;/code&gt; class&amp;#39;s convenience methods open IO streams, read bytes from them and how they move the cursor&amp;#39;s position.&lt;/p&gt;
&lt;p&gt;Methods like &lt;code&gt;IO.foreach&lt;/code&gt; and &lt;code&gt;IO#gets&lt;/code&gt; can request lines line by line instead of per number of bytes. There&amp;#39;s no performant way of looking ahead to find the next newline and take all bytes until that position, so Ruby needs to take care of splitting the file&amp;#39;s content.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MyIO
  def initialize(filename)
    fd = IO.sysopen(filename)
    @io = IO.new(fd)
  end

  def each(&amp;amp;block)
    line = &amp;quot;&amp;quot;

    while (c = @io.sysread(1)) != $/
      line &amp;lt;&amp;lt; c
    end

    block.call(line)
    each(&amp;amp;block)
  rescue EOFError
    @io.close
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example implementation, the &lt;code&gt;#each&lt;/code&gt; method takes bytes from the file using &lt;code&gt;IO#sysread&lt;/code&gt; one at a time, until the byte is &lt;code&gt;$/&lt;/code&gt;, indicating a newline. When it finds a newline, it stops taking bytes and calls the passed block with that line.&lt;/p&gt;
&lt;p&gt;This solution works but is inefficient as it calls &lt;code&gt;IO.sysread&lt;/code&gt; for every byte in the file.&lt;/p&gt;
&lt;h3 id=&quot;buffering-file-content&quot;&gt;Buffering File Content&lt;/h3&gt;
&lt;p&gt;Ruby is smarter about how it does this by keeping an internal buffer of the file&amp;#39;s content. Instead of reading the file one byte at a time, it takes 512 bytes at once and checks if there are any newlines in the returned bytes. If there are, it returns the portion before the newline and keeps the rest in memory as a buffer. If the buffer doesn&amp;#39;t include a newline, it fetches 512 bytes more until it finds one.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MyIO
  def initialize(filename)
    fd = IO.sysopen(filename)
    @io = IO.new(fd)
    @buffer = &amp;quot;&amp;quot;
  end

  def each(&amp;amp;block)
    @buffer &amp;lt;&amp;lt; @io.sysread(512) until @buffer.include?($/)

    line, @buffer = @buffer.split($/, 2)

    block.call(line)
    each(&amp;amp;block)
  rescue EOFError
    @io.close
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, the &lt;code&gt;#each&lt;/code&gt; method adds bytes to an internal &lt;code&gt;@buffer&lt;/code&gt; variable in chunks of 512 bytes until when the &lt;code&gt;@buffer&lt;/code&gt; variable includes a newline. When that happens, it splits the buffer by the first newline. The first part is the &lt;code&gt;line&lt;/code&gt;, and the second part is the new buffer.&lt;/p&gt;
&lt;p&gt;The passed block is then called with the line and the remaining &lt;code&gt;@buffer&lt;/code&gt; is kept for use in the next loop.&lt;/p&gt;
&lt;p&gt;By buffering the file&amp;#39;s content, the number of I/O calls is reduced while dividing the file in logical chunks.&lt;/p&gt;
&lt;h2 id=&quot;streaming-files&quot;&gt;Streaming Files&lt;/h2&gt;
&lt;p&gt;To summarize, streaming files works by asking the operating system&amp;#39;s kernel to open a file, then read bytes from it bit by bit. When reading a file per line in Ruby, data is taken from the file 512 bytes at a time and split up in &amp;quot;lines&amp;quot; after that.&lt;/p&gt;
&lt;p&gt;This concludes our overview of I/O and streaming files in Ruby. We’d love to know what you thought of this article, or if you have any questions. We’re always on the lookout for topics to investigate and explain, so if there’s anything magical in Ruby you’d like to read about, don’t hesitate to let us now at &lt;a href=&quot;https://twitter.com/appsignal&quot;&gt;@AppSignal&lt;/a&gt;!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Ruby's magical Enumerable module</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/05/29/ruby-magic-enumerable-and-enumerator.html">
    <id>https://blog.appsignal.com/2018/05/29/ruby-magic-enumerable-and-enumerator.html</id>
    <published>2018-05-29T00:00:00+00:00</published>
    <updated>2018-05-29T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Ruby's handling of enumerables is one of it's most magical features. In this episode of Ruby Magic, we'll learn how these work and how to make your own objects tenumerable.</summary>
    <content type="html">&lt;p&gt;It&amp;#39;s time for another episode of Ruby Magic! This time, we&amp;#39;ll look at one of Ruby&amp;#39;s most magical features, which provides most of the methods you&amp;#39;ll use when working with Ruby&amp;#39;s enumerable classes like &lt;code&gt;Array&lt;/code&gt;, &lt;code&gt;Hash&lt;/code&gt; and &lt;code&gt;Range&lt;/code&gt;. In the process, we&amp;#39;ll learn what you can do with enumerable objects, how enumeration works, and how to make an object enumerable by implementing a single method.&lt;/p&gt;
&lt;h2 id=&quot;enumerable-each-and-enumerator&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt;, &lt;code&gt;#each&lt;/code&gt; and &lt;code&gt;Enumerator&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Enumeration&lt;/em&gt; refers to traversing over objects. In Ruby, we call an object &lt;em&gt;enumerable&lt;/em&gt; when it describes a set of items and a method to loop over each of them.&lt;/p&gt;
&lt;p&gt;The built-in enumerables get their enumeration features by including the &lt;code&gt;Enumerable&lt;/code&gt; module, which provides methods like &lt;code&gt;#include?&lt;/code&gt;, &lt;code&gt;#count&lt;/code&gt;, &lt;code&gt;#map&lt;/code&gt;, &lt;code&gt;#select&lt;/code&gt; and &lt;code&gt;#uniq&lt;/code&gt;, amongst others. Most of the methods associated with arrays and hashes aren&amp;#39;t actually implemented in these classes themselves, they&amp;#39;re included.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Note&lt;/em&gt;: Some methods, like &lt;code&gt;#count&lt;/code&gt; and &lt;code&gt;#take&lt;/code&gt; on the &lt;code&gt;Array&lt;/code&gt; class, &lt;em&gt;are&lt;/em&gt; implemented specifically for arrays instead of using the ones from the &lt;code&gt;Enumerable&lt;/code&gt; module. That&amp;#39;s usually done to make operation faster.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;http://ruby-doc.org/core-2.5.1/Enumerable.html&quot;&gt;&lt;code&gt;Enumerable&lt;/code&gt; module&lt;/a&gt; relies on a method named &lt;code&gt;#each&lt;/code&gt;, which needs to be implemented in any class it&amp;#39;s included in. When called with a block on an array, the &lt;code&gt;#each&lt;/code&gt; method will execute the block for each of the array&amp;#39;s elements.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; [1,2,3].each { |i| puts &amp;quot;* #{i}&amp;quot; }
* 1
* 2
* 3
=&amp;gt; [1,2,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we call the &lt;code&gt;#each&lt;/code&gt; method on an array &lt;em&gt;without&lt;/em&gt; passing a block to execute for each of its elements, we&amp;#39;ll receive an instance of &lt;code&gt;Enumerator&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; [1,2,3].each
=&amp;gt; #&amp;lt;Enumerator: [1, 2, 3]:each&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Instances of &lt;code&gt;Enumerator&lt;/code&gt; describe how to iterate over an object. Enumerators &lt;a href=&quot;https://ruby-doc.org/core-2.5.1/Enumerator.html#method-i-next&quot;&gt;iterate over objects manually&lt;/a&gt; and chain enumeration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; %w(dog cat mouse).each.with_index { |a, i| puts &amp;quot;#{a} is at position #{i}&amp;quot; }
dog is at position 0
cat is at position 1
mouse is at position 2
=&amp;gt; [&amp;quot;dog&amp;quot;, &amp;quot;cat&amp;quot;, &amp;quot;mouse&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;#with_index&lt;/code&gt; method is a good example of how changed enumerators work. In this example, &lt;code&gt;#each&lt;/code&gt; is called on the array to return an enumerator. Then, &lt;code&gt;#with_index&lt;/code&gt; is called to add indices to each of the array&amp;#39;s elements to allow printing each element&amp;#39;s index.&lt;/p&gt;
&lt;h2 id=&quot;making-objects-enumerable&quot;&gt;Making objects enumerable&lt;/h2&gt;
&lt;p&gt;Under the hood, methods like &lt;code&gt;#max&lt;/code&gt;, &lt;code&gt;#map&lt;/code&gt; and &lt;code&gt;#take&lt;/code&gt; rely on the &lt;code&gt;#each&lt;/code&gt; method to function.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def max
  max = nil

  each do |item|
    if !max || item &amp;gt; max
      max = item
    end
  end

  max
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Internally, &lt;code&gt;Enumerable&lt;/code&gt;&amp;#39;s methods have C implementations, but the example above roughly shows how &lt;code&gt;#max&lt;/code&gt; works. By using &lt;code&gt;#each&lt;/code&gt; to loop over all values and remembering the highest, it returns the maximum value.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def map(&amp;amp;block)
  new_list = []

  each do |item|
    new_list &amp;lt;&amp;lt; block.call(item)
  end

  new_list
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;#map&lt;/code&gt; function calls the passed block with each item and puts the result into a new list to return after looping over all values.&lt;/p&gt;
&lt;p&gt;Since all methods in &lt;code&gt;Enumerable&lt;/code&gt; use the &lt;code&gt;#each&lt;/code&gt; method to some extent, our first step in making a custom class enumerable is implementing the &lt;code&gt;#each&lt;/code&gt; method.&lt;/p&gt;
&lt;h2 id=&quot;implementing-each&quot;&gt;Implementing &lt;code&gt;#each&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;By implementing the &lt;code&gt;#each&lt;/code&gt; function and including the &lt;code&gt;Enumerable&lt;/code&gt; module in a class, it becomes enumerable and receives methods like &lt;code&gt;#min&lt;/code&gt;, &lt;code&gt;#take&lt;/code&gt; and &lt;code&gt;#inject&lt;/code&gt; for free.&lt;/p&gt;
&lt;p&gt;Although most situations allow falling back to an existing object like an array and calling the &lt;code&gt;#each&lt;/code&gt; method on that, let&amp;#39;s look at an example where we have to write it ourselves from scratch. In this example, we&amp;#39;ll implement &lt;code&gt;#each&lt;/code&gt; on a &lt;em&gt;linked list&lt;/em&gt; to make it enumerable.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h3&gt;Linked lists: lists without arrays&lt;/h3&gt;
  &lt;p&gt;A &lt;a href=&quot;https://en.wikipedia.org/wiki/Linked_list&quot;&gt;linked list&lt;/a&gt; is a collection of data elements, in which each element points to the next. Each element in the list has two values, named the &lt;em&gt;head&lt;/em&gt; and the &lt;em&gt;tail&lt;/em&gt;. The head holds the element’s value, and the tail is a link to the rest of the list.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[42, [12, [73, nil]]
&lt;/code&gt;&lt;/pre&gt;
  &lt;p&gt;For a linked list with three values (42, 12 and 73), the first element’s head is 42, and the tail is a link to the second element. The second element’s head is 12, and the tail holds the third element. The third element’s head is 73, and the tail is &lt;code&gt;nil&lt;/code&gt;, which indicates the end of the list.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;In Ruby, a linked list can be created by using a class that holds two instance variables named &lt;code&gt;@head&lt;/code&gt; and &lt;code&gt;@tail&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class LinkedList
  def initialize(head, tail = nil)
    @head, @tail = head, tail
  end

  def &amp;lt;&amp;lt;(item)
    LinkedList.new(item, self)
  end

  def inspect
    [@head, @tail].inspect
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;#&amp;lt;&amp;lt;&lt;/code&gt; method is used to add new values to the list, which works by returning a new list with the passed value as the head, and the previous list as the tail.&lt;/p&gt;
&lt;p&gt;In this example, the &lt;code&gt;#inspect&lt;/code&gt; method is added so we can see into the list to check which elements it contains.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; LinkedList.new(73) &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 42
=&amp;gt; [42, [12, [73, nil]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have a linked list, let&amp;#39;s implement &lt;code&gt;#each&lt;/code&gt; on it. The &lt;code&gt;#each&lt;/code&gt; function takes a block and executes it for each value in the object. When implementing it on our linked list, we can use the list&amp;#39;s recursive nature to our advantage by calling the passed block on the list&amp;#39;s &lt;code&gt;@head&lt;/code&gt;, and calling &lt;code&gt;#each&lt;/code&gt; on the &lt;code&gt;@tail&lt;/code&gt;, if it exists.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class LinkedList
  def initialize(head, tail = nil)
    @head, @tail = head, tail
  end

  def &amp;lt;&amp;lt;(item)
    LinkedList.new(item, self)
  end

  def inspect
    [@head, @tail].inspect
  end

  def each(&amp;amp;block)
    block.call(@head)
    @tail.each(&amp;amp;block) if @tail
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When calling &lt;code&gt;#each&lt;/code&gt; on an instance of our linked list, it calls the passed block with current &lt;code&gt;@head&lt;/code&gt;. Then, it calls each on the linked list in &lt;code&gt;@tail&lt;/code&gt; unless the tail is &lt;code&gt;nil&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; list = LinkedList.new(73) &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 42
=&amp;gt; [42, [12, [73, nil]]]
irb&amp;gt; list.each { |item| puts item }
42
12
73
=&amp;gt; nil
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that our linked list responds to &lt;code&gt;#each&lt;/code&gt;, we can &lt;code&gt;include Enumberable&lt;/code&gt; to make our list enumerable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class LinkedList
  include Enumerable

  def initialize(head, tail = nil)
    @head, @tail = head, tail
  end

  def &amp;lt;&amp;lt;(item)
    LinkedList.new(item, self)
  end

  def inspect
    [@head, @tail].inspect
  end

  def each(&amp;amp;block)
    block.call(@head)
    @tail.each(&amp;amp;block) if @tail
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; list = LinkedList.new(73) &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 42
=&amp;gt; [42, [12, [73, nil]]]
irb&amp;gt; list.count
=&amp;gt; 3
irb&amp;gt; list.max
=&amp;gt; 73
irb&amp;gt; list.map { |item| item * item }
=&amp;gt; [1764, 144, 5329]
irb&amp;gt; list.select(&amp;amp;:even?)
=&amp;gt; [42, 12]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;returning-enumerator-instances&quot;&gt;Returning &lt;code&gt;Enumerator&lt;/code&gt; instances&lt;/h2&gt;
&lt;p&gt;We can now loop over all values in our linked list, but we can&amp;#39;t chain enumerable functions yet. To do that, we&amp;#39;ll need to return an &lt;code&gt;Enumerator&lt;/code&gt; instance when our &lt;code&gt;#each&lt;/code&gt; function is called without a block.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class LinkedList
  include Enumerable

  def initialize(head, tail = nil)
    @head, @tail = head, tail
  end

  def &amp;lt;&amp;lt;(item)
    LinkedList.new(item, self)
  end

  def inspect
    [@head, @tail].inspect
  end

  def each(&amp;amp;block)
    if block_given?
      block.call(@head)
      @tail.each(&amp;amp;block) if @tail
    else
      to_enum(:each)
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To wrap an object in an enumerator, we call the &lt;code&gt;#to_enum&lt;/code&gt; method on it. We pass &lt;code&gt;:each&lt;/code&gt;, as that&amp;#39;s the method the enumerator should be using internally.&lt;/p&gt;
&lt;p&gt;Now, calling our &lt;code&gt;#each&lt;/code&gt; method without a block will allow us to chain enumeration.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;irb&amp;gt; list = LinkedList.new(73) &amp;lt;&amp;lt; 12 &amp;lt;&amp;lt; 42
=&amp;gt; [42, [12, [73, nil]]]
irb&amp;gt; list.each
=&amp;gt; #&amp;lt;Enumerator: [42, [12, [73, nil]]]:each&amp;gt;
irb&amp;gt; list.map.with_index.to_h
=&amp;gt; {42=&amp;gt;0, 12=&amp;gt;1, 73=&amp;gt;2}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;nine-lines-of-code-and-an-include&quot;&gt;Nine lines of code and an include&lt;/h2&gt;
&lt;p&gt;By implementing &lt;code&gt;#each&lt;/code&gt; using the &lt;code&gt;Enumerable&lt;/code&gt; module and returning &lt;code&gt;Enumerator&lt;/code&gt; objects from our own, we were able to supercharge our linked list by adding nine lines of code and an include.&lt;/p&gt;
&lt;p&gt;This concludes our overview of enumerables in Ruby. We&amp;#39;d love to know what you thought of this article, or if you have any questions. We&amp;#39;re always on the lookout for topics to investigate and explain, so if there&amp;#39;s anything magical in Ruby you&amp;#39;d like to read about, don&amp;#39;t hesitate to let us now at &lt;a href=&quot;https://twitter.com/appsignal&quot;&gt;@AppSignal&lt;/a&gt;!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>ActiveRecord performance: the N+1 queries antipattern</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/04/24/active-record-performance-the-n-1-queries-antipattern.html">
    <id>https://blog.appsignal.com/2018/04/24/active-record-performance-the-n-1-queries-antipattern.html</id>
    <published>2018-04-24T00:00:00+00:00</published>
    <updated>2018-04-24T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">The N+1 queries problem is a common, but usually easy to spot, performance antipattern that's sometimes caused by lazy loading associations.</summary>
    <content type="html">&lt;p&gt;At AppSignal we help developers with application performance. We&amp;#39;re monitoring a huge number of apps that send billions of requests. We thought we could also help a bit with a few blogposts about Ruby and performance. The N+1 queries problem is a common antipattern in Rails applications.&lt;/p&gt;
&lt;p&gt;A lot of &lt;a href=&quot;https://en.wikipedia.org/wiki/Object-relational_mapping&quot;&gt;ORMs&lt;/a&gt;, like Rails&amp;#39; ActiveRecord, have lazy loading built in to allow you to defer querying associations until the moment they&amp;#39;re needed. It allows being implicit about which associations need to be loaded by offloading this decision to the view.&lt;/p&gt;
&lt;p&gt;The N+1 queries problem is a common, but usually easy to spot, performance antipattern that results in running a query for each association, which causes overhead when querying a large number of associations from the database.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;👋 By the way, if you like this article, there is a lot more we wrote about &lt;a href=&quot;https://www.appsignal.com/ruby&quot;&gt;Ruby (on Rails) performance&lt;/a&gt;, check out our &lt;a href=&quot;https://www.appsignal.com/ruby#ruby-monitoring-checklist&quot;&gt;Ruby performance monitoring checklist&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;lazy-loading-in-activerecord&quot;&gt;Lazy loading in ActiveRecord&lt;/h2&gt;
&lt;p&gt;ActiveRecord uses implicit lazy loading to make it easier to work with relations. Let&amp;#39;s consider the webshop example, where each &lt;em&gt;Product&lt;/em&gt; can have any number of &lt;em&gt;Variants&lt;/em&gt; which contain the product&amp;#39;s color or size, for example.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/models/product.rb
class Product &amp;lt; ActiveRecord::Base
  has_many :variants
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In &lt;code&gt;ProductsController#show&lt;/code&gt;, the detail view for one of the products, we&amp;#39;ll use &lt;code&gt;Product.find(params[:id])&lt;/code&gt; to get the product and assign it to the &lt;code&gt;@product&lt;/code&gt; variable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/products_controller.rb
class ProductsController &amp;lt; ApplicationController
  def show
    @product = Product.find(params[:id])
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the view for this action, we&amp;#39;ll loop over the product&amp;#39;s variants by calling the &lt;code&gt;variants&lt;/code&gt; method on the &lt;code&gt;@product&lt;/code&gt; variable we received from the controller.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;# app/views/products/show.html.erb
&amp;lt;h1&amp;gt;&amp;lt;%= @product.title %&amp;gt;&amp;lt;/h1&amp;gt;

&amp;lt;ul&amp;gt;
&amp;lt;%= @product.variants.each do |variant| %&amp;gt;
  &amp;lt;li&amp;gt;&amp;lt;%= variant.name %&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;% end %&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By calling &lt;code&gt;@product.variants&lt;/code&gt; in the view, Rails will query the database to get the variants for us to loop over. Aside from the explicit query we did in the controller, we can see another query is executed to fetch the variants if we check Rails&amp;#39; logs for this request.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/products/1&amp;quot; for 127.0.0.1 at 2018-04-19 08:49:13 +0200
Processing by ProductsController#show as HTML
  Parameters: {&amp;quot;id&amp;quot;=&amp;gt;&amp;quot;1&amp;quot;}
  Product Load (1.1ms)  SELECT  &amp;quot;products&amp;quot;.* FROM &amp;quot;products&amp;quot; WHERE &amp;quot;products&amp;quot;.&amp;quot;id&amp;quot; = ? LIMIT ?  [[&amp;quot;id&amp;quot;, 1], [&amp;quot;LIMIT&amp;quot;, 1]]
  Rendering products/show.html.erb within layouts/application
  Variant Load (1.1ms)  SELECT &amp;quot;variants&amp;quot;.* FROM &amp;quot;variants&amp;quot; WHERE &amp;quot;variants&amp;quot;.&amp;quot;product_id&amp;quot; = ?  [[&amp;quot;product_id&amp;quot;, 1]]
  Rendered products/show.html.erb within layouts/application (4.4ms)
Completed 200 OK in 64ms (Views: 56.4ms | ActiveRecord: 2.3ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This request executed two queries to show a product with all of its variants.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;SELECT &amp;quot;products&amp;quot;.* FROM &amp;quot;products&amp;quot; WHERE &amp;quot;products&amp;quot;.&amp;quot;id&amp;quot; = 1 LIMIT 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT &amp;quot;variants&amp;quot;.* FROM &amp;quot;variants&amp;quot; WHERE &amp;quot;variants&amp;quot;.&amp;quot;product_id&amp;quot; = 1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;looped-lazy-loading&quot;&gt;Looped lazy loading&lt;/h2&gt;
&lt;p&gt;Lazy loading has been great so far. By using an implicit query, we don&amp;#39;t have to remember to remove it from the controller when we decide we don&amp;#39;t want to show the variants on this view anymore, for example.&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s say we&amp;#39;re working on &lt;code&gt;ProductsController#index&lt;/code&gt;, where we&amp;#39;d like to show a list of all products with each of their variants. We can implement that with lazy loading the same way as we did before.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/products_controller.rb
class ProductsController &amp;lt; ApplicationController
  def index
    @products = Product.all
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-erb&quot;&gt;# app/views/products/index.html.erb
&amp;lt;h1&amp;gt;Products&amp;lt;/h1&amp;gt;

&amp;lt;% @products.each do |product| %&amp;gt;
&amp;lt;article&amp;gt;
  &amp;lt;h1&amp;gt;&amp;lt;%= product.title %&amp;gt;&amp;lt;/h1&amp;gt;

  &amp;lt;ul&amp;gt;
    &amp;lt;% product.variants.each do |variant| %&amp;gt;
      &amp;lt;li&amp;gt;&amp;lt;%= variant.description %&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;% end %&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/article&amp;gt;
&amp;lt;% end %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Unlike the first example we now get a list of products from the controller instead of a single one. The view then loops over each product, and lazy loads each variant for each product.&lt;/p&gt;
&lt;p&gt;While this works, there is one catch. Our query count is now &lt;em&gt;N+1&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;n1-queries&quot;&gt;N+1 queries&lt;/h2&gt;
&lt;p&gt;In the first example, we rendered a view for a single product and its variants. The &lt;em&gt;query count&lt;/em&gt; was 2 because we executed two queries. This request returned all products (3, in this example) from the database, and each of their variants, and it did four queries instead of two.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/products&amp;quot; for 127.0.0.1 at 2018-04-19 09:49:02 +0200
Processing by ProductsController#index as HTML
  Rendering products/index.html.erb within layouts/application
  Product Load (0.3ms)  SELECT &amp;quot;products&amp;quot;.* FROM &amp;quot;products&amp;quot;
  Variant Load (0.2ms)  SELECT &amp;quot;variants&amp;quot;.* FROM &amp;quot;variants&amp;quot; WHERE &amp;quot;variants&amp;quot;.&amp;quot;product_id&amp;quot; = ?  [[&amp;quot;product_id&amp;quot;, 1]]
  Variant Load (0.2ms)  SELECT &amp;quot;variants&amp;quot;.* FROM &amp;quot;variants&amp;quot; WHERE &amp;quot;variants&amp;quot;.&amp;quot;product_id&amp;quot; = ?  [[&amp;quot;product_id&amp;quot;, 2]]
  Variant Load (0.1ms)  SELECT &amp;quot;variants&amp;quot;.* FROM &amp;quot;variants&amp;quot; WHERE &amp;quot;variants&amp;quot;.&amp;quot;product_id&amp;quot; = ?  [[&amp;quot;product_id&amp;quot;, 3]]
  Rendered products/index.html.erb within layouts/application (5.6ms)
Completed 200 OK in 36ms (Views: 32.6ms | ActiveRecord: 0.8ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;SELECT &amp;quot;products&amp;quot;.* FROM &amp;quot;products&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT &amp;quot;variants&amp;quot;.* FROM &amp;quot;variants&amp;quot; WHERE &amp;quot;variants&amp;quot;.&amp;quot;product_id&amp;quot; = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT &amp;quot;variants&amp;quot;.* FROM &amp;quot;variants&amp;quot; WHERE &amp;quot;variants&amp;quot;.&amp;quot;product_id&amp;quot; = 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT &amp;quot;variants&amp;quot;.* FROM &amp;quot;variants&amp;quot; WHERE &amp;quot;variants&amp;quot;.&amp;quot;product_id&amp;quot; = 3&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The first query, which is executed by the explicit call to &lt;code&gt;Product.all&lt;/code&gt; in the controller, finds all products. The subsequent ones are lazily executed while looping over each product in the view.&lt;/p&gt;
&lt;p&gt;This example results in a query count of N+1, where N is the number of products, and the added one is the explicit query that fetched all products. In other words; this example does one query, and then another one for each of the results in the first query. Because N = 3 in this example, the resulting query count is &lt;code&gt;N + 1 = 3 + 1 = 4&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;While this might not really be a problem when having only three products, the query count goes up with the number of products. Because we know this request has N+1 queries, we can predict a query count of 101 when we have 100 products (&lt;code&gt;N + 1 = 100 + 1 = 101&lt;/code&gt;), for example.&lt;/p&gt;
&lt;h2 id=&quot;eager-loading-associations&quot;&gt;Eager loading associations&lt;/h2&gt;
&lt;p&gt;Instead of increasing the number of queries with the number of products like we do now, we&amp;#39;d like to have a static number of requests in this view. We can do that by explicitly preloading the variants in the controller before rendering the view.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# app/controllers/products_controller.rb
class ProductsController &amp;lt; ApplicationController
  def index
    @products = Product.all.includes(:variants)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ActiveRecord&amp;#39;s &lt;code&gt;includes&lt;/code&gt; query method makes sure the associated variants are loaded with their products. Because it knows which variants need to be loaded beforehand, it can fetch all variants of all requested products in one query.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Started GET &amp;quot;/products&amp;quot; for 127.0.0.1 at 2018-04-19 10:33:59 +0200
Processing by ProductsController#index as HTML
  Rendering products/index.html.erb within layouts/application
  Product Load (0.3ms)  SELECT &amp;quot;products&amp;quot;.* FROM &amp;quot;products&amp;quot;
  Variant Load (0.4ms)  SELECT &amp;quot;variants&amp;quot;.* FROM &amp;quot;variants&amp;quot; WHERE &amp;quot;variants&amp;quot;.&amp;quot;product_id&amp;quot; IN (?, ?, ?)  [[&amp;quot;product_id&amp;quot;, 1], [&amp;quot;product_id&amp;quot;, 2], [&amp;quot;product_id&amp;quot;, 3]]
  Rendered products/index.html.erb within layouts/application (5.9ms)
  Completed 200 OK in 45ms (Views: 40.8ms | ActiveRecord: 0.7ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By preloading the variants, the query count drops back to 2, even if the number of products increases in the future.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;SELECT &amp;quot;products&amp;quot;.* FROM &amp;quot;products&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SELECT &amp;quot;variants&amp;quot;.* FROM &amp;quot;variants&amp;quot; WHERE &amp;quot;variants&amp;quot;.&amp;quot;product_id&amp;quot; IN (1, 2, 3)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;lazy-or-eager&quot;&gt;Lazy or eager?&lt;/h2&gt;
&lt;p&gt;In most situations, getting all associated records from the database in a single query is a lot faster than lazy loading them.&lt;/p&gt;
&lt;p&gt;In this example application, the database performance difference is measurable with only three products, each having ten variants. On average, eager loading the products list is about 12.5% faster (0.7 ms vs 0.8 ms) than lazy loading. With ten products, that difference jumps to 59% (1.22 ms vs 2.98 ms). With 1000 products, the difference is almost 80%, as the eager queries clock in at 58.4 ms, while lazy loading them takes about 290.12 ms.&lt;/p&gt;
&lt;p&gt;Although lazily-loaded associations give more flexibility in the view without having to update the controller, a good rule of thumb is to have the controller handle loading the data before passing it off to the view.&lt;/p&gt;
&lt;p&gt;Lazy loading from the view works for views that show one model object and it&amp;#39;s associations (like the &lt;code&gt;ProductsController#show&lt;/code&gt; in our first example) and can be useful when having multiple views that require different data from the same controller, for example.&lt;/p&gt;
&lt;h2 id=&quot;cats-and-dolls&quot;&gt;Cats and Dolls&lt;/h2&gt;
&lt;p&gt;Cats might not agree, but sometimes it pays of to be eager rather than lazy. In this post we dove into the lazy loading in ActiveRecord and showed an example of the situations in which this can create a performance issue. Like when it leads to the N+1 queries problem.&lt;/p&gt;
&lt;p&gt;In short: always keep an eye on the development logs, or the &lt;a href=&quot;https://www.appsignal.com/tour/performance&quot;&gt;event timeline in AppSignal&lt;/a&gt;, to make sure you’re not doing queries that could be lazy loaded and keep track of your response times, especially when the amount of data that’s processed increases.&lt;/p&gt;
&lt;p&gt;If you liked this, check out some more things we wrote on performance and monitoring, like this favorite about &lt;a href=&quot;/2018/04/03/russian-doll-caching-in-rails.html&quot;&gt;Russian Doll Caching&lt;/a&gt; or this one about &lt;a href=&quot;/2018/05/01/client-side-caching-in-rails-conditional-get-requests.html&quot;&gt;Conditional Get Requests&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Benchmarking Ruby Code</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/02/27/benchmarking-ruby-code.html">
    <id>https://blog.appsignal.com/2018/02/27/benchmarking-ruby-code.html</id>
    <published>2018-02-27T00:00:00+00:00</published>
    <updated>2018-02-27T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">When working on an important piece of code in your codebase, running benchmarks to compare different implementations can give more insight into their execution speeds.</summary>
    <content type="html">&lt;p&gt;Ruby has a benchmarking tool in its standard library to help measure the performance of your code. It&amp;#39;s most useful when comparing two implementations, to find out which is fastest.&lt;/p&gt;
&lt;p&gt;In this example, we&amp;#39;re tasked with converting a Hash with string keys (like &lt;code&gt;{&amp;quot;foo&amp;quot; =&amp;gt; &amp;quot;bar&amp;quot;}&lt;/code&gt; to one with symbols (like &lt;code&gt;{:foo =&amp;gt; &amp;quot;bar&amp;quot;}&lt;/code&gt;). Throughout the examples, we&amp;#39;ll use a hash with a key and a value for each letter in the English alphabet.&lt;/p&gt;
&lt;p&gt;To quickly generate this hash without having to type it out, we&amp;#39;ll convert a range of letters to our testing hash. We&amp;#39;ll put it in the &lt;code&gt;input&lt;/code&gt; variable to use later.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;input = (&amp;quot;a&amp;quot;..&amp;quot;z&amp;quot;).map {|letter| [letter, letter]}.to_h
# =&amp;gt; {&amp;quot;a&amp;quot;=&amp;gt;&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;=&amp;gt;&amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;=&amp;gt;&amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;=&amp;gt;&amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;=&amp;gt;&amp;quot;e&amp;quot;, &amp;quot;f&amp;quot;=&amp;gt;&amp;quot;f&amp;quot;, &amp;quot;g&amp;quot;=&amp;gt;&amp;quot;g&amp;quot;, &amp;quot;h&amp;quot;=&amp;gt;&amp;quot;h&amp;quot;, &amp;quot;i&amp;quot;=&amp;gt;&amp;quot;i&amp;quot;, &amp;quot;j&amp;quot;=&amp;gt;&amp;quot;j&amp;quot;, &amp;quot;k&amp;quot;=&amp;gt;&amp;quot;k&amp;quot;, &amp;quot;l&amp;quot;=&amp;gt;&amp;quot;l&amp;quot;, &amp;quot;m&amp;quot;=&amp;gt;&amp;quot;m&amp;quot;, &amp;quot;n&amp;quot;=&amp;gt;&amp;quot;n&amp;quot;, &amp;quot;o&amp;quot;=&amp;gt;&amp;quot;o&amp;quot;, &amp;quot;p&amp;quot;=&amp;gt;&amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;=&amp;gt;&amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;=&amp;gt;&amp;quot;r&amp;quot;, &amp;quot;s&amp;quot;=&amp;gt;&amp;quot;s&amp;quot;, &amp;quot;t&amp;quot;=&amp;gt;&amp;quot;t&amp;quot;, &amp;quot;u&amp;quot;=&amp;gt;&amp;quot;u&amp;quot;, &amp;quot;v&amp;quot;=&amp;gt;&amp;quot;v&amp;quot;, &amp;quot;w&amp;quot;=&amp;gt;&amp;quot;w&amp;quot;, &amp;quot;x&amp;quot;=&amp;gt;&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;=&amp;gt;&amp;quot;y&amp;quot;, &amp;quot;z&amp;quot;=&amp;gt;&amp;quot;z&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we have our &lt;code&gt;input&lt;/code&gt; variable to test our implementations with, we&amp;#39;ll write one to see how it performs. A nice one-liner to convert all keys in our input hash to symbols instead of strings looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;input.map { |key, value| [key.to_sym, value] }.to_h
# =&amp;gt; {:a=&amp;gt;&amp;quot;a&amp;quot;, :b=&amp;gt;&amp;quot;b&amp;quot;, :c=&amp;gt;&amp;quot;c&amp;quot;, :d=&amp;gt;&amp;quot;d&amp;quot;, :e=&amp;gt;&amp;quot;e&amp;quot;, :f=&amp;gt;&amp;quot;f&amp;quot;, :g=&amp;gt;&amp;quot;g&amp;quot;, :h=&amp;gt;&amp;quot;h&amp;quot;, :i=&amp;gt;&amp;quot;i&amp;quot;, :j=&amp;gt;&amp;quot;j&amp;quot;, :k=&amp;gt;&amp;quot;k&amp;quot;, :l=&amp;gt;&amp;quot;l&amp;quot;, :m=&amp;gt;&amp;quot;m&amp;quot;, :n=&amp;gt;&amp;quot;n&amp;quot;, :o=&amp;gt;&amp;quot;o&amp;quot;, :p=&amp;gt;&amp;quot;p&amp;quot;, :q=&amp;gt;&amp;quot;q&amp;quot;, :r=&amp;gt;&amp;quot;r&amp;quot;, :s=&amp;gt;&amp;quot;s&amp;quot;, :t=&amp;gt;&amp;quot;t&amp;quot;, :u=&amp;gt;&amp;quot;u&amp;quot;, :v=&amp;gt;&amp;quot;v&amp;quot;, :w=&amp;gt;&amp;quot;w&amp;quot;, :x=&amp;gt;&amp;quot;x&amp;quot;, :y=&amp;gt;&amp;quot;y&amp;quot;, :z=&amp;gt;&amp;quot;z&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This implementation uses the &lt;code&gt;map&lt;/code&gt; method to loop over the hash to run a block for each key-value pair. In the block, it converts the key to a symbol and returns a two-element array with the newly created symbol key, and the untouched value.&lt;/p&gt;
&lt;p&gt;The result from the &lt;code&gt;map&lt;/code&gt; command is an array with 26 key-value arrays. Since we need a hash, we use &lt;code&gt;#to_h&lt;/code&gt; to convert our new array back into a hash.&lt;/p&gt;
&lt;h2 id=&quot;benchmarkmeasure&quot;&gt;Benchmark.measure&lt;/h2&gt;
&lt;p&gt;Now that we have a working implementation, we can use &lt;a href=&quot;https://ruby-doc.org/stdlib-2.5.0/libdoc/benchmark/rdoc/Benchmark.html&quot;&gt;Ruby&amp;#39;s Benchmark module&lt;/a&gt; to see how it performs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;benchmark&amp;#39;

input = (&amp;#39;a&amp;#39;..&amp;#39;z&amp;#39;).map { |letter| [letter, letter] }.to_h

puts Benchmark.measure {
  50_000.times do
    input.map { |key, value| [key.to_sym, value] }.to_h
  end
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Benchmark.measure&lt;/code&gt; takes a block, which is executed while keeping track of how long it took to execute. It returns a report string, which is printed to the console using &lt;code&gt;puts&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Since this is a quick piece of code, we run it 50.000 times to make sure we get some visible results.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ruby bench.rb
  0.810000   0.000000   0.810000 (  0.816964)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The report string shows four numbers, which represent the &lt;em&gt;user CPU time&lt;/em&gt; (the time spent executing your code), the &lt;em&gt;system CPU time&lt;/em&gt; (the time spent in the kernel), both user and system CPU time added up, and the actual time (or wall clock time) it took for the block to execute in brackets.&lt;/p&gt;
&lt;p&gt;The wall time shows us that we can run the block of code above 50.000 times in a little over 800 milliseconds. While that&amp;#39;s an impressive number, we don&amp;#39;t know what that means unless we compare it to another implementation of the code.&lt;/p&gt;
&lt;h2 id=&quot;benchmarkbm&quot;&gt;Benchmark.bm&lt;/h2&gt;
&lt;p&gt;Besides &lt;code&gt;Benchmark.measure&lt;/code&gt;, Ruby provides &lt;code&gt;Benchmark.bm&lt;/code&gt;, which can run multiple code samples and print their results. For each sample, we&amp;#39;ll call &lt;code&gt;Benchmark#report&lt;/code&gt; with a name, and the block to be executed.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;require &amp;#39;benchmark&amp;#39;

input = (&amp;quot;a&amp;quot;..&amp;quot;z&amp;quot;).map { |letter| [letter, letter] }.to_h
n = 50_000

Benchmark.bm do |benchmark|
  benchmark.report(&amp;quot;Hash[]&amp;quot;) do
    n.times do
      input.map { |key, value| [key.to_sym, value] }.to_h
    end
  end

  benchmark.report(&amp;quot;{}.tap&amp;quot;) do
    n.times do
      {}.tap do |new_hash|
        input.each do |key, value|
          new_hash[key.to_sym] = value
        end
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this benchmark, we&amp;#39;ll use &lt;code&gt;Benchmark.bm&lt;/code&gt; to test two implementations by running each 50.000 times. The first measurement block is the same as the example from before.&lt;/p&gt;
&lt;p&gt;In the second measurement block, we use a longer implementation, which creates a new hash up front. It loops over the string-key hash, and adds an element to the new hash for every item. This way, it doesn&amp;#39;t have to convert the hash to an array, and back to a hash when it&amp;#39;s finished.&lt;/p&gt;
&lt;p&gt;Running the benchmark again will show us this implementation is more than 25% faster, although the code is longer (and a little less clever) than the one-liner we tried before.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ruby bench.rb
       user     system      total        real
Hash[]  0.850000   0.000000   0.850000 (  0.851106)
{}.tap  0.610000   0.020000   0.630000 (  0.637070)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;more-benchmarking&quot;&gt;More benchmarking&lt;/h2&gt;
&lt;p&gt;When working on an important piece of code in your codebase, running benchmarks to compare different implementations can give more insight into their execution speeds. By comparing different implementations to understand how they impact performance, you&amp;#39;ll be able to avoid anti-patterns and write faster Ruby.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tip&lt;/em&gt;: A lot of common idioms are pre-benchmarked, and their results are published as &lt;a href=&quot;https://github.com/JuanitoFatas/fast-ruby&quot;&gt;fast-ruby&lt;/a&gt;. Reading through the examples can save you some benchmarking in the future.&lt;/p&gt;
&lt;p&gt;There are more options you can test for this example, and the Ruby&amp;#39;s benchmarking library has a lot more sophisticated features you can try, but this gives a good introduction to how benchmarking works in Ruby. If you&amp;#39;d like to know more about benchmarking, or have any questions or suggestions, please let us know at &lt;a href=&quot;https://twitter.com/appsignal&quot;&gt;@AppSignal&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Syntactic sugar methods in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2018/02/20/ruby-magic-syntactic-sugar-methods.html">
    <id>https://blog.appsignal.com/2018/02/20/ruby-magic-syntactic-sugar-methods.html</id>
    <published>2018-02-20T00:00:00+00:00</published>
    <updated>2018-02-20T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Ever hear about Ruby's syntactic sugar, but never knew what it meant or how to use it? In this article we'll explore just how we can use it to our advantage.</summary>
    <content type="html">&lt;p&gt;Welcome to a new Ruby Magic article! In this episode, we&amp;#39;ll look at how Ruby uses &lt;em&gt;syntactic sugar&lt;/em&gt; to make some of its syntax more expressive, or easier to read. At the end, we&amp;#39;ll know how some of Ruby&amp;#39;s tricks work under the hood and how to write our own methods that use a bit of this sugar.&lt;/p&gt;
&lt;p&gt;When writing Ruby apps it&amp;#39;s common to interact with class attributes, arrays and hashes in a way that may feel non-standard. How would we define methods to assign attributes and fetch values from an array or hash?&lt;/p&gt;
&lt;p&gt;Ruby provides a bit of syntactic sugar to make these method work when calling them. In this post we&amp;#39;ll explore how that works.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;person1 = Person.new
person1.name = &amp;quot;John&amp;quot;

array = [:foo, :bar]
array[1]  # =&amp;gt; :bar

hash = { :key =&amp;gt; :foo }
hash[:key] # =&amp;gt; :foo
hash[:key] = :value
&lt;/code&gt;&lt;/pre&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;Syntactic sugar?&lt;/h2&gt;

  &lt;p&gt;Syntactic sugar refers to the little bit of ✨ magic ✨ Ruby provides you in writing easier to read and more concise code. In Ruby this means leaving out certain symbols, spaces or writing some expression with a helper of some kind.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;method-names&quot;&gt;Method names&lt;/h2&gt;
&lt;p&gt;Let&amp;#39;s start with method names. In Ruby, we can use all kinds of characters and special symbols for method names that aren&amp;#39;t commonly supported in other languages. If you&amp;#39;ve ever written a Rails app you&amp;#39;ve probably encountered the &lt;code&gt;save!&lt;/code&gt; method. This isn&amp;#39;t something specific to Rails, but it demonstrates support for the &lt;code&gt;!&lt;/code&gt; character in Ruby method names.&lt;/p&gt;
&lt;p&gt;The same applies to other symbols such as &lt;code&gt;=&lt;/code&gt;, &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;]&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Support for these characters means we can incorporate them into our method names to be more explicit about what they&amp;#39;re for:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Assigning attributes: &lt;code&gt;person.name = &amp;quot;foo&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ask questions: &lt;code&gt;person.alive?&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Call dangerous methods: &lt;code&gt;car.destroy!&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Making objects act like something they&amp;#39;re not: &lt;code&gt;car[:wheels]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;defining-attribute-methods&quot;&gt;Defining attribute methods&lt;/h2&gt;
&lt;p&gt;When defining an attribute on a class with &lt;code&gt;attr_accessor&lt;/code&gt;, Ruby creates a reader and a writer method for an instance variable on the class.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class Person
  attr_accessor :name
end

person = Person.new
person.name = &amp;quot;John&amp;quot;
person.name # =&amp;gt; &amp;quot;John&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Under the hood, Ruby creates two methods:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Person#name&lt;/code&gt; for reading the attribute/instance variable on the class using &lt;code&gt;attr_reader&lt;/code&gt;, and;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Person#name=&lt;/code&gt; for writing the attribute/instance variable on the class using &lt;code&gt;attr_writer&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now let&amp;#39;s say we want to customize this behavior. We won&amp;#39;t use the &lt;code&gt;attr_accessor&lt;/code&gt; helper and define the methods ourselves.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class AwesomePerson
  def name
    &amp;quot;Person name: #{@name}&amp;quot;
  end

  def name=(value)
    @name = &amp;quot;Awesome #{value}&amp;quot;
  end
end

person = AwesomePerson.new
person.name = &amp;quot;Jane&amp;quot;
person.name # =&amp;gt; &amp;quot;Person name: Awesome Jane&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The method definition for &lt;code&gt;name=&lt;/code&gt; is roughly the same way you would write it when calling the method &lt;code&gt;person.name = &amp;quot;Jane&amp;quot;&lt;/code&gt;. We don&amp;#39;t define the spaces around the equals sign &lt;code&gt;=&lt;/code&gt; and don&amp;#39;t use parentheses when calling the method.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;Optional parentheses and spaces&lt;/h2&gt;

&lt;p&gt;
  You may have seen that in Ruby parentheses are optional a lot of the time.
  When passing an argument to a method, we don't have to wrap the argument in
  parentheses &lt;code&gt;()&lt;/code&gt;, but we can if it's easier to read.
&lt;/p&gt;

&lt;p&gt;
  The if-statement is a good example. In many languages you wrap the expression
  the if-statement evaluates with parentheses. In Ruby, they can be omitted.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;puts &amp;quot;Hello!&amp;quot; if (true) # With optional parentheses
puts &amp;quot;Hello!&amp;quot; if true   # Without parentheses
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The same applies to method definitions and other expressions.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def greeting name # Parentheses omitted
  &amp;quot;Hello #{name}!&amp;quot;
end

greeting(&amp;quot;Robin&amp;quot;) # With parentheses
greeting &amp;quot;Robin&amp;quot;  # Without parentheses
greeting&amp;quot;Robin&amp;quot;   # Without parentheses and spaces
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  The last line is difficult to read, but it works. The parentheses and spaces
  are optional even when calling methods.
&lt;/p&gt;

  &lt;p&gt;Just be careful not to omit every parentheses and space, some of these help Ruby understand what you mean! When in doubt, wrap your arguments in parentheses so you and Ruby know what arguments belongs to what method call.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;All the following ways of calling the method are supported, but we commonly omit the parentheses and add spaces to make the code a bit more readable.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Previous method definition:
# def name=(value)
#   @name = &amp;quot;Awesome #{value}&amp;quot;
# end

person.name = &amp;quot;Jane&amp;quot;
person.name=&amp;quot;Jane&amp;quot;
person.name=(&amp;quot;Jane&amp;quot;) # That looks a lot like the method definition!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We&amp;#39;ve now defined custom attribute reader and writer methods for the &lt;code&gt;name&lt;/code&gt; attribute. We can customize the behavior as needed and perform transformations on the value directly when assigning the attribute rather than having to use callbacks.&lt;/p&gt;
&lt;h2 id=&quot;defining---methods&quot;&gt;Defining &lt;code&gt;[ ]&lt;/code&gt; methods&lt;/h2&gt;
&lt;p&gt;The next thing we&amp;#39;ll look at are the square bracket methods &lt;code&gt;[ ]&lt;/code&gt; in Ruby. These are commonly used to fetch and assign values to Array indexes and Hash keys.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;hash = { :foo =&amp;gt; :bar, :abc =&amp;gt; :def }
hash[:foo]        # =&amp;gt; :bar
hash[:foo] = :baz # =&amp;gt; :baz

array = [:foo, :bar]
array[1] # =&amp;gt; :bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let&amp;#39;s look at how these methods are defined. When calling &lt;code&gt;hash[:foo]&lt;/code&gt; we are using some Ruby syntactic sugar to make that work. Another way of writing this is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;hash = { :foo =&amp;gt; :bar }
hash.[](:foo)
hash.[]=(:foo, :baz)
# or even:
hash.send(:[], :foo)
hash.send(:[]=, :foo, :baz)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Compared with the way we normally write this (&lt;code&gt;hash[:foo]&lt;/code&gt; and &lt;code&gt;hash[:foo] = :baz&lt;/code&gt;) we can already see some differences. In the first example (&lt;code&gt;hash.[](:foo)&lt;/code&gt;) Ruby moves the first argument between the square brackets (&lt;code&gt;hash[:foo]&lt;/code&gt;). When calling &lt;code&gt;hash.[]=(:foo, :baz)&lt;/code&gt; the second argument is passed to the method as the value &lt;code&gt;hash[:foo] = :baz&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Knowing this, we can now define our own &lt;code&gt;[ ]&lt;/code&gt; and &lt;code&gt;[ ]=&lt;/code&gt; methods the way Ruby will understand it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MyHash
  def initialize
    @internal_hash = {}
  end

  def [](key)
    @internal_hash[key]
  end

  def []=(key, value)
    @internal_hash[key] = value
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now that we know these methods are normal Ruby methods, we can apply the same logic to them as any other method. We can even make it do weird things like allow multiple keys in the &lt;code&gt;[ ]&lt;/code&gt; method.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;class MyHash
  def initialize
    @internal_hash = { :foo =&amp;gt; :bar, :abc =&amp;gt; :def }
  end

  def [](*keys)
    @internal_hash.values_at(*keys)
  end
end

hash = MyHash.new
hash[:foo, :abc] # =&amp;gt; [:bar, :def]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;create-your-own&quot;&gt;Create your own&lt;/h2&gt;
&lt;p&gt;Now that we know a bit about Ruby&amp;#39;s syntactic sugar, we can apply this knowledge to create our own methods such as custom writers, Hash-like classes and more.&lt;/p&gt;
&lt;p&gt;You may be surprised how many gems define methods such as the square brackets methods to make something feel like an Array or Hash when it really isn&amp;#39;t. One example is setting a flash message in a Rails application with:&lt;br/&gt;&lt;code&gt;flash[:alert] = &amp;quot;An error occurred&amp;quot;&lt;/code&gt;. In the AppSignal gem we use this ourselves on the &lt;code&gt;Config&lt;/code&gt; class &lt;a href=&quot;https://github.com/appsignal/appsignal-ruby/blob/2ebe7fe8b5b0708363aa71c27b2f5cc1941d9ad0/lib/appsignal/config.rb#L99-L105&quot;&gt;as a shorthand&lt;/a&gt; for fetching the configuration.&lt;/p&gt;
&lt;p&gt;This concludes our brief look at the syntactic sugar for method definition and calling in Ruby. We&amp;#39;d love to know how you liked this article, if you have any questions about it, and what you&amp;#39;d like to read about next, so be sure to let us know at &lt;a href=&quot;https://twitter.com/appsignal&quot;&gt;@AppSignal&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>A look at how Ruby interprets your code</title>
    <link rel="alternate" href="https://blog.appsignal.com/2017/08/01/ruby-magic-code-interpretation.html">
    <id>https://blog.appsignal.com/2017/08/01/ruby-magic-code-interpretation.html</id>
    <published>2017-08-01T00:00:00+00:00</published>
    <updated>2017-08-01T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">A look at how Ruby interprets your code and how you can use this knowledge to your advantage.</summary>
    <content type="html">&lt;p&gt;Welcome to a new Ruby Magic article! This time we&amp;#39;ll be looking at how Ruby interprets our code, and how we can use this knowledge to our advantage. This post will help you understand how code is interpreted, and how this can help lead to faster code.&lt;/p&gt;
&lt;h2 id=&quot;a-subtle-difference-between-symbols&quot;&gt;A subtle difference between symbols&lt;/h2&gt;
&lt;p&gt;In a previous Ruby Magic article about &lt;a href=&quot;/2016/12/21/ruby-magic-escaping-in-ruby.html&quot;&gt;Escaping characters in Ruby&lt;/a&gt; there was an example about escaping line breaks.&lt;/p&gt;
&lt;p&gt;In the example below you see how two strings are combined as one String across multiple lines, with either the plus &lt;code&gt;+&lt;/code&gt; symbol or with the backslash &lt;code&gt;\ &lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;quot;foo&amp;quot; +
  &amp;quot;bar&amp;quot;
=&amp;gt; &amp;quot;foobar&amp;quot;

# versus

&amp;quot;foo&amp;quot; \
  &amp;quot;bar&amp;quot;
=&amp;gt; &amp;quot;foobar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These two examples may look similar, but they behave quite differently. To know the difference between how these are read and interpreted, you&amp;#39;d normally need to know the nitty-gritty about the Ruby interpreter. Or, we can just ask Ruby what the difference is.&lt;/p&gt;
&lt;h2 id=&quot;instructionsequence&quot;&gt;InstructionSequence&lt;/h2&gt;
&lt;p&gt;Using the &lt;a href=&quot;http://ruby-doc.org/core-2.4.1/RubyVM/InstructionSequence.html&quot;&gt;&lt;code&gt;RubyVM::InstructionSequence&lt;/code&gt;&lt;/a&gt; class we can ask Ruby how it interprets some code we give it. This class gives us a tool set which we can use to get a glimpse of Ruby&amp;#39;s internals.&lt;/p&gt;
&lt;p&gt;What is returned in the example below is Ruby code as it&amp;#39;s understood by the &lt;a href=&quot;https://en.wikipedia.org/wiki/YARV&quot;&gt;YARV interpreter&lt;/a&gt;.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;YARV interpreter&lt;/h2&gt;

&lt;p&gt;
  YARV (Yet Another Ruby VM) is the Ruby interpreter introduced in Ruby version
  1.9, replacing the original interpreter: MRI (Matz's Ruby Interpreter).
&lt;/p&gt;

&lt;p&gt;
  Languages that use interpreters directly execute code without an intermediate
  compilation step. This means that Ruby does not first compile a program to an
  optimized machine language program, which compiled languages such as{&quot; &quot;}
  &lt;a href=&quot;https://en.wikipedia.org/wiki/C_(programming_language)&quot;&gt;C&lt;/a&gt;,{&quot; &quot;}
  &lt;a href=&quot;https://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; and{&quot; &quot;}
  &lt;a href=&quot;https://golang.org/&quot;&gt;Go&lt;/a&gt; do.
&lt;/p&gt;

&lt;p&gt;
  In Ruby, a program is first translated to an instruction set for the Ruby VM,
  and is then executed immediately after. These instructions are an intermediate
  step between your Ruby code and the code being executed in the Ruby VM.
&lt;/p&gt;

&lt;p&gt;
  These instructions make it easier for the Ruby VM to understand Ruby code
  without having to deal with syntax specific interpretation. That's handled
  while creating these instructions. Instruction sequences are optimized
  operations which represent the interpreted code.
&lt;/p&gt;

  &lt;p&gt;During the normal execution of a Ruby program we don't see these instructions, but by viewing them we can review if Ruby has interpreted our code correctly. With &lt;code&gt;InstructionSequence&lt;/code&gt; it's possible to see what kind of instructions YARV creates before it executes them.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;It&amp;#39;s not necessary to understand all of the YARV instructions that make up the Ruby interpreter. Most commands will speak for themselves.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;quot;foo&amp;quot; +
  &amp;quot;bar&amp;quot;
RubyVM::InstructionSequence.compile(&amp;#39;&amp;quot;foo&amp;quot; + &amp;quot;bar&amp;quot;&amp;#39;).to_a
# ... [:putstring, &amp;quot;foo&amp;quot;], [:putstring, &amp;quot;bar&amp;quot;] ...

# versus

&amp;quot;foo&amp;quot; \
  &amp;quot;bar&amp;quot;
RubyVM::InstructionSequence.compile(&amp;#39;&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot;&amp;#39;).to_a
# ... [:putstring, &amp;quot;foobar&amp;quot;] ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The real output contains a bit more setup commands that we will look at later, but here we can see the real difference between &lt;code&gt;&amp;quot;foo&amp;quot; + &amp;quot;bar&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The former creates two strings and combines them. The latter creates one string. This means that with &lt;code&gt;&amp;quot;foo&amp;quot; &amp;quot;bar&amp;quot;&lt;/code&gt; we only create one string, rather than three with &lt;code&gt;&amp;quot;foo&amp;quot; + &amp;quot;bar&amp;quot;&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1       2           3
  ↓       ↓           ↓
&amp;quot;foo&amp;quot; + &amp;quot;bar&amp;quot; # =&amp;gt; &amp;quot;foobar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, this is just about the most basic example we can use, but it shows a good use case of how a small detail in the Ruby language could potentially have a lot of impact:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;More allocations: every String object is allocated separately.&lt;/li&gt;
&lt;li&gt;More memory usage: every allocated String object takes up memory.&lt;/li&gt;
&lt;li&gt;Longer garbage collection: every object, even when short-lived, takes up time to be cleaned by the garbage collector. More allocations means longer garbage collection times.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;disassembling&quot;&gt;Disassembling&lt;/h2&gt;
&lt;p&gt;Another use case is debugging a logic issue. The following is an easy mistake to make, which can have big consequences. Can you spot the difference?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;1 + 2 * 3
# versus
(1 + 2) * 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can use Ruby to help us find out the difference in this slightly more complex example.&lt;/p&gt;
&lt;p&gt;By disassembling this code example we can get Ruby to print a more readable table of the commands it&amp;#39;s performing.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;1 + 2 * 3
# =&amp;gt; 7
puts RubyVM::InstructionSequence.compile(&amp;quot;1 + 2 * 3&amp;quot;).disasm
# == disasm: &amp;lt;RubyVM::InstructionSequence:&amp;lt;compiled&amp;gt;@&amp;lt;compiled&amp;gt;&amp;gt;==========
# 0000 trace            1                                               (   1)
# 0002 putobject_OP_INT2FIX_O_1_C_
# 0003 putobject        2
# 0005 putobject        3
# 0007 opt_mult         &amp;lt;callinfo!mid:*, argc:1, ARGS_SIMPLE&amp;gt;
# 0009 opt_plus         &amp;lt;callinfo!mid:+, argc:1, ARGS_SIMPLE&amp;gt;
# 0011 leave

# versus

(1 + 2) * 3
# =&amp;gt; 9
puts RubyVM::InstructionSequence.compile(&amp;quot;(1 + 2) * 3&amp;quot;).disasm
# == disasm: &amp;lt;RubyVM::InstructionSequence:&amp;lt;compiled&amp;gt;@&amp;lt;compiled&amp;gt;&amp;gt;==========
# 0000 trace            1                                               (   1)
# 0002 putobject_OP_INT2FIX_O_1_C_
# 0003 putobject        2
# 0005 opt_plus         &amp;lt;callinfo!mid:+, argc:1, ARGS_SIMPLE&amp;gt;
# 0007 putobject        3
# 0009 opt_mult         &amp;lt;callinfo!mid:*, argc:1, ARGS_SIMPLE&amp;gt;
# 0011 leave
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The example above is a bit more involved with the number of YARV instructions, but just from the order in which things are printed and executed we see the difference a pair of parentheses can make.&lt;/p&gt;
&lt;p&gt;With the parentheses around &lt;code&gt;1 + 2&lt;/code&gt; we make sure the addition is performed first, by moving it up the &lt;a href=&quot;http://mathworld.wolfram.com/Precedence.html&quot;&gt;order of operations&lt;/a&gt; in mathematics.&lt;/p&gt;
&lt;p&gt;Note that you don&amp;#39;t actually see the parentheses in the disassembly output itself, only their effect on the rest of the code.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;Disassembly&lt;/h2&gt;

&lt;p&gt;
  The Disassembly output prints a lot of things that might not immediately be
  understandable.
&lt;/p&gt;

&lt;p&gt;
  In the table format that is printed, every line starts with an operation
  number. After which it mentions the operation and finally the argument to the
  operation.
&lt;/p&gt;

&lt;p&gt;A small sample of operations we've seen so far:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code&gt;trace&lt;/code&gt; - start a trace. See the docs on &lt;a href=&quot;http://ruby-doc.org/core-2.4.1/TracePoint.html&quot;&gt;TracePoint&lt;/a&gt; for more information.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;putobject&lt;/code&gt; - push an object on the stack.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;putobject_OP_INT2FIX_O_1_C_&lt;/code&gt; - push the Integer &lt;code&gt;1&lt;/code&gt; on the stack. Optimized operation. (&lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; are optimized.)&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;putstring&lt;/code&gt; - push a string on the stack.&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;opt_plus&lt;/code&gt; - addition operation (internally optimized).&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;opt_mult&lt;/code&gt; - multiply operation (internally optimized).&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;leave&lt;/code&gt; - leave the current code context.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;

&lt;p&gt;Now that we know how the Ruby interpreter converts our developer friendly and readable Ruby code to YARV instructions, we can use this to optimize our applications.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s possible to pass along entire methods and even entire files to &lt;code&gt;RubyVM::InstructionSequence&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;puts RubyVM::InstructionSequence.disasm(method(:foo))
puts RubyVM::InstructionSequence.compile_file(&amp;quot;/tmp/hello.rb&amp;quot;).disasm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Find out why some piece of code works and why another doesn&amp;#39;t. Learn why certain symbols make code behave differently than others. The devil is in the details, and it&amp;#39;s good to know how your Ruby code is behaving in your app and if you can optimize it in any way.&lt;/p&gt;
&lt;h2 id=&quot;optimizations&quot;&gt;Optimizations&lt;/h2&gt;
&lt;p&gt;Other than being able to view your code on interpreter level and optimize for it, you can use &lt;code&gt;InstructionSequence&lt;/code&gt; to optimize your code even further.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;InstructionSequence&lt;/code&gt;, it&amp;#39;s possible to optimize certain instructions with Ruby&amp;#39;s built-in performance optimizations. The full list of available optimizations is available in the &lt;a href=&quot;http://ruby-doc.org/core-2.4.1/RubyVM/InstructionSequence.html#method-c-compile_option-3D&quot;&gt;&lt;code&gt;RubyVM::InstructionSequence.compile_option =&lt;/code&gt;&lt;/a&gt; method documentation.&lt;/p&gt;
&lt;p&gt;One of these optimizations is &lt;strong&gt;Tail Call Optimization&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;RubyVM::InstructionSequence.compile&lt;/code&gt; method accepts options to enable this optimization as such:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;some_code = &amp;lt;&amp;lt;-EOS
def fact(n, acc=1)
  return acc if n &amp;lt;= 1
  fact(n-1, n*acc)
end
EOS
puts RubyVM::InstructionSequence.compile(some_code, nil, nil, nil, tailcall_optimization: true, trace_instruction: false).disasm
RubyVM::InstructionSequence.compile(some_code, nil, nil, nil, tailcall_optimization: true, trace_instruction: false).eval
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can even turn this optimization on for all your code with &lt;code&gt;RubyVM::InstructionSequence.compile_option =&lt;/code&gt;. Just make sure to load this before any of your other code.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;RubyVM::InstructionSequence.compile_option = {
  tailcall_optimization: true,
  trace_instruction: false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For more information about how Tail Call Optimization works in Ruby check out these articles: &lt;a href=&quot;http://nithinbekal.com/posts/ruby-tco/&quot;&gt;Tail Call Optimization in Ruby&lt;/a&gt; and &lt;a href=&quot;https://blog.tdg5.com/tail-call-optimization-in-ruby-background/&quot;&gt;Tail Call Optimization in Ruby: Background&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Learn more about how Ruby interprets your code with &lt;code&gt;RubyVM::InstructionSequence&lt;/code&gt; and see what your code is really doing so you can make it more performant.&lt;/p&gt;
&lt;p&gt;This introduction to InstructionSequence might also be a fun way to learn more about how Ruby works under the hood. Who knows? You might even be interested in working on some of &lt;a href=&quot;https://github.com/ruby/ruby&quot;&gt;Ruby&amp;#39;s code&lt;/a&gt; itself.&lt;/p&gt;
&lt;p&gt;That concludes our short introduction to code compilation in Ruby. We&amp;#39;d love to know how you liked this article, if you have any questions about it, and what you&amp;#39;d like to read about next, so be sure to let us know at &lt;a href=&quot;https://twitter.com/appsignal&quot;&gt;@AppSignal&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Concurrency Deep Dive: Event loops</title>
    <link rel="alternate" href="https://blog.appsignal.com/2017/06/06/ruby-magic-concurrency-event-loop.html">
    <id>https://blog.appsignal.com/2017/06/06/ruby-magic-concurrency-event-loop.html</id>
    <published>2017-06-06T00:00:00+00:00</published>
    <updated>2017-06-06T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">A deep dive into achieving concurrency using an event loop.</summary>
    <content type="html">&lt;p&gt;Welcome to the last Ruby Magic article in our series about concurrency. In the previous editions we implemented a chat server &lt;a href=&quot;/2017/03/07/ruby-magic-concurrency-processes.html&quot;&gt;using multiple processes&lt;/a&gt; and &lt;a href=&quot;/2017/04/18/ruby-magic-concurrency-threads.html&quot;&gt;multiple threads&lt;/a&gt;. This time we&amp;#39;re going to do the same thing using an event loop.&lt;/p&gt;
&lt;h2 id=&quot;recap&quot;&gt;Recap&lt;/h2&gt;
&lt;p&gt;We&amp;#39;re going to use the same client and the same server setup we used in the earlier articles. Our aim is to build a chat system that looks like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2017-03/chat_example.png&quot; alt=&quot;Chat example&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Please see the previous articles for more details on the basic setup. The &lt;a href=&quot;https://github.com/thijsc/three-chat-servers&quot;&gt;full source code that is used in the examples in this article&lt;/a&gt; is available on GitHub, so you can experiment with it yourself.&lt;/p&gt;
&lt;h2 id=&quot;chat-server-using-an-event-loop&quot;&gt;Chat server using an event loop&lt;/h2&gt;
&lt;p&gt;Using an event loop for our chat server requires you to have a different mental model than using threads or processes. In the classic approach, a thread or process is responsible for handling a single connection. Using an event loop you have a single thread in a single process that handles multiple connections. Let&amp;#39;s see how this works by breaking it down.&lt;/p&gt;
&lt;h2&gt;Event loop&lt;/h2&gt;

&lt;p&gt;
  An event loop used by EventMachine or NodeJS for example works as follows. We
  start with informing the operating system we're interested in certain events.
  For example, when a connection to a socket is opened. We do this by calling a
  function that registers interest on some IO object, such as a connection or
  socket.
&lt;/p&gt;

&lt;p&gt;
  When something happens on this IO object, the operating system sends an event
  to our program. We put these events on a queue. The event loop keeps popping
  events off the list and handles them one by one.
&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/2016-02/event-loops.svg&quot; alt=&quot;Event Loops&quot;/&gt;&lt;/p&gt;
&lt;p&gt;
  In a sense an event loop is not truly concurrent. It works sequentially in
  very small batches to simulate the effect.
&lt;/p&gt;

&lt;p&gt;To register interest and have the operating system pass IO events to us we&amp;#39;d have to write a C extension, as there is no API present for that in the Ruby standard library. Diving into that is outside of the scope of this article, so we&amp;#39;re going to use &lt;code&gt;IO.select&lt;/code&gt; instead to generate events. &lt;code&gt;IO.select&lt;/code&gt; takes an array of &lt;code&gt;IO&lt;/code&gt; objects to monitor. It waits until one or more of the objects from the array are ready for reading or writing, and it returns an array with just those &lt;code&gt;IO&lt;/code&gt; objects.&lt;/p&gt;
&lt;p&gt;The code that takes care of everything related to a connection is implemented as a &lt;code&gt;Fiber&lt;/code&gt;: we&amp;#39;ll call this code the &amp;quot;handler&amp;quot; from now on. A &lt;code&gt;Fiber&lt;/code&gt; is a code block that can be paused and resumed. The Ruby VM doesn&amp;#39;t do this automatically, so we have to resume and yield manually. We&amp;#39;ll use the input from &lt;code&gt;IO.select&lt;/code&gt; to inform our handlers when their connections are ready for reading or writing.&lt;/p&gt;
&lt;p&gt;Like in the threaded and multi-process examples from the previous posts, we need some storage to keep track of the clients and the messages that are sent. We don&amp;#39;t need a &lt;code&gt;Mutex&lt;/code&gt; this time. Our event loop is running in a single thread, so there is no risk of objects being mutated at the same time by different threads.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;client_handlers = {}
messages = []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The client handler is implemented in the following &lt;code&gt;Fiber&lt;/code&gt;. When the socket can be read from or written to, an event is triggered to which the &lt;code&gt;Fiber&lt;/code&gt; responds. When the state is &lt;code&gt;:readable&lt;/code&gt; it reads a line from the socket and pushes this onto the &lt;code&gt;messages&lt;/code&gt; array. When the state is &lt;code&gt;:writable&lt;/code&gt; it writes any messages that have been received from other clients since the last write to the client. After handling an event it calls &lt;code&gt;Fiber.yield&lt;/code&gt;, so it will pause and wait for the next event.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def create_client_handler(nickname, socket)
  Fiber.new do
    last_write = Time.now
    loop do
      state = Fiber.yield

      if state == :readable
        # Read a message from the socket
        incoming = read_line_from(socket)
        # All good, add it to the list to write
        $messages.push(
          :time =&amp;gt; Time.now,
          :nickname =&amp;gt; nickname,
          :text =&amp;gt; incoming
        )
      elsif state == :writable
        # Write messages to the socket
        get_messages_to_send(last_write, nickname, $messages).each do |message|
          socket.puts &amp;quot;#{message[:nickname]}: #{message[:text]}&amp;quot;
        end
        last_write = Time.now
      end
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So how do we trigger the &lt;code&gt;Fiber&lt;/code&gt; to read or write at the right time when the &lt;code&gt;Socket&lt;/code&gt; is ready? We use an event loop that has four steps:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;loop do
  # Step 1: Accept incoming connections
  accept_incoming_connections

  # Step 2: Get connections that are ready for reading or writing
  get_ready_connections

  # Step 3: Read from readable connections
  read_from_readable_connections

  # Step 4: Write to writable connections
  write_to_writable_connections
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Notice that there is no magic here. This is a normal Ruby loop.&lt;/p&gt;
&lt;h3 id=&quot;step-1-accept-incoming-connections&quot;&gt;Step 1: Accept incoming connections&lt;/h3&gt;
&lt;p&gt;See if we have any new incoming connections. We use &lt;code&gt;accept_nonblock&lt;/code&gt;, which will not wait for a client to connect. It will instead raise an error if there is no new client, and if that error occurs we catch it and go to the next step. If there is a new client we create the handler for it and put that on the &lt;code&gt;clients&lt;/code&gt; store. We&amp;#39;ll use the socket object as the key of that &lt;code&gt;Hash&lt;/code&gt; so we can find the client handler later.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;begin
  socket = server.accept_nonblock
  nickname = socket.gets.chomp
  $client_handlers[socket] = create_client_handler(nickname, socket)
  puts &amp;quot;Accepted connection from #{nickname}&amp;quot;
rescue IO::WaitReadable, Errno::EINTR
  # No new incoming connections at the moment
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;step-2-get-connections-that-are-ready-for-reading-or-writing&quot;&gt;Step 2: Get connections that are ready for reading or writing&lt;/h3&gt;
&lt;p&gt;Next, we ask the OS to inform us when a connection is ready. We pass in the keys of the &lt;code&gt;client_handlers&lt;/code&gt; store for reading, writing and error handling. These keys are the socket objects we accepted in step 1. We wait for 10 milliseconds for this to happen.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;readable, writable = IO.select(
  $client_handlers.keys,
  $client_handlers.keys,
  $client_handlers.keys,
  0.01
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;step-3-read-from-readable-connections&quot;&gt;Step 3: Read from readable connections&lt;/h3&gt;
&lt;p&gt;If any of our connections are readable, we&amp;#39;ll trigger the client handlers and resume them with a &lt;code&gt;readable&lt;/code&gt; state. We can look up these client handlers because the &lt;code&gt;Socket&lt;/code&gt; object that is returned by &lt;code&gt;IO.select&lt;/code&gt; is used as the key of the handlers store.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;if readable
  readable.each do |ready_socket|
    # Get the client from storage
    client = $client_handlers[ready_socket]

    client.resume(:readable)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;step-4-write-to-writable-connections&quot;&gt;Step 4: Write to writable connections&lt;/h3&gt;
&lt;p&gt;If any of our connections are writable, we&amp;#39;ll trigger the client handlers and resume them with a &lt;code&gt;writable&lt;/code&gt; state.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;if writable
  writable.each do |ready_socket|
    # Get the client from storage
    client = $client_handlers[ready_socket]
    next unless client

    client.resume(:writable)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By using these four steps in a loop which creates handlers, and calling &lt;code&gt;readable&lt;/code&gt; and &lt;code&gt;writable&lt;/code&gt; on these handlers at the right time, we have created a fully functional evented chat server. There&amp;#39;s very little overhead per connection, and we could scale this up to a large number of concurrent clients.&lt;/p&gt;
&lt;p&gt;This approach works very well as long as we keep the amount of work per tick of the loop small. This is especially important for work that involves calculations, since an event loop runs in a single thread and thus can only utilize a single CPU. In production systems there are often multiple processes running an event loop to work around this limitation.&lt;/p&gt;
&lt;h2 id=&quot;concluding&quot;&gt;Concluding&lt;/h2&gt;
&lt;p&gt;After all this you might ask, which of these three methods should I use?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For most apps, threading makes sense. It&amp;#39;s the simplest approach to work with.&lt;/li&gt;
&lt;li&gt;If you run highly concurrent apps with long-running streams, event loops allow you to scale.&lt;/li&gt;
&lt;li&gt;If you expect your processes to crash, go for good old multi-process, as it&amp;#39;s the most robust approach.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This concludes our series on concurrency. If you want a full recap &lt;a href=&quot;/2016/03/17/ruby-magic-mastering-concurrency.html&quot;&gt;check the original mastering concurrency article&lt;/a&gt; as well as the detailed articles on &lt;a href=&quot;/2017/03/07/ruby-magic-concurrency-processes.html&quot;&gt;using multiple processes&lt;/a&gt; and &lt;a href=&quot;/2017/04/18/ruby-magic-concurrency-threads.html&quot;&gt;multiple threads&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Concurrency Deep Dive: Multi-threading</title>
    <link rel="alternate" href="https://blog.appsignal.com/2017/04/18/ruby-magic-concurrency-threads.html">
    <id>https://blog.appsignal.com/2017/04/18/ruby-magic-concurrency-threads.html</id>
    <published>2017-04-18T00:00:00+00:00</published>
    <updated>2017-04-18T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">A deep dive into achieving concurrency using threads.</summary>
    <content type="html">&lt;p&gt;In the previous edition of Ruby Magic we showed how you can &lt;a href=&quot;/2017/03/07/ruby-magic-concurrency-processes.html&quot;&gt;implement a chat system using multiple processes&lt;/a&gt;. This time we&amp;#39;ll show you how you can do the same thing using multiple threads.&lt;/p&gt;
&lt;h2 id=&quot;quick-recap&quot;&gt;Quick recap&lt;/h2&gt;
&lt;p&gt;If you want to get a full explanation of the basic setup check out the
&lt;a href=&quot;/2017/03/07/ruby-magic-concurrency-processes.html&quot;&gt;previous article&lt;/a&gt;. But to remind you quickly: this is what our chat system looks like:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2017-03/chat_example.png&quot; alt=&quot;Chat example&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We&amp;#39;re using the same client we used earlier:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# client.rb
# $ ruby client.rb
require &amp;#39;socket&amp;#39;
client = TCPSocket.open(ARGV[0], 2000)

Thread.new do
  while line = client.gets
    puts line.chop
  end
end

while input = STDIN.gets.chomp
  client.puts input
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The basic setup for the server is the same:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# server_threads.rb
# $ ruby server_threads.rb
require &amp;#39;socket&amp;#39;

puts &amp;#39;Starting server on port 2000&amp;#39;

server = TCPServer.open(2000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/thijsc/three-chat-servers&quot;&gt;full source code that is used in the examples in this article&lt;/a&gt; is available on GitHub, so you can experiment with it yourself.&lt;/p&gt;
&lt;h2 id=&quot;multi-threaded-chat-server&quot;&gt;Multi-threaded chat server&lt;/h2&gt;
&lt;p&gt;Now we&amp;#39;re getting to the part that is different compared to the
multi-process implementation. Using &lt;strong&gt;Multi-threading&lt;/strong&gt; we can do multiple things at the same time
with just one Ruby process. We will do this by spawning multiple threads that do the work.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;Threads&lt;/h2&gt;

  &lt;p&gt;
    A thread runs independently, executing code within a process. Multiple
threads can live in the same process and they can share memory.

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;/images/blog/2017-04/threads.png&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
  &lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;Some storage will be needed to store the incoming chat messages. We&amp;#39;ll be using a plain &lt;code&gt;Array&lt;/code&gt;, but we also need a &lt;code&gt;Mutex&lt;/code&gt; to make sure that only one thread changes the messages at the same time (we&amp;#39;ll see how the &lt;code&gt;Mutex&lt;/code&gt; works in a bit).&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;mutex = Mutex.new
messages = []
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next up we start a loop in which we&amp;#39;ll accept incoming connections from chat clients. Once a connection has been established, we&amp;#39;ll spawn a thread to handle the incoming and outgoing messages from that client connection.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Thread.new&lt;/code&gt; call blocks until &lt;code&gt;server.accept&lt;/code&gt; returns something, and then
yields the following block in the newly created thread. The code in the thread then proceeds to read the first line that&amp;#39;s sent and stores this as the nickname. Finally it starts sending and reading messages.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;loop do
  Thread.new(server.accept) do |socket|
    nickname = read_line_from(socket)

    # Send incoming message (coming up)

    # Read incoming messages (coming up)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;Mutex&lt;/h2&gt;

  &lt;p&gt;A mutex is an object that lets multiple threads coordinate how they
use shared resources, such as an array. A thread can indicate that it
needs access, and during this time other threads cannot access the shared
resource.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;The server reads incoming messages from the socket. It uses &lt;code&gt;synchronize&lt;/code&gt; to get a lock on
the messages store, so it can safely add a message to the messages &lt;code&gt;Array&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Read incoming messages
while incoming = read_line_from(socket)
  mutex.synchronize do
    messages.push(
      :time =&amp;gt; Time.now,
      :nickname =&amp;gt; nickname,
      :text =&amp;gt; incoming
    )
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, a &lt;code&gt;Thread&lt;/code&gt; is spawned that runs continuously in a loop, to make sure all the new messages that have been received by the server are being sent to the client. Again it gets a lock so it knows that other threads are not interfering. After it&amp;#39;s done with a tick of the loop it sleeps for a bit and then continues.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Send incoming message
Thread.new do
  sent_until = Time.now
  loop do
    messages_to_send = mutex.synchronize do
      get_messages_to_send(nickname, messages, sent_until).tap do
        sent_until = Time.now
      end
    end
    messages_to_send.each do |message|
      socket.puts &amp;quot;#{message[:nickname]}: #{message[:text]}&amp;quot;
    end
    sleep 0.2
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;Global interpreter lock&lt;/h2&gt;

  &lt;p&gt;
    You might have heard the story that Ruby cannot do &quot;real&quot; threading
    because of &lt;a href=&quot;https://en.wikipedia.org/wiki/Global_interpreter_lock&quot;&gt;Ruby's Global Interpreter Lock (GIL)&lt;/a&gt;. This is partially true. The
GIL is a lock around the execution of all Ruby code and prevents a
Ruby process from using multiple CPUs concurrently. IO operations (such as the network connections we used in this article) operate outside of the GIL, which means you can actually achieve decent concurrency in this case.
  &lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;concluding&quot;&gt;Concluding&lt;/h2&gt;
&lt;p&gt;Now we have a chat server running within a single process using a
thread per connection. This will use a lot less resources than the
multi-process implementation. If you want to see the details of the code
or try it &lt;a href=&quot;https://github.com/thijsc/three-chat-servers&quot;&gt;you can find the example code here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the &lt;a href=&quot;/2017/06/06/ruby-magic-concurrency-event-loop.html&quot;&gt;final article&lt;/a&gt; in this series we&amp;#39;ll implement this same chat server
using a single thread and an event loop. Theoretically this should even
use less resources than the thread implementation!&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Concurrency Deep Dive: Multi-process</title>
    <link rel="alternate" href="https://blog.appsignal.com/2017/03/07/ruby-magic-concurrency-processes.html">
    <id>https://blog.appsignal.com/2017/03/07/ruby-magic-concurrency-processes.html</id>
    <published>2017-03-07T00:00:00+00:00</published>
    <updated>2017-03-07T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">A deep dive into achieving concurrency using multi-process.</summary>
    <content type="html">&lt;p&gt;In a previous Ruby Magic &lt;a href=&quot;/2016/03/17/ruby-magic-mastering-concurrency.html&quot;&gt;article on Mastering Concurrency&lt;/a&gt;, we gave an introduction to the three methods of achieving concurrency that are available to us as Ruby developers. This article is the first in a three-part series where we take a deep dive into each method.&lt;/p&gt;
&lt;p&gt;First up: &lt;strong&gt;Multi-process&lt;/strong&gt;. With this method a master process forks itself to multiple worker processes. The worker process does the actual work, while the master manages the workers.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/thijsc/three-chat-servers&quot;&gt;full source code that is used in the examples in this article&lt;/a&gt; is available on GitHub, so you can experiment with it yourself.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;lets-build-a-chat-system&quot;&gt;Let&amp;#39;s build a chat system!&lt;/h2&gt;
&lt;p&gt;Building a chat system is a good way to dive into concurrency. We&amp;#39;ll need a server component of a chat system that&amp;#39;s able to maintain connections with multiple clients. This will allow us to distribute the messages it receives from one client to all the other connected clients.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2017-03/chat_example.png&quot; alt=&quot;Chat example&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Our chat server is running in the left tab. There are two chat clients running in the right tabs. Any message that is sent by a client will be received by all other clients.&lt;/p&gt;
&lt;h2 id=&quot;the-chat-client&quot;&gt;The chat client&lt;/h2&gt;
&lt;p&gt;This article focuses on the chat server, but to communicate with it we&amp;#39;ll need a chat client first. The following code will be our very simple client. (A &lt;a href=&quot;https://github.com/thijsc/three-chat-servers/blob/master/client.rb&quot;&gt;more complete example&lt;/a&gt; can be found on GitHub.)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# client.rb
# $ ruby client.rb
require &amp;#39;socket&amp;#39;
client = TCPSocket.open(ARGV[0], 2000)

Thread.new do
  while line = client.gets
    puts line.chop
  end
end

while input = STDIN.gets.chomp
  client.puts input
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The client opens a TCP connection to a server running on port 2000. When connected, it spawns a thread that will &lt;code&gt;puts&lt;/code&gt; anything the server sends, so the chat is visible in the terminal output. Finally, there&amp;#39;s a while loop that sends any line you type to the server, which it will send to all other connected clients.&lt;/p&gt;
&lt;h2 id=&quot;the-chat-server&quot;&gt;The chat server&lt;/h2&gt;
&lt;p&gt;In this example a client connects to a chat server in order to communicate with other clients. For all three concurrency approaches we will use the same TCP server from Ruby&amp;#39;s standard library.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# server_processes.rb
# $ ruby server_processes.rb
require &amp;#39;socket&amp;#39;

puts &amp;#39;Starting server on port 2000&amp;#39;

server = TCPServer.open(2000)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Up to this point the code is the same for all three concurrency models. The chat server in every model will then need to handle two scenarios:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Accept new connections from clients.&lt;/li&gt;
&lt;li&gt;Receive messages from clients and send them to all the other clients.&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;a-multi-process-chat-server&quot;&gt;A multi-process chat server&lt;/h1&gt;
&lt;p&gt;To handle these two scenarions with a multi-process chat server, we will be spawning a process per client connection. This process will handle all the messages being sent and received for that client. We can create these processes by forking the original server process.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;Forking processes&lt;/h2&gt;

  &lt;p&gt;When you call the &lt;a href=&quot;http://ruby-doc.org/core-2.4.0/Kernel.html#method-i-fork&quot;&gt;fork method&lt;/a&gt;, it creates a copy of the current process with the exact same state that the process is in.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;A forked process has its own process id, and will be visible separately in a tool like &lt;code&gt;top&lt;/code&gt; or Activity Monitor. That looks something like this:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2016-02/multi-process.svg&quot; alt=&quot;Multiple processes&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The process you start with is called the master process, and the processes that are forked out of the master process are called worker processes.&lt;/p&gt;
&lt;p&gt;Since these newly forked worker processes are truly separate processes, we cannot share memory between them and the master process. We need something to communicate between them.&lt;/p&gt;
&lt;div className=&quot;header ruby_magic&quot;&gt;
  &lt;h2&gt;Unix pipes&lt;/h2&gt;

  &lt;p&gt;To communicate between processes we will use Unix pipes. A Unix pipe sets up a two-way stream of bytes between two processes, and you can use it to to send data from one process to the other. Luckily, Ruby offers a nice wrapper around these pipes so we don't need to re-invent the wheel.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;In the following example we set up a pipe in Ruby –with a reading and a writing end– and we &lt;code&gt;fork&lt;/code&gt; the master process. The code within the block that&amp;#39;s passed to &lt;code&gt;fork&lt;/code&gt; is running in the forked process. The original process continues after this block. We then write a message to the original process from the forked one.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;reader, writer = IO.pipe

fork do
  # This is running in the forked process.
  writer.puts &amp;#39;Hello from the forked process&amp;#39;
end

# This is running in the original process, it will puts the
# message from the forked process.
puts reader.gets
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using pipes we can communicate between separate processes even though the processes are completely isolated from each other.&lt;/p&gt;
&lt;h1 id=&quot;the-chat-servers-implementation&quot;&gt;The chat server&amp;#39;s implementation&lt;/h1&gt;
&lt;p&gt;First we set up an array to keep track of the pipes for all clients and their &amp;quot;writers&amp;quot; (the writing end of the pipe), so we can communicate with the clients. Then we make sure that all incoming messages from the clients are sent to all the other clients.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;client_writers = []
master_reader, master_writer = IO.pipe

write_incoming_messages_to_child_processes(master_reader, client_writers)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can find &lt;a href=&quot;https://github.com/thijsc/three-chat-servers/blob/master/lib/processes.rb#L3-L11&quot;&gt;the implementation of &lt;code&gt;write_incoming_messages_to_child_processes&lt;/code&gt;&lt;/a&gt; on GitHub if you want to see the details of how it operates.&lt;/p&gt;
&lt;h3 id=&quot;accepting-new-connections&quot;&gt;Accepting new connections&lt;/h3&gt;
&lt;p&gt;We will need to accept incoming connections and set up the pipes. The new writer will be pushed onto the &lt;code&gt;client_writers&lt;/code&gt; array. The main process will be able to loop through the array and send a message to each worker process by writing to its pipe.&lt;/p&gt;
&lt;p&gt;We then fork the master process, and the code within the forked worker process will handle the client connection.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;loop do
  while socket = server.accept
    # Create a client reader and writer so that the master
    # process can write messages back to us.
    client_reader, client_writer = IO.pipe

    # Put the client writer on the list of writers so the
    # master process can write to them.
    client_writers.push(client_writer)

    # Fork child process, everything in the fork block
    # only runs in the child process.
    fork do
      # Handle connection
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;handling-client-connections&quot;&gt;Handling client connections&lt;/h3&gt;
&lt;p&gt;We also need to handle the client connection.&lt;/p&gt;
&lt;p&gt;The forked process starts by getting the nickname from the client (&lt;a href=&quot;https://github.com/thijsc/three-chat-servers/blob/master/client.rb#L19&quot;&gt;the client sends the nickname by default&lt;/a&gt;). After that it starts a thread in &lt;code&gt;write_incoming_messages_to_client&lt;/code&gt; that &lt;a href=&quot;https://github.com/thijsc/three-chat-servers/blob/master/lib/processes.rb#L15&quot;&gt;listens for messages from the main process&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Finally, the forked process starts a loop that listens for incoming messages and sends them to the master process. The master process makes sure the other worker process receive the message.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;nickname = read_line_from(socket)
puts &amp;quot;#{Process.pid}: Accepted connection from #{nickname}&amp;quot;

write_incoming_messages_to_client(nickname, client_reader, socket)

# Read incoming messages from the client.
while incoming = read_line_from(socket)
  master_writer.puts &amp;quot;#{nickname}: #{incoming}&amp;quot;
end

puts &amp;quot;#{Process.pid}: Disconnected #{nickname}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;a-working-chat-system&quot;&gt;A working chat system&lt;/h2&gt;
&lt;p&gt;Now the whole chat system works! But as you can see, writing a program that uses multiprocessing is quite complex and uses a lot of resources. The upside is that it&amp;#39;s very robust. If one of the child processes crashes the rest of the system just keeps working. You can try that by &lt;a href=&quot;https://github.com/thijsc/three-chat-servers&quot;&gt;running the example code&lt;/a&gt; and running &lt;code&gt;kill -9 &amp;lt;process-id&amp;gt;&lt;/code&gt; on one of the processes (you can find the process id in the server&amp;#39;s log output).&lt;/p&gt;
&lt;p&gt;In the &lt;a href=&quot;/2017/04/18/ruby-magic-concurrency-threads.html&quot;&gt;next article&lt;/a&gt; we&amp;#39;ll implement the same chat system only using threads, so we can run a server with the same features using just one process and less memory.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Running Rack: How Ruby HTTP servers run Rails apps</title>
    <link rel="alternate" href="https://blog.appsignal.com/2017/01/24/ruby-magic-building-a-ruby-http-server-part-2-running-a-rails-app.html">
    <id>https://blog.appsignal.com/2017/01/24/ruby-magic-building-a-ruby-http-server-part-2-running-a-rails-app.html</id>
    <published>2017-01-24T00:00:00+00:00</published>
    <updated>2017-01-24T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">After starting work on a simple HTTP server a while back, we're diving back in to learn how to handle POST requests and what we need to do to serve a Rails application.</summary>
    <content type="html">&lt;p&gt;&lt;em&gt;In the Ruby Magic series we love to take software apart to learn how it functions under the hood. It&amp;#39;s all about the process; the end result isn&amp;#39;t something you&amp;#39;d use in production, we learn about the internal workings of the Ruby language and its popular libraries. We publish a new article about once a month, so be sure to &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to our newsletter&lt;/a&gt; if you&amp;#39;re into this sort of thing too.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;In an earlier edition of Ruby Magic we &lt;a href=&quot;/2016/11/23/ruby-magic-building-a-30-line-http-server-in-ruby.html&quot;&gt;implemented a 30-line HTTP server in Ruby&lt;/a&gt;. Without having to write a lot of code, we were able to handle HTTP GET requests and serve a simple Rack application. This time, we&amp;#39;ll take our home made server a bit further. When we&amp;#39;re done, we&amp;#39;ll have a web server that can serve Rails&amp;#39; famous fifteen minute blog that allows you to create, update and delete posts.&lt;/p&gt;
&lt;h2 id=&quot;where-we-left-off&quot;&gt;Where we left off&lt;/h2&gt;
&lt;p&gt;Last time, we implemented just enough of a server to have it serve &lt;a href=&quot;https://github.com/rack/rack/blob/master/lib/rack/lobster.rb&quot;&gt;Rack::Lobster&lt;/a&gt; as an example application.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Our implementation opened a TCP server and waited for a request to come in.&lt;/li&gt;
&lt;li&gt;When that happened, the request-line (&lt;code&gt;GET /?flip=left HTTP/1.1\r\n&lt;/code&gt;) was parsed to get the request method (&lt;code&gt;GET&lt;/code&gt;), the path (&lt;code&gt;/&lt;/code&gt;), and the query parameters (&lt;code&gt;flip=left&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The request method, the path and the query string were passed to the Rack app, which returned a triplet with a status, some response headers and the response body.&lt;/li&gt;
&lt;li&gt;Using those, we were able to build an HTTP response to send back to the browser, before closing the connection to wait for a new request to come in.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# http_server.rb
require &amp;#39;socket&amp;#39;
require &amp;#39;rack&amp;#39;
require &amp;#39;rack/lobster&amp;#39;

app = Rack::Lobster.new
server = TCPServer.new 5678

#1
while session = server.accept
  request = session.gets
  puts request

  #2
  method, full_path = request.split(&amp;#39; &amp;#39;)
  path, query = full_path.split(&amp;#39;?&amp;#39;)

  #3
  status, headers, body = app.call({
    &amp;#39;REQUEST_METHOD&amp;#39; =&amp;gt; method,
    &amp;#39;PATH_INFO&amp;#39; =&amp;gt; path,
    &amp;#39;QUERY_STRING&amp;#39; =&amp;gt; query
  })

  #4
  session.print &amp;quot;HTTP/1.1 #{status}\r\n&amp;quot;
  headers.each do |key, value|
    session.print &amp;quot;#{key}: #{value}\r\n&amp;quot;
  end
  session.print &amp;quot;\r\n&amp;quot;
  body.each do |part|
    session.print part
  end
  session.close
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We&amp;#39;ll be continuing with the code we wrote last time. If you want to follow along, here&amp;#39;s the &lt;a href=&quot;https://gist.github.com/jeffkreeftmeijer/7f08d1f7e381b9c552666750914925eb&quot;&gt;code we ended up with&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;rack-and-rails&quot;&gt;Rack and Rails&lt;/h2&gt;
&lt;p&gt;Ruby frameworks like Rails and Sinatra are built on top of the Rack interface. Just like the instance of &lt;code&gt;Rack::Lobster&lt;/code&gt; we&amp;#39;re using to test our server right now, Rails&amp;#39; &lt;code&gt;Rails.application&lt;/code&gt; is a Rack application object. In theory, this would mean that our server should already be able to serve a Rails application.&lt;/p&gt;
&lt;p&gt;To test that, I&amp;#39;ve prepared &lt;a href=&quot;https://github.com/jeffkreeftmeijer/wups&quot;&gt;a simple Rails application&lt;/a&gt;. Let&amp;#39;s clone that into the same directory as our server.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ls
http_server.rb
$ git clone https://github.com/jeffkreeftmeijer/wups.git blog
Cloning into &amp;#39;blog&amp;#39;...
remote: Counting objects: 162, done.
remote: Compressing objects: 100% (112/112), done.
remote: Total 162 (delta 32), reused 162 (delta 32), pack-reused 0
Receiving objects: 100% (162/162), 29.09 KiB | 0 bytes/s, done.
Resolving deltas: 100% (32/32), done.
Checking connectivity... done.
$ ls
blog           http_server.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then, in our server, require the Rails application&amp;#39;s environment file instead of &lt;code&gt;rack&lt;/code&gt; and &lt;code&gt;rack/lobster&lt;/code&gt;, and put the &lt;code&gt;Rails.application&lt;/code&gt; in the &lt;code&gt;app&lt;/code&gt; variable instead of &lt;code&gt;Rack::Lobster.new&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# http_server.rb
require &amp;#39;socket&amp;#39;
require_relative &amp;#39;blog/config/environment&amp;#39;

app = Rails.application
server = TCPServer.new 5678
# ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Starting the server (&lt;code&gt;ruby http_server.rb&lt;/code&gt;) and opening &lt;a href=&quot;http://localhost:5678&quot;&gt;http://localhost:5678&lt;/a&gt; shows us we&amp;#39;re not quite there yet. The server doesn&amp;#39;t crash, but we&amp;#39;re greeted with an internal server error in the browser.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2017-01/500.png&quot; alt=&quot;500 Internal Server Error. If you are the administrator of this website, then please read this web application&amp;#39;s log file and/or the web server&amp;#39;s log file to find out what went wrong.&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Checking our server&amp;#39;s logs, we can see that we&amp;#39;re missing something called &lt;code&gt;rack.input&lt;/code&gt;. It turns out that we&amp;#39;ve been lazy while implementing our server last time, so there&amp;#39;s more work to do before we can get this Rails application to work.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ruby http_server.rb
GET / HTTP/1.1
Error during failsafe response: Missing rack.input
  ...
  http_server.rb:15:in `&amp;lt;main&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;the-rack-environment&quot;&gt;The Rack environment&lt;/h2&gt;
&lt;p&gt;Back when we implemented our server, we glossed over &lt;a href=&quot;http://www.rubydoc.info/github/rack/rack/file/SPEC#The_Environment&quot;&gt;the Rack environment&lt;/a&gt; and ignored most of the variables that are required to properly serve Rack applications. We ended up only implementing the &lt;code&gt;REQUEST_METHOD&lt;/code&gt;, &lt;code&gt;PATH_INFO&lt;/code&gt;, and &lt;code&gt;QUERY_STRING&lt;/code&gt; variables, as those were sufficient for our simple Rack app.&lt;/p&gt;
&lt;p&gt;As we&amp;#39;ve already seen from the exception when we tried to start our new application, Rails needs &lt;code&gt;rack.input&lt;/code&gt;, which is used as an input stream for raw HTTP POST data. Besides that, there are some more variables we need to pass, like the server&amp;#39;s port number, and the request cookie data.&lt;/p&gt;
&lt;p&gt;Luckily, Rack provides &lt;a href=&quot;https://github.com/rack/rack/blob/master/lib/rack/lint.rb&quot;&gt;&lt;code&gt;Rack::Lint&lt;/code&gt;&lt;/a&gt; to help make sure all variables in the Rack environment are present and valid. We can use it to test our server by wrapping our Rails app in it by calling &lt;code&gt;Rack::Lint.new&lt;/code&gt; and passing the &lt;code&gt;Rails.application&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# http_server.rb
require &amp;#39;socket&amp;#39;
require_relative &amp;#39;blog/config/environment&amp;#39;

app = Rack::Lint.new(Rails.application)
server = TCPServer.new 5678
# ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Rack::Lint&lt;/code&gt; will throw an exception when a variable in the environment is missing or invalid. Right now, starting our server again and opening &lt;a href=&quot;http://localhost:5678&quot;&gt;http://localhost:5678&lt;/a&gt; will crash the server and &lt;code&gt;Rack::Lint&lt;/code&gt; will notify us of the first error: the &lt;code&gt;SERVER_NAME&lt;/code&gt; variable wasn&amp;#39;t set.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;~/Appsignal/http-server (master) $ ruby http_server.rb
GET / HTTP/1.1
/Users/jeff/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/rack-2.0.1/lib/rack/lint.rb:20:in `assert&amp;#39;: env missing required key SERVER_NAME (Rack::Lint::LintError)
        ...
        from http_server.rb:15:in `&amp;lt;main&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By fixing each error that is thrown at us, we can keep adding variables until &lt;code&gt;Rack::Lint&lt;/code&gt; stops crashing our server. Let&amp;#39;s go over each of the variables &lt;code&gt;Rack::Lint&lt;/code&gt; requires.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SERVER_NAME&lt;/code&gt;: the server&amp;#39;s hostname. We&amp;#39;re only running this server locally right now, so we&amp;#39;ll use &amp;quot;localhost&amp;quot;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SERVER_PORT&lt;/code&gt;: the port our server is running on. We&amp;#39;ve hardcoded the port number (5678), so we&amp;#39;ll just pass that to the Rack environment.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rack.version&lt;/code&gt;: the targeted Rack &lt;em&gt;protocol&lt;/em&gt; version number as an array of integers. &lt;a href=&quot;https://github.com/rack/rack/blob/master/lib/rack.rb#L14&quot;&gt;&lt;code&gt;[1,3]&lt;/code&gt;&lt;/a&gt; at the time of writing.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rack.input&lt;/code&gt;: the input stream containing the raw HTTP post data. We&amp;#39;ll get to this later, but we&amp;#39;ll pass an empty &lt;code&gt;StringIO&lt;/code&gt; instance (with an ASCII-8BIT encoding) for now.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rack.errors&lt;/code&gt;: the error stream for &lt;code&gt;Rack::Logger&lt;/code&gt; to write to. We&amp;#39;re using &lt;code&gt;$stderr&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rack.multithread&lt;/code&gt;: our server is single-threaded, so this can be set to &lt;code&gt;false&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rack.multiprocess&lt;/code&gt;: our server is running in a single process, so this can be set to &lt;code&gt;false&lt;/code&gt; as well.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rack.run_once&lt;/code&gt;: our server can handle multiple sequential requests in one process, so this is &lt;code&gt;false&lt;/code&gt; too.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rack.url_scheme&lt;/code&gt;: no SSL support, so this can be set to &amp;quot;http&amp;quot; instead of &amp;quot;https&amp;quot;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After adding all missing variables, &lt;code&gt;Rack::Lint&lt;/code&gt; will notify us of one more problem in our environment.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ruby http_server.rb
GET / HTTP/1.1
/Users/jeff/.rbenv/versions/2.4.0/lib/ruby/gems/2.4.0/gems/rack-2.0.1/lib/rack/lint.rb:20:in `assert&amp;#39;: env variable QUERY_STRING has non-string value nil (Rack::Lint::LintError)
        ...
        from http_server.rb:18:in `&amp;lt;main&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When there&amp;#39;s no query string in the request, we&amp;#39;ll now pass &lt;code&gt;nil&lt;/code&gt; as the &lt;code&gt;QUERY_STRING&lt;/code&gt;, which is not allowed. In that case, Rack expects an empty string instead. After implementing the missing variables and updating the query string, this is what our environment looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# http_server.rb
# ...
  method, full_path = request.split(&amp;#39; &amp;#39;)
  path, query = full_path.split(&amp;#39;?&amp;#39;)

  input = StringIO.new
  input.set_encoding &amp;#39;ASCII-8BIT&amp;#39;

  status, headers, body = app.call({
    &amp;#39;REQUEST_METHOD&amp;#39; =&amp;gt; method,
    &amp;#39;PATH_INFO&amp;#39; =&amp;gt; path,
    &amp;#39;QUERY_STRING&amp;#39; =&amp;gt; query || &amp;#39;&amp;#39;,
    &amp;#39;SERVER_NAME&amp;#39; =&amp;gt; &amp;#39;localhost&amp;#39;,
    &amp;#39;SERVER_PORT&amp;#39; =&amp;gt; &amp;#39;5678&amp;#39;,
    &amp;#39;rack.version&amp;#39; =&amp;gt; [1,3],
    &amp;#39;rack.input&amp;#39; =&amp;gt; input,
    &amp;#39;rack.errors&amp;#39; =&amp;gt; $stderr,
    &amp;#39;rack.multithread&amp;#39; =&amp;gt; false,
    &amp;#39;rack.multiprocess&amp;#39; =&amp;gt; false,
    &amp;#39;rack.run_once&amp;#39; =&amp;gt; false,
    &amp;#39;rack.url_scheme&amp;#39; =&amp;gt; &amp;#39;http&amp;#39;
  })

  session.print &amp;quot;HTTP/1.1 #{status}\r\n&amp;quot;
# ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Restarting the server and visiting &lt;a href=&quot;http://localhost:5678&quot;&gt;http://localhost:5678&lt;/a&gt; again, we&amp;#39;ll be greeted with Rails&amp;#39; &amp;quot;You&amp;#39;re on Rails!&amp;quot;-page, meaning we&amp;#39;re now running an actual Rails application on our home made server!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2017-01/youre-on-rails.png&quot; alt=&quot;Yay! You&amp;#39;re on Rails!&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;parsing-http-post-bodies&quot;&gt;Parsing HTTP POST bodies&lt;/h2&gt;
&lt;p&gt;This application is more than just that index page. Visiting &lt;a href=&quot;http://localhost:5678/posts&quot;&gt;http://localhost:5678/posts&lt;/a&gt; will display an empty list of posts. If we try to create a new post by filling in the new post form and pressing &amp;quot;Create post&amp;quot;, we&amp;#39;re greeted by an &lt;code&gt;ActionController::InvalidAuthenticityToken&lt;/code&gt; exception.&lt;/p&gt;
&lt;p&gt;The authenticity token is sent along when posting a form and is used to check if the request came from a trusted source. Our server is completely ignoring POST data right now, so the token isn&amp;#39;t sent, and the request can&amp;#39;t be verified.&lt;/p&gt;
&lt;p&gt;Back when we first implemented our HTTP server, we used &lt;code&gt;session.gets&lt;/code&gt; to get the first line (called the &lt;a href=&quot;https://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.1&quot;&gt;Request-Line&lt;/a&gt;), and parsed the HTTP method and path from that. Besides parsing the Request-Line, we ignored the rest of the request.&lt;/p&gt;
&lt;p&gt;To be able to extract the POST data, we&amp;#39;ll first need to understand how an HTTP request is structured. Looking at an example, we can see that the structure resembles an HTTP response:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;POST /posts HTTP/1.1\r\n
Host: localhost:5678\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n
Accept-Encoding: gzip, deflate\r\n
Accept-Language: en-us\r\n
Content-Type: application/x-www-form-urlencoded\r\n
Origin: http://localhost:5678\r\n
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_1) AppleWebKit/602.2.14 (KHTML, like Gecko) Version/10.0.1 Safari/602.2.14\r\n
Cookie: _wups_session=LzE0Z2hSZFNseG5TR3dEVEwzNE52U0lFa0pmVGlQZGtZR3AveWlyMEFvUHRPeXlQUzQ4L0xlKzNLVWtqYld2cjdiWkpmclZIaEhJd1R6eDhaZThFbVBlN2p6QWpJdllHL2F4Z3VseUZ6NU1BRTU5Y1crM2lLRVY0UzdSZkpwYkt2SGFLZUQrYVFvaFE0VjZmZlIrNk5BPT0tLUpLTHQvRHQ0T3FycWV0ZFZhVHZWZkE9PQ%3D%3D--4ef4508c936004db748da10be58731049fa190ee\r\n
Connection: keep-alive\r\n
Upgrade-Insecure-Requests: 1\r\n
Referer: http://localhost:5678/posts/new\r\n
Content-Length: 369\r\n
\r\n
utf8=%E2%9C%93&amp;amp;authenticity_token=3fu7e8v70K0h9o%2FGNiXxaXSVg3nZ%2FuoL60nlhssUEHpQRz%2BM4ZIHjQduQMexvXrNoC2pjmhNPI4xNNA0Qkh5Lg%3D%3D&amp;amp;post%5Btitle%5D=My+first+post&amp;amp;post%5Bcreated_at%281i%29%5D=2017&amp;amp;post%5Bcreated_at%282i%29%5D=1&amp;amp;post%5Bcreated_at%283i%29%5D=23&amp;amp;post%5Bcreated_at%284i%29%5D=18&amp;amp;post%5Bcreated_at%285i%29%5D=47&amp;amp;post%5Bbody%5D=It+works%21&amp;amp;commit=Create+Post
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Much like a response, an HTTP request consists of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A Request-Line (&lt;code&gt;POST /posts HTTP/1.1\r\n&lt;/code&gt;), consisting of a method token (&lt;code&gt;POST&lt;/code&gt;), a request URI (&lt;code&gt;/posts/&lt;/code&gt;), and the HTTP version (&lt;code&gt;HTTP/1.1&lt;/code&gt;), followed by a CRLF (a carriage return: \r, followed by line feed: \n) to indicate the end of the line&lt;/li&gt;
&lt;li&gt;Header lines (&lt;code&gt;Host: localhost:5678\r\n&lt;/code&gt;). The header key, followed by a colon, then the value, and a CRLF.&lt;/li&gt;
&lt;li&gt;A newline (or a double CRLF) to separate the request line and headers from the body: (&lt;code&gt;\r\n\r\n&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The URL encoded POST body&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After using &lt;code&gt;session.gets&lt;/code&gt; to take the first line of the request (the Request-Line), we&amp;#39;re left with some header lines and a body. To get the header lines, we need to retrieve lines from the session until we find a newline (&lt;code&gt;\r\n&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;For each header line, we&amp;#39;ll split on the first colon. Everything before the colon is the key, and everything after is the value. We &lt;code&gt;#strip&lt;/code&gt; the value to remove the newline from the end.&lt;/p&gt;
&lt;p&gt;To know how many bytes we need to read from the request to get the body, we use the &amp;quot;Content-Length&amp;quot; header, which the browser automatically includes when sending a request.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# http_server.rb
# ...
  headers = {}
  while (line = session.gets) != &amp;quot;\r\n&amp;quot;
    key, value = line.split(&amp;#39;:&amp;#39;, 2)
    headers[key] = value.strip
  end

  body = session.read(headers[&amp;quot;Content-Length&amp;quot;].to_i)
# ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, instead of sending an empty object, we&amp;#39;ll send a &lt;code&gt;StringIO&lt;/code&gt; instance with the body we received via the request. Also, since we&amp;#39;re now parsing the cookies from the request&amp;#39;s header, we can add them to the Rack environment in the &lt;code&gt;HTTP_COOKIE&lt;/code&gt; variable to pass the request authenticity check.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# http_server.rb
# ...
  status, headers, body = app.call({
    # ...
    &amp;#39;REMOTE_ADDR&amp;#39; =&amp;gt; &amp;#39;127.0.0.1&amp;#39;,
    &amp;#39;HTTP_COOKIE&amp;#39; =&amp;gt; headers[&amp;#39;Cookie&amp;#39;],
    &amp;#39;rack.version&amp;#39; =&amp;gt; [1,3],
    &amp;#39;rack.input&amp;#39; =&amp;gt; StringIO.new(body),
    &amp;#39;rack.errors&amp;#39; =&amp;gt; $stderr,
    # ...
  })
# ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There we go. If we restart the server and try to submit the form again, you&amp;#39;ll see that we successfully created the first post on our blog!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2017-01/first-post.png&quot; alt=&quot;Post was successfully created.&quot;/&gt;&lt;/p&gt;
&lt;p&gt;We seriously upgraded our web server this time. Instead of just accepting GET requests from a Rack app, we&amp;#39;re now serving a complete Rails app that handles POST requests. And we still haven&amp;#39;t written more than fifty lines of code in total!&lt;/p&gt;
&lt;p&gt;If you want to play around with our new and improved server, &lt;a href=&quot;https://gist.github.com/jeffkreeftmeijer/43d46bca63de648436d6018c73bd436b&quot;&gt;here&amp;#39;s the code&lt;/a&gt;. Let us know at &lt;a href=&quot;https://twitter.com/appsignal&quot;&gt;@AppSignal&lt;/a&gt; if you want to know more, or have a specific question.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Escaping characters in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2016/12/21/ruby-magic-escaping-in-ruby.html">
    <id>https://blog.appsignal.com/2016/12/21/ruby-magic-escaping-in-ruby.html</id>
    <published>2016-12-21T00:00:00+00:00</published>
    <updated>2016-12-21T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Escaping characters in Ruby can be quite confusing. In this post we'll cover the power of the backslash symbol <code>\</code> and how you can use it.</summary>
    <content type="html">&lt;p&gt;In this post we&amp;#39;re going to be talking about escaping characters in Ruby. We&amp;#39;ll learn how to escape characters, how it works, and how to avoid escaping altogether for some use cases. If you think you know all about the &lt;code&gt;\ &lt;/code&gt;, make sure to read it all and be surprised...&lt;/p&gt;
&lt;p&gt;Let&amp;#39;s dive right in with character escaping in strings.&lt;/p&gt;
&lt;h2 id=&quot;escaping-quotes&quot;&gt;Escaping quotes&lt;/h2&gt;
&lt;p&gt;When using strings in Ruby, we sometimes need to put the quote we used to define the string inside the string itself.
When we do, we can escape the quote character with a backslash &lt;code&gt;\ &lt;/code&gt; symbol.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# Escape quotes in double quoted strings
&amp;quot;Hello \&amp;quot;world\&amp;quot;!&amp;quot;
=&amp;gt; &amp;quot;Hello \&amp;quot;world\&amp;quot;!&amp;quot;

# Escape quotes in single quoted strings
&amp;#39;Hello \&amp;#39;world\&amp;#39;!&amp;#39;
=&amp;gt; &amp;quot;Hello &amp;#39;world&amp;#39;!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we can see that Ruby defaults to double quoted strings for output and only escapes those double quotes in the output.&lt;/p&gt;
&lt;h2 id=&quot;escape-sequences&quot;&gt;Escape sequences&lt;/h2&gt;
&lt;p&gt;Besides quotes, there are more symbols we can escape in strings. For example, a newline is represented by &lt;code&gt;\n&lt;/code&gt;. This is called an &amp;quot;escape sequence&amp;quot;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;quot;Hello\nworld&amp;quot;
=&amp;gt; &amp;quot;Hello\nworld&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What gets returned is the same string as we created, but as you can see the &lt;code&gt;\n&lt;/code&gt; is highlighted, indicating it&amp;#39;s an escape sequence. If we would now print this string we see that the literal &lt;code&gt;\n&lt;/code&gt; is not printed, but an actual newline is printed instead.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;puts &amp;quot;Hello\nworld&amp;quot;
=&amp;gt; Hello
world
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This doesn&amp;#39;t work in single quoted strings. The &lt;code&gt;\n&lt;/code&gt; sequence is interpreted as a literal &lt;code&gt;\n&lt;/code&gt;. In double quoted strings you would have to escape the backslash symbol to accomplish the same result.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;#39;\n&amp;#39;
=&amp;gt; &amp;quot;\\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Examples of &lt;a href=&quot;https://en.wikipedia.org/wiki/Escape_sequences_in_C&quot;&gt;other escape sequences&lt;/a&gt; that work the same way are: &lt;code&gt;\t&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt; and &lt;code&gt;\b&lt;/code&gt;, which represent a tab, a space and a backspace respectively.&lt;/p&gt;
&lt;header className=&quot;ruby_magic&quot;&gt;
  &lt;h2&gt;Single quotes &lt;strike&gt;vs&lt;/strike&gt; and double quotes&lt;/h2&gt;
  &lt;p&gt;The difference between single and double quoted strings in Ruby is the way the string definitions represent escape sequences.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    In &lt;strong&gt;double&lt;/strong&gt; quoted strings, you can write escape sequences
    and Ruby will output their translated meaning. A &lt;code&gt;\n&lt;/code&gt; becomes a
    newline.
  &lt;/li&gt;
  &lt;li&gt;
    In &lt;strong&gt;single&lt;/strong&gt; quoted strings however, escape sequences are
    escaped and return their literal definition. A &lt;code&gt;\n&lt;/code&gt; remains a{&quot; &quot;}
    &lt;code&gt;\n&lt;/code&gt;.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
  Both string types have their use cases of course. It's likely you'll use
  double quoted strings with escape sequences to use their translated meaning, a
  newline or a tab.
&lt;/p&gt;

  &lt;p&gt;Single quotes are useful for avoiding escaping escape sequences themselves. Useful for demonstrating their usage or avoiding accidentally using escape sequences you didn't intent to.&lt;/p&gt;
&lt;/header&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;puts &amp;quot;Line 1\nLine 2&amp;quot;
=&amp;gt; Line 1
Line 2

puts &amp;#39;Using a \n we can indicate a newline.&amp;#39;
=&amp;gt; Using a \n we can indicate a newline.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;escaping-interpolation&quot;&gt;Escaping interpolation&lt;/h2&gt;
&lt;p&gt;Ruby supports interpolation inside strings. But once again, not all string definitions are created equal. Interpolation only works in double quoted strings.&lt;/p&gt;
&lt;p&gt;In the code example below we see that interpolation works in a double quoted string, but that Ruby escapes the interpolation sequence in a single quoted string, rendering it useless.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;name = &amp;quot;world&amp;quot;

&amp;quot;Hello #{name}&amp;quot;
=&amp;gt; &amp;quot;Hello world&amp;quot;

&amp;#39;Hello #{name}&amp;#39;
=&amp;gt; &amp;quot;Hello \#{name}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This behavior applies to almost every kind of string &amp;quot;magic&amp;quot;. Double quotes support it, single quotes don&amp;#39;t.&lt;/p&gt;
&lt;header className=&quot;ruby_magic&quot;&gt;
  &lt;h2&gt;Percent notation for String&lt;/h2&gt;
  &lt;p&gt;The &lt;a href=&quot;https://en.wikibooks.org/wiki/Ruby_Programming/Syntax/Literals#The_.25_Notation&quot;&gt;percent notation&lt;/a&gt; in Ruby is something inspired by the Perl programming language and gives us many shorthands for some common type definitions.&lt;/p&gt;

&lt;p&gt;
  The same behavior for single and double quoted strings applies to the percent
  notation as well.
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;code&gt;%()&lt;/code&gt; and &lt;code&gt;%Q()&lt;/code&gt; behave the same way as a double
    quoted string.
  &lt;/li&gt;
  &lt;li&gt;
    &lt;code&gt;%q()&lt;/code&gt; behaves the same way as a single quoted string.
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
  The problem with the percent notation is that you now need to escape the
  parenthesis characters &lt;code&gt;()&lt;/code&gt; instead of the quotes when the
  parenthesis aren't balanced.
&lt;/p&gt;

  &lt;p&gt;Which is why Ruby allows you to use other symbols for the percent notation as well: &lt;code&gt;%[foo]&lt;/code&gt;, &lt;code&gt;{`%{foo}`}&lt;/code&gt;, &lt;code&gt;%-foo-&lt;/code&gt;, &lt;code&gt;%?foo?&lt;/code&gt;, etc. It even supports &lt;code&gt;%&quot;foo&quot;&lt;/code&gt; and &lt;code&gt;%'foo'&lt;/code&gt;.&lt;/p&gt;
&lt;/header&gt;

&lt;p&gt;Here we see that Ruby escapes the string for us when using the percent notation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;%(Hello &amp;quot;world&amp;quot;!)
=&amp;gt; &amp;quot;Hello \&amp;quot;world\&amp;quot;&amp;quot;

# With unbalanced parenthesis
%(Hello world\)!)
=&amp;gt; &amp;quot;Hello world)!&amp;quot;

# With balanced parenthesis
%(Hello (world)!)
=&amp;gt; &amp;quot;Hello (world)!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Again, the same rules apply here as with normal single and double quoted strings. Escape sequences and interpolation are escaped by default in single quoted strings.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;name = &amp;quot;world&amp;quot;

%(Hello\n &amp;quot;#{name}&amp;quot;!)
=&amp;gt; &amp;quot;Hello\n \&amp;quot;world\&amp;quot;!&amp;quot;

%q(Hello\n &amp;quot;#{name}&amp;quot;!)
=&amp;gt; &amp;quot;Hello\\n \&amp;quot;\#{name}\&amp;quot;!&amp;quot;

%Q(Hello\n &amp;quot;#{name}&amp;quot;!)
=&amp;gt; &amp;quot;Hello\n \&amp;quot;world\&amp;quot;!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;escaping-characters-in-regular-expressions&quot;&gt;Escaping characters in regular expressions&lt;/h2&gt;
&lt;p&gt;Escaping characters also works in regular expressions. In regular expressions many characters represent more than just their literal definition.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;.&lt;/code&gt; is a wild card for any character, brackets &lt;code&gt;[]&lt;/code&gt; represent a range or a selection, parenthesis &lt;code&gt;()&lt;/code&gt; match an expression, etc. To use their literal definitions we can also escape them with the backslash symbol.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;/Hello \[world\]/
=&amp;gt; /Hello \[world\]/

/\[world\]/ =~ &amp;quot;Hello [world]&amp;quot;
=&amp;gt; 6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we didn&amp;#39;t escape the brackets, it would instead look for any of the characters between the brackets and find the first match in the character &lt;code&gt;l&lt;/code&gt; in &amp;quot;Hello&amp;quot; on position 3.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;/[world]/ =~ &amp;quot;Hello [world]&amp;quot;
=&amp;gt; 2 # zero index
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To avoid having to escape the forward slash symbol &lt;code&gt;/&lt;/code&gt;, used to define the regular expression, we can use another percent notation.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;%r{/world/}
=&amp;gt; /\/world\//
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using &lt;code&gt;%r{}&lt;/code&gt; we can define a regular expression where we don&amp;#39;t have to escape the forward slash. In the result we can see that Ruby escapes the forward slash for us.&lt;/p&gt;
&lt;h2 id=&quot;escaping-line-breaks&quot;&gt;Escaping line breaks&lt;/h2&gt;
&lt;p&gt;Previously we escaped the &amp;quot;newline&amp;quot; escape sequence &lt;code&gt;\n&lt;/code&gt; in a string in Ruby. Did you know you can also escape a line break in Ruby itself?&lt;/p&gt;
&lt;p&gt;For example, we have a very long line for a method call and this breaks our code style guide&amp;#39;s max line length.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ruby_method_with_many_arguments &amp;quot;Hello world&amp;quot;, split: &amp;quot; &amp;quot;, join: &amp;quot;\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can place the arguments on separate lines to make each individual line shorter. This works as long as the previous line ends with a comma &lt;code&gt;,&lt;/code&gt;, operators like the plus symbol &lt;code&gt;+&lt;/code&gt;, or is part of a method call wrapped in parenthesis &lt;code&gt;()&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ruby_method_with_many_arguments &amp;quot;Hello world&amp;quot;,
  split: &amp;quot; &amp;quot;,
  join: &amp;quot;\n&amp;quot;

ruby_method_with_many_arguments(
  &amp;quot;Hello world&amp;quot;,
  split: &amp;quot; &amp;quot;,
  join: &amp;quot;\n&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If instead we&amp;#39;d want to align all arguments on the same indentation level without wrapping it in parenthesis &lt;code&gt;()&lt;/code&gt; we can use a backslash &lt;code&gt;\ &lt;/code&gt; to escape the line break.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;ruby_method_with_many_arguments \
  my_string,
  split: &amp;quot; &amp;quot;,
  join: &amp;quot;\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;What we do here is not really telling Ruby to escape the newline, but that the statement will continue on the next line.&lt;/p&gt;
&lt;h2 id=&quot;escaping-line-breaks-in-string-definitions&quot;&gt;Escaping line breaks in string definitions&lt;/h2&gt;
&lt;p&gt;Escaping the line ending also works for things like string definitions. Normally if we have a multi-line string we can use the plus symbol &lt;code&gt;+&lt;/code&gt; to combine the strings on the two lines.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;quot;foo&amp;quot; +
  &amp;quot;bar&amp;quot;
=&amp;gt; &amp;quot;foobar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This creates two strings on two lines and then combines as one. So it really creates three string objects.&lt;/p&gt;
&lt;p&gt;Instead of using a plus symbol, we can escape the line break with a backslash again.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;&amp;quot;foo&amp;quot; \
  &amp;quot;bar&amp;quot;
=&amp;gt; &amp;quot;foobar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The result is the same, or is it?&lt;/p&gt;
&lt;p&gt;In the first example we&amp;#39;re actually combining two new strings, while in the second example Ruby will only create one. The Ruby interpreter will see the backslash &lt;code&gt;\ &lt;/code&gt; as a continuation of the string definition and only create one string based on the two lines. So it&amp;#39;s even better for your app&amp;#39;s memory usage.&lt;/p&gt;
&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Escaping characters in Ruby, and many other programming languages, can be quite confusing. Suddenly certain combinations of characters get a different meaning inside a double quoted string compared to being used inside a single quoted string.&lt;/p&gt;
&lt;p&gt;Hopefully this little guide has helped you with understanding how to properly escape characters and sequences in Ruby. The difference between a double and single quoted string is key here.&lt;/p&gt;
&lt;p&gt;The string &amp;quot;magic&amp;quot; of escape sequences and interpolation only really works in double quoted strings, but not in single quoted strings.&lt;/p&gt;
&lt;p&gt;There are also other ways of escaping code in Ruby itself. The percent notation helps us with avoiding to escape certain characters all the time, in strings and regular expressions.&lt;/p&gt;
&lt;p&gt;But the backslash is also very useful for writing multi-line strings and continuing a line of Ruby code on the next line. Something I use a lot to keep my code clean and readable.&lt;/p&gt;
&lt;p&gt;Let us know at &lt;a href=&quot;https://twitter.com/appsignal&quot;&gt;@AppSignal&lt;/a&gt; if you want to know more, or have a specific question about escaping characters in Ruby.&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Fun side-note: for this post, which is written in Markdown, I had to use the backslash symbol quite a lot. Just like in Ruby, Markdown allows escaping of certain characters. Normally in Markdown you can&amp;#39;t really wrap a backslash in a code block as it escapes the code block itself. Instead I had it escape a space instead.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-md&quot;&gt;`\` # Doesn&amp;#39;t work
`\ ` # Works :)
&lt;/code&gt;&lt;/pre&gt;
</content>
  </entry>

  <entry>
    <title>Building a 30 line HTTP server in Ruby</title>
    <link rel="alternate" href="https://blog.appsignal.com/2016/11/23/ruby-magic-building-a-30-line-http-server-in-ruby.html">
    <id>https://blog.appsignal.com/2016/11/23/ruby-magic-building-a-30-line-http-server-in-ruby.html</id>
    <published>2016-11-23T00:00:00+00:00</published>
    <updated>2016-11-23T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Web servers, and HTTP in general, might seem difficult to understand. In this Ruby Magic episode we'll learn how a to build a minimal Ruby HTTP server in 30 lines of code</summary>
    <content type="html">&lt;p&gt;Web servers, and HTTP in general, might seem difficult to understand. How does the browser format a request, and how does the response get sent to the user? In this Ruby Magic episode we&amp;#39;ll learn how a to build a Ruby HTTP server in 30 lines of code. When we&amp;#39;re done, our server will handle HTTP GET requests and we&amp;#39;ll use it to serve a Rack app.&lt;/p&gt;
&lt;h2 id=&quot;how-http-and-tcp-work-together&quot;&gt;How HTTP and TCP work together&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Transmission_Control_Protocol&quot;&gt;TCP&lt;/a&gt; is a transport protocol that describes how a server and a client exchange data.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol&quot;&gt;HTTP&lt;/a&gt; is a request-response protocol that specifically describes how web servers exchange data with HTTP clients or web browsers. HTTP commonly uses TCP as its transport protocol. In essence, an HTTP server is a TCP server that &amp;quot;speaks&amp;quot; HTTP.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# tcp_server.rb
require &amp;#39;socket&amp;#39;
server = TCPServer.new 5678

while session = server.accept
  session.puts &amp;quot;Hello world! The time is #{Time.now}&amp;quot;
  session.close
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example of a TCP server, the server binds to port &lt;code&gt;5678&lt;/code&gt; and waits for a client to connect. When that happens, it sends a message to the client, and then closes the connection. After it&amp;#39;s done talking to the first client, the server waits for another client to connect to send its message to again.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# tcp_client.rb
require &amp;#39;socket&amp;#39;
server = TCPSocket.new &amp;#39;localhost&amp;#39;, 5678

while line = server.gets
  puts line
end

server.close
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To connect to our server, we&amp;#39;ll need a TCP client. This example client connects to the same port (&lt;code&gt;5678&lt;/code&gt;) and uses &lt;code&gt;server.gets&lt;/code&gt; to receive data from the server, which is then printed. When it stops receiving data, it closes the connection to the server and the program will exit.&lt;/p&gt;
&lt;p&gt;When you start the server server is running (&lt;code&gt;$ ruby tcp_server.rb&lt;/code&gt;), you can start the client in a separate tab to receive the server&amp;#39;s message.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ruby tcp_client.rb
Hello world! The time is 2016-11-23 15:17:11 +0100
$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With a bit of imagination, our TCP server and client work somewhat like a web server and a browser. The client sends a request, the server responds, and the connection is closed. That&amp;#39;s how the &lt;a href=&quot;https://en.wikipedia.org/wiki/Request%E2%80%93response&quot;&gt;request-response pattern&lt;/a&gt; works, which is exactly what we need to build an HTTP server.&lt;/p&gt;
&lt;p&gt;Before we get to the good part, let&amp;#39;s look at what HTTP requests and responses look like.&lt;/p&gt;
&lt;h2 id=&quot;a-basic-http-get-request&quot;&gt;A basic HTTP GET request&lt;/h2&gt;
&lt;p&gt;The most basic &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-5&quot;&gt;HTTP GET request&lt;/a&gt; is a &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-5.1&quot;&gt;request-line&lt;/a&gt; without any additional headers or a request body.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1\r\n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The Request-Line consists of four parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A method token (&lt;code&gt;GET&lt;/code&gt;, in this example)&lt;/li&gt;
&lt;li&gt;The Request-URI (&lt;code&gt;/&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The protocol version (&lt;code&gt;HTTP/1.1&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;A CRLF (a carriage return: &lt;code&gt;\r&lt;/code&gt;, followed by line feed: &lt;code&gt;\n&lt;/code&gt;) to indicate the end of the line&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The server will respond with an &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-6&quot;&gt;HTTP response&lt;/a&gt;, which may look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP/1.1 200\r\nContent-Type: text/html\r\n\r\n\Hello world!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This response consists of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A status line: the protocol version (&amp;quot;HTTP/1.1&amp;quot;), followed by a space, the response&amp;#39;s status code (&amp;quot;200&amp;quot;), and terminated with a CRLF (&lt;code&gt;\r\n&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Optional header lines. In this case, there&amp;#39;s only one header line (&amp;quot;Content-Type: text/html&amp;quot;), but there could be multiple (separated with with a CRLF: &lt;code&gt;\r\n&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;A newline (or a double CRLF) to separate the status line and header from the body: (&lt;code&gt;\r\n\r\n&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The body: &amp;quot;Hello world!&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;a-minimal-ruby-http-server&quot;&gt;A Minimal Ruby HTTP server&lt;/h2&gt;
&lt;p&gt;Enough talk. Now that we know how to create a TCP server in Ruby and what some HTTP requests and responses look like, we can build a minimal HTTP server. You&amp;#39;ll notice that the web server looks mostly the same as the TCP server we discussed earlier. The general idea is the same, we&amp;#39;re just using the HTTP protocol to format our message. Also, because we&amp;#39;ll use a browser to send requests and parse responses, we won&amp;#39;t have to implement a client this time.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# http_server.rb
require &amp;#39;socket&amp;#39;
server = TCPServer.new 5678

while session = server.accept
  request = session.gets
  puts request

  session.print &amp;quot;HTTP/1.1 200\r\n&amp;quot; # 1
  session.print &amp;quot;Content-Type: text/html\r\n&amp;quot; # 2
  session.print &amp;quot;\r\n&amp;quot; # 3
  session.print &amp;quot;Hello world! The time is #{Time.now}&amp;quot; #4

  session.close
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After the server receives a request, like before, it uses &lt;code&gt;session.print&lt;/code&gt; to send a message back to the client: Instead of just our message, it prefixes the response with a status line, a header and a newline:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The status line (&lt;code&gt;HTTP 1.1 200\r\n&lt;/code&gt;) to tell the browser that the HTTP version is 1.1 and the response code is &amp;quot;200&amp;quot;&lt;/li&gt;
&lt;li&gt;A header to indicate that the response has a text/html content type (&lt;code&gt;Content-Type: text/html\r\n&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The newline (&lt;code&gt;\r\n&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The body: &amp;quot;Hello world! …&amp;quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Like before, it closes the connection after sending the message. We&amp;#39;re not reading the request yet, so it just prints it to the console for now.&lt;/p&gt;
&lt;p&gt;If you start the server and open &lt;a href=&quot;http://localhost:5678&quot;&gt;http://localhost:5678&lt;/a&gt; in your browser, you should see the &amp;quot;Hello world! …&amp;quot;-line with the current time, like we received from our TCP client earlier. 🎉&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2016-11/http_server.png&quot; alt=&quot;Our minimal Ruby HTTP server returning our &amp;quot;Hello world&amp;quot;-line&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;serving-a-rack-app&quot;&gt;Serving a Rack app&lt;/h2&gt;
&lt;p&gt;Until now, our server has been returning a single response for each request. To make it a little more useful, we could add more responses to our server. Instead of adding these to the server directly, we&amp;#39;ll use a &lt;a href=&quot;http://rack.github.io&quot;&gt;Rack&lt;/a&gt; app. Our server will parse HTTP requests and pass them to the Rack app, which will then return a response for the server to send back to the client.&lt;/p&gt;
&lt;p&gt;Rack is an interface between web servers that support Ruby and most Ruby web frameworks like Rails and Sinatra. In its simplest form, a Rack app is an object that responds to &lt;code&gt;call&lt;/code&gt; and returns a &amp;quot;tiplet&amp;quot;, an array with three items: an HTTP response code, a hash of HTTP headers and a body.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;app = Proc.new do |env|
  [&amp;#39;200&amp;#39;, {&amp;#39;Content-Type&amp;#39; =&amp;gt; &amp;#39;text/html&amp;#39;}, [&amp;quot;Hello world! The time is #{Time.now}&amp;quot;]]
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, the response code is &amp;quot;200&amp;quot;, we&amp;#39;re passing &amp;quot;text/html&amp;quot; as the content type through the headers, and the body is an array with a string.&lt;/p&gt;
&lt;p&gt;To allow our server to serve responses from this app, we&amp;#39;ll need to turn the returned triplet into a HTTP response string. Instead of always returning a static response, like we did before, we&amp;#39;ll now have to build the response from the triplet returned by the Rack app.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# http_server.rb
require &amp;#39;socket&amp;#39;

app = Proc.new do
  [&amp;#39;200&amp;#39;, {&amp;#39;Content-Type&amp;#39; =&amp;gt; &amp;#39;text/html&amp;#39;}, [&amp;quot;Hello world! The time is #{Time.now}&amp;quot;]]
end

server = TCPServer.new 5678

while session = server.accept
  request = session.gets
  puts request

  # 1
  status, headers, body = app.call({})

  # 2
  session.print &amp;quot;HTTP/1.1 #{status}\r\n&amp;quot;

  # 3
  headers.each do |key, value|
    session.print &amp;quot;#{key}: #{value}\r\n&amp;quot;
  end

  # 4
  session.print &amp;quot;\r\n&amp;quot;

  # 5
  body.each do |part|
    session.print part
  end
  session.close
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To serve the response we&amp;#39;ve received from the Rack app, there&amp;#39;s some changes we&amp;#39;ll make to our server:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Get the status code, headers, and body from the triplet returned by &lt;code&gt;app.call&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Use the status code to build the status line&lt;/li&gt;
&lt;li&gt;Loop over the headers and add a header line for each key-value pair in the hash&lt;/li&gt;
&lt;li&gt;Print a newline to separate the status line and headers from the body&lt;/li&gt;
&lt;li&gt;Loop over the body and print each part. Since there&amp;#39;s only one part in our body array, it&amp;#39;ll simply print our &amp;quot;Hello world&amp;quot;-message to the session before closing it.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;reading-requests&quot;&gt;Reading requests&lt;/h2&gt;
&lt;p&gt;Until now, our server has been ignoring the &lt;code&gt;request&lt;/code&gt; variable. We didn&amp;#39;t need to as our Rack app always returned the same response.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Rack::Lobster&lt;/code&gt; is an example app that ships with Rack and uses request URL parameters in order to function. Instead of the Proc we used as an app before, we&amp;#39;ll use that as our testing app from now on.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# http_server.rb
require &amp;#39;socket&amp;#39;
require &amp;#39;rack&amp;#39;
require &amp;#39;rack/lobster&amp;#39;

app = Rack::Lobster.new
server = TCPServer.new 5678

while session = server.accept
# ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Opening the browser will now show a lobster instead of the boring string it printed before. Lobstericious!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/blog/2016-11/http_server_lobster.png&quot; alt=&quot;Our minimal Ruby HTTP server running Rack::Lobster&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The &amp;quot;flip!&amp;quot; and &amp;quot;crash!&amp;quot; links link to &lt;code&gt;/?flip=left&lt;/code&gt; and &lt;code&gt;/?flip=crash&lt;/code&gt; respectively. However, when following the links, the lobster doesn&amp;#39;t flip and nothing crashes just yet. That&amp;#39;s because our server doesn&amp;#39;t handle query strings right now. Remember the &lt;code&gt;request&lt;/code&gt; variable we ignored before? If we look at our server&amp;#39;s logs, we&amp;#39;ll see the request strings for each of the pages.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;GET / HTTP/1.1
GET /?flip=left HTTP/1.1
GET /?flip=crash HTTP/1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The HTTP request strings include the request method (&amp;quot;GET&amp;quot;), the request path (&lt;code&gt;/&lt;/code&gt;, &lt;code&gt;/?flip=left&lt;/code&gt; and &lt;code&gt;/?flip=crash&lt;/code&gt;), and the HTTP version. We can use this information to determine what we need to serve.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# http_server.rb
require &amp;#39;socket&amp;#39;
require &amp;#39;rack&amp;#39;
require &amp;#39;rack/lobster&amp;#39;

app = Rack::Lobster.new
server = TCPServer.new 5678

while session = server.accept
  request = session.gets
  puts request

  # 1
  method, full_path = request.split(&amp;#39; &amp;#39;)
  # 2
  path, query = full_path.split(&amp;#39;?&amp;#39;)

  # 3
  status, headers, body = app.call({
    &amp;#39;REQUEST_METHOD&amp;#39; =&amp;gt; method,
    &amp;#39;PATH_INFO&amp;#39; =&amp;gt; path,
    &amp;#39;QUERY_STRING&amp;#39; =&amp;gt; query
  })

  session.print &amp;quot;HTTP/1.1 #{status}\r\n&amp;quot;
  headers.each do |key, value|
    session.print &amp;quot;#{key}: #{value}\r\n&amp;quot;
  end
  session.print &amp;quot;\r\n&amp;quot;
  body.each do |part|
    session.print part
  end
  session.close
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To parse the request and send the request parameters to the Rack app, we&amp;#39;ll split the request string up and send it to the Rack app:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Split the request string into a method and a full path&lt;/li&gt;
&lt;li&gt;Split the full path into a path and a query&lt;/li&gt;
&lt;li&gt;Pass those to our app in a &lt;a href=&quot;http://www.rubydoc.info/github/rack/rack/file/SPEC#The_Environment&quot;&gt;Rack environment hash&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;For example, a request like &lt;code&gt;GET /?flip=left HTTP/1.1\r\n&lt;/code&gt; will be passed to the app like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;{
  &amp;#39;REQUEST_METHOD&amp;#39; =&amp;gt; &amp;#39;GET&amp;#39;,
  &amp;#39;PATH_INFO&amp;#39; =&amp;gt; &amp;#39;/&amp;#39;,
  &amp;#39;QUERY_STRING&amp;#39; =&amp;gt; &amp;#39;?flip=left&amp;#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Restarting our server, visiting &lt;a href=&quot;http://localhost:5678&quot;&gt;http://localhost:5678&lt;/a&gt;, and clicking the &amp;quot;flip!&amp;quot;-link will now flip the lobster, and clicking the &amp;quot;crash!&amp;quot; link will crash our web server.&lt;/p&gt;
&lt;p&gt;We&amp;#39;ve just scratched the surface of implementing a HTTP server, and ours is only 30 lines of code, but it explains the basic idea. It accepts GET requests, passes the request&amp;#39;s attributes to a Rack app, and sends back responses to the browser. Although it doesn&amp;#39;t handle things like request streaming and POST requests, our server could theoretically be used to serve other Rack apps too.&lt;/p&gt;
&lt;p&gt;This concludes our quick look into building an HTTP server in Ruby. If you want to play around with our server, here&amp;#39;s the &lt;a href=&quot;https://gist.github.com/jeffkreeftmeijer/7f08d1f7e381b9c552666750914925eb&quot;&gt;code&lt;/a&gt;. Let us know at &lt;a href=&quot;https://twitter.com/appsignal&quot;&gt;@AppSignal&lt;/a&gt; if you want to know more, or have a specific question.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;If you enjoyed this article, &lt;a href=&quot;https://blog.appsignal.com/ruby-magic&quot;&gt;subscribe to the Ruby Magic newsletter&lt;/a&gt;: a (roughly) monthly po(r)tion of Ruby.&lt;/em&gt;&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Rescuing Exceptions in Ruby:
A Primer
</title>
    <link rel="alternate" href="https://blog.appsignal.com/2016/10/18/ruby-magic-exceptions-primer.html">
    <id>https://blog.appsignal.com/2016/10/18/ruby-magic-exceptions-primer.html</id>
    <published>2016-10-18T00:00:00+00:00</published>
    <updated>2016-10-18T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Make sure your exception handling is done right. Get up to speed with this Ruby Magic primer and make sure you only rescue the exceptions you need to.</summary>
    <content type="html">&lt;p&gt;At AppSignal we provide &lt;a href=&quot;https://www.appsignal.com/tour/errors&quot;&gt;error tracking&lt;/a&gt; for Ruby applications. To do so, we capture all exceptions applications throw at us and notify developers as they happen.&lt;/p&gt;
&lt;p&gt;It can be difficult to get exception handling right. In this article we&amp;#39;ll explain how it works, what problems bad handling can cause and how to rescue exceptions properly.&lt;/p&gt;
&lt;h2 id=&quot;rescuing-exceptions&quot;&gt;Rescuing exceptions&lt;/h2&gt;
&lt;p&gt;By rescuing exceptions in Ruby you can prevent your application from crashing the moment something goes wrong. With a &lt;code&gt;begin .. rescue&lt;/code&gt; block you can specify an alternative path for your application when an error occurs.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;begin
  File.read &amp;quot;config.yml&amp;quot;
rescue
  puts &amp;quot;No config file found. Using defaults.&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It&amp;#39;s also possible to specify which exceptions should be rescued. When specifying an exception class, all subclasses of this exception will also be captured.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;begin
  File.read &amp;quot;config.yml&amp;quot;
rescue SystemCallError =&amp;gt; e
  puts e.class # =&amp;gt; Errno::ENOENT
  puts e.class.superclass # =&amp;gt; SystemCallError
  puts e.class.superclass.superclass # =&amp;gt; StandardError
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the example above you can see the exception &lt;code&gt;Errno::ENOENT&lt;/code&gt; is caught when its parent &lt;code&gt;SystemCallError&lt;/code&gt; is being rescued.&lt;/p&gt;
&lt;h2 id=&quot;rescuing-too-high-up-in-the-exception-chain&quot;&gt;Rescuing too high up in the exception chain&lt;/h2&gt;
&lt;p&gt;It&amp;#39;s important not to rescue exceptions too high up the &lt;a href=&quot;http://ruby-doc.org/core-2.3.1/Exception.html&quot;&gt;Exception chain&lt;/a&gt;. When you do, all subclassed exceptions will also be caught, making the rescue block&amp;#39;s capture too generic.&lt;/p&gt;
&lt;p&gt;Here&amp;#39;s a program that reads a config file based on the argument passed to the program.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# $ ruby example.rb config.yml
def config_file
  ARGV.firs # Note the typo here, we meant `ARGV.first`.
end

begin
  File.read config_file
rescue
  puts &amp;quot;Couldn&amp;#39;t read the config file&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The error message says it couldn&amp;#39;t read the config file, but the real problem was a typo in the code.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;begin
  File.read config_file
rescue =&amp;gt; e
  puts e.inspect
end
#&amp;lt;NoMethodError: undefined method `firs&amp;#39; for []:Array&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The default exception class caught by a &lt;code&gt;begin .. rescue&lt;/code&gt; block is &lt;a href=&quot;http://ruby-doc.org/core-2.3.1/StandardError.html&quot;&gt;StandardError&lt;/a&gt;. If we don&amp;#39;t pass in a specific class, Ruby will rescue StandardError and all subclassed errors. &lt;a href=&quot;http://ruby-doc.org/core-2.3.1/NoMethodError.html&quot;&gt;NoMethodError&lt;/a&gt; is one of these errors.&lt;/p&gt;
&lt;p&gt;Rescuing a specific exception class will help prevent unrelated errors from accidentally prompting a failure state. It also allows for more specific custom error messages that are more helpful for the end user.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;config_file = &amp;quot;config.yml&amp;quot;
begin
  File.read config_file
rescue Errno::ENOENT =&amp;gt; e
  puts &amp;quot;File or directory #{config_file} doesn&amp;#39;t exist.&amp;quot;
rescue Errno::EACCES =&amp;gt; e
  puts &amp;quot;Can&amp;#39;t read from #{config_file}. No permission.&amp;quot;
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;rescuing-exception&quot;&gt;Rescuing Exception&lt;/h2&gt;
&lt;p&gt;It might still be tempting to rescue high up in the exception chain. Rescuing all errors an application can raise will prevent it from crashing. (100% uptime here we come!) However, it can cause a lot of problems.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;http://ruby-doc.org/core-2.3.1/Exception.html&quot;&gt;Exception&lt;/a&gt; class is the main exception class in Ruby. All other exceptions are subclasses of this class; if Exception is rescued all errors will be caught.&lt;/p&gt;
&lt;p&gt;Two exceptions that most applications won&amp;#39;t want to rescue are are SignalException and SystemExit.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://ruby-doc.org/core-2.3.1/SignalException.html&quot;&gt;SignalException&lt;/a&gt; is used when an outside source is telling the application to stop. This can be the Operating System when it wants to shut down, or a system administrator that wants to stop the application. &lt;a href=&quot;https://gist.github.com/tombruijn/a4181e217b8e1c46ebcc2c116223cb6a&quot;&gt;Example&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://ruby-doc.org/core-2.3.1/SystemExit.html&quot;&gt;SystemExit&lt;/a&gt; is used when &lt;code&gt;exit&lt;/code&gt; is being called from the Ruby application. When this is raised the developer wants the application to stop. &lt;a href=&quot;https://gist.github.com/tombruijn/b75dcd6722d67f7a982fddc23f295b02&quot;&gt;Example&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;If we rescue Exception and these exceptions are raised while an application is currently running the &lt;code&gt;begin ... rescue ... end&lt;/code&gt; block it cannot exit.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It&amp;#39;s generally a bad idea to rescue Exception in normal situations. When rescuing Exception, you&amp;#39;ll prevent SignalException and SystemExit to function, but also &lt;a href=&quot;http://ruby-doc.org/core-2.3.1/LoadError.html&quot;&gt;LoadError&lt;/a&gt;, &lt;a href=&quot;http://ruby-doc.org/core-2.3.1/SyntaxError.html&quot;&gt;SyntaxError&lt;/a&gt; and &lt;a href=&quot;http://ruby-doc.org/core-2.3.1/NoMemoryError.html&quot;&gt;NoMemoryError&lt;/a&gt;, to name a few. It&amp;#39;s better to rescue more specific exceptions instead.&lt;/p&gt;
&lt;h2 id=&quot;failures-in-tests&quot;&gt;Failures in tests&lt;/h2&gt;
&lt;p&gt;When Exception is rescued, using &lt;code&gt;rescue Exception =&amp;gt; e&lt;/code&gt;, other things beside your application could break. The test suite could actually be hiding some errors.&lt;/p&gt;
&lt;p&gt;In &lt;a href=&quot;https://github.com/seattlerb/minitest&quot;&gt;minitest&lt;/a&gt; and &lt;a href=&quot;http://rspec.info/&quot;&gt;RSpec&lt;/a&gt; assertions that fail will raise an exception to inform you about the failed assertion, failing the test. When they do, they raise their own custom exceptions, subclassed from Exception.&lt;/p&gt;
&lt;p&gt;If Exception is rescued in a test or in the application code, it could be silencing an assertion failure.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# RSpec example
def foo(bar)
  bar.baz
rescue Exception =&amp;gt; e
  puts &amp;quot;This test should actually fail&amp;quot;
  # Failure/Error: bar.baz
  #   &amp;lt;Double (anonymous)&amp;gt; received unexpected message :baz with (no args)
end

describe &amp;quot;#foo&amp;quot; do
  it &amp;quot;hides an &amp;#39;unexpected message&amp;#39; exception&amp;quot; do
    bar = double(to_s: &amp;quot;&amp;quot;)
    foo(bar)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;expecting-exceptions&quot;&gt;Expecting exceptions&lt;/h2&gt;
&lt;p&gt;Some code is meant to raise exceptions. In a test suite it&amp;#39;s possible to simply silence the exception in order to have the test not fail when they are raised.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;def foo
  raise RuntimeError, &amp;quot;something went wrong&amp;quot;
end

foo rescue RuntimeError
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, this doesn&amp;#39;t test if an exception was raised or not. When the exception is not raised, your test won&amp;#39;t be able to tell if the behavior is still correct.&lt;/p&gt;
&lt;p&gt;It&amp;#39;s possible to assert if the exception is raised, and if not, which exception was.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;# expecting_exceptions_spec.rb
# RSpec example
def foo
  raise NotImplementedError, &amp;quot;foo method not implemented&amp;quot;
end

describe &amp;quot;#foo&amp;quot; do
  it &amp;quot;raises a RuntimeError&amp;quot; do
    expect { foo }.to raise_error(RuntimeError)
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;1) #foo raises a RuntimeError
   Failure/Error: expect { foo }.to raise_error(RuntimeError)

     expected RuntimeError, got #&amp;lt;NotImplementedError: foo method not implemented&amp;gt; with backtrace:
       # ./expecting_exceptions_spec.rb:4:in `foo&amp;#39;
       # ./expecting_exceptions_spec.rb:9:in `block (3 levels) in &amp;lt;top (required)&amp;gt;&amp;#39;
       # ./expecting_exceptions_spec.rb:9:in `block (2 levels) in &amp;lt;top (required)&amp;gt;&amp;#39;
       # ./expecting_exceptions_spec.rb:9:in `block (2 levels) in &amp;lt;top (required)&amp;gt;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;re-raise-exception&quot;&gt;Re-raise Exception&lt;/h2&gt;
&lt;p&gt;An application should only capture exceptions as high up in the chain as the Exception class when there&amp;#39;s a very good reason. For example, when there&amp;#39;s some cleanup involved before exiting a block of code, like removing temporary files that really need to be removed.&lt;/p&gt;
&lt;p&gt;One recommendation for when you absolutely have to rescue Exception, re-raise it after you&amp;#39;re done handling the error. This way the Ruby exception handling can decide the fate of the process afterward.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;File.open(&amp;quot;/tmp/my_app.status&amp;quot;, &amp;quot;w&amp;quot;) { |f| &amp;quot;running&amp;quot; }

begin
  foo
rescue Exception =&amp;gt; e
  Appsignal.add_error e
  File.open(&amp;quot;/tmp/my_app.status&amp;quot;, &amp;quot;w&amp;quot;) { |f| &amp;quot;stopped&amp;quot; }
  raise e
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;unsure-what-to-rescue&quot;&gt;Unsure what to rescue?&lt;/h2&gt;
&lt;p&gt;As mentioned earlier, it&amp;#39;s good to be specific in what errors to rescue.&lt;/p&gt;
&lt;p&gt;When you&amp;#39;re unsure what exceptions an operation can raise, rescuing &lt;a href=&quot;http://ruby-doc.org/core-2.3.1/StandardError.html&quot;&gt;StandardError&lt;/a&gt; can be a good place to start. Run your code in different scenarios and see what exceptions it raises.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;begin
  File.open(&amp;#39;/tmp/appsignal.log&amp;#39;, &amp;#39;a&amp;#39;) { |f| f.write &amp;quot;Starting AppSignal&amp;quot; }
rescue =&amp;gt; e
  puts e.inspect
end
#&amp;lt;Errno::EACCES: Permission denied @ rb_sysopen - /tmp/appsignal.log&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Every time you come across a new exception, add specific rescue cases for those exceptions or its relevant parent class. It&amp;#39;s better to be specific in what to rescue than to rescue too many exceptions.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;begin
  file = &amp;#39;/tmp/appsignal.log&amp;#39;
  File.open(file, &amp;#39;a&amp;#39;) { |f| f.write(&amp;quot;AppSignal started!&amp;quot;) }
rescue Errno::ENOENT =&amp;gt; e
  puts &amp;quot;File or directory #{file} doesn&amp;#39;t exist.&amp;quot;
rescue Errno::EACCES =&amp;gt; e
  puts &amp;quot;Cannot write to #{file}. No permissions.&amp;quot;
end

# Or, using the parent error class
begin
  file = &amp;#39;/tmp/appsignal.log&amp;#39;
  File.open(file, &amp;#39;a&amp;#39;)
rescue SystemCallError =&amp;gt; e
  puts &amp;quot;Error while writing to file #{file}.&amp;quot;
  puts e
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This concludes our primer on exceptions handling in Ruby. Let us know at &lt;a href=&quot;http://twitter.com/appsignal&quot;&gt;@AppSignal&lt;/a&gt; if you want to know more, or have a specific question. If you want to get a better insight in where and how often exceptions are raised in your app, &lt;a href=&quot;https://www.appsignal.com/&quot;&gt;give AppSignal a try&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Introduction to Garbage Collection (Part II)</title>
    <link rel="alternate" href="https://blog.appsignal.com/2016/07/28/ruby-magic-garbage-collection-part-2.html">
    <id>https://blog.appsignal.com/2016/07/28/ruby-magic-garbage-collection-part-2.html</id>
    <published>2016-07-28T00:00:00+00:00</published>
    <updated>2016-07-28T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">In the previous episode of Ruby Magic we talked about why we need Garbage Collection (GC) and how it works in general. Now we'll dive a bit deeper into how this is implemented in Ruby.</summary>
    <content type="html">&lt;p&gt;In the &lt;a href=&quot;/2016/07/12/ruby-magic-garbage-collection-part-1.html&quot;&gt;previous episode&lt;/a&gt; of Ruby Magic we talked about why we need Garbage Collection (GC) and how it works in general. In this post we&amp;#39;ll dive a bit deeper into how this is implemented in Ruby.&lt;/p&gt;
&lt;h2 id=&quot;different-ruby-implementations&quot;&gt;Different Ruby implementations&lt;/h2&gt;
&lt;p&gt;There are a number of implementations of Ruby. Three popular ones are: MRI (Matz&amp;#39;s Ruby Interpreter), Rubinius and JRuby. Different Ruby implementations use different methods of GC. In this article we&amp;#39;ll focus on MRI, which is what most Ruby developers use.&lt;/p&gt;
&lt;h3 id=&quot;rubys-heap&quot;&gt;Ruby&amp;#39;s heap&lt;/h3&gt;
&lt;p&gt;A computer has two types of memory: Stack and Heap. The stack is very fast and is local to the context of a function call. This means that every variable that is declared in the stack is immediately freed once the function is done. The stack is very limited in size, so you cannot store larger objects that contain an image or file&amp;#39;s data, for example.&lt;/p&gt;
&lt;p&gt;This is a bad fit for storing Ruby objects. These objects very often stick around for longer than a method call. Also, it&amp;#39;s almost impossible to predict whether an object will be too big for the stack.&lt;/p&gt;
&lt;p&gt;Therefore Ruby uses the other type of memory: the heap. On the heap a program can claim some memory and is then responsible for cleanup once it&amp;#39;s done with that memory. Ruby uses this by claiming a single slab of memory to use to store Ruby objects. This is referred to as Ruby&amp;#39;s heap.&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th colSpan={2}&gt;Stack and Heap summary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;Stack memory&lt;/th&gt;
      &lt;td&gt;
        Very fast
        &lt;br /&gt;
        Used memory is freed automatically when the function call ends
        &lt;br /&gt;
        Very limited in size
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;Heap memory&lt;/th&gt;
      &lt;td&gt;
        Slightly slower than stack
        &lt;br /&gt;
        No automatic cleanup
        &lt;br /&gt;
        Size is only limited by the available memory of the computer
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So Ruby objects are always allocated on Ruby&amp;#39;s heap. If they&amp;#39;re smaller than 40 bytes their content can be directly embedded in the object. Otherwise the object points to a separate segment of memory on Ruby&amp;#39;s heap. So your Ruby object is often stored in two completely different locations in memory. Once Ruby&amp;#39;s heap is full it will create a new heap, which is used for new objects.&lt;/p&gt;
&lt;h2 id=&quot;mark-and-sweep&quot;&gt;Mark and Sweep&lt;/h2&gt;
&lt;p&gt;MRI uses a GC algorithm called Mark and Sweep. This operates by first doing a mark phase. In the mark phase the Garbage Collector scans all currently existing objects and sets a marked flag on every object it believes can be cleaned up.&lt;/p&gt;
&lt;p&gt;The mark phase halts the execution of your code. The reason for this is that the Garbage Collector has to understand all the relationships between objects that exist. If the program would be running during the mark process things might change in the meantime and the Garbage Collector wouldn&amp;#39;t be sure what the current state of an object is.&lt;/p&gt;
&lt;p&gt;Secondly the sweep phase starts. This runs in the background on Ruby 1.9 and up. The Garbage Collector quietly frees every object that was marked in the mark phase. The memory is only available again after the sweep.&lt;/p&gt;
&lt;p&gt;Since the mark phase halts the execution of your code, this is where problems in production can occur. The sweep phase is relatively benign.&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th colSpan={2}&gt;Mark and Sweep summary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;Mark phase&lt;/th&gt;
      &lt;td&gt;
        Scans existing objects
        &lt;br /&gt;
        Sets mark flag if object can be cleaned
        &lt;br /&gt;
        Halts code execution
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;Sweep phase&lt;/th&gt;
      &lt;td&gt;
        Runs in the background
        &lt;br /&gt;
        Cleans up marked objects
        &lt;br /&gt;
        Memory available again after sweep is competed
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;major-and-minor-gc-runs&quot;&gt;Major and minor GC runs&lt;/h2&gt;
&lt;p&gt;In Ruby 2.1+ the Garbage Collector does major and minor runs. It keeps track of which objects are new. If an object survives a few GC runs it&amp;#39;s marked as old. Old objects are then ignored in minor runs. This makes the minor runs much less intrusive since the Garbage Collector only has to scan objects that have just been allocated.&lt;/p&gt;
&lt;p&gt;This is useful because often a part of your memory should never be cleaned up. When you boot up Rails it loads the entire Rails framework into memory. That will stay there for the entire lifetime, so it would be a waste of resources to check all these objects every time.&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th colSpan={2}&gt;Major and minor runs&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;Major run&lt;/th&gt;
      &lt;td&gt;
        Runs less often
        &lt;br /&gt;
        More intensive to run
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;Minor run&lt;/th&gt;
      &lt;td&gt;
        Ignores old objects
        &lt;br /&gt;
        Runs more often
        &lt;br /&gt;
        Less intrusive to run
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;for-those-who-want-to-dive-deeper&quot;&gt;For those who want to dive deeper&lt;/h3&gt;
&lt;p&gt;We learned a lot about this from Aman Gupta&amp;#39;s great &lt;a href=&quot;http://tmm1.net/&quot;&gt;blog&lt;/a&gt;. Check that out if you want a deeper dive into this subject.&lt;/p&gt;
&lt;h2 id=&quot;up-next-practical-garbage-collection-tuning&quot;&gt;Up next: Practical Garbage Collection tuning&lt;/h2&gt;
&lt;p&gt;There are a number of metrics you can measure and configuration changes you can make to tune how the Garbage Collector operates. In the next installment of this GC series we will discuss these metrics and configuration parameters.&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Introduction to Garbage Collection (Part I)</title>
    <link rel="alternate" href="https://blog.appsignal.com/2016/07/12/ruby-magic-garbage-collection-part-1.html">
    <id>https://blog.appsignal.com/2016/07/12/ruby-magic-garbage-collection-part-1.html</id>
    <published>2016-07-12T00:00:00+00:00</published>
    <updated>2016-07-12T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Whenever you run your code, you use memory. But you never have to think about how to clear memory again afterwards. How does this work?</summary>
    <content type="html">&lt;p&gt;Whenever you run your code, you use memory. When you write in a language like Ruby, it seems like the memory available to you is infinite. You can just keep going without thinking about the fixed amount of memory the system running your code has. In this Ruby Magic episode we&amp;#39;ll explain how this works!&lt;/p&gt;
&lt;h2 id=&quot;a-bit-of-history&quot;&gt;A bit of history&lt;/h2&gt;
&lt;p&gt;Back in the day, scripting languages such as Ruby did not exist yet. People only wrote code in languages such as C, a low level programming language. One of the things that makes these languages low level is that you have to clean up after yourself. For example, whenever you allocate memory to store a &lt;code&gt;String&lt;/code&gt;, you also have to decide when to clean it up.&lt;/p&gt;
&lt;h3 id=&quot;manual-cleanup&quot;&gt;Manual cleanup&lt;/h3&gt;
&lt;p&gt;This looks a little something like the following mock Ruby code. It declares a variable and uses the method &lt;code&gt;free&lt;/code&gt; –this method does not actually exist in Ruby– to clean up the memory we&amp;#39;ve used after we&amp;#39;re done with the variable.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ruby 1_000_000.times do |i| variable = &amp;quot;Variable #{i}&amp;quot; puts variable free(variable) end &lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;a-tedious-way-of-programming&quot;&gt;A tedious way of programming&lt;/h3&gt;
&lt;p&gt;You might have already realized there&amp;#39;s a risk here: what if you forget to{&amp;quot; &amp;quot;} &lt;code&gt;free&lt;/code&gt; the variable? In that case the content of that variable will just stick around in memory until the process exits. If you do this often enough, you will be out of memory and your process crashes.&lt;/p&gt;
&lt;p&gt;The next example demonstrates another common issue:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ruby 1_000_000.times do |i| variable = &amp;quot;Variable #{i}&amp;quot; free(variable) puts variable end &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;We declare the variable and &lt;code&gt;free&lt;/code&gt; it. But then we try to use it again, which is impossible because it doesn&amp;#39;t exist anymore. If this were C, your program would now crash with a &lt;code&gt;segfault&lt;/code&gt;. Oops!&lt;/p&gt;
&lt;h3 id=&quot;humans-are-mistake-machines&quot;&gt;Humans are mistake machines&lt;/h3&gt;
&lt;p&gt;Humans are notoriously bad at not making these kinds of mistakes all of the time. Hence the need for a way to automatically clean up memory. The most popular way to do this –also used in Ruby– is Garbage Collection (GC).&lt;/p&gt;
&lt;h2 id=&quot;how-garbage-collection-gc-works&quot;&gt;How Garbage Collection (GC) works&lt;/h2&gt;
&lt;p&gt;In a language that uses GC, you can create objects without manually cleaning them up. Whenever you create an object, it&amp;#39;s registered with the Garbage Collector. GC tries to keep track of all references you make to this object. When it determines you&amp;#39;re not using the object any more, it is marked for cleanup. Every once in a while the Garbage Collector pauses your program and cleans up all the marked objects.&lt;/p&gt;
&lt;h3 id=&quot;looking-at-some-examples&quot;&gt;Looking at some examples&lt;/h3&gt;
&lt;p&gt;In the simple loop we used earlier the GC&amp;#39;s job is fairly easy. With every iteration of the loop, the variable isn&amp;#39;t used anywhere anymore. The variable can immediately be marked for cleanup.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ruby 1_000_000.times do |i| variable = &amp;quot;Variable #{i}&amp;quot; puts variable end &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;In the next example we pass the variable into the &lt;code&gt;puts_later&lt;/code&gt;{&amp;quot; &amp;quot;} method which waits for 30 seconds and then &lt;code&gt;puts&lt;/code&gt; the variable.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ruby def puts_later(variable) Thread.new do sleep 30 puts variable end end 1_000_000.times do |i| variable = &amp;quot;Variable #{i}&amp;quot; puts_later variable end &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The Garbage Collector&amp;#39;s job is already pretty complicated in this relatively simple example. It has to understand that we reference the variable in the{&amp;quot; &amp;quot;} &lt;code&gt;puts_later&lt;/code&gt; method. Because the method starts a thread, the Garbage Collector has to keep track of the thread and wait for it to finish. Only then can the variable can be marked for cleanup.&lt;/p&gt;
&lt;h3 id=&quot;when-it-gets-complicated&quot;&gt;When it gets complicated&lt;/h3&gt;
&lt;p&gt;Without getting into complex examples, trust me when I say the Garbage Collector&amp;#39;s job is really hard. This also explains why GC can cause overhead and problems in your production environment. It needs to have a very detailed understanding of what&amp;#39;s happening in your program to properly clear memory, which takes quite a few CPU cycles to get right. But hey, it beats cleaning up after yourself!&lt;/p&gt;
&lt;h3 id=&quot;theres-more-to-garbage-collection&quot;&gt;There&amp;#39;s more to Garbage Collection&lt;/h3&gt;
&lt;p&gt;This was only our introduction to Garbage Collection. In a future article we&amp;#39;ll look at how exactly this works in Ruby, and how you can measure and tune GC to improve the performance of your application.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; The next episode is available &lt;a href=&quot;/2016/07/28/ruby-magic-garbage-collection-part-2.html&quot;&gt;here&lt;/a&gt; .&lt;/p&gt;
</content>
  </entry>

  <entry>
    <title>Mastering Concurrency</title>
    <link rel="alternate" href="https://blog.appsignal.com/2016/03/17/ruby-magic-mastering-concurrency.html">
    <id>https://blog.appsignal.com/2016/03/17/ruby-magic-mastering-concurrency.html</id>
    <published>2016-03-17T00:00:00+00:00</published>
    <updated>2016-03-17T00:00:00+00:00</updated>
    <author>Roy Tomeij</author>
    <summary type="html">Multiple people will use your app at the same time, and you want to deliver your app as fast as possible. So you'll need some way to handle concurrency. Fear not! Most webservers already do this by default. But when you need to scale, you want to use concurrency in the most efficient way possible.</summary>
    <content type="html">&lt;h2&gt;Mastering concurrency&lt;/h2&gt;
&lt;p&gt;
  Multiple people will use your app at the same time, and you want to deliver
  your app as fast as possible. So you'll need some way to handle concurrency.
  Fear not! Most web servers already do this by default. But when you need to
  scale, you want to use concurrency in the most efficient way possible.
&lt;/p&gt;
&lt;h2&gt;Different types of concurrency&lt;/h2&gt;
&lt;p&gt;
  There are multiple ways to handle concurrency: multi-process, multi-threading
  and event-driven. Each of these have their uses, pros and cons. In this
  article, you'll learn how they differ and when to use which.
&lt;/p&gt;
&lt;header className=&quot;ruby_magic&quot; id=&quot;multi-process&quot;&gt;
  &lt;h2&gt;Multi-process (Unicorn)&lt;/h2&gt;
  &lt;p&gt;
    This is the easiest way to handle concurrency. A master process{&quot; &quot;}
    &lt;a href=&quot;https://en.wikipedia.org/wiki/Fork_(system_call)&quot;&gt;forks&lt;/a&gt; itself
    to multiple worker processes. The worker process handles the actual
    requests, while the master manages the workers.
  &lt;/p&gt;
&lt;/header&gt;

&lt;p&gt;
  Each worker process has the full codebase in memory. This makes this method
  pretty memory-intensive, and makes it hard to scale to larger infrastructures.
&lt;/p&gt;
&lt;table className=&quot;collapse&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th colSpan={2}&gt;Multi-process summary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;Use&amp;nbsp;case&lt;/th&gt;
      &lt;td&gt;
        One non-ruby example you probably know is the{&quot; &quot;}
        &lt;a href=&quot;https://www.google.com/googlebooks/chrome/small_04.html&quot;&gt;
          Chrome browser
        &lt;/a&gt;
        . It uses multi-process concurrency to give each tab their own process. It
        allows a single tab to crash without taking the full application down. In
        their case, it also helps to isolate exploits to a single tab.
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th className=&quot;green&quot;&gt;Pros&lt;/th&gt;
      &lt;td&gt;
        Most simple to implement.
        &lt;br /&gt;
        Ignores difficulties with thread safety.
        &lt;br /&gt;
        Each worker can crash without damaging the rest of the system.
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th className=&quot;red&quot;&gt;Cons&lt;/th&gt;
      &lt;td&gt;
        Each process loads the full codebase in memory. This makes it
        memory-intensive.
        &lt;br /&gt;
        Hence, it does not scale to large amounts of concurrent connections.
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;header className=&quot;ruby_magic&quot; id=&quot;multi-threading&quot;&gt;
  &lt;h2&gt;Multi-threading (Puma)&lt;/h2&gt;
  &lt;p&gt;
    This threading model allows one process to handle multiple requests at the
    same time. It does so by running multiple threads within a single process.
  &lt;/p&gt;
&lt;/header&gt;
&lt;p&gt;
  As opposed to the multi-process approach, all threads run within the same
  process. This means they share data such as global variables. Therefore, only
  small chunks of extra memory are used per thread.
&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/2016-02/threaded.svg&quot; alt=&quot;Threaded&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Global Interpreter Lock&lt;/h3&gt;
&lt;p&gt;
  This brings us to the global interpreter lock (GIL) in MRI. The GIL is a lock
  around the execution of all Ruby code. Even though our threads appear to run
  in parallel, only one thread is active at a time.
&lt;/p&gt;
&lt;p&gt;
  IO operates outside of the GIL. When you execute a database query waiting for
  the result to come back, it won't lock. Another thread will have a chance to
  do some work in the meantime. If you do a lot of math and operations on hashes
  or arrays in threads, you will only utilize a single core if you use MRI. In
  most cases you still need multiple processes to fully utilize your machine. Or
  you could use Rubinius or jRuby, which don't have a GIL.
&lt;/p&gt;
&lt;h3&gt;Thread safety&lt;/h3&gt;
&lt;p&gt;
  If you use multiple threads you have to be careful to write all code that
  manipulates shared data in a thread safe way. You can do this for example by
  using a &lt;a href=&quot;http://ruby-doc.org/core-2.2.0/Mutex.html&quot;&gt;Mutex&lt;/a&gt; to lock
  shared data structures before you manipulate them. This will ensure that other
  threads are not basing their work on stale data while you're changing the
  data.
&lt;/p&gt;
&lt;table className=&quot;collapse&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th colSpan={2}&gt;Multi-threaded summary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;Use&amp;nbsp;case&lt;/th&gt;
      &lt;td&gt;
        This is the &quot;middle of the road&quot; option. Used for a lot of standard web
        applications which should handle loads of short requests (such as a busy
        web application).
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th className=&quot;green&quot;&gt;Pros&lt;/th&gt;
      &lt;td&gt;Uses less memory than multi-process.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th className=&quot;red&quot;&gt;Cons&lt;/th&gt;
      &lt;td&gt;
        You have to make sure your code is thread safe.
        &lt;br /&gt;
        If a thread causes a a crash, it can potentially take down your process.
        &lt;br /&gt;
        The GIL locks all operations except I/O.
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;header className=&quot;ruby_magic&quot; id=&quot;event-driven&quot;&gt;
  &lt;h2&gt;Event-loop (Thin)&lt;/h2&gt;
  &lt;p&gt;
    Event-loops are used when you need to do a lot of concurrent I/O operations.
    The model itself doesn't force multiple requests to be executed at the same
    time, but it is an efficient way to handle a lot of concurrent users.
  &lt;/p&gt;
&lt;/header&gt;
&lt;p&gt;
  Below you'll see a very simple event loop written in Ruby. The loop will take
  the event from the &lt;code&gt;event_queue&lt;/code&gt; and handle it. If there is no
  event, it will sleep and repeat to see if there are new events in the queue.
&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ruby&quot;&gt;loop do
  if event_queue.any?
    handle_event(event_queue.pop)
  else
    sleep 0.1
  end
end
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Illustrated version&lt;/h3&gt;
&lt;p&gt;
  In this illustration, we're taking it a step further. The event loop now does
  a beautiful dance with the OS, queue and some memory.
&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/blog/2016-02/event-loops.svg&quot; alt=&quot;Event loops&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Step by step&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;The OS keeps track of network and disk availability.&lt;/li&gt;
  &lt;li&gt;When the OS sees the I/O is ready, it sends an event to the queue.&lt;/li&gt;
  &lt;li&gt;
    The queue is a list of events from which the event loop takes the top one.
  &lt;/li&gt;
  &lt;li&gt;The event loop handles the event.&lt;/li&gt;
  &lt;li&gt;It uses some memory to store meta data about the connections.&lt;/li&gt;
  &lt;li&gt;
    It can send a new event directly into the event queue again. For example, a
    message to shut down the queue based on the contents of an event.
  &lt;/li&gt;
  &lt;li&gt;
    If it wants to do an I/O operation, it tells the OS that it's interested in
    a specific I/O operation. The OS keeps track of the network and disk (see
    [1]) and adds an event again when I/O is ready.
  &lt;/li&gt;
&lt;/ol&gt;
&lt;table className=&quot;collapse&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th colSpan={2}&gt;Event-loop summary&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th className=&quot;green&quot;&gt;Use&amp;nbsp;case&lt;/th&gt;
      &lt;td&gt;
        When using a lot of concurrent connections to your users. Think of
        services like Slack. Chrome notifications.
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;Pros&lt;/th&gt;
      &lt;td&gt;
        Almost no memory overhead per connection.
        &lt;br /&gt;
        Scales to a huge number of parallel connections.
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th className=&quot;red&quot;&gt;Cons&lt;/th&gt;
      &lt;td&gt;
        It's a difficult mental model to understand.
        &lt;br /&gt;
        Batch sizes must be small and predictable to avoid queues building up.
      &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;header className=&quot;ruby_magic&quot;&gt;
  &lt;h2&gt;Which one should you use?&lt;/h2&gt;
  &lt;p&gt;
    We hope this article has given you a better understanding of the different
    concurrency models. It's some of the more difficult subject matter to grasp
    as a developer, but understanding it will give you the tools to experiment
    and use the right setup for your app.
  &lt;/p&gt;
&lt;/header&gt;
&lt;h3&gt;In summary&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    For most apps threading makes sense, Ruby/Rails ecosystem seems to (slowly)
    be moving this way.
  &lt;/li&gt;
  &lt;li&gt;
    If you run highly concurrent apps with long-running streams, event-loop
    allows you to scale.
  &lt;/li&gt;
  &lt;li&gt;
    If you don't have a high traffic site, or you expect your workers to break
    go for good old multi-process.
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  And, it is possible to run an event loop, inside a thread, inside a
  multi-process setup. So yes, you can have your stroopwafel and eat it too!
&lt;/p&gt;

&lt;p&gt;If you want to read more more about these concurrency models check out our detailed articles on &lt;a href=&quot;/2017/03/07/ruby-magic-concurrency-processes.html&quot;&gt;multi-process&lt;/a&gt;, &lt;a href=&quot;/2017/04/18/ruby-magic-concurrency-threads.html&quot;&gt;multi-threading&lt;/a&gt; and &lt;a href=&quot;/2017/06/06/ruby-magic-concurrency-event-loop.html&quot;&gt;event loops&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>

  </feed>
