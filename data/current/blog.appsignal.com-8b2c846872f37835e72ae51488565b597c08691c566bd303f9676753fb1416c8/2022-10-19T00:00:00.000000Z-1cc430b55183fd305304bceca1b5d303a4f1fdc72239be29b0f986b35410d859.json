{
  "title":"Improve Code in Your Ruby Application with RubyCritic",
  "date":"2022-10-19T00:00:00.000000Z",
  "author":null,
  "id":"https://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html",
  "link":"https://blog.appsignal.com/2022/10/19/improve-code-in-your-ruby-application-with-rubycritic.html",
  "content":"<p>RubyCritic provides visual reports highlighting code smells, code structure, ease of testing, and test coverage in your Ruby application.</p>\n<p>It's in active development, with new code analysis tools often being introduced as new features. It's well worth keeping track of RubyCritic's releases.</p>\n<p>This article will touch on some of RubyCritic's benefits, its dependencies, and how to read its code reports.</p>\n<p>Let's get going!</p>\n<h2 id=\"why-choose-rubycritic-for-your-ruby-on-rails-application\">Why Choose RubyCritic for Your Ruby on Rails Application?</h2>\n<p>You should consider using <a href=\"https://github.com/whitesmith/rubycritic\">RubyCritic</a> if you want a single place to review code improvements for your project. Including RubyCritic in your development process will certainly reduce the time a development team spends working on technical debts. Most technical debts will be mapped out at development time.</p>\n<p>Some benefits that RubyCritic can provide to your project and development process include:</p>\n<ul>\n<li>Unified information in one place</li>\n<li>Visual reports</li>\n<li>Easy installation</li>\n<li>Zero configuration</li>\n<li>Customization allowed</li>\n<li>Being extensible — you can make your own open-source integration</li>\n<li>A badge generator \uD83C\uDF89</li>\n</ul>\n<p>To understand how RubyCritic works, let's look at the internal dependencies it uses to make reports.</p>\n<h2 id=\"internal-dependencies-in-rubycritic\">Internal Dependencies in RubyCritic</h2>\n<p>When you add RubyCritic to your project, some dependencies will also be included.</p>\n<p>Let's highlight the dependencies that make magic happen: the Reek, Flay, and Flog gems. These dependencies allow RubyCritic to show you valuable information about your code. Understanding how they work also makes RubyCritic easier to use.</p>\n<h3 id=\"reek-detect-code-smells-in-ruby\">Reek: Detect Code Smells in Ruby</h3>\n<p><a href=\"https://github.com/troessner/reek\">Reek</a> is a gem for detecting code smells in Ruby. A bad smell in code is not about identifying wrong code, it is more about analyzing if the code could be written better.</p>\n<p>Reek's analysis identifies <em>if</em> something could be implemented in another way. It does not suggest <em>how</em>, as most code smells are associated with business logic and a developer's experience with a language.</p>\n<p>For example, you could easily rewrite an <code>if</code> statement using metaprogramming techniques. The way to correct it, though, is up to a developer according to a project's context. In this case, no library will be able to indicate the best solution.</p>\n<p>Reek detects an <a href=\"https://github.com/troessner/reek/blob/master/docs/Code-Smells.md\">extensive list of smells</a>. It examines and identifies possible smells in:</p>\n<ul>\n<li>Classes</li>\n<li>Attributes</li>\n<li>Methods</li>\n<li>Parameters</li>\n<li>Modules</li>\n<li>Iterators</li>\n<li>The implementation of polymorphism</li>\n</ul>\n<p>By finding smells, you can take steps to make your code more readable and maintainable.</p>\n<p>Reek allows for custom configuration to:</p>\n<ul>\n<li>Disable a detector by its type</li>\n<li>Exclude directories from being scanned</li>\n<li>Use filters to silence warnings</li>\n</ul>\n<p>You can even define specific code to <a href=\"https://github.com/troessner/reek/blob/master/docs/Smell-Suppression.md\">suppress in a scan</a>, a very useful feature when code is not yet finalized or refactored, or even if it is legacy code.</p>\n<p>Let's see a sample of how Reek works. In this code, the exception is just defined as <code>e</code>.</p>\n<pre><code class=\"language-ruby\"># app/controllers/erp/orders_controller.rb\n\ndef create\n  ...\n\n  rescue JSON::Schema::ValidationError =&gt; e\n    render status: :unprocessable_entity, json: {\n      type: &quot;invalid-schema&quot;,\n      title: &quot;Your request does not match the expected schema.&quot;,\n      detail: e.message\n    }\n  end\nend\n</code></pre>\n<p>It is easy to imagine that <code>e</code> means an exception, but what if we have other exceptions? Identifying them correctly is the best way to maintain good code.</p>\n<p>Reek will identify <code>e</code> as UncommunicativeVariableName and show a warning.</p>\n<pre><code class=\"language-bash\">$ reek app/controllers/erp/orders_controller.rb\nInspecting 1 file(s):\nS\n\napp/controllers/erp/orders_controller.rb -- 1 warning:\n\n  [91]:UncommunicativeVariableName: Erp::OrdersController#create has the variable name 'e' [https://github.com/troessner/reek/blob/v6.1.1/docs/Uncommunicative-Variable-Name.md]\n</code></pre>\n<h3 id=\"flay-check-for-ruby-code-duplication\">Flay: Check for Ruby Code Duplication</h3>\n<p><a href=\"https://ruby.sadi.st/Flay.html\">Flay</a> identifies structural Ruby code similarities, including:</p>\n<ul>\n<li>Detecting code duplication within a project</li>\n<li>Checking the difference at any code level</li>\n<li>Generating a score to measure how good your code is (the lower your score, the better the code)</li>\n</ul>\n<p>If Flay reports a similarity in your code, it's a high indicator that refactoring is needed. Don't ignore this! Duplicate code is a gateway to bugs. If you fix something in one place but forget about another, more bugs appear.</p>\n<p>We can check how Flay works by running it in its own source code:</p>\n<pre><code class=\"language-bash\">$ flay lib/flay.rb\nTotal score (lower is better) = 36\n\n1) Similar code found in :iter (mass = 36)\n  lib/flay.rb:80\n  lib/flay.rb:105\n</code></pre>\n<p>Flay identifies similarities between these two:</p>\n<pre><code class=\"language-ruby\"># lib/flay.rb:80\nopts.on(&quot;-m&quot;, &quot;--mass MASS&quot;, Integer, &quot;Sets mass threshold (default = #{options[:mass]})&quot;) do |m|\n  options[:mass] = m.to_i\nend\n\n# lib/flay.rb:105\nopts.on(&quot;-t&quot;, &quot;--timeout TIME&quot;, Integer, &quot;Set the timeout. (default = #{options[:timeout]})&quot;) do |t|\n  options[:timeout] = t.to_i\nend\n</code></pre>\n<p>Note that the code's spelling is not exactly the same, but its functionality is and can be refactored to avoid duplication. That's the magic of Flay!</p>\n<h3 id=\"flog-examine-your-code-complexity-in-ruby\">Flog: Examine Your Code Complexity in Ruby</h3>\n<p><a href=\"https://ruby.sadi.st/Flog.html\">Flog</a> checks how difficult your code is to test. It sets a complexity score for each line of code and sums up the score for each method and class.</p>\n<p>The higher the score, the more your code needs to be refactored because it signifies that you have a highly complex implementation.</p>\n<p>Let's see Flog in action! A small change can cause your score to variate.</p>\n<pre><code class=\"language-ruby\">def validate_expiration\n  return if exp_month.blank? || exp_year.blank?\n\n  ...\nend\n</code></pre>\n<pre><code class=\"language-bash\">$ flog app/models/credit_card.rb\n\n5.2: CreditCard#validate_expiration   app/models/credit_card.rb:12-15\n</code></pre>\n<p>Note that in the first part of the code, we have an <code>or</code> check that increases the score by 0.4 points.</p>\n<pre><code class=\"language-ruby\">def validate_expiration\n  return if exp_month.blank?\n  return if exp_year.blank?\n\n  ...\nend\n</code></pre>\n<pre><code class=\"language-bash\">$ flog app/models/credit_card.rb\n\n4.8: CreditCard#validate_expiration app/models/credit_card.rb:12-15\n</code></pre>\n<h3 id=\"other-rubycritic-dependencies\">Other RubyCritic Dependencies</h3>\n<p>RubyCritic also uses other runtime dependencies, such as:</p>\n<ul>\n<li><a href=\"https://github.com/deivid-rodriguez/byebug\"><code>byebug</code></a> - this elevates debugging Ruby applications. It allows you to run a program line by line, add breakpoints, and evaluate and track values at runtime. If you still use <code>puts</code> for debugging, it's time you get to know Byebug's features and commands.</li>\n<li><a href=\"https://github.com/rubocop/rubocop\"><code>rubocop</code></a> - a linter for Ruby code that helps you follow a style guide used by the Ruby community, or even apply your own code style. It's very useful to set standards in your team and avoid silly conflicts about spaces and tabs.</li>\n<li><a href=\"https://github.com/simplecov-ruby/simplecov\"><code>SimpleCov</code></a> - a tool to check Ruby application code coverage. You can configure it to run alongside your tests. It provides metrics on code coverage so that you can identify what you need to pay attention to and where to invest your time to create better test cases.</li>\n</ul>\n<p><a href=\"https://github.com/whitesmith/rubycritic/blob/main/rubycritic.gemspec\">Dive into RubyCritic's list of dependencies</a>.</p>\n<h2 id=\"using-rubycritic-for-your-ruby-on-rails-app\">Using RubyCritic for Your Ruby on Rails App</h2>\n<p>RubyCritic has good documentation to help you get started without much configuration. Therefore, we will focus on utilizing its resources to help us analyze its reports.</p>\n<p>RubyCritic provides 'Code', 'Smells', and 'Coverage' reports. We'll look at each of these features in turn.</p>\n<h3 id=\"the-overview-in-rubycritic\">The Overview in RubyCritic</h3>\n<p>The 'Overview' page shows a total score for your project on a donut chart, along with ratings (A being the best rating, F the worst). The 'Summary' section shows the details of each rating, including the number of files, churns (commit changes), and smells found.</p>\n<p><img src=\"/images/blog/2022-10/overview.png\" alt=\"RubyCritic Overview\"></p>\n<p>In the 'Churn vs Complexity' section here, it is already possible to identify the class with the greatest complexity, which should probably be the first point of attention.</p>\n<p>To better understand this graph, it is worth recapping <a href=\"https://www.oreilly.com/library/view/making-software/9780596808310/ch23s03.html\">code churn</a>. Code that changes frequently can raise an alert that something is wrong — maybe in the logic or the business domain, for example. Either way, looking at 'Churn vs Complexity' can help you see where the pain points are across your project.</p>\n<h3 id=\"code-report\">Code Report</h3>\n<p>The 'Code' report shows a score for each class, including indicators for churn, complexity, duplication, and smells.</p>\n<p>You can sort this list by any column to view the highest ranking factors and address the most critical issues first.</p>\n<p><img src=\"/images/blog/2022-10/code.png\" alt=\"RubyCritic Overview\"></p>\n<p>In addition, this list has a filter that allows you to search by class name quickly.</p>\n<p>Clicking on the class name will open a detailed page with the class code and metrics such as:</p>\n<ul>\n<li>Code line</li>\n<li>Quantity methods</li>\n<li>Calculated churn</li>\n<li>Complexity by method</li>\n<li>Complexity score (total per class)</li>\n<li>Amount of duplicates found</li>\n<li>Number of smells</li>\n</ul>\n<p>The line of code where an issue is found will be highlighted (based on information provided by the Reek gem).</p>\n<p>If Flog identifies any issues, you'll see a score. You'll also see if a Flay report has detected any duplicate code.</p>\n<p><img src=\"/images/blog/2022-10/reports.png\" alt=\"RubyCritic Overview\"></p>\n<h3 id=\"smells-report\">Smells Report</h3>\n<p>The 'Smells' page displays the smell type, the exact location where a smell appears, and the fix status.</p>\n<p>As mentioned earlier, the smells are detected by Reek, and sorting and filtering are also available on this page.</p>\n<p>Clicking on a class name will open a page with your code details. You can also see the classes grouped by smell type (this is missing from the 'Code' page, which only displays the number of smells).</p>\n<p><img src=\"/images/blog/2022-10/smells.png\" alt=\"RubyCritic Overview\"></p>\n<h3 id=\"coverage-report\">Coverage Report</h3>\n<p>Finally, you can see class classifications and the percentage of coverage for each class in the 'Coverage' report. In contrast to the lists on the 'Code' and 'Smells' reports, the list in 'Coverage' does not allow information to be sorted and filtered.</p>\n<p>You can only see the percentage of code coverage — no additional information is available.</p>\n<p><img src=\"/images/blog/2022-10/coverage.png\" alt=\"RubyCritic Overview\"></p>\n<p>Integrating the SimpleCov report could add more value and usefulness to this page. But in any case, the 'Coverage' report can help if you need a simple report to examine your project's test coverage.</p>\n<h2 id=\"wrap-up\">Wrap Up</h2>\n<p>In this post, we briefly looked at the benefits of RubyCritic for your Ruby application before diving into its internal dependencies: Reek, Flay, and Flog. We then ran through how to read and analyze RubyCritic's reports.</p>\n<p>As a next step, figure out how to use RubyCritic in your pipeline.</p>\n<p>Happy code refactoring!</p>\n<p><strong>P.S. If you'd like to read Ruby Magic posts as soon as they get off the press, <a href=\"https://blog.appsignal.com/ruby-magic\">subscribe to our Ruby Magic newsletter and never miss a single post</a>!</strong></p>\n"
}