{
  "title":"Build a Table Editor with Trix and Turbo Frames in Rails",
  "date":"2022-10-26T00:00:00.000000Z",
  "author":null,
  "id":"https://blog.appsignal.com/2022/10/26/build-a-table-editor-with-trix-and-turbo-frames-in-rails.html",
  "link":"https://blog.appsignal.com/2022/10/26/build-a-table-editor-with-trix-and-turbo-frames-in-rails.html",
  "content":"<p>In this post, we will implement a basic ActionText table editor for your Rails application. We'll learn how:</p>\n<ul>\n<li>ActionText and Trix handle attachments</li>\n<li>To implement our own <code>Attachable</code> type, and leverage this to build a basic table editor</li>\n<li>Turbo Frames can be used to edit the table</li>\n<li>Turbo helps and gets in the way at the same time</li>\n</ul>\n<p><em>This article draws inspiration from the excellent <a href=\"https://onrails.blog/2020/09/30/adding-tables-to-actiontext-with-stimulus-js/\">'Adding Tables to ActionText With Stimulus.js' blog post</a> from 2020. That was written before the advent of <a href=\"https://turbo.hotwired.dev\">Turbo</a> though, which we can expect to simplify matters quite a bit.</em></p>\n<p>Let's get going!</p>\n<h2 id=\"actiontext-attachments-in-rails-101\">ActionText Attachments in Rails 101</h2>\n<p><em><strong>Note</strong>: This demonstration assumes some understanding of Trix and Turbo Frames. You might find our <a href=\"https://blog.appsignal.com/2022/07/06/get-started-with-hotwire-in-your-ruby-on-rails-app.html\">'Get Started with Hotwire in Your Ruby on Rails App' post</a> helpful in learning the basics of Hotwire and Turbo Frames.</em></p>\n<p><em><a href=\"https://github.com/julianrubisch/trix-tables-turbo-frames\">You can follow along with the code demonstration with this GitHub repo</a>.</em></p>\n<p>As described in the <a href=\"https://guides.rubyonrails.org/action_text_overview.html\">ActionText documentation</a>:</p>\n<blockquote>\n<p>Action Text brings rich text content and editing to Rails. It includes the Trix editor that handles everything from formatting to links to quotes to lists to embedded images and galleries.</p>\n</blockquote>\n<p>At a high level, attachments are part of ActionText's document model. They render custom templates for any resource resolvable by a Signed Global ID (SGID). In other words, ActionText stores a reference to a certain SGID as an <code>&lt;action-text-attachment&gt;</code> element:</p>\n<pre><code class=\"language-erb\">&lt;action-text-attachment sgid=&quot;BAh7CEkiCGâ€¦&quot;&gt;&lt;/action-text-attachment&gt;\n</code></pre>\n<p>Whenever ActionText encounters such an element, it calls the <code>to_attachable_partial_path</code> method on the respective resource. By default, this method delegates to <code>to_partial_path</code>.</p>\n<p>So, as a preview, this is how our <code>Table</code>'s representation in ActionText is going to look when rendered back to HTML:</p>\n<pre><code class=\"language-html\">&lt;action-text-attachment sgid=&quot;...&quot;&gt;\n  &lt;table&gt;\n    &lt;tbody&gt;\n      &lt;tr&gt;\n        &lt;td&gt;Cell 1&lt;/td&gt;\n        &lt;td&gt;Cell 2&lt;/td&gt;\n      &lt;/tr&gt;\n      &lt;!-- more rows --&gt;\n    &lt;/tbody&gt;\n  &lt;/table&gt;\n&lt;/action-text-attachment&gt;\n</code></pre>\n<p>To conform with the ActionText Attachment API, a class has to do only two things:</p>\n<ol>\n<li>Implement <code>to_sgid</code> by including <code>GlobalID::Identification</code>. By default, all <code>ActiveRecord::Base</code> descendants already do this.</li>\n<li>Include the <code>ActionText::Attachable</code> module.</li>\n</ol>\n<p><a href=\"https://api.rubyonrails.org/classes/ActionText/Attachable.html\">The <code>ActionText::Attachable</code> module</a> offers canonical ways to convert any model to and from an SGID via the <code>attachable_sgid</code> and <code>from_attachable_sgid</code> methods. We will make use of this later on.</p>\n<p>It also provides convenience accessors for attachment metadata, such as file size and name, as well as content type.</p>\n<p>Finally, it provides the default locations for the partials used to render an attachment in the editor and rich text views.</p>\n<h2 id=\"adding-a-table-model\">Adding a Table Model</h2>\n<p>We will capitalize on ActionText's Attachment API to implement our table solution. For this, we have to create a custom model capturing our tables' data and include <code>Attachable</code>. We'll use a simple JSON(B) column to hold a two-dimensional array for the table data.</p>\n<p>To start our exploration, let's create a new Rails app with ActionText enabled:</p>\n<pre><code class=\"language-sh\">$ rails new trix-tables-turbo-frames\n$ bin/rails action_text:install\n$ bin/rails db:migrate\n</code></pre>\n<p>Because I'm not feeling creative today, let's scaffold an <code>Article</code> model with a title and rich text content:</p>\n<pre><code class=\"language-sh\">$ bin/rails g scaffold Article title:string content:rich_text\n$ bin/rails g model ActionText::Table content:json\n# or, if using postgres\n$ bin/rails g model ActionText::Table content:jsonb\n\n$ bin/rails db:migrate\n</code></pre>\n<p>Watch out, here's a surprising gotcha! The above install command created a <code>CreateActionTextTables</code> migration, so we need to rename it to <code>CreateActionTextTablesTable</code>. Additionally, we'll have it default to a 2x2 table using <code>null: false, default: [[&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;]]</code>.</p>\n<pre><code class=\"language-ruby\">class CreateActionTextTablesTable &lt; ActiveRecord::Migration[7.0]\n  def change\n    create_table :action_text_tables do |t|\n      t.json :content, null: false, default: [[&quot;&quot;, &quot;&quot;], [&quot;&quot;, &quot;&quot;]] # create a 2x2 table by default\n\n      t.timestamps\n    end\n  end\nend\n</code></pre>\n<h3 id=\"add-a-table-to-a-rails-actiontext-model\">Add a Table to a Rails ActionText Model</h3>\n<p>Before we continue with actually adding a table to rich text, we need to patch Trix's toolbar:</p>\n<pre><code class=\"language-diff\">  // app/javascript/application.js\n  import &quot;@hotwired/turbo-rails&quot;;\n  import &quot;controllers&quot;;\n- import &quot;trix&quot;;\n+ import Trix from &quot;trix&quot;;\n  import &quot;@rails/actiontext&quot;;\n\n+ const buttonHTML =\n+   '&lt;button type=&quot;button&quot;\n+      class=&quot;trix-button trix-button--icon trix-button--icon-table&quot;\n+      title=&quot;table&quot; tabindex=&quot;-1&quot;\n+      data-action=&quot;trix-table#attachTable&quot;&gt;table&lt;/button&gt;';\n+\n+ const buttonGroupElement = document\n+   .querySelector(&quot;trix-editor&quot;)\n+   .toolbarElement.querySelector(&quot;[data-trix-button-group=file-tools]&quot;);\n+\n+ buttonGroupElement.insertAdjacentHTML(&quot;beforeend&quot;, buttonHTML);\n</code></pre>\n<p>Here, we manually append a button to Trix's <code>toolbarElement</code>. Wiring this up to a <code>trix-table</code> Stimulus controller (that we've yet to build) will insert a table into the document. Let's give this button a nice SVG as content in CSS and set up some table styles while we're at it:</p>\n<pre><code class=\"language-diff\">/* app/assets/stylesheets/application.css */\n/*\n *\n *= require_tree .\n *= require_self\n */\n\n+  .trix-button--icon-table::before {\n+    background-image: url(&quot;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' class='h-6 w-6' fill='none' viewBox='0 0 24 24' stroke='currentColor' stroke-width='2'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M3 10h18M3 14h18m-9-4v8m-7 0h14a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z' /%3E%3C/svg%3E&quot;);\n+    top: 8%;\n+    bottom: 4%;\n+  }\n+\n+ table {\n+   border: 1px solid black;\n+   border-collapse: collapse;\n+ }\n+\n+ td {\n+   padding: 0.5rem!important;\n+   border: 1px solid black;\n+ }\n</code></pre>\n<p>As you can see, we have successfully added it to the &quot;file-tools&quot; group:</p>\n<p><img src=\"/images/blog/2022-10/trix-toolbar.png\" alt=\"Customized Trix Toolbar\"></p>\n<p>Now let's return to adding and manipulating tables with the help of Turbo. For this, we will first need a controller with a <code>create</code> action:</p>\n<pre><code class=\"language-sh\">$ bin/rails g controller Tables create --no-helper --skip-routes\n</code></pre>\n<p>This action can be more or less borrowed from the <a href=\"https://onrails.blog/2020/09/30/adding-tables-to-actiontext-with-stimulus-js/\">'On Rails' blog post we cited in the introduction</a>. It constructs the JSON necessary to insert an attachment on the client side: including an SGID and <code>content</code> rendered from an <code>editor</code> partial, as we shall see later.</p>\n<pre><code class=\"language-ruby\"># app/controllers/tables_controller.rb\n\nclass TablesController &lt; ApplicationController\n  layout false\n\n  def create\n    @table = ActionText::Table.create\n\n    render json: {\n      sgid: @table.attachable_sgid,\n      content: render_to_string(partial: &quot;tables/editor&quot;, locals: {table: @table}, formats: [:html])\n    }\n  end\nend\n</code></pre>\n<p>We add the relevant <strong>resourceful table routes</strong> to our configuration:</p>\n<pre><code class=\"language-diff\">  # config/routes.rb\n\n  Rails.application.routes.draw do\n    resources :articles\n+   resources :tables\n  end\n</code></pre>\n<p>Now comes the moment to plunge into the deep end: we need to build our table model. First, let's include <code>ActionText::Attachable</code> and define the relevant partial paths:</p>\n<pre><code class=\"language-diff\">  # app/models/action_text/table.rb\n\n  class ActionText::Table &lt; ApplicationRecord\n+   include ActionText::Attachable\n+\n+   attribute :content_type, :string, default: &quot;text/html&quot;\n+\n+   def to_trix_content_attachment_partial_path\n+     &quot;tables/editor&quot;\n+   end\n+\n+   def to_partial_path\n+     &quot;tables/table&quot;\n+   end\n  end\n</code></pre>\n<p>Note that we haven't defined how the table's content is stored yet. Because we declared it as a JSON(B) column in our database, we are free to choose any format. Deviating from the cited blog post a bit, let's go with a two-dimensional array. Thus, we can simply do a nested loop over the <code>content</code> like this:</p>\n<pre><code class=\"language-erb\">&lt;!-- app/views/tables/_table.html.erb --&gt;\n&lt;table&gt;\n  &lt;% table.content.each do |row| %&gt;\n    &lt;tr&gt;\n      &lt;% row.each do |column| %&gt;\n        &lt;td&gt;\n          &lt;%= column %&gt;\n        &lt;/td&gt;\n      &lt;% end %&gt;\n    &lt;/tr&gt;\n  &lt;% end %&gt;\n&lt;/table&gt;\n</code></pre>\n<p>The above partial will render whenever it is requested by <code>ActionView</code>, for example. Next, we also have to devise an <code>editor</code> partial to be used inline in Trix:</p>\n<pre><code class=\"language-erb\">&lt;!-- app/views/tables/_editor.html.erb --&gt;\n&lt;%= turbo_frame_tag &quot;table_#{table.attachable_sgid}&quot; do %&gt;\n  &lt;table&gt;\n    &lt;% table.content.each_with_index do |row, row_index| %&gt;\n      &lt;tr&gt;\n        &lt;% row.each_with_index do |column, column_index| %&gt;\n          &lt;td&gt;\n            &lt;div contenteditable&gt;&lt;%= column %&gt;&lt;/div&gt;\n          &lt;/td&gt;\n        &lt;% end %&gt;\n      &lt;/tr&gt;\n    &lt;% end %&gt;\n  &lt;/table&gt;\n&lt;% end %&gt;\n</code></pre>\n<p>The only difference, as you have probably noticed, is that we now have wrapped it in a Turbo Frame, using the SGID as a DOM id. Furthermore, we provide row and column indexes to the separator blocks and prepare for inline editing by making the inner DIV <code>contenteditable</code> â€” we'll get to that later.</p>\n<p>We will now connect our toolbar's table button to the server-side controller action we have just written. To do this, we first need to bring Rails' <a href=\"https://github.com/rails/request.js\">request.js</a> library into the project. This library will help us administer <code>post</code> requests from the client, including proper CSRF-tokens, etc.:</p>\n<pre><code class=\"language-sh\">$ bin/importmap pin @rails/request.js\n</code></pre>\n<h3 id=\"build-a-new-trix-table-stimulus-controller\">Build a New Trix Table Stimulus Controller</h3>\n<p>Now that everything is set up, let's create a new <strong>trix-table</strong> Stimulus controller. In it, we will implement the <code>attachTable</code> action referenced by our toolbar button:</p>\n<pre><code class=\"language-js\">// app/javascript/controllers/trix_table_controller.js\n\nimport { Controller } from &quot;@hotwired/stimulus&quot;;\nimport Trix from &quot;trix&quot;;\nimport { post } from &quot;@rails/request.js&quot;;\n\nexport default class extends Controller {\n  static values = {\n    url: String,\n  };\n\n  async attachTable(event) {\n    const response = await post(this.urlValue);\n\n    if (response.ok) {\n      const tableAttachment = await response.json;\n      this.insertTable(tableAttachment);\n    } else {\n      // error handling\n    }\n  }\n\n  insertTable(tableAttachment) {\n    this.attachment = new Trix.Attachment(tableAttachment);\n    this.element\n      .querySelector(&quot;trix-editor&quot;)\n      .editor.insertAttachment(this.attachment);\n    this.element.focus();\n  }\n}\n</code></pre>\n<p>It will POST to the table's <code>create</code> route, inserting the JSON response as a <strong>Trix attachment</strong>. This again borrows from the OnRails blog post, exchanging the deprecated <strong>rails-ujs</strong> calls for the newer <strong>request.js</strong> library.</p>\n<p>Now we have to actually make use of this controller in our app by adding it to the form's markup:</p>\n<pre><code class=\"language-diff\">  &lt;!-- app/views/tables/_form.html.erb --&gt;\n- &lt;%= form_with(model: article) do |form| %&gt;\n+ &lt;%= form_with(model: article, data: {controller: &quot;trix-table&quot;, trix_table_url_value: tables_path}) do |form| %&gt;\n    &lt;% if article.errors.any? %&gt;\n      &lt;div style=&quot;color: red&quot;&gt;\n        &lt;h2&gt;&lt;%= pluralize(article.errors.count, &quot;error&quot;) %&gt; prohibited this article from being saved:&lt;/h2&gt;\n\n        &lt;ul&gt;\n          &lt;% article.errors.each do |error| %&gt;\n            &lt;li&gt;&lt;%= error.full_message %&gt;&lt;/li&gt;\n          &lt;% end %&gt;\n        &lt;/ul&gt;\n      &lt;/div&gt;\n    &lt;% end %&gt;\n\n    &lt;div&gt;\n      &lt;%= form.label :title, style: &quot;display: block&quot; %&gt;\n      &lt;%= form.text_field :title %&gt;\n    &lt;/div&gt;\n\n    &lt;div&gt;\n      &lt;%= form.label :content, style: &quot;display: block&quot; %&gt;\n      &lt;%= form.rich_text_area :content %&gt;\n    &lt;/div&gt;\n\n    &lt;div&gt;\n      &lt;%= form.submit %&gt;\n    &lt;/div&gt;\n  &lt;% end %&gt;\n</code></pre>\n<p>The beauty of Stimulus.js is that only adding two data attributes to the <code>form</code> element achieves the desired result. We are now able to add tables to our article's content with a single button click:</p>\n<p><img src=\"/images/blog/2022-10/insert-table.gif\" alt=\"Inserting a Table Attachment into a Trix Editor\"></p>\n<h2 id=\"manipulating-the-table-via-turbo-frames\">Manipulating the Table via Turbo Frames</h2>\n<p>Now that we can create table attachments, let's shift our focus to manipulating the content. As it turns out, Turbo Frames are <em>almost</em> a natural fit here.</p>\n<h3 id=\"add-and-delete-table-rows-and-columns\">Add and Delete Table Rows and Columns</h3>\n<p>To add and delete table rows and columns, we create a mini-toolbar consisting of four buttons, one for each operation. Make use of the <code>button_to</code> helper and set the URL to the <code>update</code> route for the respective table. Let's add the respective operation we want to trigger as additional parameters:</p>\n<pre><code class=\"language-diff\">  &lt;!-- app/views/tables/_editor.html.erb --&gt;\n  &lt;%= turbo_frame_tag &quot;table_#{table.attachable_sgid}&quot; do %&gt;\n+   &lt;div style=&quot;display: flex&quot;&gt;\n+     &lt;%= button_to &quot;+ Row&quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &quot;addRow&quot;} %&gt;\n+     &lt;%= button_to &quot;- Row&quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &quot;removeRow&quot;} %&gt;\n+     &lt;%= button_to &quot;+ Column&quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &quot;addColumn&quot;} %&gt;\n+     &lt;%= button_to &quot;- Column&quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &quot;removeColumn&quot;} %&gt;\n+   &lt;/div&gt;\n    &lt;table&gt;\n      &lt;% table.content.each_with_index do |row, row_index| %&gt;\n        &lt;tr&gt;\n          &lt;% row.each_with_index do |column, column_index| %&gt;\n            &lt;td&gt;\n              &lt;div contenteditable&gt;&lt;%= column %&gt;&lt;/div&gt;\n            &lt;/td&gt;\n          &lt;% end %&gt;\n        &lt;/tr&gt;\n      &lt;% end %&gt;\n    &lt;/table&gt;\n  &lt;% end %&gt;\n</code></pre>\n<p>In turn, we also need to add the respective controller action(s) to our <code>TablesController</code>. Observe that the <code>update</code> action delegates those actions to the model.</p>\n<pre><code class=\"language-diff\">  # app/controllers/tables_controller.rb\n\n  class TablesController &lt; ApplicationController\n+   before_action :set_table, only: %i[show edit update destroy]\n\n    layout false\n\n+   def edit\n+   end\n\n    def create\n      @table = ActionText::Table.create\n\n      render json: {\n        sgid: @table.attachable_sgid,\n        content: render_to_string(partial: &quot;tables/editor&quot;, locals: {table: @table}, formats: [:html])\n      }\n    end\n\n+   def update\n+     if params[&quot;operation&quot;] == &quot;addRow&quot;\n+       @table.add_row\n+     elsif params[&quot;operation&quot;] == &quot;removeRow&quot;\n+       @table.remove_row\n+     elsif params[&quot;operation&quot;] == &quot;addColumn&quot;\n+       @table.add_column\n+     elsif params[&quot;operation&quot;] == &quot;removeColumn&quot;\n+       @table.remove_column\n+     else\n+       flash.alert = &quot;Unknown table operation: #{params[&quot;operation&quot;]}&quot;\n+     end\n+\n+     if @table.save\n+       redirect_to edit_table_path(id: @table.attachable_sgid)\n+     else\n+       render :edit\n+     end\n+   end\n+\n+   private\n+\n+   def set_table\n+     @table = ActionText::Attachable.from_attachable_sgid params[:id]\n+   end\n  end\n</code></pre>\n<p>After changes to the table's structure are saved, we redirect to the table's edit view. It renders the same <code>editor</code> partial, which has the side-effect of referring to the same Turbo Frame. Thus Turbo can detect the matching frame and substitute one for the other.</p>\n<pre><code class=\"language-erb\">&lt;!-- app/views/tables/edit.html.erb --&gt;\n&lt;%= render &quot;tables/editor&quot;, table: @table %&gt;\n</code></pre>\n<p>Now we have to implement the missing commands on the <code>Table</code> model.</p>\n<pre><code class=\"language-diff\">  # app/models/action_text/table.rb\n\n  class ActionText::Table &lt; ApplicationRecord\n    include ActionText::Attachable\n\n    attribute :content_type, :string, default: &quot;text/html&quot;\n\n    def to_trix_content_attachment_partial_path\n      &quot;tables/editor&quot;\n    end\n\n    def to_partial_path\n      &quot;tables/table&quot;\n    end\n\n+   def rows\n+     content.size\n+   end\n+\n+   def columns\n+     content.map(&amp;:size).max\n+   end\n+\n+   def add_row(index = rows - 1)\n+     content &lt;&lt; Array.new(columns, &quot;&quot;)\n+   end\n+\n+   def remove_row(index = rows - 1)\n+     content.delete_at(index)\n+   end\n+\n+   def add_column(index = columns - 1)\n+     content.each do |row|\n+       row &lt;&lt; &quot;&quot;\n+     end\n+   end\n+\n+   def remove_column(index = columns - 1)\n+     content.each do |row|\n+       row.delete_at(index)\n+     end\n+   end\n  end\n</code></pre>\n<p>Notably, due to our simple data structure of a two-dimensional array, the <code>add/remove&lt;sub&gt;column&lt;/sub&gt;/row</code> methods are mere proxies to modify the column and row count. Once that is in place, we can change our table's structure with button clicks:</p>\n<p><img src=\"/images/blog/2022-10/add-remove-table-rows.gif\" alt=\"Adding and Removing Table Rows and Columns\"></p>\n<h3 id=\"edit-the-content-of-table-cells\">Edit the Content of Table Cells</h3>\n<p>In addition to changing the number of columns and rows, we also want to edit the cells' content. To achieve this, we will again lean heavily on the cited blog post and create a Stimulus table editor controller.</p>\n<pre><code class=\"language-js\">// app/javascript/controllers/table_editor_controller.js\n\nimport { Controller } from &quot;@hotwired/stimulus&quot;;\nimport { patch } from &quot;@rails/request.js&quot;;\n\nexport default class extends Controller {\n  static values = {\n    url: String,\n  };\n\n  async updateCell(event) {\n    const response = await patch(this.urlValue, {\n      body: { value: event.target.textContent },\n      query: {\n        operation: &quot;updateCell&quot;,\n        row_index: event.target.dataset.rowIndex,\n        column_index: event.target.dataset.columnIndex,\n      },\n      contentType: &quot;application/json&quot;,\n      responseKind: &quot;json&quot;,\n    });\n  }\n}\n</code></pre>\n<p>The <code>updateCell</code> method will issue a PATCH request whenever a cell is edited, passing the row and column index as parameters. Now, all we have to do is connect it to our DOM:</p>\n<pre><code class=\"language-diff\">  &lt;!-- app/views/tables/_editor.html.erb --&gt;\n- &lt;%= turbo_frame_tag &quot;table_#{table.attachable_sgid}&quot; do %&gt;\n+ &lt;%= turbo_frame_tag &quot;table_#{table.attachable_sgid}&quot;,\n+    data: {controller: &quot;table-editor&quot;, table_editor_url_value: table_path(id: table.attachable_sgid)} do %&gt;\n    &lt;div style=&quot;display: flex&quot;&gt;\n      &lt;%= button_to &quot;+ Row&quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &quot;addRow&quot;} %&gt;\n      &lt;%= button_to &quot;- Row&quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &quot;removeRow&quot;} %&gt;\n      &lt;%= button_to &quot;+ Column&quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &quot;addColumn&quot;} %&gt;\n      &lt;%= button_to &quot;- Column&quot;, table_path(id: table.attachable_sgid), method: :patch, params: {operation: &quot;removeColumn&quot;} %&gt;\n    &lt;/div&gt;\n    &lt;table&gt;\n      &lt;% table.content.each_with_index do |row, row_index| %&gt;\n        &lt;tr&gt;\n          &lt;% row.each_with_index do |column, column_index| %&gt;\n            &lt;td&gt;\n-             &lt;div contenteditable&gt;&lt;%= column %&gt;&lt;/div&gt;\n+             &lt;div contenteditable\n+                data-action=&quot;input-&gt;table-editor#updateCell&quot;\n+                data-row-index=&quot;&lt;%= row_index %&gt;&quot;\n+                data-column-index=&quot;&lt;%= column_index %&gt;&quot;&gt;\n+               &lt;%= column %&gt;\n+             &lt;/div&gt;\n            &lt;/td&gt;\n          &lt;% end %&gt;\n        &lt;/tr&gt;\n      &lt;% end %&gt;\n    &lt;/table&gt;\n  &lt;% end %&gt;\n</code></pre>\n<p>The server-side <code>TablesController</code>, of course, now needs a way to handle this operation. Luckily, this is easily done in our simplified proof of concept by adding another branch to our condition. We also make sure that the <code>update</code> action can now handle JSON-type requests, even if it's merely returning an empty object here.</p>\n<pre><code class=\"language-diff\">  # app/controllers/tables_controller.rb\n\n  class TablesController &lt; ApplicationController\n    before_action :set_table, only: %i[show edit update destroy]\n\n    layout false\n\n    def edit\n    end\n\n    def create\n      @table = ActionText::Table.create\n\n      render json: {\n        sgid: @table.attachable_sgid,\n        content: render_to_string(partial: &quot;tables/editor&quot;, locals: {table: @table}, formats: [:html])\n      }\n    end\n\n    def update\n      if params[&quot;operation&quot;] == &quot;addRow&quot;\n        @table.add_row\n      elsif params[&quot;operation&quot;] == &quot;removeRow&quot;\n        @table.remove_row\n      elsif params[&quot;operation&quot;] == &quot;addColumn&quot;\n        @table.add_column\n      elsif params[&quot;operation&quot;] == &quot;removeColumn&quot;\n        @table.remove_column\n+     elsif params[&quot;operation&quot;] == &quot;updateCell&quot;\n+       @table.content[params[&quot;row_index&quot;].to_i][params[&quot;column_index&quot;].to_i] = params[&quot;value&quot;]\n      end\n\n      if @table.save\n-       redirect_to edit_table_path(id: @table.attachable_sgid)\n+       respond_to do |format|\n+         format.html { redirect_to edit_table_path(id: @table.attachable_sgid) }\n+         format.json {}\n+       end\n      else\n        render :edit\n      end\n    end\n\n    private\n\n    def set_table\n      @table = ActionText::Attachable.from_attachable_sgid params[:id]\n    end\n  end\n</code></pre>\n<p>Note that in a production app, I would advise you to choose a different strategy for sanitizing the operation than an <code>if/elsif/else</code> condition. I would probably reach for a Mediator or Proxy in this case.</p>\n<h2 id=\"the-limitations-of-trix-in-ruby\">The Limitations of Trix in Ruby</h2>\n<p>Up to this point, I assume this account has made perfect sense, but I have left out a critical detail. While we are persisting the underlying database model just fine, we are not syncing it to Trix's internal shadow representation. That's why the table snaps back to the previously stored representation when we focus out of it:</p>\n<p><img src=\"/images/blog/2022-10/document-sync-bug.gif\" alt=\"Bug When Syncing with Trix's Internal Document Model\"></p>\n<p>If we were to refresh the page now, the added content would appear, because Trix's document is freshly initialized.</p>\n<p>I have pinned this problem down to where Trix syncs its internal document when the selection changes. It just unfurls it from the shadow element <a href=\"https://github.com/basecamp/trix/blob/v2/src/trix/views/document_view.js#L52\">here</a>.</p>\n<p>I tried hooking into the <code>turbo:submit</code> event and preventing the sync just when blurring a table, but the solutions I came up with all seem very hairy and highly dependent on the internal API.</p>\n<p>The most Turbo-esque way of dealing with this, I guess, would be to wrap the whole form in an eager-loaded Turbo Frame and tell it to reload whenever Trix's content changes.</p>\n<p>Something like this should do the trick:</p>\n<pre><code class=\"language-js\">// app/javascript/controllers/trix_table_controller.js\n\n// ...\n\nconnect() {\n  this.element.addEventListener(&quot;turbo:submit-end&quot;, (e) =&gt; {\n    this.element.closest(&quot;turbo-frame&quot;).reload();\n  });\n}\n\n// ...\n</code></pre>\n<p>If you enclose your form in a Turbo Frame that you load from <code>src</code>:</p>\n<pre><code class=\"language-erb\">&lt;!-- app/views/articles/edit.html.erb --&gt;\n&lt;h1&gt;Editing article&lt;/h1&gt;\n\n&lt;%= turbo_frame_tag dom_id(@article, :form), src: form_article_path(@article) %&gt;\n</code></pre>\n<p>This approach only works with already persisted base records, though.</p>\n<h2 id=\"final-words-of-warning-on-trix\">Final Words of Warning on Trix</h2>\n<p>The proof of concept we've built uses server-rendered HTML to do away with the added complexity of serializing tables to JSON and listening for JavaScript events. It is portable to any ActionText installation and could be easily extracted to a gem.</p>\n<p>There are a couple of drawbacks, though, the most obvious one being the necessary re-syncing with Trix's document model. There might be situations where the proposed workaround is workable and others where it's a no-go. Until Trix gains a Turbo-compatible interface, there's no way around it.</p>\n<p>The second catch is that it does not use Trix's <code>undo</code> functionality (but that is true of any Trix attachment). Likewise, it would be wise to wait for upstream changes instead of tweaking the internal API.</p>\n<h2 id=\"wrap-up\">Wrap Up</h2>\n<p>In this post, we started by taking a quick look at the basics of ActionText Attachments. We then added a table to an ActionText model before tweaking it using Turbo Frames. Finally, we touched on some limitations of using Trix.</p>\n<p>Given that Trix v2 is underway, featuring a translation from CoffeeScript to plain modern JavaScript, now would be a good time to address its Turbo compatibility. Currently, the scope of what such a wrapper might look like is beyond my capabilities, but it sure looks like a window of opportunity.</p>\n<p>Happy coding!</p>\n<p><strong>P.S. If you'd like to read Ruby Magic posts as soon as they get off the press, <a href=\"https://blog.appsignal.com/ruby-magic\">subscribe to our Ruby Magic newsletter and never miss a single post</a>!</strong></p>\n"
}