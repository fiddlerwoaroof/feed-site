{
  "title":"How to Scale Ruby on Rails Applications",
  "date":"2022-11-09T00:00:00.000000Z",
  "author":null,
  "id":"https://blog.appsignal.com/2022/11/09/how-to-scale-ruby-on-rails-applications.html",
  "link":"https://blog.appsignal.com/2022/11/09/how-to-scale-ruby-on-rails-applications.html",
  "content":"<p>Today we will dive into some strategies you can use to scale Ruby on Rails applications to a huge user base.</p>\n<p>One obvious way of scaling applications is to throw more money at them. And it works amazingly well — add a few more servers, upgrade your database server, and voila, a lot of the performance issues just go <em>poof</em>!</p>\n<p>But it is often also possible to scale applications without adding more servers. That's what we will discuss today.</p>\n<p>Let's get going!</p>\n<h2 id=\"use-appsignal-for-your-rails-application\">Use AppSignal for your Rails Application</h2>\n<p>Before we dive into scaling and performance optimization, you first need to identify <em>if</em> you need to do this, what the bottlenecks are in your application, and what resources can be scaled.</p>\n<p>One easy way to do this is to use <a href=\"https://www.appsignal.com/ruby\">AppSignal's performance monitoring and metrics for Ruby</a>.</p>\n<p>The <a href=\"https://www.appsignal.com/tour/performance\">performance dashboard</a> helps you pinpoint the exact controller actions and background jobs that are slow on average.</p>\n<p>For example, here's how a performance dashboard might look for ActiveRecord:</p>\n<p><img src=\"/images/blog/2022-11/activerecord.png\" alt=\"ActiveRecord dashboard\"></p>\n<p>This gives a good starting point to any scaling journey — whether you decide to add more servers or optimize performance through code.</p>\n<p>Now let's move on to one of the simplest techniques you can use to scale your Rails app — caching.</p>\n<h2 id=\"caching-in-ruby-on-rails\">Caching in Ruby on Rails</h2>\n<p>Caching allows you to stop computing the same things again and again.</p>\n<p>For example, let's say you run a social media platform and there's a very popular post. Caching can immediately help you regain all the CPU cycles you spend rendering that post for every user. And that's only a part of what caching can help you do.</p>\n<p>Let's look at all the possible resources that can be cached.</p>\n<h3 id=\"caching-views\">Caching Views</h3>\n<p>Rendering views can sometimes be an expensive operation, especially when that view has a lot of data to be rendered. Even when the operation isn't expensive, using a pre-rendered view will give you a lot of performance as opposed to rendering that same view a million times.</p>\n<p>Rails supports this out of the box using the <a href=\"https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/CacheHelper.html#method-i-cache\"><code>cache</code></a> view helper. For example, this is how it can cache each post when rendering a list:</p>\n<pre><code class=\"language-ruby\">&lt;% @posts.each do |post| %&gt;\n  &lt;% cache post do %&gt;\n    &lt;%= render post %&gt;\n  &lt;% end %&gt;\n&lt;% end %&gt;\n</code></pre>\n<p>For this, Rails automatically caches each post under a specific key that depends on the HTML content of the template, post id, and update timestamp.</p>\n<p><em>To read more about this technique, check out the posts <a href=\"https://blog.appsignal.com/2018/03/20/fragment-caching-in-rails\">Fragment caching in Rails</a> and <a href=\"https://blog.appsignal.com/2018/08/14/rails-collection-caching\">Rails collection caching</a>.</em></p>\n<p>One thing to keep in mind, though, is that the cache keys don’t include nested template content. So if you are nesting the cache calls deeper than one level, there might be stale results. Read more about this in <a href=\"https://blog.appsignal.com/2018/04/03/russian-doll-caching-in-rails\">Russian doll caching in Rails</a>.</p>\n<h3 id=\"caching-responses\">Caching Responses</h3>\n<p>In addition to caching views/fragments, you can also choose to cache the full response of <code>GET</code> requests. This is supported through the <code>If-None-Match</code> and <code>If-Modified-Since</code> headers sent by the browsers.</p>\n<p>When an <code>If-None-Match</code> header is present on the request, the server can return a <code>304 Not Modified</code> response with no content if there are no changes to the response. The server-computed <code>Etag</code> is compared with the value inside that header.</p>\n<p>Similarly, if the <code>If-Modified-Since</code> header is present without an <code>If-None-Match</code>, the server can return a <code>304 Not Modified</code> response with no content (as long as the response hasn’t changed since that date).</p>\n<p>Rails provides easy ways to do this inside controller actions. You can simply write:</p>\n<pre><code class=\"language-ruby\">class PostsController &lt; ApplicationController\n  def show\n    @post = Post.find(params[:id])\n    fresh_when last_modified: @post.updated_at.utc, etag: @post\n  end\nend\n</code></pre>\n<p>Rails will send all the required headers to support caching, handle incoming headers, and respond with 304 when the data hasn’t changed. The server can skip rendering the full views again unless things change. You can read more about advanced configuration for this strategy in <a href=\"https://blog.appsignal.com/2018/05/01/client-side-caching-in-rails-conditional-get-requests\">Client-side caching in Rails: conditional GET requests</a>.</p>\n<h3 id=\"caching-values\">Caching Values</h3>\n<p>Finally, it is also possible to cache raw values (anything that can be serialized to the cache store). This is usually useful to cache the results of resource-intensive or slow operations and avoid performing them again.</p>\n<p>Identifying a value that can benefit from this caching depends greatly on the application, but usually, looking at your slowest events can help point you in the correct direction.</p>\n<p>Finally, when you identify what to cache, the API that Rails provides for this is very simple to use:</p>\n<pre><code class=\"language-ruby\">Rails.cache.fetch(cache_key_with_version, expires_in: 12.hours) do\n  perform_the_slow_computation\nend\n</code></pre>\n<p>The above code will <code>perform_the_slow_computation</code> only once and then cache the value under the <code>cache_key_with_version</code> key. The next time the same code is called, Rails will first check if we already have a cached value and use that instead of triggering <code>perform_the_slow_computation</code> again.</p>\n<p>The most important part of this caching strategy is to compute a good cache key that depends on all the inputs used in the value's computation. This is to ensure we don’t keep using a stale value.</p>\n<h3 id=\"cache-stores\">Cache Stores</h3>\n<p>Now that we know what to cache and the techniques Rails provides to store things in the cache, the next logical question is — where do we cache this data? Rails comes with several in-built cache store adapters. The most popular cache stores for production use cases are <a href=\"https://redis.io/\">Redis</a> and <a href=\"https://memcached.org/\">Memcached</a>. There are a couple of other options as well — the <a href=\"https://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-filestore\">file store</a> and  <a href=\"https://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-memorystore\">memory store</a>. A full discussion of these stores can be found in the post <a href=\"https://blog.appsignal.com/2018/04/17/rails-built-in-cache-stores\">Rails' built-in cache stores: an overview</a>.</p>\n<p>File and memory stores can be great for development use to get things up and running quickly. However, they are usually unsuitable for production, especially if you're working in a distributed setup with multiple servers. Redis and memcached are both suited for production use. Which one you use usually depends on the application.</p>\n<h2 id=\"background-workers-in-ruby-on-rails\">Background Workers in Ruby on Rails</h2>\n<p>Most applications need background jobs for mailers, regular clean-ups, or any other time-consuming operation that doesn't require a user to be present. Chances are, you already have a background worker set up already.</p>\n<p>Whenever you find yourself doing anything that takes more than a second to do inside a controller action, see if you can move it to a background worker instead. This could range from a user-facing operation like searching for data inside a large table to an API method that ingests a large amount of data.</p>\n<h3 id=\"example-implementation\">Example Implementation</h3>\n<p>To run custom jobs, Rails provides the <a href=\"https://edgeguides.rubyonrails.org/active_job_basics.html\">Active Job framework</a>. Let's see how we can use it to move a very complex filtering logic to a background job. First, let’s create our background job:</p>\n<pre><code class=\"language-ruby\"># jobs/filter_huge_dataset_job.rb\nclass FilterHugeDatasetJob &lt; ApplicationJob\n  queue_as :default\n\n  def perform(user, filters)\n    # search your data\n  end\nend\n</code></pre>\n<p>We can run this job from the controller like this:</p>\n<pre><code class=\"language-ruby\"># controllers/huge_datasets_controller.rb\nclass HugeDatasetsController &lt; ApplicationController\n  def index\n    FilterHugeDatasetJob.perform_later(@current_user, filters)\n  end\nend\n</code></pre>\n<p>We need to render a loading indicator on our template while we wait for our job to compute data and deliver the results.</p>\n<p>But how can we get the results from our job to the view? Turbo makes this really easy. For example, inside the view, we can subscribe to turbo-stream events on a specific notification channel using <code>turbo_stream_from</code>.</p>\n<p>Using this, let’s write our templates:</p>\n<pre><code class=\"language-ruby\"># view/huge_datasets/index.html.erb\n&lt;%= render &quot;index&quot;, user: @current_user %&gt;\n</code></pre>\n<pre><code class=\"language-ruby\"># view/huge_datasets/_index.html.erb\n&lt;%= turbo_stream_from user, :huge_datasets %&gt;\n&lt;%= render &quot;filters&quot; %&gt;\n&lt;div id=&quot;data-container&quot;&gt;\n  &lt;% if defined? data %&gt;\n    &lt;%= render partial: &quot;item&quot;, collection: data  %&gt;\n  &lt;% else %&gt;\n    &lt;%= render &quot;loading&quot; %&gt;\n  &lt;% end %&gt;\n&lt;/div&gt;\n</code></pre>\n<p>Since data is not defined in the initial controller action, we will only render a loading indicator. Let’s now deliver the results from our job:</p>\n<pre><code class=\"language-ruby\"># jobs/filter_huge_dataset_job.rb\nclass FilterHugeDatasetJob &lt; ApplicationJob\n  queue_as :default\n\n  def perform(user, filters)\n    data = search_huge_dataset(filters)\n    notify_completed(user, data)\n  end\n\n  def search_huge_dataset(filters)\n    # search your data\n  end\n\n  def notify_completed(user, data)\n    Turbo::StreamsChannel.broadcast_replace_to(\n      [user, :huge_datasets],\n      target: &quot;data-container&quot;,\n      partial: &quot;huge_datasets/index&quot;,\n      locals: { user: user, data: data }\n    )\n  end\nend\n</code></pre>\n<p>The important part here is the <code>notify_completed</code> method. It uses <a href=\"https://github.com/hotwired/turbo-rails/blob/main/app/channels/turbo/streams_channel.rb\">Turbo::StreamsChannel</a>, broadcasting a replace event to the <code>[user, :huge_datasets]</code> notification stream that we subscribed to from our view.</p>\n<p>That is everything we need to move complex operations from our controller to background jobs. The main advantage of moving tasks to the background is that background workers can be scaled independently of web servers. This frees up resources on the web server side considerably. For the user, such interfaces also feel much more responsive because we can respond quickly and deliver results incrementally.</p>\n<p><strong>Note</strong>: <em>If you need help deciding between a background job worker, read <a href=\"https://blog.appsignal.com/2022/02/15/delayed-job-vs-sidekiq-which-is-better.html\">Delayed Job vs. Sidekiq: Which Is Better?</a></em></p>\n<h2 id=\"scaling-a-database-in-your-ruby-on-rails-application\">Scaling a Database in Your Ruby on Rails Application</h2>\n<p>The last scalable resource that we will discuss in this post is the database. Databases form the core of most applications. As data and the number of servers accessing that data grows, databases start to feel the load.</p>\n<p>The easiest way to scale a database is to add more processing power and memory to the database server. As opposed to scaling web servers, doing this with a database is usually a very slow operation, especially if you have high storage.</p>\n<p>The second option to scale databases is to scale horizontally using multiple databases or by sharding your database. Check out <a href=\"https://guides.rubyonrails.org/active_record_multiple_databases.html\">Multiple Databases with Active Record</a> for more details about this.</p>\n<p>Instead, we'll focus on optimizing your database's performance by looking at PostgreSQL.</p>\n<h3 id=\"find-time-consuming-queries-in-postgresql\">Find Time-Consuming Queries in PostgreSQL</h3>\n<p>First, we need to identify our most time-consuming queries. The way we can do that is to query the <a href=\"https://www.postgresql.org/docs/current/pgstatstatements.html\"><code>pg_stat_statements</code></a> table that contains statistics about all SQL statements executed on the server. Let’s see how we can find the top 100 queries with the highest run times:</p>\n<pre><code class=\"language-sql\">SELECT query, calls, (total_exec_time/calls)::integer as avg_time_ms\nFROM pg_stat_statements\nWHERE calls &gt; 1000\nORDER BY avg_time_ms desc\nLIMIT 100;\n</code></pre>\n<p>This will return the query, the number of calls, and the average run time of these queries. Try to find the ones you think could be faster and analyze why they were slow.</p>\n<p>You can also run <code>EXPLAIN</code> or <code>EXPLAIN ANALYZE</code> on the query to see the query plan and actual execution details, respectively.</p>\n<p>One of the most important things to look out for in the results is <code>Seq Scan</code>, which indicates that Postgres has to go through all the records sequentially to run the query. If this happens, try to bypass that sequential scan by adding an index to the columns that you've filtered.</p>\n<h3 id=\"tables-with-the-most-sequential-scans\">Tables with the Most Sequential Scans</h3>\n<p>Another useful query that I like to run is to find the total number of sequential scans run against a table:</p>\n<pre><code class=\"language-sql\">SELECT relname AS name, seq_scan as count\nFROM pg_stat_user_tables\nORDER BY seq_scan DESC;\n</code></pre>\n<p>If you see a very large table (with a high number of rows) and a high count value from this result, then you have a problem. Try to check all queries against that table, find ones that can run sequential scans, and add indices to boil that down.</p>\n<h3 id=\"index-usage\">Index Usage</h3>\n<p>You can also find statistics about index usage by running this query:</p>\n<pre><code class=\"language-sql\">SELECT relname,\n   CASE idx_scan\n     WHEN 0 THEN 'Insufficient data'\n     ELSE (100 * idx_scan / (seq_scan + idx_scan))::text\n   END percent_of_times_index_used,\n   n_live_tup rows_in_table\n FROM\n   pg_stat_user_tables\n ORDER BY\n   n_live_tup DESC;\n</code></pre>\n<p>This returns the percentage of index usage for each table. A low number means that you are missing some indexes on that table.</p>\n<h2 id=\"wrap-up\">Wrap Up</h2>\n<p>In this post, we explored several strategies to scale your Ruby on Rails applications, including caching and background workers. We also looked at optimizing your PostgreSQL database's performance.</p>\n<p>Rails makes it really easy to add several layers of performance optimization to your application.</p>\n<p>The most important consideration with scalability is to identify bottlenecks in an application before we can act on them. A good performance monitoring tool can help. If you need one, check out <a href=\"https://www.appsignal.com/ruby\">AppSignal for Ruby</a>.</p>\n<p>Happy coding!</p>\n<p><strong>P.S. If you'd like to read Ruby Magic posts as soon as they get off the press, <a href=\"https://blog.appsignal.com/ruby-magic\">subscribe to our Ruby Magic newsletter and never miss a single post</a>!</strong></p>\n"
}