{
  "title":"The what, the why, and the how of WebSockets",
  "date":"2022-11-09T10:00:00.000000Z",
  "author":"rishijain",
  "id":"https://www.ombulabs.com/blog/systemdesign/websocket/rails/the-what-the-why-the-how-of-websockets",
  "link":"https://www.ombulabs.com/blog/systemdesign/websocket/rails/the-what-the-why-the-how-of-websockets.html",
  "content":"<p>Web Sockets are an integral part of a lot of modern-day systems. But have you ever wondered how a Web Socket actually works? Or does your system even need a Web Socket?\nIn this post, we are going to cover the basics of Web Sockets, i.e, the what, the why, and the how.</p>\n\n\n\n<h2>What is a Web Socket?</h2>\n\n<p>It is a way to have bi-directional, persistent, and real-time communication between a client and a server. The modern-day browsers started supporting Web Sockets in 2010 and today almost all the browsers have native support for Web Sockets.</p>\n\n<p>If we look at how things work in HTTP protocol, we see that the regular request-response mechanism is uni-directional i.e the client sends a request to the server, the server responds back with the data and then the connection is closed.</p>\n\n<p>With Web Sockets, the client can send the request to the server, but the server can also send the data to the client without the client initiating a request for it, keeping the connection between them open. This behavior makes it bi-directional.</p>\n\n<p><img src=\"/blog/assets/images/client-server.png\" alt=\"About Web Socket\" class=\"half-img\"></p>\n\n<p>Imagine building an application where your user can chat with each other and it is built over HTTP protocol. Every time a user wants to see if it has received any messages, it has to refresh the page or somehow trigger to send a request to the server. This isn't a real-time experience for the user.</p>\n\n<p>On the other hand, if this part of the application is built over Web Sockets, the user would never have to send a request to the server to fetch messages and the server can send a message to the client (the userâ€™s browser here) with the latest message, making the experience become truly real-time.</p>\n\n<h2>What did they use before Web Sockets?</h2>\n\n<p>Before Web Sockets, there were a few ways to solve problems.</p>\n\n<p>One of the ways was to keep sending AJAX requests every few milliseconds or seconds depending on the nature of the feature you are building. This mechanism is called <em>Short Polling</em>. The problem with this method is there will always be a certain delay in receiving the message. It is resource-intensive as requests will constantly be sent to the server to fetch the latest data.</p>\n\n<p>Another way was long pooling. <em>Long Pooling</em> is a technique that tries to emulate the real-time communication between the client and the server. The client sends a request to the server and the server keeps the channel open until it has the data to send back to the client. As soon as the client receives back the data, it immediately sends another request to the server to open another connection between the client and the server.</p>\n\n<p>There is another solution called <em>Server Send Events</em> which comes very close to solving the problems Web Sockets is solving. Server-Sent Events are basically a way HTTP provides to send data from the server to the client just like Web Sockets. The only downside is that it is a one-way communication, i.e, the client cannot send data to the server via the Server-Sent Events. Due to this limitation, it makes this an excellent solution for very specific kinds of use-cases, but is not a replacement for Web Sockets.</p>\n\n<p>While there are ways to get around without using the Web Sockets, there are certain problems that can only be solved by Web Sockets. Let's look at the kind of problems we should look to solve via Web Sockets.</p>\n\n<h2>When to use Web Socket over HTTP?</h2>\n\n<p>Because HTTP-based solutions are stateless and uni-directional, the server sends something to the client only when the client requests it. If you are building an app where you need to show the user profile when the user visits the profile page, it totally makes sense to keep things simple using the HTTP request-response. </p>\n\n<p>Because Web Sockets are stateful and bi-directional, the server can also send data to the client without the client explicitly requesting it. When you need to build an application where push-based, real-time communication is needed, Web Sockets should be used. Think about getting the latest updates on social media without refreshing a page, collaborative editing on a document, or even a chat room- all of these use cases need real-time and bi-directional communication.</p>\n\n<h2>How do Web Sockets work?</h2>\n\n<p>Web Sockets connection between the client and the server is persistent in nature. This means that either the client or the server has to close the connection, otherwise it remains an intact TCP connection. Whereas the HTTP will close the TCP connection as soon the response is received from the server.</p>\n\n<p>How does this connection happen?\nThe connection starts with a handshake between the client and the server. The client sends an HTTP request to the server with a few additional headers which informs the server that this is a request for a Web Socket handshake. The headers are <code>Connection: Upgrade</code> , <code>Upgrade: websocket</code> and <code>Sec-WebSocket-Key: Base64 encoded random value</code>.</p>\n<div class=\"highlight\"><pre><code class=\"language-javascript\"><span></span><span class=\"nx\">Connection</span><span class=\"o\">:</span> <span class=\"nx\">Upgrade</span>\n<span class=\"nx\">Upgrade</span><span class=\"o\">:</span> <span class=\"nx\">websocket</span>\n<span class=\"nx\">Sec</span><span class=\"o\">-</span><span class=\"nx\">WebSocket</span><span class=\"o\">-</span><span class=\"nx\">Key</span><span class=\"o\">:</span> <span class=\"nx\">h44jdY83u63bgsRwsjUSHw</span><span class=\"o\">==</span>\n</code></pre></div>\n<p>The server upon receiving this request finds that <code>Connection: Upgrade</code> is being passed and checks the value of the <code>Upgrade</code> header and sends back these headers in the response.</p>\n<div class=\"highlight\"><pre><code class=\"language-javascript\"><span></span><span class=\"nx\">HTTP</span><span class=\"o\">/</span><span class=\"mf\">1.1</span> <span class=\"mf\">101</span> <span class=\"nx\">Switching</span> <span class=\"nx\">Protocols</span>\n<span class=\"nx\">Connection</span><span class=\"o\">:</span> <span class=\"nx\">Upgrade</span>\n<span class=\"nx\">Upgrade</span><span class=\"o\">:</span> <span class=\"nx\">websocket</span>\n<span class=\"nx\">Sec</span><span class=\"o\">-</span><span class=\"nx\">WebSocket</span><span class=\"o\">-</span><span class=\"nx\">Accept</span><span class=\"o\">:</span> <span class=\"nx\">h32jsdlkjUUb8484Jsksu</span><span class=\"o\">=</span>\n</code></pre></div>\n<p>The other thing to note here is that the client and server should agree on a format/type of the data they both would communicate in. The client already knows what all format it understands, so it sends the possible options to the server and then the server has to choose one from the list otherwise risks dropping the connection.</p>\n\n<p>The header passed from the client is called <code>Sec-Websocket-Protocol</code> with possible options like this: <code>Sec-Websocket-Protocol: chat,wamp</code> and the server responds back with one of the options from the list in the same header.</p>\n\n<p><img src=\"/blog/assets/images/websocket-handshake.png\" alt=\"About Web Socket Handshake\" class=\"half-img\"></p>\n\n<h2>How to implement Web Sockets?</h2>\n\n<p>There are various open-source libraries in most languages to support the implementation of Web Sockets. A quick Google search will give you options for Python, Go, Java, Javascript, and Ruby.</p>\n\n<p>Specifically for Ruby, there are a few open-source libraries that we could use to integrate WebSockets in Rails. But ever since Rails 5 came out and specifically <a href=\"https://guides.rubyonrails.org/action_cable_overview.html\">ActionCable</a> with it, it has made integrating WebSockets quite easy and very much like coding the Rails way. </p>\n\n<p>The other open-source options are:</p>\n\n<p><a href=\"https://www.github.com/ruby-jp/websocket-client-simple\">https://www.github.com/ruby-jp/websocket-client-simple</a>\n<a href=\"https://www.github.com/igrigorik/em-websocket\">https://www.github.com/igrigorik/em-websocket</a></p>\n\n<p>I will write a separate article on how to use ActionCable to solve problems via WebSockets.</p>\n\n<p>I hope you enjoyed reading this and got some insights about Web Sockets.\nTo further read about the topic, here are some of the articles that were referred to while writing this and you can find more about WebSockets in these blogs.</p>\n\n<p><a href=\"https://www.twilio.com/docs/glossary/what-are-websockets\">https://www.twilio.com/docs/glossary/what-are-websockets</a>\n<a href=\"https://www.wallarm.com/what/a-simple-explanation-of-what-a-websocket-is\">https://www.wallarm.com/what/a-simple-explanation-of-what-a-websocket-is</a>\n<a href=\"https://ably.com/topic/websockets\">https://ably.com/topic/websockets</a></p>"
}