{
  "title":"Babel, JavaScript Transpiling And Polyfills",
  "date":"2022-11-17T00:00:00.000000Z",
  "author":null,
  "id":"https://getaround.tech/babel-transpiling-polyfills/",
  "link":"https://getaround.tech/babel-transpiling-polyfills/",
  "content":"<p><a href=\"https://babeljs.io/\">BabelJS or Babel</a> is a prevalent tool in the JavaScript ecosystem. Most developers know that it is essential when developing using brand new JavaScript features. But how does this system work?</p>\n\n<p>In this article, we’ll explain what Babel is doing under the hood to allow the use of state-of-the-art JavaScript features, and even TypeScript, without manually dealing with older browsers’ version compatibility.</p>\n\n<h2 id=\"state-of-the-art-javascript-features\">State-of-the-art JavaScript Features</h2>\n\n<p>Let’s take a step back and look at the context.</p>\n\n<p>JavaScript is a language that has evolved and is still evolving, especially in the last few years. It is based on a specification named <strong>ECMAScript</strong>, provided by <a href=\"https://www.ecma-international.org/memento/tc39.htm\">TC39 (Technical Committee 39)</a>.</p>\n\n<p><strong>Note:</strong> <em>It’s a common mistake to think that ECMAScript is the “new JavaScript” or a “standardized JavaScript”. ECMAScript is a specification for creating a scripting language when JavaScript is a scripting language. It may even happen that rare features are not following the ECMAScript specification in the experimental versions of some browsers.</em></p>\n\n<p>To be included in the ECMAScript specification, a new feature <a href=\"https://tc39.es/process-document/\">passes through a specific process with five phases</a>. So it could take some time before it is integrated into the specifications and then implemented in the browsers.</p>\n\n<p>While we, developers, can’t wait to use new exciting features that improve our <del>life</del> code, most browsers don’t support them yet, so we can’t just deliver the code as we wrote it.</p>\n\n<h2 id=\"babel-to-the-rescue\">Babel To The Rescue</h2>\n\n<p><a href=\"https://babeljs.io/\">Babel</a> is a tool that allows you to write code in the latest (or even experimental) version of JavaScript. Because not all of the browsers currently support those hot features, it will transform the cutting-edge source code down to a code supported by older browsers. Babel’s primary purpose is about two things: <strong>JavaScript transpiling</strong> and <strong>polyfills handling</strong>.</p>\n\n<p>Let’s take a look at the key points of interest regarding Babel:</p>\n<ul>\n  <li>Its configuration is defined in a <code class=\"language-plaintext highlighter-rouge\">babel.config.js</code> file located at the project’s root.</li>\n  <li>Babel uses <strong>plugins</strong> to be as modular as possible (example: <a href=\"https://babeljs.io/docs/en/babel-plugin-transform-arrow-functions\">@babel/plugin-transform-arrow-functions</a>). Each plugin is often related to one functionality or a minimal scope of functionalities.</li>\n  <li>You can create a <strong>preset</strong> from a configuration to easily share it between projects, like <code class=\"language-plaintext highlighter-rouge\">@babel/preset-env</code> to manage Babel plugins, <code class=\"language-plaintext highlighter-rouge\">@babel/preset-typescript</code> for TypeScript usage, or <code class=\"language-plaintext highlighter-rouge\">@babel/preset-react</code> for React applications.</li>\n  <li>By providing a list of targeting node environments or browsers (using <a href=\"https://github.com/browserslist/browserslist\">browserslist</a> syntax) as an option to <a href=\"https://babeljs.io/docs/en/babel-preset-env\"><code class=\"language-plaintext highlighter-rouge\">@babel/preset-env</code></a>, it will automatically decide which plugins and polyfills (thanks to <a href=\"https://github.com/zloirock/core-js\"><code class=\"language-plaintext highlighter-rouge\">core-js</code></a>) have to be applied when processing the code.</li>\n</ul>\n\n<p>Below is a simple Babel configuration file that we will use as an example throughout this article:</p>\n<figure>\n  <figcaption class=\"highlight-caption\">babel.config.js</figcaption>\n\n<figure class=\"highlight\"><pre><code class=\"language-typescript\"><span class=\"kr\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"na\">presets</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n    <span class=\"c1\">// Babel plugin/preset options are passing using an array syntax</span>\n    <span class=\"p\">[</span>\n      <span class=\"dl\">&quot;</span><span class=\"s2\">@babel/preset-env</span><span class=\"dl\">&quot;</span><span class=\"p\">,</span>\n      <span class=\"p\">{</span>\n        <span class=\"na\">targets</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n          <span class=\"dl\">&quot;</span><span class=\"s2\">&gt; 0.25%</span><span class=\"dl\">&quot;</span><span class=\"p\">,</span>\n        <span class=\"p\">],</span>\n        <span class=\"c1\">// Specify the version of core-js used, the last minor version is core-js@3.26.x</span>\n        <span class=\"na\">corejs</span><span class=\"p\">:</span> <span class=\"dl\">&quot;</span><span class=\"s2\">3.26</span><span class=\"dl\">&quot;</span><span class=\"p\">,</span>\n        <span class=\"c1\">// Specify how to handle polyfills, see polyfills handling section below</span>\n        <span class=\"na\">useBuiltIns</span><span class=\"p\">:</span> <span class=\"dl\">&quot;</span><span class=\"s2\">usage</span><span class=\"dl\">&quot;</span><span class=\"p\">,</span> <span class=\"c1\">// &quot;entry&quot;, &quot;usage&quot; or false by default</span>\n      <span class=\"p\">}]</span>\n    <span class=\"dl\">&quot;</span><span class=\"s2\">@babel/preset-react</span><span class=\"dl\">&quot;</span><span class=\"p\">,</span>\n    <span class=\"dl\">&quot;</span><span class=\"s2\">@babel/preset-typescript</span><span class=\"dl\">&quot;</span>\n  <span class=\"p\">],</span>\n  <span class=\"c1\">// Specify some plugins enabled in any cases</span>\n  <span class=\"na\">plugins</span><span class=\"p\">:</span> <span class=\"p\">[</span>\n      <span class=\"dl\">&quot;</span><span class=\"s2\">dynamic-import-webpack</span><span class=\"dl\">&quot;</span><span class=\"p\">,</span>\n  <span class=\"p\">]</span>\n<span class=\"p\">}</span></code></pre></figure>\n\n</figure>\n\n<p><strong>Note:</strong> <a href=\"https://github.com/zloirock/core-js\"><code class=\"language-plaintext highlighter-rouge\">core-js</code></a> is an NPM package that contains all polyfills for every possible ECMAScript feature. It must be installed for Babel to work with this latter. We’ll learn more about its usage in the polyfills handling section below.</p>\n\n<h3 id=\"javascript-transpiling\">JavaScript Transpiling</h3>\n\n<p>A <strong>code transpiler</strong>, slightly different from a compiler, will read the source code written in one language (here, modern JavaScript code) to produce the equivalent code in another language (here, an older and more supported JavaScript code). Afterward, a compiler, like Webpack, is still needed to collect, optimize and build a project’s final output(s).</p>\n\n<p><strong>Example:</strong> Let’s say we are writing a piece of code using <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow functions</a> and <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals\">template literals</a>:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">const</span> <span class=\"nx\">MyFunc</span> <span class=\"o\">=</span> <span class=\"nx\">arg</span> <span class=\"o\">=&gt;</span> <span class=\"s2\">`Using my argument: </span><span class=\"p\">${</span><span class=\"nx\">arg</span><span class=\"p\">}</span><span class=\"s2\">`</span></code></pre></figure>\n\n<p>With the configuration from the previous section, Babel will output the code as follows:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">var</span> <span class=\"nx\">MyFunc</span> <span class=\"o\">=</span> <span class=\"kd\">function</span> <span class=\"nx\">MyFunc</span><span class=\"p\">(</span><span class=\"nx\">arg</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"dl\">&quot;</span><span class=\"s2\">Using my argument: </span><span class=\"dl\">&quot;</span><span class=\"p\">.</span><span class=\"nx\">concat</span><span class=\"p\">(</span><span class=\"nx\">arg</span><span class=\"p\">)</span>\n<span class=\"p\">}</span></code></pre></figure>\n\n<p>As a result, arrow functions are transformed to the basic function syntax supported by every browser. Same thing for <code class=\"language-plaintext highlighter-rouge\">.concat()</code>, which is more widely supported by browsers than template literals. Finally, <code class=\"language-plaintext highlighter-rouge\">const</code> is transformed to <code class=\"language-plaintext highlighter-rouge\">var</code>, mainly for IE 11.</p>\n\n<p>To do this transformation, Babel creates an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST (Abstract syntax tree)</a>, a tree representation of the code structure. Then it applies plugins that use this AST to transform and output the code. In this example, the plugin <code class=\"language-plaintext highlighter-rouge\">@babel/plugin-transform-arrow-functions</code> was used to transform arrow functions, but there are a lot of other Babel plugins to handle any transformation.</p>\n\n<p>The good news is that <strong>it’s not necessary to know all of them to transform the code correctly, thanks to the <code class=\"language-plaintext highlighter-rouge\">@babel/preset-env</code> preset</strong>.</p>\n\n<p>Indeed, this preset <a href=\"https://github.com/babel/babel/blob/master/packages/babel-compat-data/data/plugins.json\">has a built-in list of plugins matching browser versions</a>. So, according to the browser versions list provided, it knows precisely which plugins need to be applied.</p>\n\n<p>Now that we know how to transform the code, there is still something to tackle: how to add not supported yet implementations of very recent JavaScript functions.</p>\n\n<h3 id=\"polyfills-handling\">Polyfills Handling</h3>\n\n<p>According to the <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Polyfill\">MDN</a>:</p>\n\n<blockquote>\n  <p>A polyfill is a piece of code used to provide modern functionality on older browsers that do not natively support it.</p>\n</blockquote>\n\n<p>Let’s take an example. Here is a code using <code class=\"language-plaintext highlighter-rouge\">Array.prototype.find</code> to find the first element matching a condition in an array:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"kd\">const</span> <span class=\"nx\">garage</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n  <span class=\"p\">{</span><span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Model 3</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">electric</span><span class=\"p\">:</span> <span class=\"kc\">true</span><span class=\"p\">},</span>\n  <span class=\"p\">{</span><span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">Punto</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">electric</span><span class=\"p\">:</span> <span class=\"kc\">false</span><span class=\"p\">},</span>\n  <span class=\"p\">{</span><span class=\"na\">name</span><span class=\"p\">:</span> <span class=\"dl\">'</span><span class=\"s1\">208</span><span class=\"dl\">'</span><span class=\"p\">,</span> <span class=\"na\">electric</span><span class=\"p\">:</span> <span class=\"kc\">false</span><span class=\"p\">}</span>\n<span class=\"p\">];</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">isElectric</span><span class=\"p\">(</span><span class=\"nx\">car</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"nx\">car</span><span class=\"p\">.</span><span class=\"nx\">electric</span> <span class=\"o\">===</span> <span class=\"kc\">true</span>\n<span class=\"p\">}</span>\n\n<span class=\"kd\">const</span> <span class=\"nx\">myFirstElectricCar</span> <span class=\"o\">=</span> <span class=\"nx\">garage</span><span class=\"p\">.</span><span class=\"nx\">find</span><span class=\"p\">(</span><span class=\"nx\">isElectric</span><span class=\"p\">);</span></code></pre></figure>\n\n<p>This code works well on recent browsers, but when running on Internet Explorer 11, it throws an error <code class=\"language-plaintext highlighter-rouge\">Object doesn't support property or method 'find'</code>. Indeed, the <code class=\"language-plaintext highlighter-rouge\">find()</code> method for arrays doesn’t exist for this browser and won’t exist since this browser is not updated anymore.</p>\n\n<p>The solution is to <del>drop IE 11 support</del> provide a <strong>polyfill</strong>. In this case, it could be as simple as copying/pasting <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill\">this polyfill from the MDN</a> directly into the code to make it work.</p>\n\n<p>But it is more complicated to do that for every feature used in a codebase. It’s easy to forget or duplicate too many of them in the code, while it’s complicated to test and monitor. This is where the <a href=\"https://www.npmjs.com/package/core-js\">NPM package <code class=\"language-plaintext highlighter-rouge\">core-js</code></a> full of ECMAScript polyfills, comes in.</p>\n\n<p>As for the code transpiling, the preset <code class=\"language-plaintext highlighter-rouge\">@babel/preset-env</code> has a built-in list of <code class=\"language-plaintext highlighter-rouge\">core-js</code> polyfills names that match browsers versions. According to the targeting environments, it knows which polyfills to include. From this point on, you have three ways to do that using <a href=\"https://babeljs.io/docs/en/babel-preset-env#usebuiltins\">the <code class=\"language-plaintext highlighter-rouge\">useBuiltIns</code> option</a> of <code class=\"language-plaintext highlighter-rouge\">@babel/preset-env</code>.</p>\n\n<h4 id=\"usebuiltins-entry\"><code class=\"language-plaintext highlighter-rouge\">useBuiltIns: &quot;entry&quot;</code></h4>\n\n<p>This option requires the <code class=\"language-plaintext highlighter-rouge\">core-js</code> module to be imported (and <strong>only once</strong>) at the entry point of the project. According to the standard level targeted, many import options are available:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"c1\">// Must be at the root, the very beginning of the code, before anything else</span>\n\n<span class=\"c1\">// polyfill all `core-js` features</span>\n<span class=\"k\">import</span> <span class=\"dl\">&quot;</span><span class=\"s2\">core-js</span><span class=\"dl\">&quot;</span>\n<span class=\"c1\">// OR polyfill only stable `core-js` features - ES and web standards</span>\n<span class=\"k\">import</span> <span class=\"dl\">&quot;</span><span class=\"s2\">core-js/stable</span><span class=\"dl\">&quot;</span>\n<span class=\"c1\">// OR polyfill only stable ES features</span>\n<span class=\"k\">import</span> <span class=\"dl\">&quot;</span><span class=\"s2\">core-js/es</span><span class=\"dl\">&quot;</span>\n<span class=\"c1\">// OR any other module/folder from core-js</span></code></pre></figure>\n\n<p>Then Babel will parse the code, and when it finds the <code class=\"language-plaintext highlighter-rouge\">core-js</code> import, it will transform this one-line import into multiple imports of unit modules from <code class=\"language-plaintext highlighter-rouge\">core-js</code>. As a result, it’ll <strong>only import polyfills necessary for the targeting environments whether or not the features are used</strong>. Here’s what that looks like by importing <code class=\"language-plaintext highlighter-rouge\">core-js/es</code>:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es.symbol</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n<span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es.symbol.description</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n<span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es.symbol.async-iterator</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n<span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es.symbol.has-instance</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n<span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es.symbol.is-concat-spreadable</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n<span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es.symbol.iterator</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n<span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es.symbol.match</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n<span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es.symbol.replace</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n<span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es.symbol.search</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n<span class=\"c1\">// ... and all other polyfills that exist in core-js/es...</span></code></pre></figure>\n\n<h4 id=\"usebuiltins-usage\"><code class=\"language-plaintext highlighter-rouge\">useBuiltIns: &quot;usage&quot;</code></h4>\n\n<p>This option tells Babel to <strong>automatically write</strong> the polyfill imports related to a feature each time it encounters it.</p>\n\n<p>Thus, this code:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"cm\">/* We keep the previous example with the garage of cars */</span>\n\n<span class=\"kd\">const</span> <span class=\"nx\">myFirstElectricCar</span> <span class=\"o\">=</span> <span class=\"nx\">garage</span><span class=\"p\">.</span><span class=\"nx\">find</span><span class=\"p\">(</span><span class=\"nx\">isElectric</span><span class=\"p\">);</span>\n<span class=\"kd\">const</span> <span class=\"nx\">haveMyElectricCar</span> <span class=\"o\">=</span> <span class=\"nx\">garage</span><span class=\"p\">.</span><span class=\"nx\">includes</span><span class=\"p\">(</span><span class=\"nx\">myFirstElectricCar</span><span class=\"p\">);</span></code></pre></figure>\n\n<p>will be transformed by Babel to this:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es7.array.includes</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n<span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"dl\">&quot;</span><span class=\"s2\">core-js/modules/es6.array.find</span><span class=\"dl\">&quot;</span><span class=\"p\">);</span>\n\n<span class=\"kd\">var</span> <span class=\"nx\">myFirstElectricCar</span> <span class=\"o\">=</span> <span class=\"nx\">garage</span><span class=\"p\">.</span><span class=\"nx\">find</span><span class=\"p\">(</span><span class=\"nx\">isElectric</span><span class=\"p\">);</span>\n<span class=\"kd\">var</span> <span class=\"nx\">haveElectricCar</span> <span class=\"o\">=</span> <span class=\"nx\">garage</span><span class=\"p\">.</span><span class=\"nx\">includes</span><span class=\"p\">(</span><span class=\"nx\">myFirstElectricCar</span><span class=\"p\">);</span></code></pre></figure>\n\n<p>It’s important to understand that <strong>it’s no longer needed to write <code class=\"language-plaintext highlighter-rouge\">core-js</code> imports</strong>. Polyfills imports will <strong>automatically be added at every part of the code that needs one or many polyfills</strong>. It also means that if a modern feature is used multiple times at different places, it will result in multiple imports of the same polyfills. Indeed, it assumes that a bundler (like Webpack) will collect and deduplicate imports so that polyfills are only included once in the final output(s).</p>\n\n<p>This is the most optimized and automatic way to include only the polyfills that are needed and remove them when they become unnecessary (whether they are not used anymore or the targeting environments list evolved to more recent ones).</p>\n\n<h4 id=\"usebuiltins-false\"><code class=\"language-plaintext highlighter-rouge\">useBuiltIns: false</code></h4>\n\n<p>This will tell Babel not to handle polyfills at all. Every polyfill from the different <code class=\"language-plaintext highlighter-rouge\">core-js</code> imports will be included without fine selections according to the targeted environments. It will be still possible to import <code class=\"language-plaintext highlighter-rouge\">core-js</code> manually. There won’t be any filtering but the selected modules imports:</p>\n\n<figure class=\"highlight\"><pre><code class=\"language-javascript\"><span class=\"c1\">// polyfill everything from `core-js`</span>\n<span class=\"k\">import</span> <span class=\"dl\">&quot;</span><span class=\"s2\">core-js</span><span class=\"dl\">&quot;</span>\n<span class=\"c1\">// polyfill only array ES features</span>\n<span class=\"k\">import</span> <span class=\"dl\">&quot;</span><span class=\"s2\">core-js/es/array</span><span class=\"dl\">&quot;</span>\n<span class=\"c1\">// polyfill only array.includes ES feature</span>\n<span class=\"k\">import</span> <span class=\"dl\">&quot;</span><span class=\"s2\">core-js/es/array/includes</span><span class=\"dl\">&quot;</span>\n\n<span class=\"p\">...</span><span class=\"nx\">Your</span> <span class=\"nx\">highly</span> <span class=\"nx\">up</span> <span class=\"nx\">to</span> <span class=\"nx\">date</span> <span class=\"nx\">JavaScript</span> <span class=\"nx\">code</span> <span class=\"nx\">here</span><span class=\"p\">...</span></code></pre></figure>\n\n<p>Using this way, be sure <strong>never to import polyfill twice</strong>; otherwise, it will throw an error.</p>\n\n<h3 id=\"transpiling-the-case-of-typescript\">Transpiling: The Case Of TypeScript</h3>\n\n<p><a href=\"https://www.typescriptlang.org/index.html\">The documentation</a> states, “TypeScript is a typed superset of JavaScript that compiles to plain JavaScript.” This means that any JavaScript code is a valid TypeScript code, but TypeScript is not necessarily valid JavaScript and, therefore, not supported by browsers.</p>\n\n<p>At Getaround, we use TypeScript to develop our front-end features. Consequently, we need to transform our TypeScript code to “classical JavaScript” before deploying it.</p>\n\n<p>To do so, TypeScript comes with a code transpiler. This latter will transform the TypeScript code to an ECMAScript 3 code, so it could be wrongly thought that we don’t need to transpile with Babel anymore.</p>\n\n<p>But there are some points that we need to highlight here:</p>\n<ul>\n  <li>You’ll have two different configurations to handle JavaScript-related files in the project. Babel for <code class=\"language-plaintext highlighter-rouge\">.js</code> files and Typescript for <code class=\"language-plaintext highlighter-rouge\">.ts</code> files.</li>\n  <li>TypeScript doesn’t handle polyfills as Babel does, and Babel doesn’t do type-checking as TypeScript does.</li>\n  <li>Babel is much more extensible and has a more extensive plugin ecosystem than TypeScript.</li>\n  <li>There are some incompatibilities between the two tools (you can read <a href=\"https://devblogs.microsoft.com/typescript/typescript-and-babel-7/\">this article from Microsoft</a>).</li>\n</ul>\n\n<p>So a solution here would be to keep using Babel for both cases, thanks to a dedicated preset named <code class=\"language-plaintext highlighter-rouge\">@babel/preset-typescript</code> that allows Babel to transform TypeScript code correctly. And for the type-checking, we can still rely on the <code class=\"language-plaintext highlighter-rouge\">tsc</code> CLI provided by TypeScript.</p>\n\n<h2 id=\"our-open-source-preset-configuration\">Our open-source preset configuration</h2>\n\n<p>At Getaround, we use a custom preset to share our configuration across all front-end apps. It is publicly available on our <a href=\"https://github.com/drivy/frontend-configs/blob/main/packages/babel-preset-app/index.js\"><code class=\"language-plaintext highlighter-rouge\">drivy/frontend-configs</code> Github repository</a>, along with all of our other front-end configurations.</p>\n\n<p>You can also find it on <a href=\"https://www.npmjs.com/package/@getaround-eu/babel-preset-app\">NPM</a>: <code class=\"language-plaintext highlighter-rouge\">@getaround-eu/babel-preset-app</code>.</p>\n\n<p>Don’t hesitate to take a look and to use it!</p>\n"
}