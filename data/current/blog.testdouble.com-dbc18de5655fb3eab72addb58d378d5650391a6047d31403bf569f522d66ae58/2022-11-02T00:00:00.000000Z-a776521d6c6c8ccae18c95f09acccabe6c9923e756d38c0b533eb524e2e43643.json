{
  "title":"A Lesson in Type Safety with Typescript, Remix and Prisma",
  "date":"2022-11-02T00:00:00.000000Z",
  "author":null,
  "id":"https://blog.testdouble.com/posts/2022-11-02-typescript-safety/",
  "link":"https://blog.testdouble.com/posts/2022-11-02-typescript-safety/",
  "content":"<p>While waiting for Phoenix 1.7 and LiveView 0.18 to drop, I decided to play around with <a href=\"https://remix.run\">Remix</a> a bit.\nMy experiment was to build a magic link login in Remix, using Prisma as the ORM.\nI wound up getting burned pretty badly by tricky things in both these libraries that TypeScript was not able to catch for me.\nI want to share with you some of the lessons I learned while working on this.</p>\n<p><code>loader</code> is a special function in Remix that runs on the client side before your page is rendered.\nIt is similar to <code>getServerSideProps</code> if you are familiar with NextJS, or a controller function in Phoenix or Rails.\nThis code reads the sessionToken from the cookie, and then looks up the user from that sessionToken using Prisma ORM.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ts\"><span>export</span> <span>const</span> <span>loader</span>: <span>LoaderFunction</span> <span>=</span> ({ <span>request</span> }) <span>=&gt;</span> {\n  <span>const</span> <span>session</span> <span>=</span> <span>await</span> <span>getSession</span>(<span>request</span>.<span>headers</span>.<span>get</span>(<span>&quot;Cookie&quot;</span>));\n  <span>const</span> <span>sessionToken</span> <span>=</span> <span>session</span>.<span>get</span>(<span>&quot;sessionToken&quot;</span>);\n  <span>const</span> <span>user</span> <span>=</span> <span>await</span> <span>getUserForSession</span>(<span>sessionToken</span>);\n\n  <span>return</span> { <span>user</span> };\n};\n\n<span>export</span> <span>function</span> <span>getUserForSession</span>(<span>sessionToken</span>: <span>string</span>) {\n  <span>const</span> <span>session</span> <span>=</span> <span>await</span> <span>db</span>.<span>session</span>.<span>findFirst</span>({\n    <span>where</span><span>:</span> {\n      <span>sessionToken</span><span>:</span> {\n        <span>equals</span>: <span>sessionToken</span>,\n      },\n    },\n    <span>include</span><span>:</span> {\n      <span>user</span>,\n    },\n  });\n\n  <span>if</span> (<span>session</span>) {\n    <span>return</span> <span>session</span>.<span>user</span>;\n  } <span>else</span> {\n    <span>return</span> <span>null</span>;\n  }\n}\n</code></pre></div><p>After I got it working (meaning that I could log in and out from my computer), I decided to make sure the mobile page looked good.\nI used ngrok to tunnel localhost from my computer and opened the page on my phone.</p>\n<p>I was logged in on my phone.</p>\n<p>How could this happen? This was an app that I had just written. It was impossible for me to be logged in on my phone.</p>\n<p>I’ll give you a moment to see if you can spot the problem.</p>\n<p><br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<strong>spoilers ahead</strong>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br></p>\n\n\n\n<h2 id=\"there-are-a-few-culprits\">\n  \n    <a class=\"heading-anchor\" href=\"#there-are-a-few-culprits\">There are a few culprits.</a>\n  \n</h2>\n<p>First, <code>session.get(&quot;sessionToken&quot;)</code> does not return a string, it returns an <code>any</code>.</p>\n<p>Even if I had typed it <code>const sessionToken: string = session.get(&quot;sessionToken&quot;)</code>, TypeScript would have raised no errors, because <code>string</code> satisfies the type <code>any</code>.\nInstead, <code>session.get</code> should return <code>unknown</code>, instead of <code>any</code>; since then I would have been forced to cast the type into a string. But this was library code. I could not change the type.</p>\n<p>Secondly, the <code>session.get</code> function returns <code>undefined</code> instead of <code>null</code> when the key cannot be found.\nThe patterns for this vary across the TypeScript/JavaScript ecosystem, so I don’t really fault the library code.\nNullish types are bad enough that some modern languages do away with them entirely (e.g. Haskell and Rust).\nJavaScript (and TypeScript) have 2 nullish types.</p>\n<p>So, <code>session.get(&quot;sessionToken&quot;)</code> returns <code>undefined</code>.</p>\n\n\n\n<h2 id=\"no-big-deal-right\">\n  \n    <a class=\"heading-anchor\" href=\"#no-big-deal-right\">No big deal, right?</a>\n  \n</h2>\n<p>Well, Prisma treats <code>undefined</code> differently than <code>null</code>. <a href=\"https://www.prisma.io/docs/concepts/components/prisma-client/null-and-undefined\">Here’s the documentation</a>.</p>\n<blockquote>\n<p>Prisma Client differentiates between <code>null</code> and <code>undefined</code>:</p>\n<p><code>null</code> is a value\n<code>undefined</code> means do nothing</p>\n</blockquote>\n<p>So, my where clause (<code>where: { sessionToken: { equals: sessionToken, }, },)</code>) was actually just doing nothing, exactly as Prisma documentation states.</p>\n<p>So, what are the lessons we can all learn?</p>\n<p>Even though it may seem obvious what a library is doing, and its API is very straightforward, you should always read its documentation. Reading about Prisma’s behavior around <code>null</code> and <code>undefined</code>, rather than just assuming, would have saved me a huge headache.</p>\n<p>TypeScript, by a deliberate design choice, has an escape hatch called <code>any</code>. If you (or any library you pull in) uses it, then you can no longer consider your code typesafe. Consider using <code>unknown</code> instead. Inspect the types of any library code you are using, and if they return <code>any</code>, consider casting the result to <code>unknown</code> before handling it.</p>\n"
}