{
  "title":"Building passwordless email auth in Rails",
  "date":"2022-10-25T00:00:00.000000Z",
  "author":null,
  "id":"https://blog.testdouble.com/posts/2022-10-25-building-passwordless-email-auth-in-rails/",
  "link":"https://blog.testdouble.com/posts/2022-10-25-building-passwordless-email-auth-in-rails/",
  "content":"<p>I’m working on a new Rails app, and I finally got to the part where I need to\nfigure out how I’m going to handle authentication.</p>\n<p>What’ll it be this time? I could:</p>\n<ul>\n<li>Depend on <a href=\"https://github.com/heartcombo/devise\">Devise</a>, which is popular and\nfeature-rich, but is so complex that—if I’m being honest—I would\nnever understand how my own app’s authentication system worked</li>\n<li>Outsource identity management to an OAuth service like Google, Facebook,\nTwitter, or GitHub, whether by using an\n<a href=\"https://github.com/omniauth/omniauth\">omniauth</a> adapter or by <a href=\"https://blog.testdouble.com/posts/2021-02-11-theres-no-such-thing-as-a-free-gem/\">rolling my\nown</a></li>\n<li>Implement a password management system for the app using\n<a href=\"https://api.rubyonrails.org/v7.0.4/classes/ActiveModel/SecurePassword/ClassMethods.html#method-i-has_secure_password\">has_secure_password</a>\nand rebuilding all the supporting features that tend to tag along (e.g. email\nconfirmation, password reset, changing email addresses)</li>\n<li>Adopt the burgeoning Passkey standard using\n<a href=\"https://webauthn.guide\">Webauthn</a>, which relies on the cryptographic security\nof people’s modern computing devices to act as tokens</li>\n</ul>\n<p>I thought long and hard about it, but I didn’t like any of these options. I look\nforward to being able to quickly plug in a Passkey-based authentication feature,\nbut <a href=\"https://twitter.com/searls/status/1580562003050930176?s=20&amp;t=SjWZvq1uw0I32JZc4v_ohQ\">we’re just not there\nyet</a>.</p>\n<p>Ultimately, I settled on creating an email-based passwordless authentication\nworkflow. You’ve probably experienced something like this as a user:</p>\n<ol>\n<li>Enter your email address</li>\n<li>Check your inbox</li>\n<li>Click the link</li>\n<li>Be logged in</li>\n<li>Feel annoyed it opened a new tab</li>\n</ol>\n<p>(Unfortunately, it seems not much can be done about Step 5.)</p>\n<p>Asking users to shuffle between an app and their email inbox has always felt\nsuboptimal. That said, it’s important to consider that most password-based\naccount systems represent the same thing with extra steps by requiring users to\nopen an email to verify their address or reset their password. So if there’s any\nsuperfluity to be eliminated from a self-hosted authentication system, it’s with\nthe password, not the email address.</p>\n<p>So, with that settled: where to start?</p>\n\n\n\n<h2 id=\"cant-a-gem-do-this-for-us\">\n  \n    <a class=\"heading-anchor\" href=\"#cant-a-gem-do-this-for-us\">Can’t a gem do this for us?</a>\n  \n</h2>\n<p>Whenever implementing a feature that others have certainly done before, I’ll be\nthe first to reach for the nearest search engine and type: <code>{{description of feature}} ruby on rails</code> and see if there’s a good-enough drop-in solution to\nthe problem. And indeed, my cursory survey yielded several gems that implement\nthis workflow. Unfortunately, none seemed to fit my (rather exacting)\npreferences for being minimal, opinionated, and well-encapsulated. And\nregardless, authentication is one area of your app that’s worth understanding\nand owning—it’s so critical that if it ever breaks, you’ll want to be in total\ncontrol over fixing it.</p>\n<p>When “gem shopping” fails to yield an immediate answer, I like to sketch out my\nideal gem API. The goal isn’t necessarily to plan to build a new gem (though it\n<a href=\"https://blog.testdouble.com/talks/2021-11-10-how-to-make-a-gem-of-a-gem/\">might explain</a> why I end up\nmaking so many of them), but rather to validate whether a sound gem API <em>could\nexist at all</em> in the context of a Rails app. The more Rails features that a gem\ninterfaces with, the less encapsulated its API could possibly be and—even if\n<a href=\"https://api.rubyonrails.org/classes/Rails/Railtie.html\">Railties</a> exposed every\nnecessary extension point—the more magical and mysterious the gem’s API would\nseem to users.</p>\n<p>Consider all of the headline features of Rails that an email-based passwordless\nauthentication workflow would need to touch:</p>\n<ul>\n<li>Active Record for persisting an authentication token and its expiration to the\ndatabase</li>\n<li>Action Dispatch for setting up routing to a login form, submission action,\nauthentication handler, and logout path</li>\n<li>Action Controller for implementing the above actions, the requisite session\nmanagement, and for setting up a general <code>before_action</code> filter to ensure\nusers are logged in (or else redirected to a login page)</li>\n<li>Action View for rendering the form and the email</li>\n<li>Active Job for <a href=\"https://guides.rubyonrails.org/action_mailer_basics.html#calling-the-mailer\">deferring the\ndelivery</a>\nof emails until after the HTTP response is complete</li>\n<li>Action Mailer for sending emails</li>\n</ul>\n<p>Wow, authentication features depend on a <em>lot</em> of Rails APIs to do their job!\nAlmost every border between our app and the outside world is crossed at some\npoint.</p>\n<p>Just try to imagine a gem that could implement all of this for us while\nproviding a straightforward API made up of simple methods and boring return\nvalues. Now think about how it might gracefully handle every permutation of\napplication configuration: alternative templating languages, non-relational\ndatabases, non-default session stores… maintenance would be a nightmare! By\nthese standards, a “good” library may not even be possible.</p>\n<p>By the end of this exercise, I was confident in my conviction that rolling my\nown authentication code would be outright better than relying on a dependency,\nno matter how well-designed.</p>\n\n\n\n<h2 id=\"how-would-we-build-this\">\n  \n    <a class=\"heading-anchor\" href=\"#how-would-we-build-this\">How would we build this?</a>\n  \n</h2>\n<p>Authentication features are often better imagined as a workflow of discrete\nsteps rather than as a spatial arrangement of components, because the process\nnecessarily spans multiple HTTP requests, emails, and user actions.</p>\n<p>So what might that workflow look like?</p>\n<ol>\n<li>\n<p>A controller filter detects a request isn’t authenticated and redirects the\nuser to a login form</p>\n</li>\n<li>\n<p>The user types in their email and clicks “Sign in” or “Create Account”</p>\n</li>\n<li>\n<p>The system sends an email with a magic link by:</p>\n<ol>\n<li>Matching the email address to the corresponding user (or else creating a\nnew one)</li>\n<li>Generating a secure token and persisting it alongside an expiry timestamp</li>\n<li>Delivering an email with a link that includes the token as a query\nparameter</li>\n</ol>\n</li>\n<li>\n<p>The user opens the email and clicks the link</p>\n</li>\n<li>\n<p>The authentication action looks up the user by the token and, if it’s valid,\nassigns their ID to a session variable</p>\n</li>\n</ol>\n<p>As with any feature, there are numerous other complications we could choose to\neither implement or defer along the way. Maybe we want to pass a redirect path\nalong with the token so the user will be directed to the page they were\noriginally trying to access when they were prompted to sign in. Or we could\nmitigate a denial of service attack vector by rate-limiting the number of emails\nthe system will send. Or we might first check that the user doesn’t have an\nexisting non-expired token before generating a new one—that way, they’d receive\nthe same valid magic link across multiple emails.</p>\n<p>Rather than get too in the weeds with complications, let’s start building a\nstraightforward version of this feature and take things one step at a time.</p>\n<p>The code snippets in this blog post have been gently edited for readability, so\nwe’ve published an example app where you can see everything plugged together in\n<a href=\"https://github.com/testdouble/magic_email_demo\">testdouble/magic_email_demo</a> on\nGitHub.</p>\n\n\n\n<h2 id=\"ensuring-users-are-logged-in-with-a-before_action-filter\">\n  \n    <a class=\"heading-anchor\" href=\"#ensuring-users-are-logged-in-with-a-before_action-filter\">Ensuring users are logged in with a <code>before_action</code> filter</a>\n  \n</h2>\n<p>Our very first step will be to require users to be signed in by adding a\ncontroller filter that checks the session (by default encrypted by\n<a href=\"https://api.rubyonrails.org/classes/ActionDispatch/Session/CookieStore.html\">CookieStore</a>)\nfor a previously-authenticated user ID.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>class</span> <span>ApplicationController</span> <span>&lt;</span> <span>ActionController</span><span>::</span><span>Base</span>\n  before_action <span>:require_login</span>\n\n  <span>def</span> <span>require_login</span>\n    @current_user <span>=</span> <span>User</span><span>.</span>find_by(id: session<span>[</span><span>:user_id</span><span>]</span>)\n    <span>return</span> <span>if</span> @current_user<span>.</span>present?\n\n    redirect_to new_login_email_path(\n      <span>redirect_path</span>: request<span>.</span>original_fullpath\n    )\n  <span>end</span>\n<span>end</span>\n</code></pre></div><p>Reading the method, you might notice the <code>require_login</code> filter performs two\nunrelated tasks. First, it sets a <code>@current_user</code> instance variable for use by\nthe controller action. Second, if no <code>User</code> was found, no one is logged in\nand therefore the request should be considered unauthorized, so the user is\nredirected to a login form. To ensure we direct the user to the page they\nintended to visit, we do one last sneaky thing by appending\n<code>request.original_fullpath</code> to a query param named <code>redirect_path</code>, which we’ll\nultimately append to the magic link we email the user.</p>\n<div class=\"aside-wrap\">\n  <p class=\"aside\">By choosing to make authentication required by default across the application,\nwe won’t run the risk of allowing unauthenticated users to access privileged\nareas of the app in the event we forget to sprinkle in a <code>before_action</code> at the\ntop</p>\n</div>\n\n<p>Because the above filter will run for <em>every single controller action</em> in our\napplication, the user’s browser would be repeatedly redirected to the same\n<code>new_login_email_path</code> unless that path’s corresponding controller action\nskipped the <code>require_login</code> filter. So while we’re here, let’s add a convenience\nmethod to allow controllers to opt out of the authentication requirement:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>def</span> <span>self</span><span>.</span><span>logged_out_users_welcome!</span>\n  skip_before_action <span>:require_login</span>\n<span>end</span>\n</code></pre></div>\n\n\n<h2 id=\"creating-a-login-form-without-a-password-field\">\n  \n    <a class=\"heading-anchor\" href=\"#creating-a-login-form-without-a-password-field\">Creating a login form without a password field</a>\n  \n</h2>\n<p>Designing a great login form is <a href=\"https://blog.codinghorror.com/the-god-login/\">notoriously\ndifficult</a>, but passwordless\nemail-based authentication will let us eliminate one field, at least.</p>\n<p>To start, that <code>new_login_email_path</code> method isn’t defined yet. We can demand it\ninto existence in <code>config/routes.rb</code> with:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>Rails</span><span>.</span>application<span>.</span>routes<span>.</span>draw <span>do</span>\n  resource <span>:login_email</span>\n  <span># …</span>\n<span>end</span>\n</code></pre></div><p>And create a corresponding controller in <code>login_emails_controller.rb</code> with a\n<code>new</code> action that grabs the <code>redirect_path</code> parameter:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>class</span> <span>LoginEmailsController</span> <span>&lt;</span> <span>ApplicationController</span>\n  logged_out_users_welcome!\n\n  <span>def</span> <span>new</span>\n    @redirect_path <span>=</span> params<span>[</span><span>:redirect_path</span><span>]</span>\n  <span>end</span>\n<span>end</span>\n</code></pre></div><p><em><strong>[Heads up:</strong> Rails 7 defaults to raising an error when redirecting to an\nexternal domain. This prevents our <code>redirect_path</code> parameter from being\nmanipulated by a malicious actor to mislead a user. You should make sure\n<a href=\"https://edgeguides.rubyonrails.org/configuring.html#config-action-controller-raise-on-open-redirects\">config.action_controller.raise_on_open_redirects</a>\nis enabled.<strong>]</strong></em></p>\n<p>From here, we can start a <code>new.html.erb</code> form in <code>views/login_emails</code>:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-fallback\">&lt;%= form_with url: login_email_path do |f| %&gt;\n  &lt;%= f.hidden_field :redirect_path, value: @redirect_path %&gt;\n  &lt;%= f.email_field :email, placeholder: &quot;human@example.com&quot; %&gt;\n  &lt;%= f.submit &quot;Send Login Link&quot; %&gt;\n&lt;% end %&gt;\n</code></pre></div><p>In our (slightly more styled) <a href=\"https://github.com/testdouble/magic_email_demo\">sample\napp</a>, that form looks something\nlike this:</p>\n<img src=\"https://cdn-blog.testdouble.com/img/passwordless/form.3f152de08ad4cd8f5d4bc8dfd06486c9212c1622f262c563235bf156f5202364.png\" alt=\"Our simple one-field login form\">\n\n<p>When a user enters an email address and submits the form, the <code>create</code> action\nof our controller will be invoked, so we’ll write that next.</p>\n\n\n\n<h2 id=\"handling-the-form-submission\">\n  \n    <a class=\"heading-anchor\" href=\"#handling-the-form-submission\">Handling the form submission</a>\n  \n</h2>\n<p>Here’s what the <code>create</code> action looks like in <code>LoginEmailsController</code>:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>def</span> <span>create</span>\n  <span>EmailAuth</span><span>::</span><span>EmailsLink</span><span>.</span>new<span>.</span>email(\n    <span>email</span>: params<span>[</span><span>:email</span><span>]</span>,\n    <span>redirect_path</span>: params<span>[</span><span>:redirect_path</span><span>]</span>\n  )\n  flash<span>[</span><span>:notice</span><span>]</span> <span>=</span> <span>&quot;E-mail sent to </span><span>#{</span>params<span>[</span><span>:email</span><span>]</span><span>}</span><span> (probably!)&quot;</span>\n  redirect_to login_email_path\n<span>end</span>\n</code></pre></div><div class=\"aside-wrap\">\n  <p class=\"aside\">The <code>login_email_path</code> just renders a <a href=\"https://github.com/testdouble/magic_email_demo/blob/main/app/views/login_emails/show.html.erb\">simple HTML\npage</a>\ninstructing users to check their email.</p>\n</div>\n\n<p>Granted, the <a href=\"https://blog.testdouble.com/talks/2017-05-11-how-to-program/\">way I program</a> in Rails is\nidiosyncratic, but hopefully it’s clear enough:</p>\n<ul>\n<li><code>EmailAuth</code> is a namespace under <code>app/lib</code> where we’ll put as much of this\nfeature’s behavior as can be separated from Rails constructs like controllers\nand mailers</li>\n<li><code>EmailsLink</code> is a verb-first class name, which is a practice I follow to\ndifferentiate objects implementing features from objects encapsulating data\nvalues</li>\n<li>The <code>EmailsLink#email</code> method does just that: emails the given address a magic\nlink. I try to separate <a href=\"https://en.wikipedia.org/wiki/Command%E2%80%93query_separation\">command and query\nmethods</a> when\npossible, which is why—as a command—the method doesn’t return a meaningful\nvalue</li>\n</ul>\n<p>I often talk about immediately searching for an “escape hatch” when writing\nRails controller actions. Controllers agglomerate so many disparate concerns on\ntheir own that adding custom application logic to an action very often leads to\nmingling feature behavior with controller specifics like <code>session</code>, <code>params</code>,\nand <code>response</code>. Once this happens, it can be extraordinarily difficult to\nextract the resulting procedural code into plain ol' Ruby objects (“POROs”). By\nimmediately delegating to <code>EmailsLink</code> before giving the feature a second\nthought, we can make sure to avoid that outcome.</p>\n<div class=\"aside-wrap\">\n  <p class=\"aside\">While these examples are shared in order, I actually wrote this feature working\noutside in by practicing what I call “<a href=\"https://blog.testdouble.com/talks/2015-09-10-how-i-use-test-doubles/\">Discovery\nTesting</a>”\nto test-drive a design for <code>EmailsLink</code> by imagining all of the dependencies it\nmight need specifying those interactions using our\n<a href=\"https://github.com/testdouble/mocktail\">Mocktail</a> gem before I implemented any\nof the feature’s actual behavior. If you’re interested, check out the\n<a href=\"https://github.com/testdouble/magic_email_demo/blob/main/test/lib/email_auth/emails_link_test.rb\">EmailsLinkTest\nsource</a>\nand work outside-in.</p>\n</div>\n\n<p>Now that we have our entry point defined, let’s go to work and figure out how to\ngenerate magic links!</p>\n\n\n\n<h3 id=\"finding-or-creating-a-user-for-the-given-email-address\">\n  \n    <a class=\"heading-anchor\" href=\"#finding-or-creating-a-user-for-the-given-email-address\">Finding (or creating) a user for the given email address</a>\n  \n</h3>\n<p>In this simple example, we’re going to let anyone create an account with any\nemail address. If the provided address matches a <code>User</code> record, we’ll return it;\notherwise we’ll create a new one. (We probably wouldn’t normally design a form\nthat made it <em>quite</em> so easy to accidentally persist new users in production,\nhowever.)</p>\n<p>Let’s start by making our <code>EmailsLink</code> entry point real:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>module</span> EmailAuth\n  <span>class</span> <span>EmailsLink</span>\n    <span>def</span> <span>email</span>(<span>email</span>:, <span>redirect_path</span>:)\n    <span>end</span>\n  <span>end</span>\n<span>end</span>\n</code></pre></div><p>Because this object’s role is to orchestrate several tasks needed to send or\ngenerate an email with a magic link, let’s proactively push the implementation\nof any of those behaviors into first-class objects in their own right. Let’s\nstart with something responsible for pairing up email addresses with user\nmodels.</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>module</span> EmailAuth\n  <span>class</span> <span>EmailsLink</span>\n    <span>def</span> <span>initialize</span>\n      @finds_or_creates_user <span>=</span> <span>FindsOrCreatesUser</span><span>.</span>new\n    <span>end</span>\n\n    <span>def</span> <span>email</span>(<span>email</span>:, <span>redirect_path</span>:)\n      user <span>=</span> @finds_or_creates_user<span>.</span>find_or_create(email)\n    <span>end</span>\n  <span>end</span>\n<span>end</span>\n</code></pre></div><p>The best place to think of a class or method name is inside the thing that needs\nto use it, because there’s no place where it’s more important for the\nnames we choose to make sense. And there’s no easier way to validate that a new\nmethod’s parameters and return value are workable.</p>\n<p>Since this is the only way to create users in my app, it makes sense to give it\nan easy-to-find name like <code>FindsOrCreatesUser</code>. Because the class name says what\nthe object does, the method name is uselessly redundant. In some apps, I’ll name\neach method <code>call</code> so it quacks like a\n<a href=\"https://docs.ruby-lang.org/en/3.1/Proc.html\">Proc</a>. In this app, I gave each\nmethod a descriptive name instead, in case I later choose to collapse multiple\nsmall classes into a larger one.</p>\n<p>Here’s <code>FindsOrCreatesUser</code>’s implementation:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>module</span> EmailAuth\n  <span>class</span> <span>FindsOrCreatesUser</span>\n    <span>def</span> <span>find_or_create</span>(email)\n      user <span>=</span> <span>User</span><span>.</span>find_or_create_by(\n        <span>email</span>: email<span>.</span>strip<span>.</span>downcase\n      )\n      <span>if</span> user<span>.</span>persisted?\n        user\n      <span>end</span>\n    <span>end</span>\n  <span>end</span>\n<span>end</span>\n</code></pre></div><p>Most of the heavy lifting here is done by <code>ActiveRecord::Relation</code>’s handy\n<a href=\"https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_create_by\">find_or_create_by</a>\nmethod, of course. Because we are calling the\n<a href=\"https://twitter.com/searls/status/1582475257926934530?s=20&amp;t=usysYF6_D7F76j4fuwSCOg\">bangless</a>\nversion of the method (as opposed to\n<a href=\"https://api.rubyonrails.org/classes/ActiveRecord/Relation.html#method-i-find_or_create_by!\">find_or_create_by!</a>),\nit will actually return an invalid unpersisted model if an email address is\nmalformed. We want this object to return <code>nil</code> in that case, which is why we\nneed the <code>persisted?</code> check.</p>\n\n\n\n<h3 id=\"generating-an-authentication-token\">\n  \n    <a class=\"heading-anchor\" href=\"#generating-an-authentication-token\">Generating an authentication token</a>\n  \n</h3>\n<p>With that implemented, we can return to <code>EmailsLink</code> and think about our next\nrequirement:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>module</span> EmailAuth\n  <span>class</span> <span>EmailsLink</span>\n    <span>def</span> <span>initialize</span>\n      @finds_or_creates_user <span>=</span> <span>FindsOrCreatesUser</span><span>.</span>new\n      @generates_token <span>=</span> <span>GeneratesToken</span><span>.</span>new\n    <span>end</span>\n\n    <span>def</span> <span>email</span>(<span>email</span>:, <span>redirect_path</span>:)\n      <span>return</span> <span>unless</span> (user <span>=</span> @finds_or_creates_user<span>.</span>find_or_create(email))\n\n      token <span>=</span> @generates_token<span>.</span>generate(user)\n    <span>end</span>\n  <span>end</span>\n<span>end</span>\n</code></pre></div><div class=\"aside-wrap\">\n  <p class=\"aside\">Tastes vary on how densely-packed this is, but note that we turned our\n<code>find_or_create</code> assignment into a guard clause by prepending <code>return unless</code>.\nThis will effectively bail out when an invalid email address is submitted.</p>\n</div>\n\n<p>Following the same pattern, we added a dependency named <code>GeneratesToken</code> that\ntakes a user. Here’s its implementation:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>module</span> EmailAuth\n  <span>class</span> <span>GeneratesToken</span>\n    <span>TOKEN_SHELF_LIFE</span> <span>=</span> <span>30</span>\n\n    <span>def</span> <span>generate</span>(user)\n      <span>unless</span> user<span>.</span>auth_token<span>.</span>present? <span>&amp;&amp;</span> user<span>.</span>auth_token_expires_at<span>.</span>future?\n        user<span>.</span>update!(\n          <span>auth_token</span>: <span>SecureRandom</span><span>.</span>urlsafe_base64,\n          <span>auth_token_expires_at</span>: <span>TOKEN_SHELF_LIFE</span><span>.</span>minutes<span>.</span>from_now\n        )\n      <span>end</span>\n      user<span>.</span>auth_token\n    <span>end</span>\n  <span>end</span>\n<span>end</span>\n</code></pre></div><p>If a user already has an unexpired authentication token, <code>generate</code> will simply\nreturn it. Otherwise, it will save a new token and an expiration timestamp set\nthirty minutes in the future.</p>\n<p>If you’ve never used\n<a href=\"https://docs.ruby-lang.org/en/3.1/SecureRandom.html\">SecureRandom</a> before, it’s\na super convenient way to generate immediately-useful cryptographically-secure\nvalues by relying on <code>openssl</code> or the underlying operating system as opposed to\nRuby’s internal <a href=\"https://docs.ruby-lang.org/en/3.1/Random.html\">Random class</a>.</p>\n\n\n\n<h3 id=\"delivering-an-email-with-a-magic-link\">\n  \n    <a class=\"heading-anchor\" href=\"#delivering-an-email-with-a-magic-link\">Delivering an email with a magic link</a>\n  \n</h3>\n<p>We now have what we need to send an email that can enable users to log into the\nsystem. Let’s update our <code>EmailsLink</code> class to depend on a newly-imagined\ndependency to handle this for us:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>module</span> EmailAuth\n  <span>class</span> <span>EmailsLink</span>\n    <span>def</span> <span>initialize</span>\n      @finds_or_creates_user <span>=</span> <span>FindsOrCreatesUser</span><span>.</span>new\n      @generates_token <span>=</span> <span>GeneratesToken</span><span>.</span>new\n      @delivers_email <span>=</span> <span>DeliversEmail</span><span>.</span>new\n    <span>end</span>\n\n    <span>def</span> <span>email</span>(<span>email</span>:, <span>redirect_path</span>:)\n      <span>return</span> <span>unless</span> (user <span>=</span> @finds_or_creates_user<span>.</span>find_or_create(email))\n\n      @delivers_email<span>.</span>deliver(\n        <span>user</span>: user,\n        <span>token</span>: @generates_token<span>.</span>generate(user),\n        <span>redirect_path</span>: redirect_path\n      )\n    <span>end</span>\n  <span>end</span>\n<span>end</span>\n</code></pre></div><p>Above, <code>DeliversEmail#deliver</code> takes the keyword arguments the email template\nwill be interested in. (As a command method, any return value is incidental.) I\ndecided to pass the <code>token</code> separately as opposed to expecting the mailer to\nknow that the token is persisted as part of a <code>User</code> record, since that’s an\nimplementation detail that could reasonably change (in keeping with the spirit\nof the <a href=\"https://blog.testdouble.com/posts/2022-06-15-law-of-demeter/\">Law of Demeter</a>).</p>\n<p>If you have an allergy to very small classes, you may experience a reaction to\nthe implementation of <code>DeliversEmail</code>, however:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>module</span> EmailAuth\n  <span>class</span> <span>DeliversEmail</span>\n    <span>def</span> <span>deliver</span>(<span>user</span>:, <span>token</span>:, <span>redirect_path</span>:)\n      <span>LoginLinkMailer</span><span>.</span>with(\n        <span>user</span>: user,\n        <span>token</span>: token,\n        <span>redirect_path</span>: redirect_path\n      )<span>.</span>login_link<span>.</span>deliver_later\n    <span>end</span>\n  <span>end</span>\n<span>end</span>\n</code></pre></div><p>Personally, I don’t mind this indirection. The <a href=\"https://guides.rubyonrails.org/action_mailer_basics.html\">Action Mailer\nAPI</a> has always felt\nawkward to use. Messages are defined as instance methods but invoked as class\nmethods. There are multiple ways to assign arguments. Calling <code>deliver_now</code> is\nalmost always wrong, but so is expecting every developer to remember as much\neach time they invoke a mailer. So if a little wrapper object can provide a\nbetter experience to the method’s caller, I’d take that deal.</p>\n<p>The mailer itself mostly shovels its params to its view, since the bulk of the\nwork has been done already in our POROs (<code>FindsOrCreatesUser</code> and\n<code>GeneratesToken</code>):</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>class</span> <span>LoginLinkMailer</span> <span>&lt;</span> <span>ApplicationMailer</span>\n  <span>def</span> <span>login_link</span>\n    @user <span>=</span> params<span>[</span><span>:user</span><span>]</span>\n    @token <span>=</span> params<span>[</span><span>:token</span><span>]</span>\n    @redirect_path <span>=</span> params<span>[</span><span>:redirect_path</span><span>]</span>\n\n    mail(\n      <span>to</span>: @user<span>.</span>email,\n      <span>subject</span>: <span>&quot;Your Magic Login Link&quot;</span>\n    )\n  <span>end</span>\n<span>end</span>\n</code></pre></div><p>Speaking of the view, <code>login_link.html.erb</code> is also simple and straightforward:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-fallback\">&lt;h1&gt;Hello!&lt;/h1&gt;\n&lt;p&gt;\n  Here is your\n  &lt;%= link_to &quot;link to login&quot;,\n    login_emails_authenticate_url(\n      token: @token,\n      redirect_path: @redirect_path\n    )\n  %&gt;.\n  It expires in &lt;%= EmailAuth::GeneratesToken::TOKEN_SHELF_LIFE %&gt; minutes.\n&lt;/p&gt;\n</code></pre></div><p>Importantly, when calling a <code>_url</code> helper, Rails needs to know the correct\nprotocol, domain, and port to prefix to the path. This is exposed in Action\nMailer’s configuration and is often handled separately for each environment.</p>\n<p>In <code>config/development.rb</code>, I point to <code>localhost:3000</code> since that’s where the\nserver is bound by default:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\">config<span>.</span>action_mailer<span>.</span>default_url_options <span>=</span> {\n  <span>host</span>: <span>&quot;localhost&quot;</span>,\n  <span>port</span>: <span>&quot;3000&quot;</span>\n}\n</code></pre></div><p>And in <code>config/test.rb</code>, I specify only what I need to in order to give my\ntests something to assert against:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\">config<span>.</span>action_mailer<span>.</span>default_url_options <span>=</span> {\n  <span>host</span>: <span>&quot;example.com&quot;</span>\n}\n</code></pre></div>\n\n\n<h2 id=\"opening-the-email-and-clicking-the-link\">\n  \n    <a class=\"heading-anchor\" href=\"#opening-the-email-and-clicking-the-link\">Opening the email and clicking the link</a>\n  \n</h2>\n<p>By default, emails will be printed to the log in development, but keeping an eye\non a terminal to scan and copy-paste a carefully-coiffed URL inside an HTML\nemail is tedious, time-consuming, and a poor approximation of a real user’s\nexperience. At the same time, setting up actually-working-for-real email\ndelivery in development is more trouble than it’s worth.</p>\n<div class=\"aside-wrap\">\n  <p class=\"aside\">Normally, I use Action Mailer’s built-in <a href=\"https://guides.rubyonrails.org/action_mailer_basics.html#previewing-emails\">preview\nfeature</a>\nfor inspecting emails generated by my app, but because each email contains a\ntime-sensitive URL with a unique token that determines who gets logged in, it\nisn’t a good fit for opening an email as a step in a workflow.</p>\n</div>\n\n<p>That’s what led me to pull in the\n<a href=\"https://github.com/ryanb/letter_opener\">letter_opener</a> gem for the first time.\nSimply add the gem to your Gemfile’s <code>:development</code> group and sprinkle two more\nlines into your <code>config/development.rb</code>:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\">config<span>.</span>action_mailer<span>.</span>delivery_method <span>=</span> <span>:letter_opener</span>\nconfig<span>.</span>action_mailer<span>.</span>perform_deliveries <span>=</span> <span>true</span>\n</code></pre></div><p>As soon as <code>letter_opener</code> is wired up, any emails sent by the system will be\ninstantly opened in a new browser tab, both saving time and displaying what the\nrendered HTML will look like:</p>\n<img src=\"https://cdn-blog.testdouble.com/img/passwordless/letter_opener.f0d29534c38243a2ad17fd54c53a927989d51bbe34a9e213f03846a0ceaaa37d.png\" alt=\"An email preview in Safari\">\n\n<p>Because this feature is composed of so many steps, it’s worth pausing at each\npoint to validate that the parameters are being sent correctly before we move\nonto the next step. To verify the URL in the email, I first visited\n<a href=\"http://localhost:3000/numbers?count=8\">localhost:3000/numbers?count=8</a>, allowed\nmyself to be redirected, and then submitted the login form.</p>\n<p>Here’s the URL that was contained in the email’s link:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-fallback\">http://localhost:3000/login_emails/authenticate?redirect_path=%2Fnumbers%3Fcount%3D8&amp;token=EnJBIJKJczC0jI4sBMwMPg\n</code></pre></div><p>Valid-looking <code>token</code>? Check. URL-encoded <code>redirect_path</code> seem right? Check.</p>\n\n\n\n<h2 id=\"authenticating-a-login-request\">\n  \n    <a class=\"heading-anchor\" href=\"#authenticating-a-login-request\">Authenticating a login request</a>\n  \n</h2>\n<p>Good news! It’s time to authenticate that a user’s request includes a valid\ntoken and assign them to a session. Because we’ve eschewed a typical login\nform, we won’t be responding to an HTTP POST request with a corresponding\n<code>create</code> action. (And because email clients don’t execute JavaScript, we can’t\n<a href=\"https://guides.rubyonrails.org/working_with_javascript_in_rails.html#method\">trick them into sending a\nPOST</a>\nwhen clicking that link, either.)</p>\n<p>Instead, let’s add a custom route to our existing controller that can respond to\nboth GET and POST requests and name both the path fragment and the action\n<code>authenticate</code>:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>Rails</span><span>.</span>application<span>.</span>routes<span>.</span>draw <span>do</span>\n  match <span>&quot;login_emails/authenticate&quot;</span>, <span>to</span>: <span>&quot;login_emails#authenticate&quot;</span>, <span>via</span>: <span>[</span><span>:get</span>, <span>:post</span><span>]</span>\n  resource <span>:login_email</span>\n  <span># …</span>\n<span>end</span>\n</code></pre></div><p>And here’s that <code>authenticate</code> action’s implementation:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>class</span> <span>LoginEmailsController</span> <span>&lt;</span> <span>ApplicationController</span>\n  <span># …</span>\n  <span>def</span> <span>authenticate</span>\n    result <span>=</span> <span>EmailAuth</span><span>::</span><span>ValidatesLoginAttempt</span><span>.</span>new<span>.</span>validate(params<span>[</span><span>:token</span><span>]</span>)\n    <span>if</span> result<span>.</span>success?\n      reset_session\n      session<span>[</span><span>:user_id</span><span>]</span> <span>=</span> result<span>.</span>user<span>.</span>id\n      flash<span>[</span><span>:notice</span><span>]</span> <span>=</span> <span>&quot;Welcome, </span><span>#{</span>result<span>.</span>user<span>.</span>email<span>}</span><span>!&quot;</span>\n      redirect_to params<span>[</span><span>:redirect_path</span><span>]</span>\n    <span>else</span>\n      flash<span>[</span><span>:error</span><span>]</span> <span>=</span> <span>&quot;We weren't able to log you in with that link. Try again?&quot;</span>\n      redirect_to new_login_path(<span>redirect_path</span>: params<span>[</span><span>:redirect_path</span><span>]</span>)\n    <span>end</span>\n  <span>end</span>\n<span>end</span>\n</code></pre></div><div class=\"aside-wrap\">\n  <p class=\"aside\">If you’re familiar with <a href=\"https://guides.rubyonrails.org/security.html#sessions\">session\nmanagement</a> in Rails,\nthis should be familiar. Because the response ends by redirecting to the user’s\noriginally-intended path, that request will run our <code>require_login</code> filter,\nwhich will, in turn, use <code>session[:user_id]</code> to populate a <code>@current_user</code>\ninstance variable for each subsequent request.</p>\n</div>\n\n<p>There’s a reason this is the application’s longest method in any class that\nextends a Rails type: every single thing it does must be invoked from a\ncontroller: <code>reset_session</code>, <code>session</code>, <code>flash[]</code>, and <code>redirect_to</code>. There’s\nenough going on here to make me glad for my “escape hatch” strategy of\nimplementing feature logic someplace outside the controller itself.</p>\n<p>With that in mind, let’s take a look at <code>ValidatesLoginAttempt</code> referenced\nabove:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>module</span> EmailAuth\n  <span>class</span> <span>ValidatesLoginAttempt</span>\n    <span>Result</span> <span>=</span> <span>Struct</span><span>.</span>new(<span>:success?</span>, <span>:user</span>, <span>keyword_init</span>: <span>true</span>)\n\n    <span>def</span> <span>validate</span>(token)\n      user <span>=</span> <span>User</span><span>.</span>where(<span>auth_token</span>: token)\n        <span>.</span>where(<span>&quot;auth_token_expires_at &gt; ?&quot;</span>, <span>Time</span><span>.</span>zone<span>.</span>now)\n        <span>.</span>first\n\n      <span>if</span> user<span>.</span>present?\n        <span>Result</span><span>.</span>new(success?: <span>true</span>, <span>user</span>: user)\n      <span>else</span>\n        <span>Result</span><span>.</span>new(success?: <span>false</span>)\n      <span>end</span>\n    <span>end</span>\n  <span>end</span>\n<span>end</span>\n</code></pre></div><p>Fortunately, the implementation isn’t too complicated. While it does make the\nassumption that <code>SecureRandom.urlsafe_base64</code> will never return the same string\ntwice in a fifteen minute period, that’s probably a safe bet.</p>\n<p>The only pattern worth commenting on here is the declaration of a <code>Result</code>\n<a href=\"https://docs.ruby-lang.org/en/3.1/Struct.html\">Struct</a> to return a value that\ncan both indicate <code>success?</code> and identify the <code>user</code> to the caller. We could\nhave just as well conditionally returned a <code>User</code> or <code>nil</code>, but sometimes it’s\nnice to return a value that’s explicit about a query method’s outcome. Given\nthat the thing we’re writing is named “validate”, the primary response a caller\nshould expect is “yes” or “no”, and any reference to the <code>user</code> is merely\nmetadata associated with a successful response.</p>\n<p>It’s time for the moment of truth: clicking the link in the email we just sent\nand seeing if it successfully logs us in and redirects us to where we want to\ngo:</p>\n<img src=\"https://cdn-blog.testdouble.com/img/passwordless/yatta.b45ef5df51470ac5f34d8a9425e06219de4a352726851383b1fef7c5ce78fe62.png\" alt=\"A successfully authenticated page\">\n\n<p>Huzzah! We’re logged in! And our original path was successfully propagated, too!\n(Try not to think too hard about the fact that the application we’ve been\nworking so hard to protect with this authentication system apparently does\nnothing but generate colorful random numbers.)</p>\n\n\n\n<h2 id=\"allowing-users-to-log-out\">\n  \n    <a class=\"heading-anchor\" href=\"#allowing-users-to-log-out\">Allowing users to log out</a>\n  \n</h2>\n<p>Not a lot of people know this, but the most commonly-requested feature after\nimplementing a login system is to provide some way for users to log out. Let’s\nsave our product owner a step and just handle that ourselves now.</p>\n<p>In our ERB template, we can rely on the\n<a href=\"https://github.com/hotwired/turbo-rails\">turbo-rails</a> gem to make an ordinary\n<code>&lt;a&gt;</code> tag trigger an HTTP DELETE request by adding a\n<code>data-turbo-method=&quot;delete&quot;</code> attribute to the link like this:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-fallback\">&lt;%= link_to &quot;Log out&quot;, login_email_path, data: { &quot;turbo-method&quot;: :delete } %&gt;\n</code></pre></div><p><em><strong>[Heads up:</strong> this recently changed! Prior to Rails 7, this attribute would\nhave been named <code>data-method</code> and observed by\n<a href=\"https://github.com/rails/rails-ujs\">rails-ujs</a> as opposed to Turbo.<strong>]</strong></em></p>\n<p>Now that we have a link that maps to our <code>LoginEmailsController</code>’s <code>destroy</code>\naction, we can easily implement it:</p>\n<div class=\"highlight\"><pre tabindex=\"0\"><code class=\"language-ruby\"><span>class</span> <span>LoginEmailsController</span> <span>&lt;</span> <span>ApplicationController</span>\n  <span>def</span> <span>destroy</span>\n    reset_session\n    flash<span>[</span><span>:notice</span><span>]</span> <span>=</span> <span>&quot;Your account has been successfully logged out.&quot;</span>\n    redirect_to new_login_email_path\n  <span>end</span>\n  <span># …</span>\n<span>end</span>\n</code></pre></div><p>That’s it! After everything we’ve been through together, it feels nice to write\na simple three-line method as a controller action.</p>\n\n\n\n<h2 id=\"thanks-for-taking-the-time\">\n  \n    <a class=\"heading-anchor\" href=\"#thanks-for-taking-the-time\">Thanks for taking the time</a>\n  \n</h2>\n<p>Maybe you landed here because you’re interested in adding an email-based login\nfeature to your Rails app. In that case, I hope this tutorial helps you build\nyour own! Showing people how to do stuff is definitely one reason I write\nblog posts that show people how to do stuff.</p>\n<p>But there’s another reason. Why take what could have been a dozen code examples\nand instead publish a 4000 word tutorial? Because I believe code alone can never\ntell the whole story. Code as an artifact is merely a distillation of countless\nhard questions, failed experiments, and iterative tweaks that programmers must\nendure to ship working software. Behind each variable name is an expression of\nintent. Behind every if statement lies a design choice. And the more input we as\ndevelopers receive of different ways to approach planning, structuring, and\nmodifying code, the better prepared we will be for the innumerable challenges we\nencounter in this profession.</p>\n<p>Conference talks, screencasts, technical books, and blog posts like this one can\nall help us learn how to both write code and how to <em>think</em> about writing code.\nBut nothing will ever beat the real deal: practicing the craft of writing code\nyourself. At Test Double, we’ve assembled a cadre of programmers who are not\nonly excellent practitioners, but brilliant communicators, talented teachers,\nand empathetic teammates. If you find value in content like this, you wouldn’t\nbelieve how much more there is to be gained by pair-programming with a Test\nDouble agent to work alongside you in <em>your</em> team’s codebase, thinking through\nhard problems with you in real-time, and striving to get things done at a level\nof quality we can all take pride in.</p>\n<p>If that’s an experience you’d be interested in having for yourself and your\nteam, please <a href=\"https://testdouble.com/contact\">reach out to us</a> to talk about how\nTest Double might work with your company, both to build great things and to\nimprove as software engineers.</p>\n"
}