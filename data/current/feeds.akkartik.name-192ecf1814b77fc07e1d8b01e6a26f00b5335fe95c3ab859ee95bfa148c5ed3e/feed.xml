<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet  type="text/xsl" media="screen" href="/~d/styles/rss2full.xsl"?><?xml-stylesheet  type="text/css" media="screen" href="http://feeds.akkartik.name/~d/styles/itemcontent.css"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:feedburner="http://rssnamespace.org/feedburner/ext/1.0" version="2.0">
  <channel>
    <title>Kartik Agaram</title>
    <link>http://akkartik.name</link>
    <description/>
    <language>en-us</language>
    <atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="self" type="application/rss+xml" href="http://feeds.akkartik.name/kartiks-scrapbook"/><feedburner:info uri="kartiks-scrapbook"/><atom10:link xmlns:atom10="http://www.w3.org/2005/Atom" rel="hub" href="http://pubsubhubbub.appspot.com/"/><item>
      <title>Mu's neighborhood</title>
      <link>http://feeds.akkartik.name/~r/kartiks-scrapbook/~3/oUiT9EXTvm8/neighborhood</link>
      <pubDate>Sun, 13 Jun 2021 14:54:27 -0700</pubDate>
      <guid isPermaLink="false">http://akkartik.name/post/neighborhood</guid>
      <description>&lt;p&gt;
&lt;a href='/about'&gt;My goal&lt;/a&gt; for &lt;a href=&quot;https://github.com/akkartik/mu&quot;&gt;Mu&lt;/a&gt; is
software that is accountable to the people it affects. But it's been difficult
to talk to people about Mu's goals because of the sheer number of projects
that use similar words but lead to very different priorities and actions. Some
of these I like to be associated with, some &lt;span style='color:red'&gt;not so
much&lt;/span&gt;.
&lt;p&gt;
&lt;em&gt;if you care about making software accountable&lt;/em&gt;
&lt;p&gt;
&lt;!-- more --&gt;
&lt;p&gt;
There are two ways to describe the provenance of software: in terms of the
people who made it or checked it out, and in terms of its internals. The two
ways are often described with similar-sounding words.
&lt;p&gt;
On one hand, &lt;b&gt;&lt;a style='color:red' href='https://en.wikipedia.org/wiki/Trust_metric#Transitivity'&gt;trust
chaining&lt;/a&gt;&lt;/b&gt; is a way to transform trust in one person into trust in
another.
&lt;p&gt;
Trust chaining is also used to transform trust in people into trust in
artifacts. Performing arithmetic on an artifact to &lt;b&gt;verify&lt;/b&gt; a trust
relationship such as &quot;person X owns this signature&quot;.
&lt;p&gt;
On the other hand, &lt;b&gt;proofs&lt;/b&gt; convey an argument to a reader and let the
reader assess how objective and ironclad it is without needing to trust the
author.
&lt;p&gt;
Automated proofs can be checked by a computer, but are still amenable to human
readers. (Beyond automated proofs, zero-knowledge proofs are more about
verification. Conveying ownership of artifacts rather than objectivity of
knowledge. That way lie ideas like &lt;span style='color:red'&gt;proof of work&lt;/span&gt;.
I want to exclude these from my preferred notion of 'proof'. &lt;a href='/contact'&gt;Let
me know&lt;/a&gt; if you can think of a clearer word than 'proof' for my desired
category.)
&lt;p&gt;
&lt;span style='color:red'&gt;Trusted computing&lt;/span&gt; uses trust chaining to shackle
a software stack to some distant server running some arbitrary software.
(&lt;a href='https://cs.stanford.edu/people/eroberts/cs201/projects/trusted-computing/what.html'&gt;more
details&lt;/a&gt;)
&lt;p&gt;
&lt;a href='https://en.wikipedia.org/wiki/Reproducible_builds'&gt;Reproducible
builds&lt;/a&gt; are about getting some arbitrary set of software to generate
deterministic output given identical input. The build recipe acts as a proof
that a binary was generated from it.
&lt;p&gt;
&lt;a href='http://bootstrappable.org'&gt;Bootstrappable builds&lt;/a&gt; are about making
&lt;em&gt;all&lt;/em&gt; the software needed for a program available for auditing.
Including all the software needed to build it, and all the software needed to
build that, and so on. The build recipe acts as a proof that source code for
the entire supply chain is available for auditing.
&lt;p&gt;
(&lt;span style='color:red'&gt;Bootstrapping&lt;/span&gt; is about getting a compiler to
build its own source code. Such a similar term, so &lt;a href=&quot;/trusting_trust.pdf&quot;&gt;antithetical&lt;/a&gt;
to bootstrappable builds.)
&lt;p&gt;
&lt;a href='https://github.com/crev-dev/crev'&gt;Collaborative code review&lt;/a&gt; is
about getting people to sign off on software packages once source code is
available. There's no proof here, but it becomes possible to verify that some
people inspected sources and found no major issues.
&lt;p&gt;
Problems in this category:
&lt;ul&gt;
&lt;li&gt;people make mistakes; I want to verify not just what people think, but &lt;em&gt;why&lt;/em&gt;
&lt;li&gt;stacks currently grow complex faster than attempts to make them auditable
&lt;li&gt;auditability doesn't help answer people's questions about &lt;em&gt;why&lt;/em&gt; a
piece of software does something seemingly questionable
&lt;/ul&gt;
&lt;p&gt;
Even so:
&lt;ul&gt;
&lt;li&gt;some auditability is a vast improvement over none
&lt;li&gt;auditability is vastly more important for the lowest levels of the stack,
where it's more tractable to obtain
&lt;/ul&gt;
&lt;p&gt;
&lt;em&gt;if you care about bringing software closer to the people it affects&lt;/em&gt;
&lt;p&gt;
Minimalism is about building simple programs with as little code as possible,
starting from some arbitrary set of software. (&lt;a href=&quot;http://arclanguage.org&quot;&gt;example&lt;/a&gt;
&lt;a href=&quot;https://dwm.suckless.org&quot;&gt;example&lt;/a&gt; &lt;a href=&quot;https://100r.co/site/nasu.html&quot;&gt;example&lt;/a&gt;)
&lt;p&gt;
&lt;a href='https://malleable.systems'&gt;Malleable software&lt;/a&gt; or
&lt;a href='https://tcher.tech/publications/PhilipTchernavskij_PhDThesis.pdf'&gt;end-user programming&lt;/a&gt;
is about building programs to be as easy to change as they are to use.
Building atop some arbitrary set of software.
&lt;p&gt;
Problems in this category:
&lt;ul&gt;
&lt;li&gt;things (&lt;a href=&quot;https://wiki.xxiivv.com/site/uxn.html&quot;&gt;example&lt;/a&gt;) are often not
minimal or simple if you get into details (&lt;a href=&quot;https://packages.ubuntu.com/hirsute/libsdl2-2.0-0&quot;&gt;example&lt;/a&gt;)
&lt;li&gt;to permit open-ended changes you have to take control of more and more of
the stack (&lt;a href=&quot;https://medium.com/feenk/one-rendering-tree-918eae49bcff&quot;&gt;example&lt;/a&gt;)
&lt;li&gt;minimal software has a constant temptation to grow less minimal over time
(&lt;a href=&quot;https://en.wikipedia.org/wiki/Unix&quot;&gt;example&lt;/a&gt;)
&lt;/ul&gt;
&lt;p&gt;
Even so:
&lt;ul&gt;
&lt;li&gt;they can deliver a great deal of capability even if they're not perfect
&lt;/ul&gt;
&lt;p&gt;
&lt;em&gt;editorializing&lt;/em&gt;
&lt;p&gt;
I care about software that is &lt;em&gt;accountable&lt;/em&gt; to &lt;em&gt;the people it
affects&lt;/em&gt;. Both sides matter.
&lt;p&gt;
The word 'trust' provides cover for a large amount of bad behavior.
A &lt;a href='https://en.wikipedia.org/wiki/Trusted_Platform_Module'&gt;trusted platform module&lt;/a&gt;
provides trust to large companies about the hardware their &quot;intellectual
property&quot; runs on. It does not provide trust to the individual people whose
computers it inhabits.
&lt;p&gt;
Proofs work better than some cryptographic sign-off. If a trust relationship is
found to have a problem, it must be revoked wholesale. Repeated revocations
reduce confidence. If a proof is found to have a problem, it's usually easy to
patch. There are enough details to determine if things are improving.
&lt;p&gt;
Trust relationships can change. Habits can be hard to change. That contrast
implies that the result of an audit cannot be binary. It is untenable to tell
people to stop using software that grows abusive. When software does something
a person dislikes, they should be able to 1. find the sources, 2. build the
sources, 3. modify the sources at any level of granularity, and 4. feel
confident in the results of their actions.
&lt;p&gt;
It's important that this be an incremental process. Minor tweaks in response to
minor dissatisfactions aren't just first-world problems. Going through all four
steps for something minor creates confidence that one will be prepared when
major changes are needed.
&lt;p&gt;
Size matters. It can take surprisingly little code to lose this property of
&lt;em&gt;incremental accountability&lt;/em&gt;.
&lt;p&gt;
The number of zones of ownership matters. You can make incrementally accountable
software by relying on others, but not too many others. Minimizing the
dependency tree may well be more important than minimizing lines of code.
&lt;p&gt;
&lt;a href=&quot;https://github.com/akkartik/mu&quot;&gt;Mu&lt;/a&gt; is reproducible, auditable and almost
entirely incrementally accountable (property 3. above hasn't been stress-tested
much and so remains a work in progress). I flatter myself that it's difficult
to ask &quot;why&quot; questions in the form of code changes without triggering a failing
test or other error message that answers them.
&lt;p&gt;
However, Mu too has problems:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt;I have to do without many things at the moment: network support, concurrency,
files, pointing device, performance, etc., etc.
&lt;li&gt;it's unclear if this way leads to any program anybody else would find
useful enough to want to modify
&lt;/ul&gt;
&lt;p&gt;
Even so:
&lt;ul&gt;
&lt;li&gt;if it's hard to create incrementally accountable software, perhaps we
shouldn't be relying on software so much
&lt;/ul&gt;
&lt;p&gt;
&lt;em&gt;Conclusion&lt;/em&gt;
&lt;p&gt;
It's worth thinking about different pieces of software in terms of what you
give up when using them. Some points of comparison:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt;Most software: Memory safety (either directly or in build dependencies), reproducible builds, auditable builds, incremental accountability.
&lt;li&gt;&lt;a href='http://suckless.org'&gt;The suckless school&lt;/a&gt;: Memory safety, reproducible builds, auditable builds, incremental accountability.
&lt;li&gt;Rust: &lt;a href='https://users.rust-lang.org/t/testing-out-reproducible-builds/9758'&gt;reproducible builds&lt;/a&gt;, auditable builds, incremental accountability.
&lt;li&gt;&lt;a href=&quot;http://bootstrappable.org/projects/mes.html&quot;&gt;bootstrappable&lt;/a&gt;: Memory safety, incremental accountability.
&lt;li&gt;&lt;a href=&quot;https://wiki.xxiivv.com/site/uxn.html&quot;&gt;Uxn&lt;/a&gt;: Memory safety, large screen, lots of RAM, reproducible builds. (Incremental accountability seems less important when programs are so tiny.)
&lt;li&gt;&lt;a href='https://github.com/akkartik/mu/tree/main/linux'&gt;Mu on Linux&lt;/a&gt;: Graphics, some memory safety and incremental accountability (Linux dependency), portability
&lt;li&gt;&lt;a href=&quot;https://github.com/akkartik/mu&quot;&gt;Mu&lt;/a&gt;: Networking, concurrency, files, performance, portability.
&lt;/ul&gt;
&lt;p&gt;
Thank you for reading. Here's a screenshot of a Mu program I made for my kids
today: &quot;chessboard with rainbows&quot;.
&lt;p&gt;
&lt;img style='width:100%; margin-bottom:1em' src='/images/20210613-mu-bowboard.png'&gt;
&lt;p&gt;
&lt;span class='btw'&gt;(This post was inspired by &lt;a href='https://www.ribbonfarm.com/you-are-here'&gt;Ribbonfarm's
periodic maps&lt;/a&gt;.)&lt;img src=&quot;http://feeds.feedburner.com/~r/kartiks-scrapbook/~4/oUiT9EXTvm8&quot; height=&quot;1&quot; width=&quot;1&quot; alt=&quot;&quot;/&gt;</description>
    <feedburner:origLink>http://akkartik.name/blog/neighborhood</feedburner:origLink></item>
    <item>
      <title>The Mu Computer in 2020</title>
      <link>http://feeds.akkartik.name/~r/kartiks-scrapbook/~3/zrAWWYbnaa8/mu-2020</link>
      <pubDate>Wed, 30 Dec 2020 15:41:14 -0800</pubDate>
      <guid isPermaLink="false">http://akkartik.name/post/mu-2020</guid>
      <description>&lt;p&gt;
&lt;div style='margin-left:3em'&gt;
&lt;span class='left_quote_char'&gt;&amp;ldquo;&lt;/span&gt;&lt;em&gt;There are two ways of constructing
software. One way is to make it so simple that there are obviously no deficiencies,
and the other way is to make it so complicated that there are no obvious
deficiencies. The first method requires a willingness to accept limitations,
and to compromise when conflicting objectives cannot be met.&amp;rdquo;&lt;/em&gt;
&lt;br&gt;&amp;mdash; &lt;a href='http://worrydream.com/refs/Hoare%20-%20The%20Emperors%20Old%20Clothes.pdf'&gt;C.
A. R. Hoare&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
It seems to me that modern computers trap people in a vicious cycle. Compatibility
guarantees breed complexity over time as the world changes. Complexity is
managed by introducing layers of abstraction. Abstractions introduce new
compatibility guarantees. Over the decades this vicious cycle leads to even
professional programmers understanding only a tiny fraction of the software
infrastructure that runs their computers. As a result, our world is increasingly
captured by software that is unaccountable to people.
&lt;p&gt;
For several years now I've had &lt;a href='/about'&gt;a vision&lt;/a&gt; for a computer
that allows anyone to audit its inner workings, where any operation can be
decomposed strictly into a parsimonious combination of simpler operations,
terminating without cyclic dependencies or circular reasoning at some ground
level. Ideally it would do this in a way that rewards curiosity, leading to a
virtuous cycle where an order of magnitude more people grow to understand how
their computer works as they use it.
&lt;p&gt;
Nowhere in this picture are compatibility guarantees, version numbers or
forced upgrades. At any point your computer should be internally consistent
and free of known historical accidents. Even if this means upgrades are more
work and so more infrequent, and that our computers must be slower. Or do
less. That seems like a worthwhile trade for &lt;a href='https://www.youtube.com/watch?v=pW-SOdj4Kkk'&gt;a
more sustainable world&lt;/a&gt;.
&lt;p&gt;
At the start of 2020 the state of &lt;a href='https://github.com/akkartik/mu'&gt;the
Mu computer&lt;/a&gt; looked like this:
&lt;p&gt;
&lt;!-- more --&gt;
&lt;p&gt;
&lt;img src='/images/20201230-2019.png' style='width:100%; margin-bottom:1em'&gt;
&lt;p&gt;
The blue stack on the left was my current computer, without changes. The stack
on the right was a better computer using some existing pieces (blue) and some
new pieces (red). The arrow between the stacks was like a wormhole between
worlds. I was using the existing world to build the new world, but the idea
was for the new world to be self-sufficient once it was set up.
&lt;p&gt;
At the end of 2020, more details of the picture are becoming clear:
&lt;p&gt;
&lt;img src='/images/20201230-2020.png' style='width:100%; margin-bottom:1em'&gt;
&lt;p&gt;
I now have a self-sufficient computer in the middle stack that can
&lt;a href='http://akkartik.name/akkartik-convivial-20200607.pdf'&gt;rebuild itself&lt;/a&gt;
without needing much mainstream software. Since its focus is on building
itself, the currency of the realm is streams of text. An existing Linux kernel
provides clean primitives for operating on streams of text over &lt;tt&gt;stdin&lt;/tt&gt;/&lt;tt&gt;stdout&lt;/tt&gt;.
Beyond that the Mu computer fends for itself. It even has a shell, though it
doesn't look anything like Unix has taught us to expect:
&lt;p&gt;
&lt;img src='/images/20201229-mu-environment.png' style='width:100%; margin-bottom:1em'&gt;
&lt;p&gt;
It's a &lt;a href='http://worrydream.com/#!/StopDrawingDeadFish'&gt;live-updating&lt;/a&gt;
postfix environment entirely in text mode that shows the top-level evolution
of your computation (including side-effects in little fake screens) at a
glance, where you can drill down into any function call when you need more
details. Check out the &lt;a href='https://archive.org/details/@kartik_agaram'&gt;15
two-minute demos&lt;/a&gt; I made in 2020.
&lt;p&gt;
I don't represent size and complexity in my pictures above. The mainstream
stack running on our computers contains
&lt;a href='https://caseymuratori.com/blog_0031'&gt;hundreds of millions of lines of code&lt;/a&gt;,
and would look like a ball of spaghetti if we zoomed into the connections
between levels. The middle stack requires twelve million lines for the Linux
kernel, but aside from that weighs in at 50k lines of straight-line dependencies,
most of them mapping to individual instructions of machine code, two thirds of
which are comments or automated tests. (It does a lot less, of course. The
goal is to start with a sustainable stack and then preserve sustainability
properties as we thoughtfully add functionality.) Finally, the final and most
nascent stack on the right gets rid of the twelve million lines of Linux, and
can do even less at the moment. All it can do is &lt;a href='/images/20201227-256color.png'&gt;draw pixels on the screen&lt;/a&gt;
and process keystrokes.
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; No wifi, no networking.
&lt;li&gt; No file system yet, just sectors on a local disk.
&lt;li&gt; No multitouch, no touchscreen, no mouse, not even any shift key support yet.
&lt;li&gt; No graphics acceleration, no fonts, no way to print text.
&lt;li&gt; No virtual memory, no GC, not even any memory reclamation yet.
&lt;/ul&gt;
&lt;p&gt;
But it's a start. A moderately sized screen, a keyboard, gigabytes of RAM and
a guarantee of memory-safety. Let's see where 2021 leads.
&lt;p&gt;
&lt;span class='btw'&gt;(&lt;a href='https://merveilles.town/@akkartik/105467785655674076'&gt;Initial
revision on Mastodon&lt;/a&gt;.)&lt;/span&gt;&lt;img src=&quot;http://feeds.feedburner.com/~r/kartiks-scrapbook/~4/zrAWWYbnaa8&quot; height=&quot;1&quot; width=&quot;1&quot; alt=&quot;&quot;/&gt;</description>
    <feedburner:origLink>http://akkartik.name/blog/mu-2020</feedburner:origLink></item>
    <item>
      <title>Mu: The first 6 years</title>
      <link>http://feeds.akkartik.name/~r/kartiks-scrapbook/~3/pnLHSLmX5Ko/convivial-computing</link>
      <pubDate>Sun, 15 Mar 2020 22:23:46 -0700</pubDate>
      <guid isPermaLink="false">http://akkartik.name/post/convivial-computing</guid>
      <description>&lt;p&gt;
Over the last few months I've written up in one place the entire argument
for&amp;mdash;and comprehensive description of&amp;mdash;what I've been working on
since 2014. It will be published in the proceedings of the &lt;em&gt;Convivial
Computing Salon&lt;/em&gt;. From &lt;a href='https://2020.programming-conference.org/home/salon-2020#Call-for-Submissions'&gt;the
call for submissions&lt;/a&gt;:
&lt;p&gt;
&lt;blockquote style='border-left:2px #888 solid; padding-left:0.5em'&gt;
In &lt;a href='/illich.pdf'&gt;&lt;em&gt;Tools for Conviviality&lt;/em&gt; [1973]&lt;/a&gt;, Ivan Illich said, &amp;ldquo;I choose
the term &amp;lsquo;conviviality&amp;rsquo; to designate the opposite of industrial
productivity&amp;hellip; Tools foster conviviality to the extent to which they can
be easily used, by anybody, as often or as seldom as desired, for the accomplishment
of a purpose chosen by the user&amp;hellip; People need new tools to work with
rather than tools that work &amp;lsquo;for&amp;rsquo; them.&amp;rdquo;
&lt;p&gt;
We were promised bicycles for the mind, but we got aircraft carriers instead.
We believe Illich’s critique of the damage to society from technology
escalation offers a fresh perspective from which to discuss the pathologies of
modern software development, and to seek better alternatives.
&lt;/blockquote&gt;
&lt;p&gt;
An inspiring theme. My response: &lt;a href='/akkartik-convivial-20200607.pdf'&gt;&amp;ldquo;Bicycles
for the mind have to be see-through.&amp;rdquo;&lt;/a&gt; Get it? When I look over at my
bicycle I can see right through its frame. I can take in at a glance how the
mechanism works, how the pedals connect up with the wheels, and how the wheels
connect up with the brakes. And yet, when we try to build bicycles for the
mind, we resort to &amp;ldquo;hiding&amp;rdquo; and &amp;ldquo;abstraction&amp;rdquo;. I think
this analogy has a lot more power than we credit, a lot more wisdom to impart
if we only let it in. I think conviviality requires tools with exposed
mechanisms that reward curiosity.
&lt;p&gt;
I've been trying to falsify this hypothesis for 6 years. There are still large
gaps to investigate, but so far it's holding up. &lt;a href='/akkartik-convivial-20200607.pdf'&gt;Read
on &amp;rarr;&lt;/a&gt; [pdf; 25 pages]&lt;img src=&quot;http://feeds.feedburner.com/~r/kartiks-scrapbook/~4/pnLHSLmX5Ko&quot; height=&quot;1&quot; width=&quot;1&quot; alt=&quot;&quot;/&gt;</description>
    <feedburner:origLink>http://akkartik.name/blog/convivial-computing</feedburner:origLink></item>
    <item>
      <title>Mu: Sketching out a minimal system programming language</title>
      <link>http://feeds.akkartik.name/~r/kartiks-scrapbook/~3/4VFVKnAjjOE/mu-2019-2</link>
      <pubDate>Tue, 15 Oct 2019 15:18:14 -0700</pubDate>
      <guid isPermaLink="false">http://akkartik.name/post/mu-2019-2</guid>
      <description>&lt;p&gt;
&lt;a href='/post/mu-2019-1'&gt;In the previous post&lt;/a&gt;, I described what &lt;a href='https://github.com/akkartik/mu#readme'&gt;my
new hobbyist computing stack&lt;/a&gt; looks like today, and how the design decisions
seemed to accumulate inevitably from a small set of axiomatic goals. In this
post I describe some (far more speculative) future plans for Mu and try to
articulate how the design process continues to seem pre-ordained.
&lt;p&gt;
(Many of the sections below outline constraints before describing a design
that mostly fits them. This flow is inspired by &lt;a href='https://en.wikipedia.org/wiki/Notes_on_the_Synthesis_of_Form'&gt;
Christopher Alexander's &lt;em&gt;&amp;ldquo;Notes on the synthesis of form&amp;rdquo;&lt;/em&gt;&lt;/a&gt;.)
&lt;p&gt;
&lt;!-- more --&gt;
&lt;p&gt;
To recap, I plan 3 levels of languages for Mu:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; Level 1 (SubX): just the processor's instruction set with some syntax
sugar
&lt;li&gt; Level 2 (Mu): a memory-safe language
&lt;li&gt; Level 3 (TBD): an expressive high-level language
&lt;/ul&gt;
&lt;p&gt;
So far Mu has just level 1 (described in &lt;a href='/post/mu-2019-1'&gt;the
prequel&lt;/a&gt;). After writing 30k LoC in level 1, the thing I miss most is the
safety of a higher-level language. In particular, memory safety. I repeatedly
make the following kinds of errors:
&lt;p&gt;
&lt;ol&gt;
&lt;li&gt; I allocate local variables on the stack but forget to clean them up
before returning.
&lt;p&gt;
&lt;li&gt; I accidentally clobber a register in a function without first saving the
caller's version of it.
&lt;p&gt;
&lt;li&gt; I accidentally clobber memory outside the bounds of an array.
&lt;p&gt;
&lt;li&gt; I accidentally continue to hold on to a heap allocation after I've freed
it.
&lt;p&gt;
&lt;/ol&gt;
&lt;p&gt;
The first two are problems that C solves. The latter two are not. Accordingly,
level 2 will have some similarity with C but also major differences. Like C's
original goals, it's intended to be easy to translate to native machine code.
Unlike C, however:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; It is intended to &lt;em&gt;remain&lt;/em&gt; easy to translate over time. C compilers
have &lt;em&gt;optimization passes&lt;/em&gt; that have grown ever more complex and
sophisticated over time in a search for higher performance. Mu is intended to
never have an optimizer.
&lt;p&gt;
&lt;li&gt; It is intended to always be built out of lower level languages. This
imposes some tight constraints on the number of features it can have.
&lt;p&gt;
&lt;li&gt; Performance is not a priority. &lt;a href='https://cr.yp.to/qmail/qmailsec-20071101.pdf'&gt;I
want to make it safe before I make it fast.&lt;/a&gt; In particular, to keep the
translation simple, I'm willing to use run-time checks for things like
out-of-bounds memory access.
&lt;p&gt;
&lt;li&gt; To keep the translation simple, I give up mathematical notation. You
won't be able to say things like `&lt;tt&gt;a + b*c&lt;/tt&gt;` (that C compilers then
need &lt;a href=&quot;https://en.wikipedia.org/wiki/Common_subexpression_elimination&quot;&gt;CSE&lt;/a&gt;
to optimize).
&lt;p&gt;
&lt;/ul&gt;
&lt;p&gt;
Since the compiler won't optimize code, not just in the initial phase but
&lt;em&gt;ever&lt;/em&gt;, the language should allow the programmer complete control over
performance. It won't let you write utterly unsafe code (bump down to machine
code for that), but it shouldn't introduce gratuitous overheads when emitting
machine code. C started out simple to translate, but gained declarative
keywords like &lt;tt&gt;inline&lt;/tt&gt; and &lt;tt&gt;register&lt;/tt&gt; over time. I want to push
much harder than C on being easy to translate. For the most part there should
be a 1-to-1 mapping between statements and x86 instructions. Just with more
safety.
&lt;p&gt;
&amp;lsquo;Compiling&amp;rsquo; feels too pompous a word for this process. Let's call
it just &amp;lsquo;translating&amp;rsquo; instead. And it turns out to be surprisingly
constraining. If you start out with the goals stated above about the target
instruction set and how parsimonious the translation process needs to be, there
seems to be exactly one core language you can end up with.
&lt;p&gt;
&lt;em&gt;Ingredients&lt;/em&gt;
&lt;p&gt;
As hinted above, the language has to be exclusively statement-oriented. While
I &lt;a href=&quot;/post/wart&quot;&gt;prefer&lt;/a&gt; the syntax of purely expression-oriented languages,
that's something to build higher up in Mu. Not having to translate expressions
to statements avoids the need to detect common sub-expressions and so on.
&lt;p&gt;
I said above that I want instructions to map 1:1 to instructions. The x86
instruction set doesn't allow instructions to access more than one memory
location. The simplest way to work with this restriction is to make registers
explicit in our code, so that they're a constant consideration for the
programmer. Mu will be a manually register-allocated language. It will still
&lt;em&gt;check&lt;/em&gt; your register allocation and flag an error if multiple variables
overlap on the same register. But it's up to the programmer to manage registers
and spill to memory when necessary. The good news: the programmer can &lt;em&gt;really&lt;/em&gt;
optimize register use when it matters.
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
x/&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; &lt;span style='color:blue; margin-left:1em'&gt;# variable x is stored in register &lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt;&lt;/span&gt;
x &lt;span style='color:blue; margin-left:3.4em'&gt;# variable x is stored in memory
&lt;/pre&gt;
&lt;p&gt;
The language will specify types of variables. The translator need only
compare the input and output types of each statement in isolation.
&lt;p&gt;
Types allow restrictions to instructions to support memory safety. For
example, `&lt;tt&gt;add&lt;/tt&gt;` can be restricted to numbers, `&lt;tt&gt;index&lt;/tt&gt;` to
arrays, and `&lt;tt&gt;get&lt;/tt&gt;` to records (structs). All three may emit the same
instruction in machine code, but the logical semantics allow us to forbid
arbitrary pointer arithmetic.
&lt;p&gt;
In addition to types, variables can also specify their storage location:
whether they're allocated on a register, on the stack or on the data segment.
The skeleton of the translator starts to take shape now: after parsing and
type-checking, a simple dispatch loop that decides what instruction to emit
based on both the operation and where the operands are stored.
&lt;p&gt;
The one feature I miss most when programming in machine code is the ability to
declare a struct/record type and access record fields rather than numeric
offsets. Mu will have user-defined types.
&lt;p&gt;
While most Mu code will be translated 1:1 into binary, there will be a handful
of situations where instructions are inserted without any counterpart in the
sources. The list so far:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; Stack management. When I declare local variables I'd like them to be
automatically popped off the stack when exiting scope.
&lt;li&gt; Checking array bounds. Every index into an array compares with its
length. To make this check convenient, all array start with their lengths in
Mu.
&lt;li&gt; Checking pointers into the heap. Heap allocations can be reclaimed, and
we want to immediately flag dereferences to stale pointers after they've been
reclaimed.
&lt;/ul&gt;
&lt;p&gt;
This is the hazy plan. Still lots of details to work out.
&lt;p&gt;
&lt;em&gt;Milestones&lt;/em&gt;
&lt;p&gt;
Here's an outline of the broad milestones planned for Mu's eponymous level-2
language:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; Parse core syntax into some intermediate representation.
&lt;li&gt; Code-generate just instructions with integer operands, for starters.
&lt;li&gt; Variable declarations and scopes.
&lt;li&gt; User-defined types.
&lt;li&gt; Address types. We probably need them. How to make them safe?
&lt;li&gt; Addresses on the heap, and how to detect when they're reclaimed.
&lt;/ul&gt;
&lt;p&gt;
I'll sketch out the first three in this post, and then go off to build the
language with just integers. Once I'm done with it I'll flesh out the rest.
&lt;p&gt;
&lt;em&gt;Core syntax&lt;/em&gt;
&lt;p&gt;
As I said in &lt;a href='/post/mu-2019-1'&gt;the previous post&lt;/a&gt;, machine code for
any processor consists of linear sequences of instructions. These instructions
uniformly consist of an operation and some number of operands. Conceptually:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
op o1, o2, &amp;hellip;
&lt;/pre&gt;
&lt;p&gt;
Different processors impose constraints on these operands. In x86 most
instructions can take at most two operands. At most one of them can lie in
memory, and at most operand can be written to. The constraints are independent;
instructions may write to either memory or registers.
&lt;p&gt;
Machine code usually requires multiple primitive instructions to perform a
call to a user-defined function. It seems useful for primitive operations and
calls to user-defined functions to have a uniform syntax.
&lt;p&gt;
It would be nice to be able to see at a glance which operands of an instruction
are read or written.
&lt;p&gt;
Conventional Assembly languages use order to distinguish the output parameter.
However they don't support a syntax for function calls.
&lt;p&gt;
One potential syntax may be:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
o1, o2, &amp;hellip; &amp;larr; op i1, i2, &amp;hellip;
&lt;/pre&gt;
&lt;p&gt;
However, this scheme doesn't admit a clean place for operands that are both
read and written. (We'll call them &amp;lsquo;&lt;em&gt;inout&lt;/em&gt;&amp;rsquo; operands,
extrapolating from &amp;lsquo;input&amp;rsquo; and &amp;lsquo;output&amp;rsquo;.) Inout
operands are common in x86 machine code, where you can have at most two
operands:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; Add operand o1 &lt;em&gt;to&lt;/em&gt; o2;
&lt;li&gt; subtract o1 &lt;em&gt;from&lt;/em&gt; o2;
&lt;li&gt; compute the bitwise `&lt;tt&gt;AND&lt;/tt&gt;` of o1 and o2, and store the result in
o1;
&lt;li&gt; &amp;hellip;and so on.
&lt;/ul&gt;
&lt;p&gt;
User-defined functions can also have inout operands. It would be nice to
highlight them uniformly.
&lt;p&gt;
It would also be nice to see at a glance which operands are in registers, and
which are in memory.
&lt;p&gt;
However, specifying both input/output and reg/mem properties explicitly for
every single operand seems excessive, both for the implementor and for users.
&lt;p&gt;
Function calls can pass inputs and outputs either on the stack or in registers.
Typically the stack holds only input or inout operands. You &lt;em&gt;could&lt;/em&gt;
move the return address down to make some extra room to write outputs to. But
these stack manipulations take up instructions, and calls would lose a core
symmetry: it's easy and useful to check that the amount of data pushed before
a call matches the amount of data popped off after.
&lt;p&gt;
Function calls can return results in registers, but callers must always know
precisely which registers are being written. Separating output registers gives
a sense of flexibility that is false.
&lt;p&gt;
Finally, registers can't hold types larger than a single word. Larger types
need memory, and often they need to allocate this memory. If we assume memory
management is manual, it makes functions more self-contained and easy to test
if they don't do their own memory allocation. Instead the predominant idiom in
C and Assembly is for the caller to be responsible for allocating space for
results. The callee simply writes into this space.
&lt;p&gt;
That's a lot of constraints, and quite heterogenous! Putting them all together,
it seems to me they point toward only one solution:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; Give up on separating inputs from outputs in the general case. C is wise
here.
&lt;p&gt;
&lt;li&gt; Highlight output registers of function calls. These are just for documentation
and error-checking. As we saw above, you can't mix and match arbitrary
registers into the outputs of a call. But it's still nice for the reader to be
able to tell at a glance which registers are being modified where, and for the
translator to detect when the wrong output register is assumed in a call.
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&lt;span style='color:DarkSeaGreen'&gt;fn&lt;/span&gt; factorial n : int &lt;span style='color:DarkSeaGreen'&gt;&amp;rarr;&lt;/span&gt; result/&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; : int [
&amp;nbsp;  &amp;hellip;
]
&lt;span style='color:blue'&gt;# call&lt;/span&gt;
x/&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; &amp;larr; factorial 20  &lt;span style='color:blue; margin-left:1em'&gt;# ok&lt;/span&gt;
x/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; &amp;larr; factorial 20  &lt;span style='color:blue; margin-left:1em'&gt;# error&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
&lt;li&gt; Highlight output registers of primitives:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
x/&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; &amp;larr; copy y
&lt;/pre&gt;
&lt;p&gt;
Unlike function calls, primitive instructions can usually write to any
register.
&lt;p&gt;
&lt;li&gt; Put inout registers of primitive instructions only on the output. For
example adding y to x when x is a register:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
x/&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; &amp;larr; add y
&lt;/pre&gt;
&lt;p&gt;
&lt;li&gt; Other than registers, memory addresses written to are really inout. Never
put them on the output side. The above two instructions when the destination is
not a register:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
copy-to x, y/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt;
add-to x, y/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt;
copy-bytes-to x, y &lt;span style='color:blue; margin-left:1em'&gt;# function call&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
The &lt;tt&gt;-to&lt;/tt&gt; suffix helps indicate which operand is written. It also seems
to suggest a convention of putting outputs first. You &lt;em&gt;could&lt;/em&gt; use a
&lt;tt&gt;-from&lt;/tt&gt; suffix and keep outputs clearly at the end. But what if you have
multiple inputs? It seems more common to have a single output.
&lt;p&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;em&gt;Code generation&lt;/em&gt;
&lt;p&gt;
Once we've parsed a core syntax we need to emit code for each instruction.
Function calls are straightforward, given pre-existing syntax sugar. In Mu:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
o1, o2 &lt;- f i1, i2
&lt;/pre&gt;
&lt;p&gt;
In machine code with syntax sugar:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
(f i1 i2) &lt;span style='color:blue; margin-left:1em'&gt;# output registers are implied&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
In machine code without syntax sugar:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
push i2
push i1
call f
add 8 bytes to &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
Since each operand is in a separate instruction, it is free to live in a
register or memory.
&lt;p&gt;
Now for primitives. I'll show a quick sketch of how we translate &lt;tt&gt;add&lt;/tt&gt;
instructions to x86 opcodes based on the storage type of their operands. Other
instructions will follow similar logic.
&lt;p&gt;
The x86 instruction set operates on registers, memory or literals. Data in
registers is addressed directly. Data in the stack is accessed in offsets of
the stack pointer: `&lt;tt&gt;*(esp+n)&lt;/tt&gt;` where `&lt;tt&gt;n&lt;/tt&gt;` is usually a static
value. Global variables are accessed as labels (32-bit addresses). We also
capitalize global variables by convention.
&lt;p&gt;
Each add instruction takes two operands. Here are the opcodes (and optional
sub-opcodes) we care about, from &lt;a href='https://c9x.me/x86/html/file_module_x86_id_5.html'&gt;the
Intel manual&lt;/a&gt; (with optional sub-opcode or &lt;em&gt;subop&lt;/em&gt; after the slash):
&lt;p&gt;
&lt;style&gt;
.table1 th { font-weight:bold; }
table.table1, .table1 th, .table1 td {
&amp;nbsp;  border:1px solid black;
&amp;nbsp;  padding:0.5em;
}
&lt;/style&gt;
&lt;table class='table1' style='margin-left:4em; margin-top:-1.5em'&gt;
&lt;tr&gt;
&amp;nbsp;  &lt;th width='100px'&gt;&lt;/th&gt;
&amp;nbsp;  &lt;th colspan=4 style='width:300px; text-align:center'&gt;&amp;larr; Source operand &amp;rarr;&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&amp;nbsp;  &lt;th&gt;Destination&lt;br&gt;Operand &amp;darr;&lt;/th&gt;
&amp;nbsp;  &lt;th&gt;Literal&lt;/th&gt;
&amp;nbsp;  &lt;th&gt;Register&lt;/th&gt;
&amp;nbsp;  &lt;th&gt;Local&lt;/th&gt;
&amp;nbsp;  &lt;th&gt;Global&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&amp;nbsp;  &lt;td style='font-weight:bold'&gt;Register&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;81 /0&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;01&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;03&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;03&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&amp;nbsp;  &lt;td style='font-weight:bold'&gt;Local&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;81 /0&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;01&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;X&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&amp;nbsp;  &lt;td style='font-weight:bold'&gt;Global&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;81 /0&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;01&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;X&lt;/td&gt;
&amp;nbsp;  &lt;td&gt;X&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;
Alternatively, showing where operands are stored (destination first):
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&lt;span style='display:inline-block; width:200px'&gt;reg += literal&lt;/span&gt; &amp;#8658; 81 0/subop %reg literal/imm32
&lt;span style='display:inline-block; width:200px'&gt;stack += literal&lt;/span&gt; &amp;#8658; 81 0/subop *(esp+offset) literal/imm32
&lt;span style='display:inline-block; width:200px'&gt;Global += literal&lt;/span&gt; &amp;#8658; 81 0/subop *Global literal/imm32
&lt;span style='display:inline-block; width:200px'&gt;reg += reg2&lt;/span&gt; &amp;#8658; 01 %reg reg2/r32
&lt;span style='display:inline-block; width:200px'&gt;stack += reg2&lt;/span&gt; &amp;#8658; 01 *(esp+offset) reg2/r32
&lt;span style='display:inline-block; width:200px'&gt;Global += reg2&lt;/span&gt; &amp;#8658; 01 *Global reg2/r32
&lt;span style='display:inline-block; width:200px'&gt;reg += stack&lt;/span&gt; &amp;#8658; 03 *(esp+offset) reg/r32
&lt;span style='display:inline-block; width:200px'&gt;reg += Global&lt;/span&gt; &amp;#8658; 03 *Global reg/r32
&lt;/pre&gt;
&lt;p&gt;
Other binary operations get translated similarly. (For details on the &lt;em&gt;metadata&lt;/em&gt;
after slashes, see the section on &amp;ldquo;Error-checking&amp;rdquo; in &lt;a href='/post/mu-2019-1'&gt;the
previous post&lt;/a&gt; and &lt;a href='https://github.com/akkartik/mu#readme'&gt;the
project Readme&lt;/a&gt;.)
&lt;p&gt;
&lt;em&gt;Variable declarations&lt;/em&gt;
&lt;p&gt;
Mu needs to be able to declare friendly names for locations in memory or
register. How would they work? Again, we'll start with some goals/constraints:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; We'd like to be able to attach types to registers or memory locations, so
that errors in writing incompatible values to them can be quickly caught.
&lt;p&gt;
&lt;li&gt; Registers can only hold a word-sized type.
&lt;p&gt;
&lt;li&gt; We shouldn't have to explicitly deallocate variables when exiting a scope.
&lt;p&gt;
&lt;li&gt; We'd like to allocate vars close to their use rather than at the top of a
function. Ideally we'd like to support scopes in blocks rather than just for
entire function bodies.
&lt;p&gt;
&lt;li&gt; We'd like to be able to exit early and automatically clean up.
&lt;p&gt;
&lt;li&gt; We'd like to avoid unnecessary shadowing. If a variable isn't used anymore it
shouldn't need to be restored.
&lt;p&gt;
&lt;/ul&gt;
&lt;p&gt;
Here's a declaration for a local variable with a type:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&lt;span style='color:DarkSeaGreen'&gt;var&lt;/span&gt; x : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
This gets translated to (&amp;#8658;)
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
subtract 4 from &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
You can also initialize a variable with 0's:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&lt;span style='color:DarkSeaGreen'&gt;var&lt;/span&gt; x : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; 0
&lt;/pre&gt;
&lt;p&gt;
&amp;#8658;
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
push 0
&lt;/pre&gt;
&lt;p&gt;
Variables on the stack (offsets from &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt;)
have a single type for their entire lifetimes.
&lt;p&gt;
If you're allocating a variable to a register, you can also turn any instruction
writing to a single register into an initialization:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&lt;span style='color:DarkSeaGreen'&gt;var&lt;/span&gt; x/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; copy y
&lt;/pre&gt;
&lt;p&gt;
It's also fine to read from a register and write to a conceptually new variable in the same register:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&lt;span style='color:DarkSeaGreen'&gt;var&lt;/span&gt; opcode/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; and inst/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; 0xff
&lt;/pre&gt;
&lt;p&gt;
While register variables have a single type for their entire lifetimes, it's totally fine for a register to be used by multiple variables of distinct types in a single function or block. Put another way, register variables tend to have shorter lifetimes than variables on the stack.
&lt;p&gt;
&lt;hr style='width:20%; border:1px dotted #888'&gt;
&lt;p&gt;
Variable declarations interact with Mu's &lt;tt&gt;{}&lt;/tt&gt; blocks. Here's a variable allocated on the stack:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&lt;span style='color:DarkSeaGreen; margin-left:2em'&gt;var&lt;/span&gt; x : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; 0
&lt;span style='margin-left:2em'&gt;&amp;hellip;&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;
This gets translated to (&amp;#8658;) the following level-1 pseudocode:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&lt;span style='margin-left:2em'&gt;push 0&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;&amp;hellip;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;add 4 to &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt;&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;
Similarly, a variable allocated to a register:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&lt;span style='color:DarkSeaGreen; margin-left:2em'&gt;var&lt;/span&gt; x/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; copy y
&lt;span style='margin-left:2em'&gt;&amp;hellip;&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;
&amp;#8658;
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&lt;span style='margin-left:2em'&gt;push &lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt;&lt;/span&gt; &lt;span style='color:blue; margin-left:1em'&gt;# spill register&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; &amp;larr; copy y&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;&amp;hellip;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;pop to &lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; &lt;span style='color:blue; margin-left:1em'&gt;# restore register&lt;/span&gt;&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;
(This approach fits a calling convention where all registers are saved by the
callee rather than the caller.)
&lt;p&gt;
Variables don't always need to be shadowed; sometimes they're safe to clobber.
Rather than taking on responsibilities of analyzing lifetimes, Mu provides a
single simple rule: the first variable in a register shadows previous values,
and subsequent variables to the same register in the same block clobber:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&lt;span style='color:DarkSeaGreen; margin-left:2em'&gt;var&lt;/span&gt; x/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; copy y
&lt;span style='color:DarkSeaGreen; margin-left:2em'&gt;var&lt;/span&gt; z/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; &amp;hellip;A&amp;hellip;
&lt;span style='margin-left:2em'&gt;&amp;hellip;B&amp;hellip;&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;
&amp;#8658;
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&lt;span style='margin-left:2em'&gt;push &lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; &amp;larr; copy y&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; &amp;larr; &amp;hellip;A&amp;hellip;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;&amp;hellip;B&amp;hellip;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;pop to &lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;
To shadow, create a new inner block.
&lt;p&gt;
&lt;hr style='width:20%; border:1px dotted #888'&gt;
&lt;p&gt;
Early exits should also clean up any variables in a block.
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&lt;span style='color:DarkSeaGreen; margin-left:2em'&gt;var&lt;/span&gt; x/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; copy y
&lt;span style='color:DarkSeaGreen; margin-left:2em'&gt;break-if&lt;/span&gt; &amp;hellip;A&amp;hellip;
&lt;span style='margin-left:2em'&gt;&amp;hellip;B&amp;hellip;&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;
&amp;#8658;
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&lt;span style='margin-left:2em'&gt;push &lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;ecx &amp;larr; copy y&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;{&lt;/span&gt;
&lt;span style='color:DarkSeaGreen; margin-left:4em'&gt;break-if&lt;/span&gt; &amp;hellip;A&amp;hellip;
&lt;span style='margin-left:4em'&gt;&amp;hellip;B&amp;hellip;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;}&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;pop to &lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;
Early returns are more complicated, because we may need to unwind multiple
blocks. The Mu translator is responsible for tracking the size of the stack
frame at any point, and updating the stack appropriately before returning.
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&lt;span style='color:DarkSeaGreen; margin-left:2em'&gt;var&lt;/span&gt; x/&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; copy y
&lt;span style='color:DarkSeaGreen; margin-left:2em'&gt;return-if&lt;/span&gt; &amp;hellip;A&amp;hellip;
&lt;span style='margin-left:2em'&gt;&amp;hellip;B&amp;hellip;&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;
&amp;#8658;
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&lt;span style='margin-left:2em'&gt;push &lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt;&lt;/span&gt; &lt;span style='color:blue; margin-left:1em'&gt;# spill register&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;ecx &amp;larr; copy y&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;{&lt;/span&gt;
&lt;span style='color:DarkSeaGreen; margin-left:4em; font-weight:bold'&gt;break-unless&lt;/span&gt; &amp;hellip;A&amp;hellip;
&lt;span style='margin-left:4em'&gt;&amp;laquo;increment &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt; appropriately&amp;raquo;&lt;/span&gt;
&lt;span style='color:DarkSeaGreen; margin-left:4em'&gt;return&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;}&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;&amp;hellip;B&amp;hellip;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;pop to &lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; &lt;span style='color:blue; margin-left:1em'&gt;# single restore&lt;/span&gt;&lt;/span&gt;
}
&lt;/pre&gt;
&lt;p&gt;
&lt;em&gt;Wrap up&lt;/em&gt;
&lt;p&gt;
Putting these ideas together, here's what factorial looks like in a bare-bones
but type-safe system programming language targeting x86 (supporting only
integers so far):
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&lt;span style='color:DarkSeaGreen'&gt;fn&lt;/span&gt; factorial n : int &lt;span style='color:DarkSeaGreen'&gt;&amp;rarr;&lt;/span&gt; result/&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; : int {
&lt;span style='color:blue; margin-left:2em'&gt;# if (n &lt;= 1) return 1&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;compare n, 1
&lt;span style='margin-left:2em'&gt;{
&lt;span style='color:DarkSeaGreen; margin-left:4em'&gt;break-if&lt;/span&gt; &amp;gt;
&lt;span style='color:DarkSeaGreen; margin-left:4em'&gt;return&lt;/span&gt; 1
&lt;span style='margin-left:2em'&gt;}
&lt;span style='color:blue; margin-left:2em'&gt;# otherwise return n * factorial(n-1)&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;{
&lt;span style='color:DarkSeaGreen; margin-left:4em'&gt;break-if&lt;/span&gt; &amp;lt;=
&lt;span style='color:blue; margin-left:4em'&gt;# var tmp = n-1&lt;/span&gt;
&lt;span style='color:DarkSeaGreen; margin-left:4em'&gt;var&lt;/span&gt; tmp/&lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt; : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; copy n
&lt;span style='margin-left:4em'&gt;decrement tmp&lt;/span&gt;
&lt;span style='color:blue; margin-left:4em'&gt;# return n * factorial(tmp)&lt;/span&gt;
&lt;span style='color:DarkSeaGreen; margin-left:4em'&gt;var&lt;/span&gt; tmp2/&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; : &lt;span style='color:DarkSeaGreen'&gt;int&lt;/span&gt; &amp;larr; factorial tmp
&lt;span style='margin-left:4em'&gt;result &amp;larr; multiply n, tmp2&lt;/span&gt;
&lt;span style='color:DarkSeaGreen; margin-left:4em'&gt;return&lt;/span&gt; result
&lt;span style='margin-left:2em'&gt;}
}
&lt;/pre&gt;
&lt;p&gt;
And here's the level-1 machine code I plan for it to be translated to:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
factorial:
&lt;span style='color:blue; margin-left:2em'&gt;# function prologue&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;55/push-&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;89/&amp;lt;- %&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt; 4/r32/&lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt;&lt;/span&gt;
&lt;span style='color:blue; margin-left:2em'&gt;# if (n &lt;= 1) return 1&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;81 7/subop/compare *(&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;+8)&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;{&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;7f/jump-if-greater &lt;span style='color:DarkSeaGreen'&gt;break&lt;/span&gt;/disp8&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;b8/copy-to-&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; 1/imm32&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;e9/jump $factorial:end/disp32&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;}&lt;/span&gt;
&lt;span style='color:blue; margin-left:2em'&gt;# otherwise return n * factorial(n-1)&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;{&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;7e/jump-if-lesser-or-equal &lt;span style='color:DarkSeaGreen'&gt;break&lt;/span&gt;/disp8&lt;/span&gt;
&lt;span style='color:blue; margin-left:4em'&gt;# var tmp = n-1&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;53/push-&lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;&lt;/span&gt; &lt;span style='color:grey; margin-left:1em'&gt;# spill&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;8b/-&gt; *(&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;+8) 3/r32/&lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;4b/decrement-&lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;&lt;/span&gt;
&lt;span style='color:blue; margin-left:4em'&gt;# return n * factorial(tmp)&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;(factorial %&lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;)&lt;/span&gt; &lt;span style='color:blue; margin-left:1em'&gt;# &amp;rarr; &lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;f7 4/subop/multiply-into-eax *(&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;+8)&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;5b/pop-to-&lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;&lt;/span&gt; &lt;span style='color:grey; margin-left:1em'&gt;# restore&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;e9/jump $factorial:end/disp32&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;}&lt;/span&gt;
$factorial:end:
&lt;span style='color:blue; margin-left:2em'&gt;# function epilogue&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;89/&amp;lt;- %&lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt; 5/r32/&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;5d/pop-to-&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;c3/return&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
This isn't as efficient as what I wrote by hand at the bottom of &lt;a href='/post/mu-2019-1'&gt;the
previous post&lt;/a&gt;, but seems like a realistic translation based on this post.
&lt;p&gt;
Ok, time to get to work building it. I'd love to hear suggestions or feedback
based on this design, either in the comments below or &lt;a href='mailto:ak@akkartik.com'&gt;over
email&lt;/a&gt;.
&lt;p&gt;
&lt;div class='btw'&gt;(Thanks Garth Goldwater, &lt;a href='https://twitter.com/vladimir_vg'&gt;Vladimir Gordeev&lt;/a&gt;,
&lt;a href='https://twitter.com/CodingFiend'&gt;Edward de Jong&lt;/a&gt;, &lt;a href='https://breckyunits.com'&gt;Breck
Yunits&lt;/a&gt;, &lt;a href='http://boomla.com'&gt;Tibor Halter&lt;/a&gt;, &lt;a href='https://github.com/rdentato'&gt;Remo
Dentato&lt;/a&gt; and &lt;a href='http://www.federicopereiro.com'&gt;Federico Pereiro&lt;/a&gt;
for helpful feedback on drafts of this post.)&lt;/div&gt;&lt;img src=&quot;http://feeds.feedburner.com/~r/kartiks-scrapbook/~4/4VFVKnAjjOE&quot; height=&quot;1&quot; width=&quot;1&quot; alt=&quot;&quot;/&gt;</description>
    <feedburner:origLink>http://akkartik.name/blog/mu-2019-2</feedburner:origLink></item>
    <item>
      <title>Mu: A minimal hobbyist computing stack</title>
      <link>http://feeds.akkartik.name/~r/kartiks-scrapbook/~3/1i1vM8S3iW8/mu-2019-1</link>
      <pubDate>Mon, 14 Oct 2019 15:13:21 -0700</pubDate>
      <guid isPermaLink="false">http://akkartik.name/post/mu-2019-1</guid>
      <description>&lt;p&gt;
&lt;div style='margin-left:3em'&gt;
&lt;span class='left_quote_char'&gt;&amp;ldquo;&lt;/span&gt;&lt;em&gt;It is far better to have an
under-featured product that is rock solid, fast, and small than one that
covers what an expert would consider the complete requirements.&amp;rdquo;&lt;/em&gt;
&lt;br&gt;&amp;mdash; &lt;a href='https://en.wikipedia.org/wiki/Richard_P._Gabriel'&gt;Richard
Gabriel&lt;/a&gt;'s &lt;a href='https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf'&gt;best
summary&lt;/a&gt; (pg 219) of his essay, &lt;a href='https://www.dreamsongs.com/RiseOfWorseIsBetter.html'&gt;&amp;ldquo;Worse
is Better&amp;rdquo;&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
Over the past year I've been working on a minimal-dependency hobbyist computing
stack (everything above the processor) called &lt;a href=&quot;https://github.com/akkartik/mu#readme&quot;&gt;Mu&lt;/a&gt;.
The goal is to:
&lt;ol&gt;
&lt;li&gt; build up infrastructure people can enjoy programming on,
&lt;li&gt; using as little code as possible, so that people can also hack on the
underpinnings, modifying them to suit diverse desires.
&lt;/ol&gt;
&lt;p&gt;
&lt;!-- more --&gt;
&lt;p&gt;
Conventional stacks kinda support 1 if you squint, but they punt on 2, so it
can take years to understand just one piece of infrastructure (like the C
compiler). It looks like nobody understands the entire stack anymore. I'd like
Mu to be a stack a single person can hold in their head all at once, and modify
in radical ways.
&lt;p&gt;
(While it should support understanding everything, you aren't expected to
understand everything. Mu tries to reward curiosity, but should get out of the
way when you're just trying to get something done.)
&lt;p&gt;
One implication of fitting in a single head: Mu constrains the number of
supported languages. Languages have a way of growing into isolated universes,
and interoperation between languages adds its own complexities. It seems
better for future readers if the stack minimizes the number of such boundaries,
even if writers are inconvenienced somewhat.
&lt;p&gt;
I eventually want to make it easy to swap out one kind of language for
another, so that people can program in Lisp-like or Python-like or C-like
syntax according to their taste. But regardless of which notations any given Mu
computer has, it will be parsimonious in the number of &lt;a href=&quot;https://www.jsoftware.com/papers/tot.htm&quot;&gt;notations&lt;/a&gt;
readers have to learn to understand and take ownership of a single computer.
&lt;p&gt;
Each of these notations needs to be simple enough that it can be implemented
out of lower-level notations. The fact that C compilers are written in C
contributes a lot of the complexity that makes compilers black magic to most
people.
&lt;p&gt;
A year in, it's surprising how inevitable the design has seemed. If the
journey starts at a specific processor architecture and the goal is to
minimize layers of translation above it while paying attention to dependencies,
the final destination seems quite inevitable (ignoring minor syntactic
choices). This discovery seems worth sharing more broadly, if only so others
can prove me wrong and suggest alternative designs.
&lt;p&gt;
&lt;em&gt;Outline&lt;/em&gt;
&lt;p&gt;
Since Mu looks quite different from conventional stacks, I need a few blog
posts to cover all the ground. My plan is to give Mu just 3 distinct languages
(only the first currently exists; the third is not even planned yet).
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; Level 1: just the processor's instruction set with some syntax sugar
&lt;li&gt; Level 2: a memory-safe language
&lt;li&gt; Level 3: an expressive high-level language
&lt;/ul&gt;
&lt;p&gt;
These levels don't quite map to familiar terms. Level 1 has some attributes of
machine code and Assembly. Level 2 has some attributes of Assembly and very
high-level languages.
&lt;p&gt;
An alternative view of this stack is &lt;a href='/parnas.pdf'&gt;the
primary affordance each level provides&lt;/a&gt;:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; Level 1: structured control flow
&lt;li&gt; Level 2: strong typing
&lt;li&gt; Level 3: mould the computer to how people think
&lt;/ul&gt;
&lt;p&gt;
Each of these affordances requires a global change to the programming model.
Within each level I try to keep things as &lt;a href=&quot;/post/habitability&quot;&gt;habitable&lt;/a&gt; as
possible using just local syntax sugar (tools that don't need to understand
the entire codebase).
&lt;p&gt;
The rest of this post focuses on level 1. &lt;a href='/post/mu-2019-2'&gt;The
sequel&lt;/a&gt; describes a preliminary design for level 2. I won't get to level 3
until I finish building level 2. So far I've written 40k lines of code (LoC)
in level 1, and 30k LoC in &lt;a href='/post/mu'&gt;an earlier prototype&lt;/a&gt; that
has some resemblance to level 2. Since I want each level to be &lt;a href=&quot;/post/habitability&quot;&gt;habitable&lt;/a&gt;
in isolation, it seems like a good idea to write a decent amount of code in it
before moving on to higher levels. (This is a big difference from &lt;a href=&quot;http://web.archive.org/web/20061108010907/http://www.rano.org/bcompiler.html&quot;&gt;past&lt;/a&gt;
&lt;a href=&quot;https://github.com/kragen/stoneknifeforth&quot;&gt;approaches&lt;/a&gt; to &lt;a href=&quot;http://git.savannah.nongnu.org/cgit/stage0.git/tree/README&quot;&gt;bootstrapping&lt;/a&gt;,
which try to do as little as possible in each level before jumping to higher
levels. The lower levels inevitably end up being hard for newcomers to
understand or interactively take apart.)
&lt;p&gt;
&lt;em&gt;Level 1: SubX&lt;/em&gt;
&lt;p&gt;
At the lowest level my goal is to pick a processor and make the experience of
programming in raw machine code not completely suck.
&lt;p&gt;
I mentioned above that each level builds on levels below, but that's a lie at
this level. I don't enjoy editing binary and don't want my readers to have to
either. Instead I have an alternative plan, with two prongs:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; A C++ translator that converts a textual format to binary.
&lt;li&gt; A self-hosted translator that converts the textual format to binary.
&lt;/ul&gt;
&lt;p&gt;
The C++ translator is more familiar, but pulls in some gigantic dependencies.
The self-hosted translator will look strange but have a tiny codebase and a
tiny surface area (just 3 OS syscalls, for example). Both translators will
emit &lt;em&gt;identical&lt;/em&gt; binaries, which is helpful when debugging the system.
&lt;p&gt;
Complete details for how to operate these tools are in the &lt;a href=&quot;https://github.com/akkartik/mu#readme&quot;&gt;Readme&lt;/a&gt;.
This post is a quick tour of the major design choices, but if it's interesting
you should clone the repo and read the Readme in a text editor. Mu is really
intended to be &lt;a href='/post/comprehension'&gt;played with interactively, rather
than passively read&lt;/a&gt;.
&lt;p&gt;
Ok, design choices. My computer runs x86, and it's the most open platform I
have. So Mu is going to run on x86. It is explicitly not designed to be
portable. So we'll start with a quick tour of x86. Here's what you need to
know.
&lt;p&gt;
The x86 instruction set is 40 years old. It started out as an 8-bit processor,
then turned into a 16-bit, 32-bit and now 64-bit processor. It has accumulated
hacks and bolted on features over its history. To help it fit in my head, I've
chosen a &lt;a href='https://github.com/akkartik/mu/blob/master/subx_opcodes'&gt;fairly
regular subset&lt;/a&gt; of x86 for SubX (hence the name), focusing on just 32-bit
values (and a couple of instructions for 8-bit bytes so that I can iterate
over strings).
&lt;p&gt;
&lt;em&gt;Instructions&lt;/em&gt;
&lt;p&gt;
Machine code for any processor consists of linear sequences of instructions.
All the nested block structure and nested calls of higher-level languages are
gone by this point. All you have is long lists of instructions with the
ability to conditionally skip some subsequences and run some subsequences
repeatedly. (Really, instructions are just numbers, so all you have are long
sequences of numbers.)
&lt;p&gt;
Every instruction in machine code starts with an &lt;em&gt;opcode&lt;/em&gt;, some series
of bits that specifies which instruction to run. Assembly languages then
provide friendly names for opcodes like `&lt;tt&gt;add&lt;/tt&gt;` and `&lt;tt&gt;jump&lt;/tt&gt;`. In
a complex instruction set like for the x86 processor, `&lt;tt&gt;add&lt;/tt&gt;` maps to
&lt;a href='https://c9x.me/x86/html/file_module_x86_id_5.html'&gt;a whole family of
opcodes&lt;/a&gt;, and there's significant logic to deduce the opcode for an
instruction based on its arguments. It also takes a significant amount of code
to provide good error messages. There are many reasonable-seeming combinations
of operands that x86 doesn't let you add together, and it's hard to compress
that knowledge into a short error message tailored to a specific situation.
&lt;p&gt;
SubX doesn't provide names for opcodes; you have to use the raw opcodes
directly. This eliminates code for translating names to opcodes, and it also
enormously simplifies error messages. The programmer needs to work from the
list of opcodes, and each error needs to only handle a single case. In
practice, this hasn't felt like a major hindrance, because understanding error
messages returned by Assemblers often requires understanding the underlying
opcodes anyway. I've been finding good error messages to be more valuable than
syntactic conveniences. (I'd love &lt;a href='mailto:mu@akkartik.com'&gt;feedback&lt;/a&gt;
on this decision.)
&lt;p&gt;
To see the complete list of opcodes supported by SubX at any point in time,
type:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&lt;span style='color:#888'&gt;$&lt;/span&gt; bootstrap help opcodes
&lt;/pre&gt;
&lt;p&gt;
&lt;em&gt;Operands&lt;/em&gt;
&lt;p&gt;
Each instruction operates on some small number of operands. In x86 instructions
can't take more than 2 operands for the most part. Since there are only two
operands, and since binary operations like addition are fundamental, most
instructions both read and write from one operand:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; Add operand o1 &lt;em&gt;to&lt;/em&gt; o2;
&lt;li&gt; subtract o1 &lt;em&gt;from&lt;/em&gt; o2;
&lt;li&gt; compute the bitwise `&lt;tt&gt;AND&lt;/tt&gt;` of o1 and o2, and store the result in
o1;
&lt;li&gt; &amp;hellip;and so on.
&lt;/ul&gt;
&lt;p&gt;
Operands may be stored in either &lt;em&gt;registers&lt;/em&gt; or memory. Registers are
some small number of named (really numbered) locations. The x86 processor has
8:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; &lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; (0)
&lt;li&gt; &lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt; (1)
&lt;li&gt; &lt;span style='color:DarkSeaGreen'&gt;edx&lt;/span&gt; (2)
&lt;li&gt; &lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt; (3)
&lt;li&gt; &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt; (4)
&lt;li&gt; &lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt; (5)
&lt;li&gt; &lt;span style='color:DarkSeaGreen'&gt;esi&lt;/span&gt; (6)
&lt;li&gt; &lt;span style='color:DarkSeaGreen'&gt;edi&lt;/span&gt; (7)
&lt;/ul&gt;
&lt;p&gt;
Operands in memory are also usually specified using registers somehow:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; `*&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt;`: value in memory at address provided in &lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt;
&lt;li&gt; `*(&lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt;+4)`: value in memory at address &lt;span style='color:DarkSeaGreen'&gt;ecx&lt;/span&gt;+4
&lt;li&gt; &amp;hellip;and so on.
&lt;/ul&gt;
&lt;p&gt;
All this gets turned into numbers, but we don't need the details for this
post. Consult the Readme for details.
&lt;p&gt;
&lt;em&gt;Error-checking&lt;/em&gt;
&lt;p&gt;
One big problem programming in raw x86 machine code is that instructions are
not all the same size. Instruction boundaries aren't aligned to every 4 bytes,
or something like that. The processor is &lt;em&gt;parsing&lt;/em&gt; future instruction
boundaries as it reads in earlier instructions. It's really easy to accidentally
add an extra byte or forget a byte to an instruction. When that happens, bytes
that were intended to be opcodes can be interpreted as operands, and &lt;em&gt;vice
versa&lt;/em&gt;. The program goes silently off the rails, and may not show an error
message until much later. The difficulty of debugging such errors is arguably
the single biggest obstacle to a good programming experience.
&lt;p&gt;
This is the point at which Assembly languages nope out and go build a whole new
syntax for themselves, categorizing opcodes into instruction names and so on.
Since SubX needs to be self-hosted and every feature in it needs to be
programmed in SubX, its solution to this problem is to stay with machine code,
but add lots of space for &lt;em&gt;metadata&lt;/em&gt;. Here's a sample instruction in
SubX:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
89/&amp;lt;- 5/rm32/&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt; 4/r32/&lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt; &lt;span style='color:blue; margin-left:2em'&gt;# copy &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt; to &lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;&lt;/span&gt; 
&lt;/pre&gt;
&lt;p&gt;
Instructions lie all on one line. They consist of multiple words separated by
whitespace. Each word contains a &lt;em&gt;datum&lt;/em&gt; until the first slash. The
datum is the only part that makes it into the binary. Everything in a word
after the datum and the first slash is metadata. As you see, you can have
multiple bits of metadata squirrelled away in a word, all separated by slashes.
&lt;p&gt;
Metadata is optional and often ignored, so it's a good place for little
comments. However, certain special words for &lt;em&gt;argument types&lt;/em&gt; trigger
error-checking. In the above instruction, Mu ignores the `&lt;tt&gt;/&amp;lt;-&lt;/tt&gt;` and
reads just the &amp;lsquo;89&amp;rsquo;. However, it knows that opcode 89 expects a
`&lt;tt&gt;/rm32&lt;/tt&gt;` and `&lt;tt&gt;/r32&lt;/tt&gt;` argument. If it fails to see one of them
in the rest of the instruction, it immediately flags an error. If it sees any
of the other known argument types in the instruction when it doesn't expect
them&amp;mdash;it immediately flags an error. (The register names `/&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;`
and `&lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt;` are just comments to aid the
reader.)
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&lt;span style='color:#888'&gt;$&lt;/span&gt; bootstrap translate init.linux examples/ex1.subx -o a.elf
'bb/copy-to-ebx' (copy imm32 to EBX): missing imm32 operand
&lt;/pre&gt;
&lt;p&gt;
(The code samples in this post hide some details that aren't important on a
first encounter with Mu. I'll elide the actual opcodes further down.)
&lt;p&gt;
While this use of metadata is specific to the properties of x86, they're a
general mechanism for lots of different checks one may want to apply. I used
them in several ways in &lt;a href='https://github.com/akkartik/mu1'&gt;a previous
prototype&lt;/a&gt;. I've started to think of the structure of words and metadata as
&amp;ldquo;s-statements&amp;rdquo;, by analogy with s-expressions. A fairly fundamental
uniform syntax that can be used in diverse situations where one doesn't want
arbitrary nesting.
&lt;p&gt;
&lt;em&gt;Structured programming&lt;/em&gt;
&lt;p&gt;
As I mentioned above, the primary motivation for the SubX layer is to make
working with control flow more ergonomic. The x86 processor tracks what
instruction to execute using the special &lt;span style='color:DarkSeaGreen'&gt;eip&lt;/span&gt;
register. This register can't be modified by most instructions. Only jumps and
calls modify it.
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
jump 237  &lt;span style='color:blue; margin-left:10em'&gt;# add 237 to &lt;span style='color:DarkSeaGreen'&gt;eip&lt;/span&gt;&lt;/span&gt; 
&lt;/pre&gt;
&lt;p&gt;
It gets tedious to adjust the byte offsets every time you add or delete an
instruction. So SubX provides named &lt;em&gt;labels&lt;/em&gt; for specific points in the
instruction stream, just like conventional Assembly languages. For example:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
jump-if-equal $foo
&amp;hellip;
$foo:  &lt;span style='color:blue; margin-left:12em'&gt;# jump to here&lt;/span&gt; 
&lt;/pre&gt;
&lt;p&gt;
&amp;#8658;
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
jump-if-equal 237
&lt;/pre&gt;
&lt;p&gt;
Another convenience (not usually found in Assembly language) is the special
labels `&lt;tt&gt;{&lt;/tt&gt;` and `&lt;tt&gt;}&lt;/tt&gt;`, `&lt;tt&gt;break&lt;/tt&gt;` and `&lt;tt&gt;loop&lt;/tt&gt;`.
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
{
&amp;nbsp;  jump-if-equal break
&amp;nbsp;  &amp;hellip;
&amp;nbsp;  jump loop
}
&lt;/pre&gt;
&lt;p&gt;
&amp;#8658;
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
$loop1:
&amp;nbsp;  jump-if-equal $break1
&amp;nbsp;  &amp;hellip;
&amp;nbsp;  jump $loop1
$break1:
&lt;/pre&gt;
&lt;p&gt;
Basically the `&lt;tt&gt;{&lt;/tt&gt;` and `&lt;tt&gt;}&lt;/tt&gt;` get translated into labels, and
`&lt;tt&gt;break&lt;/tt&gt;` gets translated into a jump to the enclosing `&lt;tt&gt;}&lt;/tt&gt;`.
Correspondingly, `&lt;tt&gt;loop&lt;/tt&gt;` gets translated to a jump to the enclosing
(earlier) `&lt;tt&gt;{&lt;/tt&gt;`. This syntax is surprisingly ergonomic and
&lt;a href='/post/mu'&gt;proved surprisingly easy to teach to non-programmers during
the Mu1 prototype&lt;/a&gt;. Where you would say, in an imperative language:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
if (&amp;lt;predicate&amp;gt;) {
&amp;nbsp;  &amp;hellip;
}
&lt;/pre&gt;
&lt;p&gt;
in SubX you would say:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&amp;lt;flag&amp;gt; = &amp;lt;predicate&amp;gt;
{
&amp;nbsp;  jump-unless &amp;lt;flag&amp;gt; break
&amp;nbsp;  &amp;hellip;
}
&lt;/pre&gt;
&lt;p&gt;
&lt;em&gt;Functions&lt;/em&gt;
&lt;p&gt;
Idiomatic machine code programs consist of &lt;em&gt;functions&lt;/em&gt; operating on
&lt;em&gt;data&lt;/em&gt;. No matter what your high-level language does, and no matter
what processor it runs on, at bottom it's translated to some interplay between
functions and data. This section gets into that interplay in some detail.
&lt;p&gt;
We keep a program's functions and data segregated in memory to a &lt;em&gt;code
segment&lt;/em&gt; and &lt;em&gt;data segment&lt;/em&gt;, respectively. (There are a variety of
historic reasons for this that are not interesting. There is also one currently
topical reason that is very interesting: security. A segment is a contiguous
block of memory that gets a single access restriction. Code segments can be
executed from but not written to (after the OS loads them initially). Data
segments can be written but not executed. This &lt;a href='https://en.wikipedia.org/wiki/W%5EX'&gt;W^X
constraint&lt;/a&gt; is a critical pillar for securing computers; bad things happen
when programs can be induced to modify their own code.)
&lt;p&gt;
In addition to the data segment a program starts out with, it can request
various segments of empty working memory. A crucial one needed for functions
to work is the &lt;em&gt;stack&lt;/em&gt;. Stacks help keep local variables in functions
isolated from each other. In particular, they're necessary for recursive
functions that call themselves either directly or indirectly. Each call must
get new copies of locals that don't interfere with other calls.
&lt;p&gt;
Here's one way function calls can work (used by many modern platforms): Before
making a call the caller pushes arguments on the stack. The function can now
access them from the stack. After it returns the caller pops the arguments off
the stack to clean up. Recursive calls get separate &lt;em&gt;frames&lt;/em&gt; on the
stack.
&lt;p&gt;
Since the stack is temporary space that gets cleaned up after a function
returns, it's also an ideal place for local variables. Just push stuff on the
stack and make sure to clean it up before you return. The caller is none the
wiser.
&lt;p&gt;
Managing arguments and local variables does require each function to know
precisely where they live. One unambiguous way to specify arguments and local
variables (again used by many modern platforms) is as offsets off of a special
&lt;em&gt;stack pointer&lt;/em&gt; register (&lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt;
above). The x86 instruction set provides `&lt;tt&gt;push&lt;/tt&gt;` instructions that
automatically decrement &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt;, and
`&lt;tt&gt;pop&lt;/tt&gt;` instructions that automatically increment &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt;.
(The stack grows downward.)
&lt;p&gt;
Bottomline: calls in SubX consist by convention of some number of `&lt;tt&gt;push&lt;/tt&gt;`
instructions, one `&lt;tt&gt;call&lt;/tt&gt;` instruction, and some cleanup of the stack.
SubX provides the following syntax sugar:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
(f o1 o2 o3)
&lt;/pre&gt;
&lt;p&gt;
&amp;#8658;
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
push o3
push o2
push o1
call f
add 12 to &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt; &lt;span style='color:blue; margin-left:1em'&gt;# pop 3 args * 4 bytes each&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
&lt;em&gt;Strings&lt;/em&gt;
&lt;p&gt;
Strings (arrays of bytes, ignoring character encodings) are a workhorse of
high-level languages, but Assembly doesn't make them convenient to deal with.
Programming in SubX involves writing lots of automated tests, and tests are
most useful when they give good error messages. So passing strings into
functions is a crucial mechanism. SubX allows string literals. When it
encounters one, it appends the new literal to the data segment and replaces it
with its label in the code segment.
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&amp;nbsp;== code
(f o1 o2 &quot;foo&quot;)
&lt;p&gt;
&amp;nbsp;== data
&amp;hellip;&lt;em&gt;data&lt;/em&gt;&amp;hellip;
&lt;/pre&gt;
&lt;p&gt;
&amp;#8658;
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
&amp;nbsp;== code
(f o1 o2 $string1)
&lt;p&gt;
&amp;nbsp;== data
&amp;hellip;&lt;em&gt;data&lt;/em&gt;&amp;hellip;
$string1:
&amp;nbsp;  66 6f 6f  &lt;span style='color:blue; margin-left:1em'&gt;# Utf-8 for &amp;lsquo;f&amp;rsquo; &amp;lsquo;o&amp;rsquo; &amp;lsquo;o&amp;rsquo;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
&lt;em&gt;Tests&lt;/em&gt;
&lt;p&gt;
One of the ways I'm able to sling large programs at such a low level is by
writing lots of automated tests. A test harness isn't a common sight in
Assembly programming. SubX adds a single new mechanism that makes testing
ergonomic: when emitting a binary it generates a new function called `run-tests`
that calls every function in the program that starts with &amp;lsquo;test-&amp;rsquo;.
&lt;p&gt;
Putting all this syntax sugar together, here's a SubX function to compute the
factorial of a number, along with one automated test:
&lt;p&gt;
&lt;pre style='margin-left:2em; font-family:courier,fixed'&gt;
factorial: &lt;span style='color:blue; margin-left:1em'&gt;# n : int &amp;rarr; result/&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; : int&lt;/span&gt;
&lt;span style='color:blue; margin-left:2em'&gt;# function prologue&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;55/push-&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;89/&amp;lt;- &lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt; 4/r32/&lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;&lt;span style='color:blue'&gt;# save registers&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;53/push-&lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;&lt;/span&gt;
&lt;span style='color:blue; margin-left:2em'&gt;# if (n &lt;= 1) return 1&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;81 7/subop/compare *(&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;+8)&lt;/span&gt; &lt;span style='color:blue; margin-left:1em'&gt;# n is at *(&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;+8)&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;{&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;7f/jump-if-greater &lt;span style='color:DarkSeaGreen'&gt;break&lt;/span&gt;/disp8&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;b8/copy-to-&lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; 1/imm32&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;}&lt;/span&gt;
&lt;span style='color:blue; margin-left:2em'&gt;# otherwise return n * factorial(n-1)&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;{&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;7e/jump-if-lesser-or-equal &lt;span style='color:DarkSeaGreen'&gt;break&lt;/span&gt;/disp8&lt;/span&gt;
&lt;span style='color:blue; margin-left:4em'&gt;# &lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt; = n-1&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;8b/-&gt; *(&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;+8) 3/r32/&lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;4b/decrement-&lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;&lt;/span&gt;
&lt;span style='color:blue; margin-left:4em'&gt;# return n * factorial(ebx)&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;(factorial &lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;)&lt;/span&gt; &lt;span style='color:blue; margin-left:1em'&gt;# &amp;rarr; &lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:4em'&gt;f7 4/subop/multiply-into-eax *(&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;+8)&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;}&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;&lt;span style='color:blue'&gt;# restore registers&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;5b/pop-to-&lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;&lt;/span&gt;
&lt;span style='color:blue; margin-left:2em'&gt;# function epilogue&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;89/&amp;lt;- &lt;span style='color:DarkSeaGreen'&gt;esp&lt;/span&gt; 5/r32/&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;5d/pop-to-&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;c3/return&lt;/span&gt;
&lt;p&gt;
test-factorial:
&lt;span style='margin-left:2em'&gt;(factorial 5)&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;(check-ints-equal 120 &lt;span style='color:DarkSeaGreen'&gt;eax&lt;/span&gt; &lt;span style='color:darkCyan'&gt;&quot;failure: factorial(5)&quot;&lt;/span&gt;)&lt;/span&gt;
&lt;span style='margin-left:2em'&gt;c3/return&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;
(Ignore all the magic numbers for opcodes, just trust that &amp;lsquo;5b&amp;rsquo;
means &amp;lsquo;pop to &lt;span style='color:DarkSeaGreen'&gt;ebx&lt;/span&gt;&amp;rsquo;, that
&amp;lsquo;5/r32&amp;rsquo; means &amp;lsquo;&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;&amp;rsquo;,
and so on.)
&lt;p&gt;
&lt;em&gt;Summary&lt;/em&gt;
&lt;p&gt;
SubX is designed to be easy to self-host, so it mixes and matches features from
machine code, conventional Assembly and higher-level programming languages:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt; No mnemonics; programmer must provide all numeric opcodes and operands
directly.
&lt;li&gt; Error-checking using metadata.
&lt;li&gt; Syntax sugar for function calls and expressions like `&lt;tt&gt;*(&lt;span style='color:DarkSeaGreen'&gt;ebp&lt;/span&gt;+8)&lt;/tt&gt;`.
&lt;li&gt; Literal strings.
&lt;li&gt; Automated test harness.
&lt;/ul&gt;
&lt;p&gt;
The combination of these mechanisms has been ergonomic enough that I've written
40k LoC in SubX over the past year. I've successfully gotten SubX bootstrapped
in itself. I've built an emulator for SubX that can emit traces of instructions
executed, and this trace provides me with &lt;a href='https://github.com/akkartik/mu/blob/master/browse_trace/Readme.md'&gt;a
time-travel debugging experience&lt;/a&gt;. I can also package up SubX programs with
a third-party OS kernel into bootable disk images that run natively or &lt;a
href='/post/iso-on-linode'&gt;on a cloud server&lt;/a&gt;. In spite of these milestones,
the syntax above is still (obviously) not entirely copacetic. In &lt;a href='/post/mu-2019-2'&gt;the
next post&lt;/a&gt; I describe my attempts to design the next level up, with strong
type-safety and memory-safety. Rather to my surprise, the design process
continues to seem inevitable.
&lt;p&gt;
&lt;div class='btw'&gt;(Thanks Garth Goldwater and &lt;a href='https://github.com/rdentato'&gt;Remo
Dentato&lt;/a&gt; for helpful feedback on drafts of this post.)&lt;/div&gt;&lt;img src=&quot;http://feeds.feedburner.com/~r/kartiks-scrapbook/~4/1i1vM8S3iW8&quot; height=&quot;1&quot; width=&quot;1&quot; alt=&quot;&quot;/&gt;</description>
    <feedburner:origLink>http://akkartik.name/blog/mu-2019-1</feedburner:origLink></item>
    <item>
      <title>Four example projects</title>
      <link>http://feeds.akkartik.name/~r/kartiks-scrapbook/~3/P6LqZ4jFsFg/four-repos</link>
      <pubDate>Sat, 16 Mar 2019 00:08:22 -0700</pubDate>
      <guid isPermaLink="false">http://akkartik.name/post/four-repos</guid>
      <description>&lt;p&gt;
&lt;div style='margin-left:3em'&gt;
&lt;span class='left_quote_char'&gt;&amp;ldquo;&lt;/span&gt;&lt;em&gt;Most kinds of power require a
substantial sacrifice&amp;hellip; By the time someone has acquired it, he has also
matured to the point where he won't use it unwisely.&lt;/em&gt;&amp;rdquo;
&lt;br&gt;&amp;mdash; Ian Malcolm, &lt;a href='https://www.imdb.com/title/tt0107290/quotes?item=qt1464414'&gt;&amp;ldquo;Jurassic Park&amp;rdquo;&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;div style='margin-left:3em'&gt;
&lt;span class='left_quote_char'&gt;&amp;ldquo;&lt;/span&gt;&lt;em&gt;It is impossible to form
anything which has the character of nature by adding pre-formed parts.&lt;/em&gt;&amp;rdquo;
&lt;br&gt;&amp;mdash; Christopher Alexander, &lt;a href='https://www.amazon.com/Timeless-Way-Building-Christopher-Alexander/dp/0195024028'&gt;&amp;ldquo;A Timeless Way of Building&amp;rdquo;&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
Lately I tend to program in a certain unconventional manner. A series of design
choices, each seemingly reasonable in isolation, take me pretty far from
conventional wisdom.
&lt;p&gt;
&lt;!-- more --&gt;
&lt;p&gt;
&lt;ol&gt;
&lt;p&gt;
&lt;li&gt; Axiomatically, &lt;a href='/about'&gt;I care as much about the experience of
reading my code&lt;/a&gt; as that of running my programs.
&lt;p&gt;
&lt;li&gt; Programs are easier to grok when you can run them, so I try to keep my
programs super easy to build.
&lt;p&gt;
&lt;li&gt; Dependencies add moving parts when building from source, so I try to
minimize them.
&lt;p&gt;
&lt;li&gt; All languages tend to directly or indirectly depend on C, so I try to cut
out the middle men and program directly in C (unless I'm &lt;a href=&quot;https://archive.org/details/akkartik-mu-2021-04-22&quot;&gt;prototyping&lt;/a&gt;).
&lt;p&gt;
&lt;li&gt; Describing dependencies explicitly tends to make C projects (header files
and so on) hard to reorganize, so I rely on small codebase size and automatically
generated headers to keep my code supple.
&lt;p&gt;
&lt;li&gt; Grokking strange new codebases is hard, so I organize my projects in
&lt;a href='/post/wart-layers'&gt;layers&lt;/a&gt; that can be ignored in the beginning to
focus on a tiny subset of code that still builds and runs.
&lt;p&gt;
&lt;li&gt; Determining if a code change is good &lt;a href='/post/1451852'&gt;can be harder
than making the change itself&lt;/a&gt;, so I try to provide lots of automated tests
as guardrails for newcomers.
&lt;p&gt;
&lt;li&gt; And finally, this list is already pretty long so I give up on almost
everything else, making a virtue of a &lt;a href=&quot;/post/unfolding&quot;&gt;rough&lt;/a&gt;, low-polish aesthetic in hopes of
minimizing my area of concern and so controlling complexity over time.
Sometimes people are forced to go in and modify my codebase.
&lt;a href='https://en.wikipedia.org/wiki/Wabi-sabi'&gt;So be it!&lt;/a&gt;
&lt;p&gt;
&lt;/ol&gt;
&lt;p&gt;
Applied together, these concerns make my projects look fairly unfamiliar at
first glance, with strange directives mixed into what seems like a C program,
files auto-generated by the build system, strange looking tests and so on. To
help newcomers gain an initial orientation, here is a series of four example
repos that gradually introduce my idioms:
&lt;p&gt;
&lt;ul&gt;
&lt;p&gt;
&lt;li&gt; &lt;a href='https://git.sr.ht/~akkartik/basic-build'&gt;basic-build&lt;/a&gt;: a
zero-dependency build system in 30 lines of code. All it needs is &lt;tt&gt;/bin/sh&lt;/tt&gt;.
&lt;p&gt;
&lt;li&gt; &lt;a href='https://git.sr.ht/~akkartik/basic-test'&gt;basic-test&lt;/a&gt;: a
bare-bones test harness for C in 45 lines of code.
&lt;p&gt;
&lt;li&gt; &lt;a href='https://git.sr.ht/~akkartik/basic-whitebox-test'&gt;basic-whitebox-test&lt;/a&gt;:
a sandbox for &lt;a href='/post/tracing-tests'&gt;my white-box tests&lt;/a&gt; that enable
more comprehensive testing, more radical code reorganizations, and &lt;a href='https://git.sr.ht/~akkartik/basic-whitebox-test/tree/main/browse_trace/Readme.md'&gt;more scalable &amp;ldquo;debug by &lt;tt&gt;print&lt;/tt&gt;&amp;rdquo;&lt;/a&gt;.
&lt;p&gt;
&lt;li&gt; &lt;a href='https://git.sr.ht/~akkartik/basic-layers'&gt;basic-layers&lt;/a&gt;: a
sandbox for &lt;a href='/post/wart-layers'&gt;my non-modular, abstraction-busting
approach to organizing large-ish projects&lt;/a&gt;.
&lt;p&gt;
&lt;/ul&gt;
&lt;p&gt;
My hope is that these repos act like foundational &amp;ldquo;meta layers&amp;rdquo;
that help peel back some of the complexity in my larger &lt;a href='https://github.com/akkartik/mu/blob/master/Readme.md'&gt;Mu&lt;/a&gt;
project, and so make it more accessible to others. They aren't really
intended to be read in a browser, so &lt;tt&gt;git clone&lt;/tt&gt; them (Mac or *nix) and
try following the Readme. &lt;a href='mailto:ak@akkartik.com'&gt;Comments and
feedback most appreciated,&lt;/a&gt; particularly if you're moved to try building
something using them.
&lt;p&gt;
&lt;em&gt;(Update 2019-08-14: &lt;a href='https://github.com/rdentato/bld'&gt;Remo Dentato
has a project developing &lt;tt&gt;basic-build&lt;/tt&gt; further.&lt;/a&gt;)&lt;/em&gt;&lt;img src=&quot;http://feeds.feedburner.com/~r/kartiks-scrapbook/~4/P6LqZ4jFsFg&quot; height=&quot;1&quot; width=&quot;1&quot; alt=&quot;&quot;/&gt;</description>
    <feedburner:origLink>http://akkartik.name/blog/four-repos</feedburner:origLink></item>
    <item>
      <title>Nobody's just reading your code</title>
      <link>http://feeds.akkartik.name/~r/kartiks-scrapbook/~3/nmxFZdKT0ew/comprehension</link>
      <pubDate>Sun, 25 Feb 2018 19:11:20 -0800</pubDate>
      <guid isPermaLink="false">http://akkartik.name/post/comprehension</guid>
      <description>&lt;p&gt;
&lt;em&gt;A guest post by &lt;a href='http://an1lam.github.io/about.html'&gt;Stephen
Malina&lt;/a&gt;, my partner in crime on &lt;a href='https://github.com/akkartik/mu'&gt;Mu&lt;/a&gt;.&lt;/em&gt;
&lt;p&gt;
Most programmers agree that we don't read enough code. The
interviews in Peter Seibel's book, &lt;a href='https://www.amazon.com/gp/product/1430219483/ref=as_li_ss_tl?ie=UTF8&amp;linkCode=sl1&amp;tag=&amp;linkId=8efd5271f2629980e5785fafb178b201'&gt;&amp;ldquo;Coders at work&amp;rdquo;&lt;/a&gt;
highlight a comical contradiction: almost all the programmers interviewed by
Seibel recommend that others read code for fun, but none of them routinely do
so themselves. Seibel even &lt;a href='http://www.gigamonkeys.com/code-quarterly/2011/hal-abelson'&gt;asked
Hal Abelson&lt;/a&gt; (of &lt;a href='https://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs'&gt;SICP&lt;/a&gt;
fame) directly about this phenomenon:
&lt;p&gt;
&lt;div style='margin-left:3em'&gt;
&lt;span class='left_quote_char'&gt;&amp;ldquo;&lt;/span&gt;I want to dig a little deeper on
this. You, like many other people, say programmers should read code. Yet when
I ask what code have you read for fun or edification, you—also like many other
people—answer that you read students’ code, which is your job, and review code
at Google, which is also your job. But it doesn’t sound like you sit down of
an evening with a nice printout and read it.
&lt;/div&gt;
&lt;p&gt;
&lt;!-- more --&gt;
&lt;a href=&quot;http://www.gigamonkeys.com/code-reading&quot;&gt;Seibel&lt;/a&gt;, &lt;a href='http://prog21.dadgum.com/194.html'&gt;James Hague&lt;/a&gt;
and &lt;a href=&quot;http://disq.us/p/qvter6&quot;&gt;others&lt;/a&gt; have all tried to justify why code
reading is so uncommon, and they make good points. But perhaps the conversation
is led astray by use of the word &amp;lsquo;read&amp;rsquo;. I wonder if Abelson and
the others would have had more examples if Seibel had asked them what code
they had &lt;em&gt;learned about&lt;/em&gt; for fun. Perhaps the word &amp;lsquo;read&amp;rsquo;
put them in a passive frame of mind, causing them to filter out programs
they'd &lt;em&gt;hacked on&lt;/em&gt;?
&lt;p&gt;
We all read code already; it’s just that we usually read when we want to edit.
And the &lt;em&gt;comprehension&lt;/em&gt; that questions about reading are really
concerned with&amp;mdash;it comes from both reading and writing, interleaved in
complex ways.
&lt;p&gt;
That hacking produces better comprehension than passive, linear reading fits
with what we know about learning. &lt;a href='http://nautil.us/issue/40/learning/how-i-rewired-my-brain-to-become-fluent-in-math-rp'&gt;Barbara Oakley&lt;/a&gt;,
&lt;a href='http://158.132.155.107/posh97/private/learning/learning-Simon.htm'&gt;Herbert Simon&lt;/a&gt;,
&lt;a href='http://calnewport.com/blog/2012/08/10/you-know-what-you-write-the-textbook-method-for-ultra-learning'&gt;Cal Newport&lt;/a&gt;,
and &lt;a href='http://projects.ict.usc.edu/itw/gel/EricssonDeliberatePracticePR93.PDF'&gt;Anders Ericsson&lt;/a&gt;
all describe how solid understanding emerges from active exploration, critical
examination, repetition, and synthesis. Hacking beats passive reading on three
out of four of these criteria:
&lt;p&gt;
&lt;ol&gt;
&lt;li&gt;Active exploration: When you hack, you want to eventually produce a
change in the codebase. This desire guides your path through the code. When
you read passively you let the code’s linear flow guide you.
&lt;p&gt;
&lt;li&gt;Critical examination: When you hack, you evaluate existing code in light
of the change you want to make. Deciding what to use and remove keeps you from
accepting the existing system as canon. When you read linearly, you lack a
goal against which you can critically examine the existing code.
&lt;p&gt;
&lt;li&gt;Synthesis: To change the program as you desire, you synthesize existing
code with new code.
&lt;p&gt;
&lt;li&gt;Repetition: Neither hacking nor linear reading involve useful repetition,
unless you treat your change to make like a &lt;em&gt;kata&lt;/em&gt; and mindfully
re-implement it multiple times.
&lt;p&gt;
&lt;/ol&gt;
&lt;p&gt;
Learning through hacking also leverages the natural structure of a codebase.
Good books guide their readers through series of questions and their answers,
but codebases are inherently non-linear, like a map. You can ask an infinite
number of questions of a map. How far is it from A to B? Which is the nearest
town to C? But you can’t expect a map to tell you what questions to ask, and
it makes no sense to read a map linearly from top to bottom, left to right.
&lt;p&gt;
Reframing reading as &amp;lsquo;navigation&amp;rsquo; suggests that our conventional
discussions of clean code and interfaces ignore the things that actually make
unfamiliar code accessible to outsiders. Clean, solidified abstractions are
like well-marked, easy-to-follow paths through a forest &amp;mdash; very useful if
they lead in the direction we need to go, but less useful when we want to
blaze arbitrary new paths through the forest.
&lt;p&gt;
Instead, let's focus on &lt;em&gt;guiding exploration&lt;/em&gt;, making it easier for
readers to answer their own questions about codebases. I’m still figuring out
how to do this; so far I have just a couple of preliminary ideas:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt;Suggest features in your code that make good exercises for re-implementation.
Provide an initial Git commit without the feature, give them hints where
necessary, and link them to the actual change plus others’ attempts at
producing it.
&lt;p&gt;
&lt;li&gt;Rather than conceiving of documentation as something that explains
individual modules, focus on overviews of how the modules fit together (like
&lt;a href='http://fabiensanglard.net/git_code_review/index.php'&gt;Fabien Sanglard's&lt;/a&gt;
for Git).
&lt;p&gt;
&lt;/ul&gt;
&lt;p&gt;
&lt;em&gt;Afterword&lt;/em&gt;
&lt;p&gt;
Others have explored similar ideas from different perspectives:
&lt;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href='http://www.catb.org/esr/faqs/hacker-howto.html'&gt;&amp;ldquo;How To Be A Hacker&amp;rdquo;&lt;/a&gt;:
Eric Raymond discusses what he calls the &amp;ldquo;the incremental-hacking
cycle&amp;rdquo;, a process by which someone gradually expands their understanding
of a codebase by making bigger and bigger changes to it.
&lt;p&gt;
&lt;li&gt;&lt;a href='https://www.drmaciver.com/2016/05/how-to-read-a-mathematics-textbook'&gt;&amp;ldquo;How to read a math textbook&amp;rdquo;&lt;/a&gt;:
David Maciver describes a problem- and theorem-driven approach for learning
math which you could adapt to reading programs.
&lt;p&gt;
&lt;li&gt;&lt;a href='http://www.pathsensitive.com/2018/01/the-benjamin-franklin-method-of-reading.html'&gt;&amp;ldquo;The
Benjamin Franklin method of reading programming books&amp;rdquo;&lt;/a&gt;: James
Koppel's take on Anders Ericsson.
&lt;p&gt;
&lt;/ul&gt;&lt;img src=&quot;http://feeds.feedburner.com/~r/kartiks-scrapbook/~4/nmxFZdKT0ew&quot; height=&quot;1&quot; width=&quot;1&quot; alt=&quot;&quot;/&gt;</description>
    <feedburner:origLink>http://akkartik.name/blog/comprehension</feedburner:origLink></item>
    <item>
      <title>Delimited continuations in a statement-oriented language</title>
      <link>http://feeds.akkartik.name/~r/kartiks-scrapbook/~3/-tJtnQypHZk/continuations</link>
      <pubDate>Mon, 27 Nov 2017 03:46:12 -0800</pubDate>
      <guid isPermaLink="false">http://akkartik.name/post/continuations</guid>
      <description>&lt;p&gt;
I've been periodically wrestling with the concept of &lt;a href=&quot;https://en.wikipedia.org/wiki/Continuation&quot;&gt;continuations&lt;/a&gt;
for several years now, and have somehow never gotten comfortable with them.
Looking back, I think this was for two reasons:
&lt;p&gt;
&lt;ol&gt;
&lt;li&gt;Continuations are usually explained in the context of high-level languages
with higher-order functions and lots of nested function calls. But continuations
fundamentally subvert the notion of &amp;ldquo;function&amp;rdquo;. Operators like
&amp;lsquo;&lt;tt&gt;reset&lt;/tt&gt;&amp;rsquo; looked like functions, but had &lt;a href='https://en.wikipedia.org/wiki/Action_at_a_distance'&gt;&amp;ldquo;spooky
action at a distance&amp;rdquo;&lt;/a&gt; effects that were hard to reason about.&lt;/li&gt;
&lt;p&gt;
&lt;li&gt;I had trouble finding real-world programs where continuations are more
expressive than regular recursive function calls with well-designed data
structures. For example, classic back-tracking problems like &lt;a href='https://www.cs.cmu.edu/~rwh/introsml/techniques/optexccont.htm'&gt;the
N-queens problem&lt;/a&gt; have elegant solutions that don't require continuations.
Were continuations just a low-level primitive for building more high-level
tools like generators (&lt;tt&gt;&amp;lsquo;yield&amp;rsquo;&lt;/tt&gt;) and exceptions? Building
fluency with a concept requires developing an instinct for when it's applicable.
&lt;p&gt;
&lt;/ol&gt;
&lt;!-- more --&gt;
&lt;p&gt;
In response to the first issue, I've been adding delimited continuations to &lt;a href=&quot;https://github.com/akkartik/mu&quot;&gt;Mu&lt;/a&gt;
(my experimental testbed for &lt;a href='/about'&gt;ways to make the big picture of
codebases more comprehensible&lt;/a&gt;, and for &lt;a href='/post/mu'&gt;ways to teach
programming without dwelling on syntax&lt;/a&gt;). And indeed, implementing continuations
did seem to help me understand them better. And they did seem more comprehensible
in a statement-oriented language where the mind was already accustomed to
running into jump instructions. In Mu it becomes more obvious that that
continuation operators are just stack manipulations.
&lt;p&gt;
However, I still didn't have confidence that I actually &lt;em&gt;had&lt;/em&gt; built
delimited continuations. Perhaps in translating them from Scheme to Mu I'd
hamstrung them in some subtle way? This question connected up with the second
issue: I had a hammer, but no non-trivial nails to use it on.
&lt;p&gt;
Recently, I remembered an old favorite of mine: &lt;a href='https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html'&gt;&amp;ldquo;Coroutines
in C&amp;rdquo;&lt;/a&gt; by Simon Tatham. Coroutines are known to be implementable
using continuations, and Simon's essay had a nice example program using
coroutines.
&lt;p&gt;
One thing led to another, and I ended up porting Simon's essay: &lt;b&gt;&lt;a href='/coroutines-in-mu/'&gt;&amp;ldquo;Coroutines
in Mu&amp;rdquo;&lt;/a&gt;&lt;/b&gt;.
&lt;p&gt;
I'm probably just weird and &lt;a href='http://wiki.c2.com/?BrainDamage'&gt;brain
damaged&lt;/a&gt; for preferring to see continuations in a sort of Assembly language
rather than a high-level one. But if you've tried to understand continuations
in the past and not gotten comfortable with them, try working through my essay
and see if coming at the idea from a different angle helps. Prerequisites:
knowledge of C and Simon's original.
&lt;p&gt;
&lt;em&gt;Grateful appreciation to Simon Tatham for generously permitting me to
remix his essay, and to Stephen Malina for closely reading my version and
carefully checking all the code examples.&lt;/em&gt;&lt;img src=&quot;http://feeds.feedburner.com/~r/kartiks-scrapbook/~4/-tJtnQypHZk&quot; height=&quot;1&quot; width=&quot;1&quot; alt=&quot;&quot;/&gt;</description>
    <feedburner:origLink>http://akkartik.name/blog/continuations</feedburner:origLink></item>
    <item>
      <title>The cargo cult of versioning</title>
      <link>http://feeds.akkartik.name/~r/kartiks-scrapbook/~3/hfq6gKju-bo/versioning</link>
      <pubDate>Fri, 10 Nov 2017 19:15:32 -0800</pubDate>
      <guid isPermaLink="false">http://akkartik.name/post/versioning</guid>
      <description>&lt;p&gt;
[&lt;em&gt;Update Nov 27: This post had issues, and I retract some of my more
provocative claims. See the errata at the end.&lt;/em&gt;]
&lt;p&gt;
All software comes with a version, some sequence of digits, periods and
characters that seems to march ever upward. Rarely are the optimistically
increasing versions accompanied by a commensurate increase in robustness.
Instead, upgrading to new versions often causes regressions, and the stream of
versions ends up spawning an extensive grapevine to disseminate information
about the best version to use. Unsatisfying as this state of affairs is to
everyone, I didn't think that the problem lay with these version numbers
themselves. They're just names, right? However, over the past year I've
finally had my attention focused on them, thanks to two people:
&lt;p&gt;
&lt;!-- more --&gt;
&lt;div style='margin-left:3em'&gt;
&lt;li&gt;Rich Hickey pointed out &lt;a href='https://www.youtube.com/watch?v=oyLBGkS5ICk'&gt;last
year&lt;/a&gt; that the convention of bumping the major version of a library to
indicate incompatibility conveys no more actionable information than just
changing the name of the library.
&lt;p&gt;
&lt;li&gt;I recently encountered &lt;a href='http://stevelosh.com/blog/2012/04/volatile-software'&gt;this
post from 2012 by Steve Losh&lt;/a&gt;, pointing out that if version numbers were
any good, we'd almost always be looking to use the latest version number. But
that doesn't happen. In the real world we're constantly trying to hold the
stream of versions back, to clamp version numbers to some ceiling. &lt;em&gt;Pinning&lt;/em&gt;
our systems to use a specific version or range of versions.
&lt;/div&gt;
&lt;p&gt;
Why is version pinning so prevalent? The proximal reason is that modern
package managers uniformly&lt;sup&gt;&lt;a href='#f1'&gt;1&lt;/a&gt;&lt;/sup&gt; fail to provide the sane default of &quot;give me the
latest compatible version, excluding breaking changes.&quot;
&lt;p&gt;
&lt;div style='margin-left:3em'&gt;
&lt;li&gt;RubyGems defaults to newest version available. So if you don't specify a
version for a dependency and they create a breaking v3.0 when you've been
implicitly using v2.2, &lt;em&gt;boom&lt;/em&gt;. Result: best practice of pinning major
version using the &lt;em&gt;&lt;a href='http://guides.rubygems.org/patterns/#declaring-dependencies'&gt;twiddle-waka&lt;/a&gt;&lt;/em&gt;
or &lt;a href='https://robots.thoughtbot.com/rubys-pessimistic-operator'&gt;pessimistic&lt;/a&gt;
operator all over the place, and Steve Losh shaking head sadly.
&lt;p&gt;
&lt;li&gt;NPM for Node.js defaults to version tagged &quot;latest&quot;. Again, if you go
with the default version your project is liable to go &lt;em&gt;boom&lt;/em&gt; at some
future date. Best practice is to pin major versions using either the tilde
operator or tags. Cue more sadness for Steve Losh. [&lt;em&gt;Edit&lt;/em&gt;: The
fact that you're required to provide some sort of version string at least
raises the question of what it should be. It's still a gotcha that the empty
string &lt;span style='font-family:fixed; background-color:#f6f6f6'&gt;&quot;&quot;&lt;/span&gt;
means &quot;latest&quot;, but it's mitigated by the use of &lt;span style='font-family:fixed;
background-color:#f6f6f6'&gt;npm install --save&lt;/span&gt; to record dependencies
rather than editing package.json directly.]
&lt;p&gt;
&lt;li&gt;&lt;strike&gt;Leiningen for Clojure once again defaults to the latest version.&lt;/strike&gt;
[&lt;em&gt;Correction&lt;/em&gt;: &lt;a href='https://lobste.rs/s/a4wvbs/cargo_cult_versioning#c_nd8oir'&gt;a
comment&lt;/a&gt; pointed out that Clojure has no default, but always requires a
version. This approach suffers from the opposite problem: you never get
&lt;em&gt;any&lt;/em&gt; bugfixes or security fixes unless you explicitly mess with
package.clj.]
&lt;p&gt;
&lt;li&gt;&amp;hellip;and so on.
&lt;/div&gt;
&lt;p&gt;
These are all deep, competent projects. Why are their defaults so uniformly
useless and misleading? The underlying reason is the traditional format of
version numbers: mashing together multiple numbers into a single string, and
more importantly &lt;em&gt;separating&lt;/em&gt; the version string from the name of a
package. A dependency that is just a name provides no hint on what version you
want compatibility &lt;em&gt;with&lt;/em&gt;, so a package manager has no easy way to pick
a good default version.
&lt;p&gt;
&lt;em&gt;Towards a better approach&lt;/em&gt;
&lt;p&gt;
To begin with, it's weird that versions are strings. &lt;a href='https://github.com/npm/node-semver/blob/master/test/major-minor-patch.js'&gt;Parsing
versions is non-trivial.&lt;/a&gt; Let's just make them a tuple. Instead of &quot;3.0.2&quot;,
we'll say &quot;(3, 0, 2)&quot;.
&lt;p&gt;
Next, move the major version to part of the name of a package. &quot;Rails 5.1.4&quot;
becomes &quot;Rails-5 (1, 4)&quot;. By following Rich Hickey's suggestion above, we also
sidestep the question of what the default version should be. There's just no
way to refer to a package without its major version.
&lt;p&gt;
Since we always want to provide the latest version by default, the distinction
between minor versions and patch levels is moot. Just combine the 2-tuple into
a single number. &quot;LeftPad 17.5.0&quot; would now become something like &quot;LeftPad-17
37&quot;.
&lt;p&gt;
At this point you could even get rid of the version altogether and just use
the commit hash on the rare occasions when we need a version identifier. We're
all on the internet, and we're all constantly running &lt;span style='font-family:fixed;
background-color:#f6f6f6'&gt;npm install&lt;/span&gt; or equivalent. Just say &quot;Leftpad-17&quot;,
it's cleaner.
&lt;p&gt;
And that's it. Package managers should provide no options for version pinning.
&lt;p&gt;
A package manager that followed such a proposal would foster an eco-system
with greater care for introducing incompatibility&lt;sup&gt;&lt;a href='#f2'&gt;2&lt;/a&gt;&lt;/sup&gt;.
Packages that wantonly broke their consumers would &quot;gain a reputation&quot; and get
out-competed by packages that didn't, rather than gaining a &quot;temporary&quot;
pinning that serves only to &lt;a href='http://250bpm.com/blog:51'&gt;perpetuate
them&lt;/a&gt;. The occasional unintentional breakage would necessitate people
downstream cloning repositories and changing dependency URLs, which would
create a much more stringent atmosphere of accountability for the breaking
package. As a result, breaking changes wouldn't live so long that they gain
&lt;em&gt;new&lt;/em&gt; users.
&lt;p&gt;
In particular, &lt;a href='http://semver.org'&gt;Semantic Versioning&lt;/a&gt; is misguided,
an attempt to fix something that is broken beyond repair. The correct way to
practice semantic versioning is without any version strings at all, just Rich
Hickey's directive: &lt;b&gt;if you change behavior, rename&lt;/b&gt;. Or ok, keep a
number around if you &lt;em&gt;really&lt;/em&gt; need a security blanket. Either way, we
programmers should be manually messing with version numbers a whole lot less.
They're a holdover from the pre-version-control pre-internet days of shrink-wrapped
software, vestigial in a world of pervasive connectivity and constant push
updates. All version numbers do is provide cover for incompatibilities to hide
under.
&lt;p&gt;
&lt;em&gt;Update (Nov 27)&lt;/em&gt;
&lt;p&gt;
This post aroused a lot of great feedback on &lt;a href='https://news.ycombinator.com/item?id=15676691'&gt;Hacker
News&lt;/a&gt; and &lt;a href='https://lobste.rs/s/a4wvbs/cargo_cult_versioning'&gt;Lobste.rs&lt;/a&gt;.
After a day of engaging with comments my conclusion was that I should have
been more explicit about my focus: the flow for upgrading (and testing)
software in development, not deploying to production. In particular, the post
doesn't make &lt;em&gt;any&lt;/em&gt; claims about versions in production. Reproducible
builds are great! But you just need a hash for them. Right?
&lt;p&gt;
A prolonged exchange with &lt;a href='https://github.com/joelparkerhenderson/versioning'&gt;Joel
Parker Henderson&lt;/a&gt; convinced me that it's just not feasible to separate
operational concerns from development concerns. A common question when
managing software in production is, &quot;what version is this running?&quot; And that
question quickly requires drilling down to the constituent pieces of a release
and &lt;em&gt;their&lt;/em&gt; versions. A hash makes that too hard. And you can't have
separate version strings for development and deployment either, that's just a
recipe for confusion. Therefore, if you take operational considerations into
account, my claim that we don't need versions at all is invalid.
&lt;p&gt;
What, if anything, remains of value in this post? Package managers should by
default never upgrade dependencies past a major version.
&lt;p&gt;
The design goal of a package manager should be that a dependency once added
to &lt;tt&gt;Gemfile&lt;/tt&gt; or &lt;tt&gt;package.json&lt;/tt&gt; should never need to be modified
until it's deleted. What people specify manually goes there, what the package
manager deduces goes somewhere else (like &lt;tt&gt;Gemfile.lock&lt;/tt&gt;). If people
are editing version strings &lt;em&gt;en masse&lt;/em&gt; in &lt;tt&gt;Gemfile&lt;/tt&gt; or equivalent,
that is a smell.
&lt;p&gt;
In the next mainstream platform, the versions people specify for dependencies
should consist of just a major version, because that's the part that the
package manager can never deduce. SemVer is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Siren_(mythology)&quot;&gt;siren&lt;/a&gt;
here because it conflates pieces from multiple jurisdictions. The major
version is the user's responsibility, and minor and patch versions are the
package manager's. Why coalesce the two? That just necessitates baroque syntax
like twiddle-waka to do the safe thing.
&lt;p&gt;
(And oh, if RubyGems and NPM are smelly, the Clojure approach totally stinks.
Clojure requires manual intervention to pull in compatible/security fixes for
dependencies. It follows the existing Java approach, but Java's eco-system
predates the advance of package managers, half of whose &lt;a href='https://en.wikipedia.org/wiki/Package_manager'&gt;reason
for existence&lt;/a&gt; &amp;mdash; after installing dependencies &amp;mdash; is updating
dependencies. I may still be unaware of some design rationale here, but for
now I think Leiningen really missed an opportunity to improve on Java here.)
&lt;p&gt;
&lt;br/&gt;
&lt;center&gt;&lt;em&gt;footnotes&lt;/em&gt;&lt;/center&gt;
&lt;p&gt;
&lt;a name='f1'&gt;&lt;/a&gt;1. One exception here is Go, where the standard &lt;span
style='font-family:fixed; background-color:#f6f6f6'&gt;go get&lt;/span&gt; command &lt;a
href='https://stackoverflow.com/questions/24855081/how-do-i-import-a-specific-version-of-a-package-using-go-get/26546559#26546559'&gt;requires
no versions, and always grabs the head of the repo&lt;/a&gt;. However, the community
seems to be turning from the light to the darkness with &lt;a href='https://blog.gopheracademy.com/advent-2016/saga-go-dependency-management'&gt;a
proposal&lt;/a&gt; for a tool called &lt;span style='font-family:fixed; background-color:#f6f6f6'&gt;go
dep&lt;/span&gt;. It's unclear to me if this is due to a failure of communication on
the part of the original authors of Go, or if there's a deeper justification
for &lt;span style='font-family:fixed; background-color:#f6f6f6'&gt;go dep&lt;/span&gt;
that I'm missing. If you know, set me straight in the comments below.
&lt;p&gt;
&lt;a name='f2'&gt;&lt;/a&gt;2. Following Steve Losh, we'll allow packages ending in &quot;-0&quot;
to make incompatible changes to their heart's content.&lt;img src=&quot;http://feeds.feedburner.com/~r/kartiks-scrapbook/~4/hfq6gKju-bo&quot; height=&quot;1&quot; width=&quot;1&quot; alt=&quot;&quot;/&gt;</description>
    <feedburner:origLink>http://akkartik.name/blog/versioning</feedburner:origLink></item>
    <item>
      <title>How the right syntax can help teach recursion</title>
      <link>http://feeds.akkartik.name/~r/kartiks-scrapbook/~3/09761iUJMW0/swamp</link>
      <pubDate>Tue, 13 Sep 2016 20:48:19 -0700</pubDate>
      <guid isPermaLink="false">http://akkartik.name/post/swamp</guid>
      <description>&lt;p&gt;
(Or why &lt;tt style='font-size:110%'&gt;goto&lt;/tt&gt; is worth keeping around in modern
languages.)
&lt;p&gt;
&lt;div style='margin-left:3em'&gt;
&lt;span class='left_quote_char'&gt;&amp;ldquo;&lt;/span&gt;&lt;em&gt;It seems to me that there have
been two really clean, consistent models of programming so far: the C model
and the Lisp model. These two seem points of high ground, with swampy lowlands
between them.&amp;rdquo;&lt;/em&gt; &amp;mdash; &lt;a href='http://www.paulgraham.com/rootsoflisp.html'&gt;Paul Graham&lt;/a&gt;
&lt;/div&gt;
&lt;p&gt;
A cool thing happened during a &lt;a href=&quot;/post/mu&quot;&gt;lesson&lt;/a&gt; today, and I wanted to try to capture
the magic before it slipped through my fingers. It happened while I was trying
to teach recursion (without ever using that word) using my side project, &lt;a href=&quot;https://github.com/akkartik/mu&quot;&gt;Mu&lt;/a&gt;.
The experience got me thinking about the quote above, and wondering if there
was a way to bridge the summits of C and Lisp without having to go through the
&amp;ldquo;swampy lowlands&amp;rdquo; between them.
&lt;p&gt;
&lt;!-- more --&gt;
But I'm getting ahead of myself. I've &lt;a href='http://akkartik.name/post/mu'&gt;written about Mu&lt;/a&gt;
before, but you don't need to remember any of that for this post. All you need
to know is that it's basically a cleaned up reimplementation of C's memory
model, with the ability to manipulate addresses in memory.
&lt;p&gt;
If you learned programming using C you probably learned to create a generic
linked list something like this (using a sort of timeless mish-mash of C and
C++ that is guaranteed to not compile):
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;&lt;span style='color:DarkSeaGreen'&gt;struct&lt;/span&gt; list&amp;lt;&lt;span style='color:Salmon'&gt;T&lt;/span&gt;&amp;gt; {
&amp;nbsp;  &lt;span style='color:Salmon'&gt;T&lt;/span&gt; value;
&amp;nbsp;  list&amp;lt;&lt;span style='color:Salmon'&gt;T&lt;/span&gt;&amp;gt;* rest;
&amp;nbsp;}
&lt;/pre&gt;
&lt;p&gt;
In Mu you'd write this as:
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;&lt;span style='color:DarkSeaGreen'&gt;container&lt;/span&gt; list:&lt;span style='color:Salmon'&gt;_T&lt;/span&gt; [
&amp;nbsp;  value:&lt;span style='color:Salmon'&gt;_T&lt;/span&gt;
&amp;nbsp;  rest:address:list:&lt;span style='color:Salmon'&gt;_T&lt;/span&gt;  &lt;span style='color:blue'&gt;# &quot;an address to a list of &lt;span style='color:Salmon'&gt;_T&lt;/span&gt;&quot;&lt;/span&gt;
&amp;nbsp;]
&lt;/pre&gt;
&lt;p&gt;
To gradually introduce recursion I first had my student write a function to
calculate the length of a list. In C you'd tend to do this using a loop:
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;int length(list&amp;lt;T&amp;gt;* &lt;span style='color:Sienna'&gt;x&lt;/span&gt;) {
&amp;nbsp;  int &lt;span style='color:Salmon'&gt;result&lt;/span&gt; = 0;
&amp;nbsp;  &lt;span style='color:DarkSeaGreen'&gt;while&lt;/span&gt; (&lt;span style='color:Sienna'&gt;x&lt;/span&gt;) {
&amp;nbsp;    ++&lt;span style='color:Salmon'&gt;result&lt;/span&gt;;
&amp;nbsp;    &lt;span style='color:Sienna'&gt;x&lt;/span&gt; = &lt;span style='color:Sienna'&gt;x&lt;/span&gt;-&gt;rest;
&amp;nbsp;  }
&amp;nbsp;  &lt;span style='color:DarkSeaGreen'&gt;return&lt;/span&gt; &lt;span style='color:Salmon'&gt;result&lt;/span&gt;;
&amp;nbsp;}
&lt;/pre&gt;
&lt;p&gt;
This was my student's initial approach as well in Mu:
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;&lt;span style='color:DarkSeaGreen'&gt;def&lt;/span&gt; length &lt;span style='color:Sienna'&gt;x&lt;/span&gt;:address:list:_T &lt;span style='color:DarkSeaGreen'&gt;&amp;rarr;&lt;/span&gt; &lt;span style='color:Salmon'&gt;result&lt;/span&gt;:number [
&amp;nbsp;  &lt;span style='color:Salmon'&gt;result&lt;/span&gt; &amp;larr; copy 0
&amp;nbsp;  {
&amp;nbsp;    &lt;span style='color:DarkSeaGreen'&gt;break-unless&lt;/span&gt; &lt;span style='color:Sienna'&gt;x&lt;/span&gt;  &lt;span style='color:blue'&gt;# break if &lt;span style='color:Sienna'&gt;x&lt;/span&gt; is empty&lt;/span&gt;
&amp;nbsp;    &lt;span style='color:Salmon'&gt;result&lt;/span&gt; &amp;larr; add &lt;span style='color:Salmon'&gt;result&lt;/span&gt; 1
&amp;nbsp;    &lt;span style='color:Sienna'&gt;x&lt;/span&gt; &amp;larr; rest &lt;span style='color:Sienna'&gt;x&lt;/span&gt;
&amp;nbsp;    &lt;span style='color:DarkSeaGreen'&gt;loop&lt;/span&gt;
&amp;nbsp;  }
&amp;nbsp;  &lt;span style='color:DarkSeaGreen'&gt;return&lt;/span&gt; &lt;span style='color:Salmon'&gt;result&lt;/span&gt;
&amp;nbsp;]
&lt;/pre&gt;
&lt;p&gt;
That translates pretty exactly from the idiomatic C. The only difference is
syntax: Mu instructions look like Basic or Assembly: just sequences of
instructions, no nested expressions or blocks. But they're doing the same
(hopefully obvious) thing.
&lt;p&gt;
Now for a recursive version. C tends to teach recursion later and use it less
frequently, so for a point of comparison we'll switch gears and imagine a
counterfactual universe where we're learning programming using Lisp&lt;sup&gt;&lt;a href='#f1'&gt;1&lt;/a&gt;&lt;/sup&gt;
(again with some liberties taken to make it easier to read that guarantee it
won't run anywhere in &lt;em&gt;this&lt;/em&gt; universe):
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;&lt;span style='color:blue'&gt;; the length of a list is 1 more&lt;/span&gt;
&amp;nbsp;&lt;span style='color:blue'&gt;; than the length of the rest of the list&lt;/span&gt;
&amp;nbsp;&lt;span style='color:DarkSeaGreen'&gt;def&lt;/span&gt; length (&lt;span style='color:Sienna'&gt;x&lt;/span&gt;)
&amp;nbsp;  &lt;span style='color:DarkSeaGreen'&gt;if&lt;/span&gt; (empty? &lt;span style='color:Sienna'&gt;x&lt;/span&gt;)
&amp;nbsp;    0
&amp;nbsp;    (+ 1 (length rest.&lt;span style='color:Sienna'&gt;x&lt;/span&gt;))
&lt;/pre&gt;
&lt;p&gt;
My student's Mu solution (after some struggles):
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;&lt;span style='color:blue'&gt;# the length of a list is 1 more&lt;/span&gt;
&amp;nbsp;&lt;span style='color:blue'&gt;# than the length of the rest of the list&lt;/span&gt;
&amp;nbsp;&lt;span style='color:DarkSeaGreen'&gt;def&lt;/span&gt; length &lt;span style='color:Sienna'&gt;x&lt;/span&gt;:address:list:_T &lt;span style='color:DarkSeaGreen'&gt;&amp;rarr;&lt;/span&gt; &lt;span style='color:Salmon'&gt;result&lt;/span&gt;:number [
&amp;nbsp;  &lt;span style='color:DarkSeaGreen'&gt;return-unless&lt;/span&gt; &lt;span style='color:Sienna'&gt;x&lt;/span&gt;, 0
&amp;nbsp;  &lt;span style='color:Sienna'&gt;x&lt;/span&gt; &amp;larr; rest &lt;span style='color:Sienna'&gt;x&lt;/span&gt;
&amp;nbsp;  &lt;span style='color:Salmon'&gt;result&lt;/span&gt; &amp;larr; length &lt;span style='color:Sienna'&gt;x&lt;/span&gt;
&amp;nbsp;  &lt;span style='color:Salmon'&gt;result&lt;/span&gt; &amp;larr; add 1, &lt;span style='color:Salmon'&gt;result&lt;/span&gt;
&amp;nbsp;]
&lt;/pre&gt;
&lt;p&gt;
It's a little harder to see because Lisp exclusively uses expressions while Mu
exclusively uses statements, but the two versions translate pretty exactly
between one another. The only difference is that you need to explicitly
provide types in Mu, just like in C.
&lt;p&gt;
Things got more interesting when we tried to translate another classic approach
to recursion that every programmer should possess in their toolbox: using an
accumulator. The above recursive version calculates the length &quot;on the way
out&quot;:
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;length [1, 2, 3]
&amp;nbsp;  &amp;rArr;length [2, 3]
&amp;nbsp;    &amp;rArr;length &amp;#91;3&amp;#93;
&amp;nbsp;      &amp;rArr;length []
&amp;nbsp;      &lt;span style='color:Salmon'&gt;0&lt;/span&gt; &amp;lArr;
&amp;nbsp;    &lt;span style='color:Salmon'&gt;1&lt;/span&gt; &amp;lArr;
&amp;nbsp;  &lt;span style='color:Salmon'&gt;2&lt;/span&gt; &amp;lArr;
&amp;nbsp;&lt;span style='color:Salmon'&gt;3&lt;/span&gt; &amp;lArr;
&lt;/pre&gt;
&lt;p&gt;
To calculate it &quot;on the way in&quot;, we'll use an extra argument to accumulate the
result:
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;length [1, 2, 3], &lt;span style='color:Salmon'&gt;0&lt;/span&gt;
&amp;nbsp;  &amp;rArr;length [2, 3], &lt;span style='color:Salmon'&gt;1&lt;/span&gt;
&amp;nbsp;    &amp;rArr;length &amp;#91;3&amp;#93;, &lt;span style='color:Salmon'&gt;2&lt;/span&gt;
&amp;nbsp;      &amp;rArr;length [], &lt;span style='color:Salmon'&gt;3&lt;/span&gt;
&amp;nbsp;      3 &amp;lArr;
&amp;nbsp;    3 &amp;lArr;
&amp;nbsp;  3 &amp;lArr;
&amp;nbsp;3 &amp;lArr;
&lt;/pre&gt;
&lt;p&gt;
You'd tend to write it like this in Lisp:
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;&lt;span style='color:DarkSeaGreen'&gt;def&lt;/span&gt; length (&lt;span style='color:Sienna'&gt;x&lt;/span&gt; &lt;span style='color:Salmon'&gt;total&lt;/span&gt;)
&amp;nbsp;  if (empty? &lt;span style='color:Sienna'&gt;x&lt;/span&gt;)
&amp;nbsp;    &lt;span style='color:Salmon'&gt;total&lt;/span&gt;
&amp;nbsp;    (length rest.&lt;span style='color:Sienna'&gt;x&lt;/span&gt; (+ &lt;span style='color:Salmon'&gt;total&lt;/span&gt; 1))
&lt;/pre&gt;
&lt;p&gt;
My student wrote it like this in Mu:
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;&lt;span style='color:DarkSeaGreen'&gt;def&lt;/span&gt; length &lt;span style='color:Sienna'&gt;x&lt;/span&gt;:address:list:_T, &lt;span style='color:Salmon'&gt;total&lt;/span&gt;:number &lt;span style='color:DarkSeaGreen'&gt;&amp;rarr;&lt;/span&gt; &lt;span style='color:Salmon'&gt;total&lt;/span&gt;:number [
&amp;nbsp;  &lt;span style='color:DarkSeaGreen'&gt;return-unless&lt;/span&gt; &lt;span style='color:Sienna'&gt;x&lt;/span&gt;, &lt;span style='color:Salmon'&gt;total&lt;/span&gt;
&amp;nbsp;  &lt;span style='color:Sienna'&gt;x&lt;/span&gt; &amp;larr; rest &lt;span style='color:Sienna'&gt;x&lt;/span&gt;
&amp;nbsp;  &lt;span style='color:Salmon'&gt;total&lt;/span&gt; &amp;larr; add &lt;span style='color:Salmon'&gt;total&lt;/span&gt;, 1
&amp;nbsp;  &lt;span style='color:Salmon'&gt;total&lt;/span&gt; &amp;larr; length &lt;span style='color:Sienna'&gt;x&lt;/span&gt;, &lt;span style='color:Salmon'&gt;total&lt;/span&gt;
&amp;nbsp;]
&lt;/pre&gt;
&lt;p&gt;
Again, a pretty exact translation. But I prefer the Mu version because it's
obvious that it's tail-recursive. With Lisp it's always been non-trivial to
know when a function is tail-recursive. You can't just blindly count parens,
you have to try to &quot;run&quot; the function in your mind. In Mu you can just check
the final instruction.
&lt;p&gt;
This benefit becomes even more apparent when you try to perform tail-recursion
elimination. All you have to do is &lt;em&gt;replace the recursive call with a jump (&lt;tt style='font-size:110%'&gt;goto&lt;/tt&gt;)
to the start of the function&lt;/em&gt;:
&lt;p&gt;
&lt;pre style='font-family:courier,fixed; margin-left:3em'&gt;
&amp;nbsp;def length x:address:list:_T, total:number &amp;rarr; total:number [
&amp;nbsp;  &lt;span style='color:SteelBlue'&gt;+start&lt;/span&gt;
&amp;nbsp;  return-unless x, total
&amp;nbsp;  x &amp;larr; rest x
&amp;nbsp;  total &amp;larr; add total, 1
&amp;nbsp;  &lt;span style='color:DarkSeaGreen'&gt;jump&lt;/span&gt; &lt;span style='color:SteelBlue'&gt;+start&lt;/span&gt;      &lt;span style='text-decoration:line-through'&gt;total &amp;larr; length x, total&lt;/span&gt;
&amp;nbsp;]
&lt;/pre&gt;
&lt;p&gt;
That was a pretty neat insight for my student, and it happened purely by
accident. It was startling how easy the translation from tail-recursive to
iterative versions was, and how easy it suddenly became to explain recursion
and recursion-elimination to a 12-year old in a single lesson. Strip C of its
historical accidents and you end up with something just as useful as Lisp for
teaching recursion.
&lt;p&gt;
The episode also helps highlight how the use of a single strategic &lt;tt style='font-size:110%'&gt;goto&lt;/tt&gt;
can help clarify a subject. A corollary of &lt;a href='https://en.wikipedia.org/wiki/Homoiconicity'&gt;homoiconicity&lt;/a&gt;
is that compiler optimizations too can benefit from &lt;a href='http://fexpr.blogspot.in/2016/08/interpreted-programming-languages.html'&gt;being data&lt;/a&gt;;
it makes them easier to understand. Even as high-level languages provide
increasingly abstract representations, it's worth keeping low-level features
like &lt;tt style='font-size:110%'&gt;goto&lt;/tt&gt;&lt;sup&gt;&lt;a href='#f2'&gt;2&lt;/a&gt;&lt;/sup&gt;
available in the source representation. They let you prototype compiler
optimizations without leaving the source language. They help you realize that
optimizations are just a more powerful kind of Lisp macro.
&lt;p&gt;
&lt;br/&gt;
&lt;center&gt;&lt;em&gt;footnotes&lt;/em&gt;&lt;/center&gt;
&lt;p&gt;
&lt;a name='f1'&gt;1.&lt;/a&gt; Or Haskell or one of the functional languages. I just
happen to be more familiar with Lisp.
&lt;p&gt;
&lt;a name='f2'&gt;2.&lt;/a&gt; Another example: Mu's addresses aren't really like C's
pointers. They're as safe as a high-level language. But they let you simulate
what happens &lt;em&gt;below&lt;/em&gt; Mu without actually &lt;em&gt;leaving&lt;/em&gt; Mu.&lt;img src=&quot;http://feeds.feedburner.com/~r/kartiks-scrapbook/~4/09761iUJMW0&quot; height=&quot;1&quot; width=&quot;1&quot; alt=&quot;&quot;/&gt;</description>
    <feedburner:origLink>http://akkartik.name/blog/swamp</feedburner:origLink></item>
  </channel>
</rss>
