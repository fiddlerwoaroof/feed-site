<?xml version="1.0" encoding="UTF-8"?><?xml-stylesheet  href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns="http://www.w3.org/2005/Atom" xmlns:openSearch="http://a9.com/-/spec/opensearchrss/1.0/" xmlns:blogger="http://schemas.google.com/blogger/2008" xmlns:georss="http://www.georss.org/georss" xmlns:gd="http://schemas.google.com/g/2005" xmlns:thr="http://purl.org/syndication/thread/1.0"><id>tag:blogger.com,1999:blog-636187583995536423</id><updated>2022-10-26T05:59:51.961+04:00</updated><category term="Programming"/><category term="Ruby"/><category term="Ruby on Rails"/><category term="Javascript"/><category term="Databases"/><category term="TypeScript"/><category term="Security"/><category term="Angular"/><category term="HTTP"/><category term="nextjs"/><category term="NodeJS"/><category term="Optimization"/><category term="React"/><category term="Testing"/><category term="authentication"/><category term="ActiveJob"/><category term="Bash"/><category term="Blog"/><category term="Books"/><category term="Concurrency"/><category term="DNS"/><category term="Debugging"/><category term="Docker"/><category term="Emails"/><category term="Fibers"/><category term="Go"/><category term="Google Maps"/><category term="MongoDB"/><category term="Networks"/><category term="Performance"/><category term="Podcasts"/><category term="Postmark"/><category term="Pusher"/><category term="Ractors"/><category term="Rant"/><category term="Redux"/><category term="Resources"/><category term="SQL"/><category term="Tracking"/><category term="TypeORM"/><category term="phone"/><category term="redis"/><category term="sms"/><title type="text">Dmitry Ishkov</title><subtitle type="html">Software Engineer on the run üíªüèÉüéí
&lt;br&gt;
Find me on &lt;a href=&quot;https://www.instagram.com/the_russkiy/&quot;&gt;Instagram&lt;/a&gt; | &lt;a href=&quot;https://twitter.com/the_russkiy&quot;&gt;Twitter&lt;/a&gt; |  &lt;a href=&quot;https://www.linkedin.com/in/dmitryishkov&quot;&gt;LinkedIn&lt;/a&gt; |  &lt;a href=&quot;https://github.com/therusskiy/&quot;&gt;GitHub&lt;/a&gt;
&lt;br&gt;
&lt;a href=&quot;mailto:dmitry@hey.com&quot;&gt;dmitry@hey.com&lt;/a&gt;</subtitle><link rel="http://schemas.google.com/g/2005#feed" type="application/atom+xml" href="https://www.dmitry-ishkov.com/feeds/posts/default"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/"><link rel="hub" href="http://pubsubhubbub.appspot.com/"><link rel="next" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default?start-index=26&amp;max-results=25"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><generator version="7.00" uri="http://www.blogger.com">Blogger</generator><openSearch:totalResults>34</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-4742131304822791554</id><published>2022-03-19T17:00:00.001+04:00</published><updated>2022-03-19T17:07:12.389+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="nextjs"/><category scheme="http://www.blogger.com/atom/ns#" term="TypeScript"/><title type="text">Inlined images in Next.js</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;img style=&quot;display: block; padding: 1em 0; text-align: center; clear: right; float: right; margin-left: 30px&quot; alt=&quot;Article Logo&quot; border=&quot;0&quot; width=&quot;300&quot; data-original-height=&quot;574&quot; data-original-width=&quot;576&quot; src=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEgl7ERZ_O3_V6W8ax9osZq_491eIr8WOTODcE_eAoCWhQ2zJOZk7r8d6qXoc5Kse6JsKC-S2wR1Pjc0bFRWTmWzAh6vyb5ofAWGIyoJ5m2UyAxT6LeEbW0VS20g2n43cc9vPDJcPpSdjbBXGw31n4JgT55il6x9DpiftfSxUaph_KzuvShmseScgu4d9A=s320&quot;/&gt;&lt;/div&gt; &lt;p&gt;    The slowest part of loading a web page is almost always user network. &lt;/p&gt;&lt;p&gt;    If you have small images like an app logo that you don't want to wait for on network, one tool in your toolbox is to inline these images using base64 encoding. &lt;/p&gt;&lt;p style=&quot;clear: both&quot;&gt;    This is how inlined images look in a browser: &lt;/p&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEgAfh14oNTS7R3oS8C_KzJl9Gxza6vif2Zs9xB4xrNycKaWrorsuaCFvRbVRwiLqjJMtethoobdF7KD6KIP-uqj2XYA42PxZ7jhRUfm9ku8G39f_GXxxS2D0JxS1QUO6EVrJ0W3HFT6OOH1rrBdHFsgpY85lXwi1DD0wwlyySq34OOavkEDJo5u83SGRA&quot; style=&quot;display: block; padding: 1em 0; text-align: center; &quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; data-original-height=&quot;258&quot; data-original-width=&quot;687&quot; src=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEgAfh14oNTS7R3oS8C_KzJl9Gxza6vif2Zs9xB4xrNycKaWrorsuaCFvRbVRwiLqjJMtethoobdF7KD6KIP-uqj2XYA42PxZ7jhRUfm9ku8G39f_GXxxS2D0JxS1QUO6EVrJ0W3HFT6OOH1rrBdHFsgpY85lXwi1DD0wwlyySq34OOavkEDJo5u83SGRA&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;h2&gt;Desired usage&lt;/h2&gt;&lt;p&gt;    Our goal is to be able to write the following if we want to have an inlined image: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;import logo from 'images/app-logo.inline.png'&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;     and the following for the regular URL (notice the &lt;code&gt;.inline.&lt;/code&gt; part of the file name): &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;import logo from 'images/app-logo.png'&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;    It can be later used as usual via: &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;&amp;lt;Image src={logo}/&amp;gt;&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Implementation&lt;/h2&gt; &lt;p&gt;    How do we do this in Next.js? &lt;/p&gt;&lt;p&gt;    We have to add &lt;code class=&quot;javascript&quot;&gt;url-loader&lt;/code&gt; to &lt;code class=&quot;javascript&quot;&gt;package.json&lt;/code&gt; and tweak &lt;code class=&quot;javascript&quot;&gt;next.config.js&lt;/code&gt;. &lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// next.config.js&lt;br /&gt;module.exports = {&lt;br /&gt;  // ...&lt;br /&gt;  webpack: (config) =&gt; {&lt;br /&gt;    // find the built-in loader&lt;br /&gt;    const imageLoaderRule = config.module.rules.find(&lt;br /&gt;      (rule) =&gt; rule.loader === 'next-image-loader'&lt;br /&gt;    )&lt;br /&gt;    // make the loader ignore *.inline files&lt;br /&gt;    imageLoaderRule.exclude = /\.inline\.(png|jpg|svg)$/i&lt;br /&gt;    &lt;br /&gt;    // add a new URL loader for *.inline files&lt;br /&gt;    config.module.rules.push({&lt;br /&gt;      test: /\.inline\.(png|jpg|gif)$/i,&lt;br /&gt;      use: [&lt;br /&gt;        {&lt;br /&gt;          loader: 'url-loader'&lt;br /&gt;        }&lt;br /&gt;      ]&lt;br /&gt;    })&lt;br /&gt;    return config&lt;br /&gt;  },&lt;br /&gt;  // ..&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Types&lt;/h2&gt;&lt;p&gt;If we want to avoid Typescript errors we also need to declare types for these inline files&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;typescript&quot;&gt;// images/index.d.ts&lt;br /&gt;declare module '*.inline.png' {&lt;br /&gt;  const value: string&lt;br /&gt;  export default value&lt;br /&gt;}&lt;br /&gt;declare module '*.inline.jpg' {&lt;br /&gt;  const value: string&lt;br /&gt;  export default value&lt;br /&gt;}&lt;br /&gt;declare module '*.inline.svg' {&lt;br /&gt;  const value: string&lt;br /&gt;  export default value&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// tsconfig.json&lt;br /&gt;{&lt;br /&gt;  // ...&lt;br /&gt;  &quot;include&quot;: [&quot;images/index.d.ts&quot;, &quot;next-env.d.ts&quot;, &quot;**/*.ts&quot;, &quot;**/*.tsx&quot;]&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/4742131304822791554"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/4742131304822791554"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2022/03/inlined-images-in-nextjs.html" title="Inlined images in Next.js"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blogger.googleusercontent.com/img/a/AVvXsEgl7ERZ_O3_V6W8ax9osZq_491eIr8WOTODcE_eAoCWhQ2zJOZk7r8d6qXoc5Kse6JsKC-S2wR1Pjc0bFRWTmWzAh6vyb5ofAWGIyoJ5m2UyAxT6LeEbW0VS20g2n43cc9vPDJcPpSdjbBXGw31n4JgT55il6x9DpiftfSxUaph_KzuvShmseScgu4d9A=s72-c" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-2506077776243474247</id><published>2022-03-13T20:41:00.004+04:00</published><updated>2022-03-14T20:24:18.154+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Databases"/><category scheme="http://www.blogger.com/atom/ns#" term="NodeJS"/><category scheme="http://www.blogger.com/atom/ns#" term="TypeORM"/><category scheme="http://www.blogger.com/atom/ns#" term="TypeScript"/><title type="text">Migration locks for TypeORM</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;img style=&quot;display: block; padding: 1em 0; text-align: center; clear: right; float: right; margin-left: 30px&quot; alt=&quot;Article Logo&quot; border=&quot;0&quot; width=&quot;300&quot; data-original-height=&quot;431&quot; data-original-width=&quot;513&quot; src=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEghTv9-4gxxFpX-Q-MxnTd9agx9fJ-UbKRVBycif7AOTz8xzP2kYiCXfo550--4JOSP5SQzCG0TLPz1-HHN_FA0lsWoEIJ4hSSr7LEl3YjqBeCKMHfm_jJbUaCv-yeVDo2QH6_e96qDH_AMZq1K8gyoRNGu_V0y5FUzwRId4mTlfbx1BB4bsBcH7te0kw=s320&quot;/&gt;&lt;/div&gt;&lt;p&gt;    Schema migrations is a must-have functionality for any DB framework. &lt;/p&gt;&lt;p&gt;    TypeORM provides decent utilities for dealing with migrations, however having a decade of experience in Ruby on Rails I got really spoiled and take some features for granted. &lt;/p&gt;&lt;p&gt;    One of these features is locking a database while a migration going on so 2 processes running concurrently don't step on each other's toes. This is also important when you run migrations in Kubernetes before launching your app.  &lt;/p&gt;&lt;p&gt;  I was really surprised to find out that this basic feature     &lt;a href=&quot;https://github.com/typeorm/typeorm/issues/3400#issuecomment-453470186&quot; target=&quot;_blank&quot;&gt;is not supported&lt;/a&gt;, so decided to implement it on my own. &lt;/p&gt; &lt;h2&gt;Implementation&lt;/h2&gt; &lt;pre&gt;&lt;code class=&quot;typescript&quot;&gt;// typeormMigrationUtils.ts&lt;br /&gt;import { Connection, createConnection } from 'typeorm'&lt;br /&gt;import config from '../ormconfig'&lt;br /&gt;import CRC32 from 'crc-32'&lt;br /&gt;&lt;br /&gt;const MIGRATOR_SALT = 2053462845&lt;br /&gt;&lt;br /&gt;async function withAdvisoryLock(&lt;br /&gt;  connection: Connection,&lt;br /&gt;  callback: () =&gt; Promise&amp;lt;void&amp;gt;&lt;br /&gt;): Promise&amp;lt;boolean&amp;gt; {&lt;br /&gt;  // generate a unique lock name, has to be an integer&lt;br /&gt;  const lockName = CRC32.str(config.database as string) * MIGRATOR_SALT&lt;br /&gt;  let lock = false&lt;br /&gt;  try {&lt;br /&gt;    // try to acquire a lock&lt;br /&gt;    const [{ pg_try_advisory_lock: locked }]: [&lt;br /&gt;      { pg_try_advisory_lock: boolean }&lt;br /&gt;    ] = await connection.manager.query(&lt;br /&gt;      `SELECT pg_try_advisory_lock(${lockName})`&lt;br /&gt;    )&lt;br /&gt;    lock = locked&lt;br /&gt;&lt;br /&gt;    // if already locked, print a warning an exit&lt;br /&gt;    if (!lock) {&lt;br /&gt;      console.warn(`Failed to get advisory lock: ${lockName}`)&lt;br /&gt;      return false&lt;br /&gt;    }&lt;br /&gt;&lt;br /&gt;    // execute our code inside the lock&lt;br /&gt;    await callback()&lt;br /&gt;&lt;br /&gt;    return true&lt;br /&gt;  } finally {&lt;br /&gt;    // if we acquired a lock, we need to unlock it&lt;br /&gt;    if (lock) {&lt;br /&gt;      const [{ pg_advisory_unlock: wasLocked }]: [&lt;br /&gt;        { pg_advisory_unlock: boolean }&lt;br /&gt;      ] = await connection.manager.query(&lt;br /&gt;        `SELECT pg_advisory_unlock(${lockName})`&lt;br /&gt;      )&lt;br /&gt;&lt;br /&gt;      if (!wasLocked) {&lt;br /&gt;        console.warn(`Advisory lock was not locked: ${lockName}`)&lt;br /&gt;      }&lt;br /&gt;    }&lt;br /&gt;  }&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;export async function migrateDatabase() {&lt;br /&gt;  const connection = await createConnection({ ...config, logging: true })&lt;br /&gt;  await withAdvisoryLock(connection, async () =&gt; {&lt;br /&gt;    await connection.runMigrations({&lt;br /&gt;      transaction: 'all'&lt;br /&gt;    })&lt;br /&gt;  })&lt;br /&gt;  await connection.close()&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;export async function syncDatabase() {&lt;br /&gt;  const connection = await createConnection({ ...config, logging: true })&lt;br /&gt;  await withAdvisoryLock(connection, async () =&gt; {&lt;br /&gt;    await connection.synchronize()&lt;br /&gt;  })&lt;br /&gt;  await connection.close()&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;Usage&lt;/h2&gt; &lt;p&gt;  You can run them like this: &lt;p&gt; &lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// package.json&lt;br /&gt;  &quot;scripts&quot;: {&lt;br /&gt;    ...&lt;br /&gt;    &quot;db:migrate&quot;: &quot;ts-node ./src/scripts/migrateDatabase.ts&quot;,&lt;br /&gt;    &quot;db:sync&quot;: &quot;ts-node ./src/scripts/syncDatabase.ts&quot;,&lt;br /&gt;    &quot;db:migrate:prod&quot;: &quot;node ./dist/src/scripts/migrateDatabase.js&quot;,&lt;br /&gt;    &quot;db:sync:prod&quot;: &quot;node ./dist/src/scripts/syncDatabase.js&quot;,&lt;br /&gt;    ...&lt;br /&gt;  },&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;typescript&quot;&gt;// migrateDatabase.ts&lt;br /&gt;import { migrateDatabase } from './typeormMigrationUtils'&lt;br /&gt;&lt;br /&gt;;(async () =&gt; {&lt;br /&gt;  await migrateDatabase()&lt;br /&gt;})()&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&quot;typescript&quot;&gt;// syncDatabase.ts&lt;br /&gt;import { syncDatabase } from './typeormMigrationUtils'&lt;br /&gt;&lt;br /&gt;;(async () =&gt; {&lt;br /&gt;  await syncDatabase()&lt;br /&gt;})()&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/2506077776243474247"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/2506077776243474247"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2022/03/migration-locks-for-typeorm.html" title="Migration locks for TypeORM"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blogger.googleusercontent.com/img/a/AVvXsEghTv9-4gxxFpX-Q-MxnTd9agx9fJ-UbKRVBycif7AOTz8xzP2kYiCXfo550--4JOSP5SQzCG0TLPz1-HHN_FA0lsWoEIJ4hSSr7LEl3YjqBeCKMHfm_jJbUaCv-yeVDo2QH6_e96qDH_AMZq1K8gyoRNGu_V0y5FUzwRId4mTlfbx1BB4bsBcH7te0kw=s72-c" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-7883629957265872233</id><published>2022-02-27T19:41:00.004+04:00</published><updated>2022-02-27T19:44:48.789+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="nextjs"/><category scheme="http://www.blogger.com/atom/ns#" term="TypeScript"/><title type="text">Using image loader is Next.js</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;img style=&quot;display: block; padding: 1em 0; text-align: center; clear: right; float: right; margin-left: 30px&quot; alt=&quot;Article Logo&quot; border=&quot;0&quot; width=&quot;300&quot; data-original-height=&quot;377&quot; data-original-width=&quot;372&quot; src=&quot;https://blogger.googleusercontent.com/img/a/AVvXsEjQESVgPJIfzsSLy1rh-wmPgz8PJIOftHlM3NX5sAkCWYSidKf0cfC1t4yIPyz89cXRoxDT6875Nk-wlO5hVziBfOcOydJu_Ma-CzucGyrVvjrpgPCNb1Dyh-KzSWdwuz8A5CDlBtiTm8Rft36ypB3sGpt2QHJhHETV6ZIgMkieE1C__N8JMwQ8y1ENvQ=s320&quot;/&gt;&lt;/div&gt;&lt;p&gt;    Next.js has managed to kill off create-react-app and despite new rivals (in the face of Remix) is a de-facto way to start new React apps. &lt;/p&gt;&lt;p&gt;  One of the awesome features that Next.js and its platform Vercel provides is a way to automatically optimize images for different screens to make both user and developer experience much smoother.  &lt;/p&gt;&lt;p&gt;    However, if your app has any non-trivial number of images that are generated by users you may soon end up visiting Vercel's     &lt;a href=&quot;https://vercel.com/docs/concepts/limits/overview#typical-monthly-usage-guidelines&quot; target=&quot;_blank&quot;&gt;limits page&lt;/a&gt;. Turns out that even on Hobby and Pro plans you are limited to 1000 and 5000 images per month, any overage is going to cost you dearly. &lt;/p&gt;&lt;p&gt;    At this point, you are going to start shopping for alternative image optimization solutions. You can either host your own via     &lt;a href=&quot;http://www.thumbor.org&quot; target=&quot;_blank&quot;&gt;Thumbor&lt;/a&gt; or &lt;a href=&quot;https://github.com/imgproxy/imgproxy&quot; target=&quot;_blank&quot;&gt;imgproxy&lt;/a&gt; or use one of the hosted solutions like     &lt;a href=&quot;https://cloudinary.com/&quot; target=&quot;_blank&quot;&gt;Cloudinary&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;Regardless of what service you choose, it needs to be integrated into Next.js.&lt;p&gt;&lt;p&gt;After taking a look at Cloudinary as an example, even their &lt;a href=&quot;https://cloudinary.com/pricing&quot; target=&quot;_blank&quot;&gt;free plan&lt;/a&gt; offers 25k transformations a month and 1000 overage costs $0.40 instead of $9, while providing more features.&lt;/p&gt;&lt;p&gt;Next.js &lt;a         href=&quot;https://nextjs.org/docs/api-reference/next/image#built-in-loaders&quot; target=&quot;_blank&quot;&gt;documentation talks&lt;/a&gt; about using a built-in Cloudinary loader. Unfortunately, I found that it is     &lt;a href=&quot;https://github.com/vercel/next.js/blob/6178e7cf6d8822f6f29014c5410c455ca7bafbc2/packages/next/client/image.tsx#L813-L823&quot;&gt;beyond primitive&lt;/a&gt; and simply specifying the loader is not enough, as it won't work in development, and you are missing out on any juicy features that other providers might have.&lt;/p&gt;&lt;p&gt;So in this article, I am going to show you an example of how to implement your own Next.js image loader using Cloudinary as an example.&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;typescript&quot;&gt;&lt;br /&gt;import NextImage from 'next/image'&lt;br /&gt;import { useCallback } from 'react'&lt;br /&gt;import compact from 'lodash/compact'&lt;br /&gt;&lt;br /&gt;const CLOUDINARY_HOST = 'https://some-domain.mo.cloudinary.net'&lt;br /&gt;&lt;br /&gt;type ImageLoaderProps = {&lt;br /&gt;  src: string&lt;br /&gt;  width: number&lt;br /&gt;  quality?: number&lt;br /&gt;  root?: string&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// strip any leading slashes&lt;br /&gt;function normalizeSrc(src: string): string {&lt;br /&gt;  return src[0] === '/' ? src.slice(1) : src&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;type Props = Parameters&amp;lt;typeof NextImage&amp;gt;[0] &amp; {&lt;br /&gt;  // https://cloudinary.com/documentation/media_optimizer_transformations#automatic_quality&lt;br /&gt;  quality?:&lt;br /&gt;    | 'auto'&lt;br /&gt;    | 'auto:best'&lt;br /&gt;    | 'auth:good'&lt;br /&gt;    | 'auto:eco'&lt;br /&gt;    | 'auto:low'&lt;br /&gt;    | number&lt;br /&gt;  gravity?:&lt;br /&gt;    | 'auto'&lt;br /&gt;    | 'center'&lt;br /&gt;    | 'north_east'&lt;br /&gt;    | 'north'&lt;br /&gt;    | 'north_west'&lt;br /&gt;    | 'west'&lt;br /&gt;    | 'south_west'&lt;br /&gt;    | 'south'&lt;br /&gt;    | 'south_east'&lt;br /&gt;    | 'east'&lt;br /&gt;  crop?:&lt;br /&gt;    | 'crop'&lt;br /&gt;    | 'fill'&lt;br /&gt;    | 'fill_pad'&lt;br /&gt;    | 'fit'&lt;br /&gt;    | 'lfill'&lt;br /&gt;    | 'limit'&lt;br /&gt;    | 'lpad'&lt;br /&gt;    | 'mfit'&lt;br /&gt;    | 'mpad'&lt;br /&gt;    | 'pad'&lt;br /&gt;    | 'scale'&lt;br /&gt;    | 'thumb'&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;// https://cloudinary.com/documentation/transformation_reference&lt;br /&gt;const Image = ({&lt;br /&gt;  quality = 'auto',&lt;br /&gt;  gravity = 'center',&lt;br /&gt;  crop = 'limit',&lt;br /&gt;  width: initialWidth,&lt;br /&gt;  height: initialHeight,&lt;br /&gt;  ...props&lt;br /&gt;}: Props): ReturnType&amp;lt;typeof NextImage&amp;gt; =&gt; {&lt;br /&gt;  const aspectRatio: number | null =&lt;br /&gt;    typeof initialWidth === 'number' &amp;&amp; typeof initialHeight === 'number'&lt;br /&gt;      ? initialWidth / initialHeight&lt;br /&gt;      : null&lt;br /&gt;  const cloudinaryLoader = useCallback(&lt;br /&gt;    ({ src, width }: ImageLoaderProps): string =&gt; {&lt;br /&gt;      const height =&lt;br /&gt;        gravity === 'auto' &amp;&amp; aspectRatio ? width / aspectRatio : null&lt;br /&gt;      const params = compact([&lt;br /&gt;        'f_auto',&lt;br /&gt;        'c_' + crop,&lt;br /&gt;        'g_' + gravity,&lt;br /&gt;        'w_' + width,&lt;br /&gt;        height ? 'h_' + height : '',&lt;br /&gt;        'q_' + (quality || 'auto')&lt;br /&gt;      ])&lt;br /&gt;      if (&lt;br /&gt;        gravity === 'auto' &amp;&amp;&lt;br /&gt;        !['fill', 'lfill', 'fill_pad', 'thumb', 'crop'].includes(crop)&lt;br /&gt;      ) {&lt;br /&gt;        console.error(&lt;br /&gt;          'Automatic cropping is supported for the fill, lfill, fill_pad, thumb and crop modes.'&lt;br /&gt;        )&lt;br /&gt;      }&lt;br /&gt;      const paramsString = `tx=${params.join(',')}&amp;resource_type=image`&lt;br /&gt;      const normalizedSrc = normalizeSrc(src)&lt;br /&gt;      const parsedUrl = new URL(src)&lt;br /&gt;      const joiner = parsedUrl.search &amp;&amp; parsedUrl.search.length ? '&amp;' : '?'&lt;br /&gt;      return `${CLOUDINARY_HOST}/${normalizedSrc}${joiner}${paramsString}`&lt;br /&gt;    },&lt;br /&gt;    [crop, quality, gravity, aspectRatio]&lt;br /&gt;  )&lt;br /&gt;&lt;br /&gt;  let imageSrc: string | null = null&lt;br /&gt;  // Next image accepts different types of imports&lt;br /&gt;  if (!props.src) {&lt;br /&gt;    imageSrc = null&lt;br /&gt;  } else if (typeof props.src === 'string') {&lt;br /&gt;    imageSrc = props.src&lt;br /&gt;  } else if (typeof props.src.default !== 'undefined') {&lt;br /&gt;    imageSrc = props.src.default.src&lt;br /&gt;  } else if (typeof props.src.src !== 'undefined') {&lt;br /&gt;    imageSrc = props.src.src&lt;br /&gt;  }&lt;br /&gt;  // disable optimization for dev environment and images present in source code&lt;br /&gt;  const isNextImage = imageSrc?.includes('_next/static') || process.env.NODE_ENV === 'development'&lt;br /&gt;  return (&lt;br /&gt;    &amp;lt;NextImage&lt;br /&gt;            {...props}&lt;br /&gt;            height={initialHeight}&lt;br /&gt;            loader={isNextImage ? undefined : cloudinaryLoader}&lt;br /&gt;            width={initialWidth}&lt;br /&gt;    /&amp;gt;&lt;br /&gt;  )&lt;br /&gt;}&lt;br /&gt;&lt;br /&gt;export default Image&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/7883629957265872233"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/7883629957265872233"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2022/02/using-image-loader-is-nextjs.html" title="Using image loader is Next.js"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://blogger.googleusercontent.com/img/a/AVvXsEjQESVgPJIfzsSLy1rh-wmPgz8PJIOftHlM3NX5sAkCWYSidKf0cfC1t4yIPyz89cXRoxDT6875Nk-wlO5hVziBfOcOydJu_Ma-CzucGyrVvjrpgPCNb1Dyh-KzSWdwuz8A5CDlBtiTm8Rft36ypB3sGpt2QHJhHETV6ZIgMkieE1C__N8JMwQ8y1ENvQ=s72-c" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-1829600074175428873</id><published>2021-07-25T17:54:00.002+04:00</published><updated>2021-07-26T10:51:07.693+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Concurrency"/><category scheme="http://www.blogger.com/atom/ns#" term="Fibers"/><category scheme="http://www.blogger.com/atom/ns#" term="HTTP"/><category scheme="http://www.blogger.com/atom/ns#" term="Ractors"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby"/><title type="text">HTTP server in Ruby 3 - Fibers &amp; Ractors</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;img style=&quot;display: block; padding: 1em 0; text-align: center; clear: right; float: right; margin-left: 30px&quot; alt=&quot;Article Logo&quot; border=&quot;0&quot; width=&quot;300&quot; data-original-height=&quot;615&quot; data-original-width=&quot;615&quot; src=&quot;https://1.bp.blogspot.com/-j40MHRyKrzY/YPxhq5Bo5FI/AAAAAAABzZA/QwNtbODPaFsuLVWznMjlC2QNZfSw9P-KwCLcBGAsYHQ/s615/ruby-http-server.jpeg&quot;/&gt;&lt;/div&gt;&lt;p&gt;    &lt;em&gt;This is part #2. Head over to &lt;a href=&quot;https://www.dmitry-ishkov.com/2021/07/ruby-http-server-from-ground-up.html&quot; target=&quot;_blank&quot;&gt;part #1&lt;/a&gt; to learn about HTTP in Ruby.&lt;/em&gt;&lt;/p&gt;&lt;h3&gt;Motivation&lt;/h3&gt;&lt;p&gt;    Historically Ruby's been lacking in the concurrency department. Ruby has &quot;native&quot; threads (prior to 1.9 there were only &quot;green&quot;), which means there can be multiple threads controlled by an OS, but only 1 thread can be executed at a time, this is managed via Global Interpreter Lock (GIL). However, native calls and I/O calls can be executed in parallel. During an I/O call, a thread gives up control and waits for a signal that the I/O has finished. This means I/O heavy applications can benefit from multiple threads. &lt;/p&gt;&lt;p&gt;    In this article we are going to explore different concurrency modes for our HTTP server:     &lt;ul&gt;        &lt;li&gt;Single-threaded&lt;/li&gt;        &lt;li&gt;Multi-threaded&lt;/li&gt;        &lt;li&gt;Fibers&lt;/li&gt;        &lt;li&gt;Ractors&lt;/li&gt;    &lt;/ul&gt;&lt;/p&gt;&lt;h3&gt;Single-threaded&lt;/h3&gt;&lt;p&gt;    Let's start simple and see how a single threaded HTTP server could look like (&lt;a         href=&quot;https://github.com/TheRusskiy/ruby3-http-server/blob/master/servers/single_threaded_server.rb&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;full code&lt;/em&gt;&lt;/a&gt;): &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;def start&lt;br /&gt;    socket = TCPServer.new(HOST, PORT)&lt;br /&gt;    socket.listen(SOCKET_READ_BACKLOG)&lt;br /&gt;    loop do&lt;br /&gt;      conn, _addr_info = socket.accept&lt;br /&gt;      request = RequestParser.call(conn)&lt;br /&gt;      status, headers, body = app.call(request)&lt;br /&gt;      HttpResponder.call(conn, status, headers, body)&lt;br /&gt;    rescue =&gt; e&lt;br /&gt;      puts e.message&lt;br /&gt;    ensure&lt;br /&gt;      conn&amp;.close&lt;br /&gt;    end&lt;br /&gt;end&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Multi-threaded&lt;/h3&gt;&lt;p&gt;    Like discussed earlier, threads in Ruby help performance when there's a lot of I/O. Most real-life applications are like that. Some of the I/O: read from the incoming TCP connection, call database, call an external API, respond via the TCP connection. &lt;/p&gt;&lt;p&gt;    Now let's implement a multi-threaded server and a thread pool     (&lt;a         href=&quot;https://github.com/TheRusskiy/ruby3-http-server/blob/master/servers/multi_threaded_server.rb&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;full code&lt;/em&gt;&lt;/a&gt;): &lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;def start&lt;br /&gt;  pool = ThreadPool.new(size: WORKERS_COUNT)&lt;br /&gt;  socket = TCPServer.new(HOST, PORT)&lt;br /&gt;  socket.listen(SOCKET_READ_BACKLOG)&lt;br /&gt;  loop do&lt;br /&gt;    conn, _addr_info = socket.accept&lt;br /&gt;    # execute the request in one of the threads&lt;br /&gt;    pool.perform do&lt;br /&gt;      begin&lt;br /&gt;        request = RequestParser.call(conn)&lt;br /&gt;        status, headers, body = app.call(request)&lt;br /&gt;        HttpResponder.call(conn, status, headers, body)&lt;br /&gt;      rescue =&gt; e&lt;br /&gt;        puts e.message&lt;br /&gt;      ensure&lt;br /&gt;        conn&amp;.close&lt;br /&gt;      end&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;ensure&lt;br /&gt;  pool&amp;.shutdown&lt;br /&gt;end&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Thread pool (simplified implementation):&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;class ThreadPool&lt;br /&gt;  attr_accessor :queue, :running, :size&lt;br /&gt;&lt;br /&gt;  def initialize(size:)&lt;br /&gt;    self.size = size&lt;br /&gt;&lt;br /&gt;    # threadsafe queue to manage work&lt;br /&gt;    self.queue = Queue.new&lt;br /&gt;&lt;br /&gt;    size.times do&lt;br /&gt;      Thread.new(self.queue) do |queue|&lt;br /&gt;        # &quot;catch&quot; in Ruby is a lesser known&lt;br /&gt;        # way to change flow of the program,&lt;br /&gt;        # similar to propagating exceptions&lt;br /&gt;        catch(:exit) do&lt;br /&gt;          loop do&lt;br /&gt;            # `pop` blocks until there's&lt;br /&gt;            # something in the queue&lt;br /&gt;            task = queue.pop&lt;br /&gt;            task.call&lt;br /&gt;          end&lt;br /&gt;        end&lt;br /&gt;      end&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;&lt;br /&gt;  def perform(&amp;block)&lt;br /&gt;    self.queue &lt;&lt; block&lt;br /&gt;  end&lt;br /&gt;&lt;br /&gt;  def shutdown&lt;br /&gt;    size.times do&lt;br /&gt;      # this is going to make threads&lt;br /&gt;      # break out of the infinite loop&lt;br /&gt;      perform { throw :exit }&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;end&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To read more about multi-threaded architecture in a Web Server you can refer to &lt;a         href=&quot;https://github.com/puma/puma/blob/master/docs/architecture.md&quot; target=&quot;_blank&quot;&gt;Puma Architecture&lt;/a&gt;. Unlike our simple implementation, there is an extra thread that reads from requests and sends connections to the thread pool. We are going to implement this pattern later when dealing with Ractors.&lt;/p&gt;&lt;h3&gt;Fibers&lt;/h3&gt;&lt;p&gt;Fibers are a lesser-known addition to Ruby 3 (or rather a &lt;a         href=&quot;https://docs.ruby-lang.org/en/master/Fiber/SchedulerInterface.html&quot; target=&quot;_blank&quot;&gt;scheduler interface&lt;/a&gt; for Fibers). You can think of Fibers as routines (e.g. goroutines). They are similar to threads, except instead of Operating System managing them, Ruby does. An advantage of that is less context switching, which means we have a smaller performance penalty when switching between Fibers than if OS switches between threads.&lt;/p&gt;&lt;p&gt;Where things get peculiar, is that with Fibers, you are responsible for implementing that scheduler. Thankfully there are several schedulers packaged into gems:&lt;/p&gt;&lt;ul&gt;    &lt;li&gt;        &lt;a href=&quot;https://github.com/dsh0416/evt&quot; target=&quot;_blank&quot;&gt;evt&lt;/a&gt;    &lt;/li&gt;    &lt;li&gt;        &lt;a href=&quot;https://github.com/digital-fabric/libev_scheduler&quot; target=&quot;_blank&quot;&gt;libev_scheduler&lt;/a&gt;    &lt;/li&gt;    &lt;li&gt;        &lt;a href=&quot;https://github.com/socketry/async&quot; target=&quot;_blank&quot;&gt;Async&lt;/a&gt;    &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;So let's see how our server is going to look like with Fibers (&lt;a         href=&quot;https://github.com/TheRusskiy/ruby3-http-server/blob/master/servers/fiber_server.rb&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;full code&lt;/em&gt;&lt;/a&gt;):&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;def start&lt;br /&gt;  # Fibers are not going to work without a scheduler.&lt;br /&gt;  # A scheduler is on for a current thread.&lt;br /&gt;  Fiber.set_scheduler(Libev::Scheduler.new)&lt;br /&gt;&lt;br /&gt;  Fiber.schedule do&lt;br /&gt;    server = TCPServer.new(HOST, PORT)&lt;br /&gt;    server.listen(SOCKET_READ_BACKLOG)&lt;br /&gt;    loop do&lt;br /&gt;      conn, _addr_info = server.accept&lt;br /&gt;      # ideally we need to limit number of fibers&lt;br /&gt;      # via a thread pool, as accepting infinite number&lt;br /&gt;      # of request is a bad idea:&lt;br /&gt;      # we can run out of memory or other resources,&lt;br /&gt;      # there are diminishing returns to too many fibers,&lt;br /&gt;      # without backpressure to however is sending the requests it's hard&lt;br /&gt;      # to properly load balance and queue requests&lt;br /&gt;      Fiber.schedule do&lt;br /&gt;        request = RequestParser.call(conn)&lt;br /&gt;        status, headers, body = app.call(request)&lt;br /&gt;        HttpResponder.call(conn, status, headers, body)&lt;br /&gt;      rescue =&gt; e&lt;br /&gt;        puts e.message&lt;br /&gt;      ensure&lt;br /&gt;        conn&amp;.close&lt;br /&gt;      end&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;end&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;References: &lt;br&gt;    Don't Wait For Me! Scalable Concurrency for Ruby 3: &lt;a href=&quot;https://www.youtube.com/watch?v=Y29SSOS4UOc&quot; target=&quot;_blank&quot;&gt;https://www.youtube.com/watch?v=Y29SSOS4UOc&lt;/a&gt;    &lt;br&gt;    Fiber API: &lt;a href=&quot;https://docs.ruby-lang.org/en/master/Fiber.html&quot; target=&quot;_blank&quot;&gt;https://docs.ruby-lang.org/en/master/Fiber.html&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Ractors&lt;/h3&gt;&lt;p&gt;Ractors are the shiniest addition to Ruby 3. Ractors are similar to threads, except multiple Ractors &lt;strong&gt;can&lt;/strong&gt; execute in parallel, each Ractor has its own GIL.&lt;/p&gt;&lt;p&gt;&lt;em id=&quot;ractors-warning&quot;&gt;Unfortunately, the word &quot;toy&quot; is not a metaphor, Ractors have a long way to go before they become usable. In my experiments, I get many segfaults on MacOS. No segfaults on Linux, but bugs still. For example, any time an exception was not rescued inside a Ractor the app has a chance of crashing. What may be even more important, is that 2 Ractors can't interact with the same object unless it is explicitly marked as shared. At the time of writing Ruby standard library has too many global objects, which makes sending an HTTP request not possible.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;So let's see how our server is going to look like with Ractors (&lt;a         href=&quot;https://github.com/TheRusskiy/ruby3-http-server/blob/master/servers/ractor_server.rb&quot; target=&quot;_blank&quot;&gt;&lt;em&gt;full code&lt;/em&gt;&lt;/a&gt;):&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;def start&lt;br /&gt;  # the queue is going to be used to&lt;br /&gt;  # fairly dispatch incoming requests,&lt;br /&gt;  # we pass the queue into workers&lt;br /&gt;  # and the first free worker gets&lt;br /&gt;  # the yielded request&lt;br /&gt;  queue = Ractor.new do&lt;br /&gt;    loop do&lt;br /&gt;      conn = Ractor.receive&lt;br /&gt;      Ractor.yield(conn, move: true)&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;  # workers determine concurrency&lt;br /&gt;  WORKERS_COUNT.times.map do&lt;br /&gt;    # we need to pass the queue and the server so they are available&lt;br /&gt;    # inside Ractor&lt;br /&gt;    Ractor.new(queue, self) do |queue, server|&lt;br /&gt;      loop do&lt;br /&gt;        # this method blocks until the queue yields a connection&lt;br /&gt;        conn = queue.take&lt;br /&gt;        request = RequestParser.call(conn)&lt;br /&gt;        status, headers, body = server.app.call(request)&lt;br /&gt;        HttpResponder.call(conn, status, headers, body)&lt;br /&gt;        # I have found that not rescuing errors does not only kill the ractor,&lt;br /&gt;        # but causes random `allocator undefined for Ractor::MovedObject` errors&lt;br /&gt;        # which crashes the whole program&lt;br /&gt;      rescue =&gt; e&lt;br /&gt;        puts e.message&lt;br /&gt;      ensure&lt;br /&gt;        conn&amp;.close&lt;br /&gt;      end&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;  # the listener is going to accept new connections&lt;br /&gt;  # and pass them onto the queue,&lt;br /&gt;  # we make it a separate Ractor, because `yield` in queue&lt;br /&gt;  # is a blocking operation, we wouldn't be able to accept new connections&lt;br /&gt;  # until all previous were processed, and we can't use `send` to send&lt;br /&gt;  # connections to workers because then we would send requests to workers&lt;br /&gt;  # that might be busy&lt;br /&gt;  listener = Ractor.new(queue) do |queue|&lt;br /&gt;    socket = TCPServer.new(HOST, PORT)&lt;br /&gt;    socket.listen(SOCKET_READ_BACKLOG)&lt;br /&gt;    loop do&lt;br /&gt;      conn, _addr_info = socket.accept&lt;br /&gt;      queue.send(conn, move: true)&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;  Ractor.select(listener)&lt;br /&gt;end&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;References: &lt;br&gt;    Ractor API: &lt;a href=&quot;https://docs.ruby-lang.org/en/master/Ractor.html&quot; target=&quot;_blank&quot;&gt;https://docs.ruby-lang.org/en/master/Ractor.html&lt;/a&gt;    &lt;br&gt;    Ractors specification: &lt;a href=&quot;https://github.com/ko1/ruby/blob/dc7f421bbb129a7288fade62afe581279f4d06cd/doc/ractor.md&quot; target=&quot;_blank&quot;&gt;https://github.com/ko1/ruby/blob/dc7f421bbb129a7288fade62afe581279f4d06cd/doc/ractor.md&lt;/a&gt;&lt;/p&gt;&lt;h3&gt;Performance testing&lt;/h3&gt;&lt;p&gt;This article wouldn't be complete if we didn't put our servers to action.&lt;/p&gt;&lt;p&gt;We are going to test each server against several types of tasks:&lt;/p&gt;&lt;ul&gt;    &lt;li&gt;CPU computation (&lt;a             href=&quot;https://github.com/TheRusskiy/ruby3-http-server/blob/master/apps/cpu_heavy_app.rb&quot; target=&quot;_blank&quot;&gt;code&lt;/a&gt;)&lt;/li&gt;    &lt;li&gt;File reading (&lt;a             href=&quot;https://github.com/TheRusskiy/ruby3-http-server/blob/master/apps/file_serving_app.rb&quot; target=&quot;_blank&quot;&gt;code&lt;/a&gt;)&lt;/li&gt;    &lt;li&gt;HTTP requests (&lt;a             href=&quot;https://github.com/TheRusskiy/ruby3-http-server/blob/master/apps/web_request_app.rb&quot; target=&quot;_blank&quot;&gt;code&lt;/a&gt;)&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;In the table below I am showing a number of requests per second (higher is better). We are loading servers with 4 concurrent requests.&lt;/p&gt;&lt;style&gt;    .table-bordered {         border-collapse: collapse;     }     .table-bordered th, .table-bordered td {         border: 1px solid black;     } &lt;/style&gt;&lt;table class=&quot;table-bordered&quot;&gt;    &lt;thead&gt;    &lt;tr&gt;        &lt;th&gt;&lt;/th&gt;        &lt;th&gt;CPU load&lt;/th&gt;        &lt;th&gt;File reading&lt;/th&gt;        &lt;th&gt;HTTP requests&lt;/th&gt;    &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;    &lt;tr&gt;        &lt;td&gt;Single-threaded&lt;/td&gt;        &lt;td&gt;112.95&lt;/td&gt;        &lt;td&gt;10932.28&lt;/td&gt;        &lt;td&gt;2.84&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;Multi-threaded&lt;/td&gt;        &lt;td&gt;99.91&lt;/td&gt;        &lt;td&gt;7207.42&lt;/td&gt;        &lt;td&gt;10.92&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;Fibers&lt;/td&gt;        &lt;td&gt;113.45&lt;/td&gt;        &lt;td&gt;9922.96&lt;/td&gt;        &lt;td&gt;10.89&lt;/td&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;Ractors&lt;/td&gt;        &lt;td&gt;389.97&lt;/td&gt;        &lt;td&gt;18391.25&lt;/td&gt;        &lt;td&gt;-*&lt;/td&gt;    &lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;&lt;em&gt;* Ractors didn't run due to &lt;a href=&quot;#ractors-warning&quot;&gt;the limitation&lt;/a&gt; I described earlier, the standard library is not yet equipped to send HTTP requests. Perhaps we could try implementing reading from the server using TCP, but I stopped at that.&lt;/em&gt;&lt;h4&gt;    Notes on the results &lt;/h4&gt;&lt;p&gt;    For the &lt;strong&gt;CPU-heavy task&lt;/strong&gt;, we see that Ractors really outperform all other servers, by almost 4x (concurrency we used). Multi-threaded performed worse than single-threaded due to overhead of switching between threads, while fibers performed nearly identical to single-threaded (which is a good thing here, means very little overhead).     &lt;br&gt;    One very unpleasant surprise is that Ractors actually performed worse when I executed the following code, no idea how to explain it, lot's of work lies ahead of the Ruby team: &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;10.times do |i|&lt;br /&gt;  1000.downto(1) do |j|&lt;br /&gt;    Math.sqrt(j) * i / 0.2&lt;br /&gt;  end&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;    For the &lt;strong&gt;file serving&lt;/strong&gt; task, I have to note, that I have a very fast NVMe SSD, so it seems that wait time was very low and results resemble the CPU task. &lt;/p&gt;&lt;p&gt;    For the &lt;strong&gt;HTTP task&lt;/strong&gt;, the slowest one expectedly was single-threaded. Both fibers and multi-threaded server performed nearly 4 times faster (again, with the concurrency of 4, we could go higher than that). &lt;/p&gt;&lt;h3&gt;Conclusions&lt;/h3&gt;&lt;p&gt;    Given what a typical Rails server does, simply goes multi-threaded can yield great results, because usually the slowest parts are I/O bound.     &lt;br&gt;    If you have a CPU-heavy computation that you need to do, perhaps Ractors could be your answer, but given the drastic changes they are going to require, I expect it's going to take community many years before they can be applied in practice.     &lt;br&gt;    In that sense, Fibers might actually be the most useful addition, you can use them today in limited scope, for example to perform multiple web requests with a lower overhead than threads. I advise caution still, as fibers have their own thread-local variables. &lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/1829600074175428873"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/1829600074175428873"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2021/07/http-server-in-ruby-3-fibers-ractors.html" title="HTTP server in Ruby 3 - Fibers &amp; Ractors"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-j40MHRyKrzY/YPxhq5Bo5FI/AAAAAAABzZA/QwNtbODPaFsuLVWznMjlC2QNZfSw9P-KwCLcBGAsYHQ/s72-c/ruby-http-server.jpeg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-4753324874730558390</id><published>2021-07-03T21:42:00.004+04:00</published><updated>2021-07-25T18:12:49.509+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="HTTP"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby"/><title type="text">Ruby HTTP server from the ground up</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;img style=&quot;display: block; padding: 1em 0; text-align: center; clear: right; float: right; margin-left: 30px&quot; alt=&quot;Article Logo&quot; border=&quot;0&quot; width=&quot;300&quot; data-original-height=&quot;461&quot; data-original-width=&quot;557&quot; src=&quot;https://1.bp.blogspot.com/-8xj5Tfpd3ck/YOCUtRsSjYI/AAAAAAABxjU/nRT6fLzBiUIxWzCZlo9khHDVOC3PkzNpwCLcBGAsYHQ/s400/ruby-server.png&quot;/&gt;&lt;/div&gt;&lt;p&gt;    Getting something to work quickly is important when you are starting out, but if you want to become better at programming it's important to know a few levels below the abstractions you are used to be working with. &lt;/p&gt;&lt;p&gt;    When it comes to Web development it's important to know how HTTP works, and what better way to do that than go through baptism by fire and build our own HTTP server. &lt;/p&gt; &lt;h3&gt;How does HTTP look anyway?&lt;/h3&gt;&lt;p&gt;    HTTP is plaintext protocol implemented over TCP so we can easily inspect what requests look like (&lt;em&gt;HTTP 2 is actually no longer plaintext, it's binary for efficiency purposes&lt;/em&gt;).     &lt;br&gt;    One way to look at request structure is to use curl with &lt;code&gt;-v&lt;/code&gt; (verbose) flag: &lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;curl http://example.com/something -H &quot;x-some-header: value&quot; -v&lt;/code&gt;&lt;/pre&gt;    Outputs &lt;pre&gt;&lt;code&gt;GET /something HTTP/1.1&lt;br /&gt;Host: example.com&lt;br /&gt;User-Agent: curl/7.64.1&lt;br /&gt;Accept: */*&lt;br /&gt;x-some-header: value&lt;/code&gt;&lt;/pre&gt;    &lt;br&gt;    And in response we get &lt;pre&gt;&lt;code&gt;HTTP/1.1 404 Not Found&lt;br /&gt;Age: 442736&lt;br /&gt;Cache-Control: max-age=604800&lt;br /&gt;Content-Type: text/html; charset=UTF-8&lt;br /&gt;Date: Sat, 03 Jul 2021 15:02:03 GMT&lt;br /&gt;Expires: Sat, 10 Jul 2021 15:02:03 GMT&lt;br /&gt;...&lt;br /&gt;Content-Length: 1256&lt;br /&gt;&lt;br /&gt;&amp;lt;!doctype html&amp;gt;&lt;br /&gt;&amp;lt;html&amp;gt;&lt;br /&gt;&amp;lt;head&amp;gt;&lt;br /&gt;...&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt; &lt;h3&gt;The plan&lt;/h3&gt;&lt;p&gt;Let's define the steps we are going to need:&lt;/p&gt;&lt;ul&gt;    &lt;li&gt;Listen on a local socket for incoming TCP connections&lt;/li&gt;    &lt;li&gt;Read incoming request's data (text)&lt;/li&gt;    &lt;li&gt;Parse the text of the request to extract method, path, query, headers and body from it&lt;/li&gt;    &lt;li&gt;Send the request to our app and get a response&lt;/li&gt;    &lt;li&gt;Send the response to the remote socket via the connection&lt;/li&gt;    &lt;li&gt;Close the connection&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;With that in mind let's setup the general structure of our program:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;require 'socket'&lt;br /&gt;&lt;br /&gt;class SingleThreadedServer&lt;br /&gt;  PORT = ENV.fetch('PORT', 3000)&lt;br /&gt;  HOST = ENV.fetch('HOST', '127.0.0.1').freeze&lt;br /&gt;  # number of incoming connections to keep in a buffer&lt;br /&gt;  SOCKET_READ_BACKLOG = ENV.fetch('TCP_BACKLOG', 12).to_i&lt;br /&gt;&lt;br /&gt;  attr_accessor :app&lt;br /&gt;&lt;br /&gt;  # app: a Rack app&lt;br /&gt;  def initialize(app)&lt;br /&gt;    self.app = app&lt;br /&gt;  end&lt;br /&gt;&lt;br /&gt;  def start&lt;br /&gt;    socket = listen_on_socket&lt;br /&gt;    loop do # continuously listen to new connections&lt;br /&gt;      conn, _addr_info = socket.accept&lt;br /&gt;      request = RequestParser.call(conn)&lt;br /&gt;      status, headers, body = app.call(request)&lt;br /&gt;      HttpResponder.call(conn, status, headers, body)&lt;br /&gt;    rescue =&gt; e&lt;br /&gt;      puts e.message&lt;br /&gt;    ensure # always close the connection&lt;br /&gt;      conn&amp;.close&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;end&lt;br /&gt;&lt;br /&gt;SingleThreadedServer.new(SomeRackApp.new).start&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;    Listening on a socket &lt;/h3&gt; &lt;p&gt;A &quot;full&quot; version of the implementation of &lt;code&gt;listen_on_socket&lt;/code&gt; looks like that:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;def listen_on_socket&lt;br /&gt;    Socket.new(:INET, :STREAM)&lt;br /&gt;    socket.setsockopt(Socket::SOL_SOCKET, Socket::SO_REUSEADDR, true)&lt;br /&gt;    socket.bind(Addrinfo.tcp(HOST, PORT))&lt;br /&gt;    socket.listen(SOCKET_READ_BACKLOG)&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;However, there's a lot of boilerplate here and all this code could be replaced with:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;def listen_on_socket&lt;br /&gt;    socket = TCPServer.new(HOST, PORT)&lt;br /&gt;    socket.listen(SOCKET_READ_BACKLOG)&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Parsing a request&lt;/h3&gt;&lt;p&gt;Before we start let's define what an end should look like. We want our server to be Rack compatible. Here's an example I found of what Rack expects in its environment as a part of the request:&lt;/p&gt;&lt;code style=&quot;font-size: 0.8em&quot;&gt;    {&quot;GATEWAY_INTERFACE&quot;=&gt;&quot;CGI/1.1&quot;, &quot;PATH_INFO&quot;=&gt;&quot;/&quot;, &quot;QUERY_STRING&quot;=&gt;&quot;&quot;, &quot;REMOTE_ADDR&quot;=&gt;&quot;127.0.0.1&quot;, &quot;REMOTE_HOST&quot;=&gt;&quot;localhost&quot;, &quot;REQUEST_METHOD&quot;=&gt;&quot;GET&quot;, &quot;REQUEST_URI&quot;=&gt;&quot;http://localhost:9292/&quot;, &quot;SCRIPT_NAME&quot;=&gt;&quot;&quot;, &quot;SERVER_NAME&quot;=&gt;&quot;localhost&quot;, &quot;SERVER_PORT&quot;=&gt;&quot;9292&quot;, &quot;SERVER_PROTOCOL&quot;=&gt;&quot;HTTP/1.1&quot;, &quot;SERVER_SOFTWARE&quot;=&gt;&quot;WEBrick/1.3.1 (Ruby/2.2.1/2015-02-26)&quot;, &quot;HTTP_HOST&quot;=&gt;&quot;localhost:9292&quot;, &quot;HTTP_ACCEPT_LANGUAGE&quot;=&gt;&quot;en-US,en;q=0.8,de;q=0.6&quot;, &quot;HTTP_CACHE_CONTROL&quot;=&gt;&quot;max-age=0&quot;, &quot;HTTP_ACCEPT_ENCODING&quot;=&gt;&quot;gzip&quot;, &quot;HTTP_ACCEPT&quot;=&gt;&quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&quot;, &quot;HTTP_USER_AGENT&quot;=&gt;&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36&quot;, &quot;rack.version&quot;=&gt;[1, 3], &quot;rack.url_scheme&quot;=&gt;&quot;http&quot;, &quot;HTTP_VERSION&quot;=&gt;&quot;HTTP/1.1&quot;, &quot;REQUEST_PATH&quot;=&gt;&quot;/&quot;} &lt;/code&gt;&lt;p&gt;We are not going to return all of these params, but let's at least return the most important ones.&lt;/p&gt;&lt;p&gt;First thing we are going to need is to parse a request line, it's structure probably looks familiar to you:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;MAX_URI_LENGTH = 2083 # as per HTTP standard&lt;br /&gt;&lt;br /&gt;def read_request_line(conn)&lt;br /&gt;    # e.g. &quot;POST /some-path?query HTTP/1.1&quot;&lt;br /&gt;&lt;br /&gt;    # read until we encounter a newline, max length is MAX_URI_LENGTH&lt;br /&gt;    request_line = conn.gets(&quot;\n&quot;, MAX_URI_LENGTH)&lt;br /&gt;&lt;br /&gt;    method, full_path, _http_version = request_line.strip.split(' ', 3)&lt;br /&gt;&lt;br /&gt;    path, query = full_path.split('?', 2)&lt;br /&gt;&lt;br /&gt;    [method, full_path, path, query]&lt;br /&gt;end&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After the request line come the headers:&lt;/p&gt; &lt;p&gt;Let's remember how they look like, each header is a separate line:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Cache-Control: max-age=604800&lt;br /&gt;Content-Type: text/html; charset=UTF-8&lt;br /&gt;Content-Length: 1256&lt;/code&gt;&lt;/pre&gt; &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;MAX_HEADER_LENGTH = (112 * 1024) # how it's defined in Webrick, Puma and other servers&lt;br /&gt;&lt;br /&gt;def read_headers(conn)&lt;br /&gt;    headers = {}&lt;br /&gt;    loop do&lt;br /&gt;        line = conn.gets(&quot;\n&quot;, MAX_HEADER_LENGTH)&amp;.strip&lt;br /&gt;&lt;br /&gt;        break if line.nil? || line.strip.empty?&lt;br /&gt;&lt;br /&gt;        # header name and value are separated by colon and space&lt;br /&gt;        key, value = line.split(/:\s/, 2)&lt;br /&gt;&lt;br /&gt;        headers[key] = value&lt;br /&gt;    end&lt;br /&gt;&lt;br /&gt;    headers&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;As a result we get:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br /&gt;    &quot;Cache-Control&quot; =&gt; &quot;max-age=604800&quot;&lt;br /&gt;    &quot;Content-Type&quot; =&gt; &quot;text/html; charset=UTF-8&quot;&lt;br /&gt;    &quot;Content-Length&quot; =&gt; &quot;1256&quot;&lt;br /&gt;}&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Next we need to read the body, not all requests are expected to have a body, only POST and PUT:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;def read_body(conn:, method:, headers:)&lt;br /&gt;    return nil unless ['POST', 'PUT'].include?(method)&lt;br /&gt;&lt;br /&gt;    remaining_size = headers['content-length'].to_i&lt;br /&gt;&lt;br /&gt;    conn.read(remaining_size)&lt;br /&gt;end&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Having all the blocks from above we can finish our simplified implementation:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;class RequestParser&lt;br /&gt;  class &lt;&lt; self&lt;br /&gt;    def call(conn)&lt;br /&gt;      method, full_path, path, query = read_request_line(conn)&lt;br /&gt;&lt;br /&gt;      headers = read_headers(conn)&lt;br /&gt;&lt;br /&gt;      body = read_body(conn: conn, method: method, headers: headers)&lt;br /&gt;&lt;br /&gt;      # read information about the remote connection&lt;br /&gt;      peeraddr = conn.peeraddr&lt;br /&gt;      remote_host = peeraddr[2]&lt;br /&gt;      remote_address = peeraddr[3]&lt;br /&gt;&lt;br /&gt;      # our port&lt;br /&gt;      port = conn.addr[1]&lt;br /&gt;      {&lt;br /&gt;        'REQUEST_METHOD' =&gt; method,&lt;br /&gt;        'PATH_INFO' =&gt; path,&lt;br /&gt;        'QUERY_STRING' =&gt; query,&lt;br /&gt;        # rack.input needs to be an IO stream&lt;br /&gt;        &quot;rack.input&quot; =&gt; body ? StringIO.new(body) : nil,&lt;br /&gt;        &quot;REMOTE_ADDR&quot; =&gt; remote_address,&lt;br /&gt;        &quot;REMOTE_HOST&quot; =&gt; remote_host,&lt;br /&gt;        &quot;REQUEST_URI&quot; =&gt; make_request_uri(&lt;br /&gt;          full_path: full_path,&lt;br /&gt;          port: port,&lt;br /&gt;          remote_host: remote_host&lt;br /&gt;        )&lt;br /&gt;      }.merge(rack_headers(headers))&lt;br /&gt;    end&lt;br /&gt;&lt;br /&gt;    # ... (methods we implemented above)&lt;br /&gt;&lt;br /&gt;    def rack_headers(headers)&lt;br /&gt;      # rack expects all headers to be prefixed with HTTP_&lt;br /&gt;      # and upper cased&lt;br /&gt;      headers.transform_keys do |key|&lt;br /&gt;        &quot;HTTP_#{key.upcase}&quot;&lt;br /&gt;      end&lt;br /&gt;    end&lt;br /&gt;&lt;br /&gt;    def make_request_uri(full_path:, port:, remote_host:)&lt;br /&gt;      request_uri = URI::parse(full_path)&lt;br /&gt;      request_uri.scheme = 'http'&lt;br /&gt;      request_uri.host = remote_host&lt;br /&gt;      request_uri.port = port&lt;br /&gt;      request_uri.to_s&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;end&lt;/code&gt;&lt;/pre&gt; &lt;h3&gt;Sending a response&lt;/h3&gt; &lt;p&gt;Let's skip the Rack app part for a time, we are going to implement it later, and implement sending a response:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;class HttpResponder&lt;br /&gt;  STATUS_MESSAGES = {&lt;br /&gt;    # ...&lt;br /&gt;    200 =&gt; 'OK',&lt;br /&gt;    # ...&lt;br /&gt;    404 =&gt; 'Not Found',&lt;br /&gt;    # ...&lt;br /&gt;  }.freeze&lt;br /&gt;&lt;br /&gt;  # status: int&lt;br /&gt;  # headers: Hash&lt;br /&gt;  # body: array of strings&lt;br /&gt;  def self.call(conn, status, headers, body)&lt;br /&gt;    # status line&lt;br /&gt;    status_text = STATUS_MESSAGES[status]&lt;br /&gt;    conn.send(&quot;HTTP/1.1 #{status} #{status_text}\r\n&quot;, 0)&lt;br /&gt;&lt;br /&gt;    # headers&lt;br /&gt;    # we need to tell how long the body is before sending anything,&lt;br /&gt;    # this way the remote client knows when to stop reading&lt;br /&gt;    content_length = body.sum(&amp;:length)&lt;br /&gt;    conn.send(&quot;Content-Length: #{content_length}\r\n&quot;, 0)&lt;br /&gt;    headers.each_pair do |name, value|&lt;br /&gt;      conn.send(&quot;#{name}: #{value}\r\n&quot;, 0)&lt;br /&gt;    end&lt;br /&gt;&lt;br /&gt;    # tell that we don't want to keep the connection open&lt;br /&gt;    conn.send(&quot;Connection: close\r\n&quot;, 0)&lt;br /&gt;&lt;br /&gt;    # separate headers from body with an empty line&lt;br /&gt;    conn.send(&quot;\r\n&quot;, 0)&lt;br /&gt;&lt;br /&gt;    # body&lt;br /&gt;    body.each do |chunk|&lt;br /&gt;      conn.send(chunk, 0)&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;end&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;That's an example of what we can send:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK&lt;br /&gt;Content-Type: text/html; charset=UTF-8&lt;br /&gt;Content-Length: 53&lt;br /&gt;&lt;br /&gt;&amp;lt;html&amp;gt;&lt;br /&gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&lt;br /&gt;&amp;lt;body&amp;gt;hello world&amp;lt;/body&amp;gt;&lt;br /&gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt; &lt;h3&gt;Rack App&lt;/h3&gt; &lt;p&gt;Any Rack app needs to return &lt;code&gt;status&lt;/code&gt;, &lt;code&gt;headers&lt;/code&gt;, &lt;code&gt;body&lt;/code&gt;. Status is an integer, body is an array of strings (chunks).&lt;/p&gt; &lt;p&gt;With that in mind let's make an app that's going to read files from the file system based on the request path:&lt;/p&gt; &lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;class FileServingApp&lt;br /&gt;  # read file from the filesystem based on a path from&lt;br /&gt;  # a request, e.g. &quot;/test.txt&quot;&lt;br /&gt;  def call(env)&lt;br /&gt;    # this is totally unsecure, but good enough for the demo&lt;br /&gt;    path = Dir.getwd + env['PATH_INFO']&lt;br /&gt;    if File.exist?(path)&lt;br /&gt;      body = File.read(path)&lt;br /&gt;      [200, { &quot;Content-Type&quot; =&gt; &quot;text/html&quot; }, [body]]&lt;br /&gt;    else&lt;br /&gt;      [404, { &quot;Content-Type&quot; =&gt; &quot;text/html&quot; }, ['']]&lt;br /&gt;    end&lt;br /&gt;  end&lt;br /&gt;end&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Final word&lt;/h3&gt; &lt;p&gt;    That was pretty simple, was it not? &lt;br /&gt;    Because we skipped all the corner cases! &lt;br /&gt;    &lt;br /&gt;    If you want you dive into the topic in greater detail I encourage you to jump into WEBRick &lt;a         href=&quot;https://github.com/ruby/webrick/blob/master/lib/webrick/httprequest.rb&quot; target=&quot;_blank&quot;&gt;code&lt;/a&gt;, it's implemented in pure Ruby. You can learn more about Rack from &lt;a href=&quot;https://webapps-for-beginners.rubymonstas.org/rack/hello_world.html&quot; target=&quot;_blank&quot;&gt; this article&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;    If you want see the full version of the code we just wrote, you can check out the Github repo: &lt;a         href=&quot;https://github.com/TheRusskiy/ruby3-http-server/blob/master/servers/single_threaded_server.rb&quot; target=&quot;_blank&quot;&gt;github.com/TheRusskiy/ruby3-http-server/blob/master/servers/single_threaded_server.rb&lt;/a&gt;. &lt;/p&gt; &lt;p&gt;  Next we are going to experiment with different ways of processing requests: single threaded server, multi-threaded server and even Fibers / Ractors from Ruby 3.   &lt;br/&gt;  &lt;strong&gt;Head over to &lt;a href=&quot;https://www.dmitry-ishkov.com/2021/07/http-server-in-ruby-3-fibers-ractors.html&quot; target=&quot;_blank&quot;&gt;part #2&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/4753324874730558390"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/4753324874730558390"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2021/07/ruby-http-server-from-ground-up.html" title="Ruby HTTP server from the ground up"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-8xj5Tfpd3ck/YOCUtRsSjYI/AAAAAAABxjU/nRT6fLzBiUIxWzCZlo9khHDVOC3PkzNpwCLcBGAsYHQ/s72-c/ruby-server.png" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-5508114225437976355</id><published>2021-05-25T14:55:00.010+04:00</published><updated>2021-07-03T18:33:17.722+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Emails"/><category scheme="http://www.blogger.com/atom/ns#" term="Postmark"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby on Rails"/><category scheme="http://www.blogger.com/atom/ns#" term="Tracking"/><title type="text">Track Opened Emails In Rails</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;img alt=&quot;article logo&quot; style=&quot;display: block; padding: 1em 0; text-align: center; clear: right; float: right; margin-left: 30px&quot; border=&quot;0&quot; width=&quot;300&quot; data-original-height=&quot;568&quot; data-original-width=&quot;612&quot; src=&quot;https://1.bp.blogspot.com/--Zd7VzgXLUM/YKzFjZvl-vI/AAAAAAABuJg/nhy4UmUqHh8ZvHgNGiVgXORI7d3xhWw6QCLcBGAsYHQ/s400/email%2Btracking.jpeg&quot;/&gt;&lt;/div&gt;&lt;p&gt;    Tracking opened emails is a technique that, if used responsibly, can provide utility to both you and your users.     &lt;br&gt;    Here a few use cases where it makes sense to me: &lt;/p&gt;&lt;ul&gt;    &lt;li&gt;Appointment updates. If your appointment in a car dealership was rescheduled an email is sent. If the email is not read in the next couple of hours a repeat email can be sent or a CS agent may follow up with a call.&lt;/li&gt;    &lt;li&gt;Uber-style fulfillment, where contractors are notified of lucrative jobs available to them. If nobody claims a job, a CS agent can go through users who are known not to have read the email.&lt;/li&gt;    &lt;li&gt;Providing estimates to event organizers how many people are going to show up based a on number of opened emails.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;    In this article, we are going to implement such a system for transactional emails using Rails and Postmark (a service that sends emails). We are going to use the &lt;a href=&quot;https://github.com/wildbit/postmark-rails&quot; target=&quot;_blank&quot;&gt;Postmark gem&lt;/a&gt;. &lt;/p&gt;&lt;h2&gt;Usage&lt;/h2&gt;&lt;p&gt;First of all, let's see how the code usage of the tool we are building is going to look like:&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;def new_blog_post(blog_post, subscriber)&lt;br /&gt;    store_message(&lt;br /&gt;      email_name: 'new_blog_post',&lt;br /&gt;      entity: blog_post,&lt;br /&gt;      user: subscriber&lt;br /&gt;    )&lt;br /&gt;&lt;br /&gt;    mail(&lt;br /&gt;      to: subscriber.email,&lt;br /&gt;      subject: &quot;New Post: #{blog_post.title}&quot;,&lt;br /&gt;      track_opens: 'true'&lt;br /&gt;    )&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;ruby&quot;&gt;all_emails = blog_post.sent_emails.count&lt;br /&gt;opened_emails = blog_post.sent_emails.opened.count&lt;br /&gt;open_rate = opened_emails.fdiv(all_emails)&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt; &lt;h2&gt;What is a tracking pixel?&lt;/h2&gt;&lt;p&gt;  By adding &lt;strong&gt;track_opens: 'true'&lt;/strong&gt; you are instructing Postmark to include a unique 1x1 image in the email. When a user opens that email the image gets loaded, which notifies the Postmark that the email was opened. It may not always work depending on an email client and user's settings. &lt;/p&gt;&lt;h2&gt;Implementation&lt;/h2&gt;&lt;h3&gt;Setup&lt;/h3&gt;&lt;p&gt;To track email status we are going to create records in a database table:&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/cb4adca186e5a14dc2a99921b150ca04.js?file=migration.rb&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/cb4adca186e5a14dc2a99921b150ca04.js?file=sent_email.rb&quot;&gt;&lt;/script&gt; &lt;p&gt;The next step is to define a callback that's going to be executed any time an email is sent, for that we need to add the following code to initializers:&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/cb4adca186e5a14dc2a99921b150ca04.js?file=postmark_observer.rb&quot;&gt;&lt;/script&gt; &lt;h3&gt;Mailer&lt;/h3&gt;&lt;p&gt;    To pass these params from our mailer we need to define the &lt;strong&gt;store_message&lt;/strong&gt; method.     &lt;br /&gt;    With this code any time we successfully send an email we are also going to create a record in the &lt;strong&gt;sent_emails&lt;/strong&gt; table. &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/cb4adca186e5a14dc2a99921b150ca04.js?file=application_mailer.rb&quot;&gt;&lt;/script&gt; &lt;h3&gt;Webhooks&lt;/h3&gt;&lt;p&gt;The next step is to start accepting webhooks from Postmark.&lt;/p&gt;&lt;p&gt;Let's define a webhook for opening an email, then do a similar thing for bounced emails.&lt;/p&gt; &lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-RcIn94NSUeg/YKy9KN0IDjI/AAAAAAABuJY/vT03ga2DUkMAVKte6tHydU3x_z-shQnDwCLcBGAsYHQ/s1005/Screenshot%2B2021-05-25%2Bat%2B16.59.16.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center; &quot; target=&quot;_blank&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; height=&quot;400&quot; data-original-height=&quot;1005&quot; data-original-width=&quot;618&quot; src=&quot;https://1.bp.blogspot.com/-RcIn94NSUeg/YKy9KN0IDjI/AAAAAAABuJY/vT03ga2DUkMAVKte6tHydU3x_z-shQnDwCLcBGAsYHQ/s400/Screenshot%2B2021-05-25%2Bat%2B16.59.16.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt; &lt;p&gt;And controller code that's going to handle these webhooks:&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/cb4adca186e5a14dc2a99921b150ca04.js?file=routes.rb&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/cb4adca186e5a14dc2a99921b150ca04.js?file=postmark_controller.rb&quot;&gt;&lt;/script&gt; &lt;p&gt;Here's how these services are implemented:&lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/cb4adca186e5a14dc2a99921b150ca04.js?file=email_opened_service.rb&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/cb4adca186e5a14dc2a99921b150ca04.js?file=email_bounced_service.rb&quot;&gt;&lt;/script&gt; &lt;p&gt;    That is all, use responsibly, and thank you for reading! &lt;/p&gt; &lt;p&gt;    p.s. you can see the full example repo &lt;a href=&quot;https://github.com/TheRusskiy/rails-track-opened-emails&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;here&lt;/strong&gt;&lt;/a&gt;. &lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/5508114225437976355"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/5508114225437976355"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2021/05/track-opened-emails-in-rails.html" title="Track Opened Emails In Rails"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/--Zd7VzgXLUM/YKzFjZvl-vI/AAAAAAABuJg/nhy4UmUqHh8ZvHgNGiVgXORI7d3xhWw6QCLcBGAsYHQ/s72-c/email%2Btracking.jpeg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-9098642651157945195</id><published>2021-05-15T12:43:00.003+04:00</published><updated>2021-05-17T10:45:02.839+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="HTTP"/><category scheme="http://www.blogger.com/atom/ns#" term="Performance"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby"/><title type="text">Turbocharge HTTP requests in Ruby</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;img alt=&quot;article logo&quot; style=&quot;display: block; padding: 1em 0; text-align: center; clear: right; float: right;&quot; border=&quot;0&quot; width=&quot;300&quot; data-original-height=&quot;354&quot; data-original-width=&quot;431&quot; src=&quot;https://1.bp.blogspot.com/-RZ9UACeGHxA/YJ-BpBrjLFI/AAAAAAABtEg/OZr8x3pGVAMWEEau5vzsed5bVrVLne6-QCLcBGAsYHQ/s400/itsalive.jpeg&quot;/&gt;&lt;/div&gt; &lt;h2&gt;The problem&lt;/h2&gt;&lt;p&gt;    The slowest part in many applications is I/O, especially network I/O. We spend a lot of trying to make sure we reduce the number of calls and cache results of API calls to 3rd party services and resources. &lt;/p&gt; &lt;p&gt;    Imagine we want to get data from &lt;a href=&quot;https://rickandmortyapi.com/&quot;&gt;Rick and Morty API&lt;/a&gt;. In this article, we are going to speed up subsequent requests to this API by almost &lt;strong&gt;4x times&lt;/strong&gt;. &lt;/p&gt; &lt;h2&gt;The solution&lt;/h2&gt;&lt;p&gt;    And yet there's a trick that even very senior developers and popular API library/clients forget about that can shave off precious time of your network calls built right into HTTP. &lt;/p&gt; &lt;p&gt;    Establishing an HTTP connection is very costly, &lt;a         href=&quot;https://www.cloudflare.com/learning/ssl/what-happens-in-a-tls-handshake/&quot; target=&quot;_blank&quot;&gt;especially if it uses TLS&lt;/a&gt;. This is a fixed price added to your HTTP calls that can be avoided by using keep-alive - a mechanism built into HTTP. &lt;/p&gt; &lt;p&gt;    According to &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_persistent_connection&quot; target=&quot;_blank&quot;&gt;Wiki&lt;/a&gt;: &lt;br&gt;    &lt;em&gt;HTTP keep-alive, or HTTP connection reuse, is the idea of using a single TCP connection to send and receive multiple HTTP requests/responses, as opposed to opening a new connection for every single request/response pair. &lt;/em&gt;&lt;/p&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center&quot;&gt;&lt;img alt=&quot;connections-ping-pong&quot; border=&quot;0&quot; width=&quot;600&quot; data-original-height=&quot;1340&quot; data-original-width=&quot;2110&quot;  style=&quot;padding: 1em 0;&quot; src=&quot;https://1.bp.blogspot.com/-A7W-065R2HU/YJ-H3SmNTWI/AAAAAAABtEo/vJS11iSJiEk92MdRWrW7PhcRzoH1ygQ2ACLcBGAsYHQ/s600/Screenshot%2B2021-05-15%2Bat%2B16.35.25.png&quot;/&gt;&lt;/div&gt; &lt;h2&gt;Desired usage&lt;/h2&gt;&lt;p&gt;We want our solution to resemble Ruby's standard library as much as possible, namely &lt;a         href=&quot;https://ruby-doc.org/stdlib-2.4.1/libdoc/net/http/rdoc/Net/HTTP.html&quot; target=&quot;_blank&quot;&gt;Net::HTTP&lt;/a&gt;.&lt;/p&gt;&lt;p&gt;    Using Ruby's standard library we could use: &lt;/p&gt;&lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;uri = URI(&quot;http://example.com&quot;)&lt;br /&gt;http = Net::HTTP.new(uri.host, uri.port)&lt;br /&gt;request = Net::HTTP::Get.new(uri.request_uri)&lt;br /&gt;response = http.request(request)&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt;&lt;p&gt;    Our &lt;strong&gt;PersistentHttpClient&lt;/strong&gt; usage would look like that: &lt;/p&gt;&lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;uri = URI(&quot;http://example.com&quot;)&lt;br /&gt;http = PersistentHttpClient.get(uri)&lt;br /&gt;request = Net::HTTP::Get.new(uri.request_uri)&lt;br /&gt;response = http.request(request)&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;h2&gt;Implementation&lt;/h2&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/bcec13fda6589d13ef8a658bda561a7e.js?file=persistent_http_client.rb&quot;&gt;&lt;/script&gt; &lt;h2&gt;Benchmarks&lt;/h2&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/bcec13fda6589d13ef8a658bda561a7e.js?file=benchmark.rb&quot;&gt;&lt;/script&gt; &lt;p&gt;    As we can see, for this simple HTTP call the speed gain is a whopping &lt;strong&gt;3.9x&lt;/strong&gt;!     &lt;br&gt;    Of course, for API calls where a server takes longer to process a request the gain won't as big, but for simple calls, the difference can't be ignored. &lt;/p&gt; &lt;p style=&quot;display: none&quot;&gt;    The advantage of this approach in comparison to something like &lt;a href=&quot;https://github.com/drbrain/net-http-persistent&quot;&gt;github.com/drbrain/net-http-persistent&lt;/a&gt;    is that the solution in this article doesn't keep connections open indefinitely to drain resources and have memory leaks. Also, it automatically manages a cache of clients instead of you having to deal with that ad hoc. &lt;/p&gt; &lt;p&gt;    It's important to remember that the keep-alive timeout that you set on the Ruby side must be respected by the server that receives it, some servers may choose to close a connection despite this setting. &lt;/p&gt; &lt;h2&gt;What's on the server?&lt;/h2&gt; &lt;p&gt;    I think it's also important to mention, that while keep-alive connections provide utility to clients, they can potentially     &lt;a href=&quot;https://www.nginx.com/blog/http-keepalives-and-web-performance/&quot;&gt;overload your servers&lt;/a&gt; if not configured properly. Misbehaving clients can hog your memory, thus it's important to place your precious application servers behind a reverse proxy such as Nginx. &lt;/p&gt; &lt;p&gt;    Thank you for reading! &lt;/p&gt; </content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/9098642651157945195"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/9098642651157945195"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2021/05/turbocharge-http-requests-in-ruby.html" title="Turbocharge HTTP requests in Ruby"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-RZ9UACeGHxA/YJ-BpBrjLFI/AAAAAAABtEg/OZr8x3pGVAMWEEau5vzsed5bVrVLne6-QCLcBGAsYHQ/s72-c/itsalive.jpeg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-361876427877956377</id><published>2021-05-10T14:04:00.006+04:00</published><updated>2021-05-10T14:21:28.416+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="authentication"/><category scheme="http://www.blogger.com/atom/ns#" term="Javascript"/><category scheme="http://www.blogger.com/atom/ns#" term="nextjs"/><category scheme="http://www.blogger.com/atom/ns#" term="TypeScript"/><title type="text">Next.js: restrict pages to authenticated users</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;div style=&quot;display: block; padding: 1em 0; text-align: center; clear: right; float: right; margin-left: 20px; margin-bottom: 20px&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; width=&quot;250&quot; data-original-height=&quot;326&quot; data-original-width=&quot;325&quot; src=&quot;https://1.bp.blogspot.com/-gwD4nvKHK5M/YJj2PWpH7wI/AAAAAAABtAM/gMaOUYwjda0JLMNglR3yMOSrpt9FvxpEQCLcBGAsYHQ/s400/lock2.jpeg&quot;/&gt;&lt;/div&gt;&lt;/div&gt; &lt;p&gt;Many websites have pages that need to be restricted to authenticated users, for example profile pages or dashboards.&lt;/p&gt;&lt;p&gt;  Next.js web framework comes with a lot of functionality built-in JS compilation, rendering code on server and caching.   &lt;br/&gt;  When it comes to most other aspecs, it's up to a programmer to build, including such needed functionality as restricting access to some pages only to authenticated users. &lt;/p&gt;&lt;p&gt;  In this article we are going to build just that: a function that augments a page object, that could be used like that: &lt;/p&gt;&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/7e5404a8a12896efb79b8ec7848c5dbb.js?file=example-page.tsx&quot;&gt;&lt;/script&gt;&lt;p&gt;  Here's the implementation in TypeScript: &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/7e5404a8a12896efb79b8ec7848c5dbb.js?file=requireAuth.ts&quot;&gt;&lt;/script&gt;&lt;p&gt;  In order to make it work on server we are going to need one more utility function &lt;strong&gt;fetchWithCookies&lt;/strong&gt;.   &lt;br /&gt;  When making HTTP request from inside a Web Browser, the browser automatically sends cookies with each requests and then stores new cookies if a response comes in with &lt;strong&gt;set-cookie&lt;/strong&gt; header.   &lt;br /&gt;  On server-side we need to build this feature ourselves, because neither Next.js nor NodeJS make any assumption about a request flow.   &lt;br /&gt;  In order to do that we can leverage &lt;strong&gt;ctx: { req, res }&lt;/strong&gt; object that Next.js passes into &lt;strong&gt;getInitialProps&lt;/strong&gt; during SSR. &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/7e5404a8a12896efb79b8ec7848c5dbb.js?file=makeHttpClient.ts&quot;&gt;&lt;/script&gt;&lt;p&gt;  Of course this implementation is only one way to do this, for example the HTTP client looks different if you are using Apollo Graphql.  &lt;/p&gt;&lt;p&gt;  Thank you for reading! &lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/361876427877956377"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/361876427877956377"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2021/05/restrict-nextjs-page-to-authenticated.html" title="Next.js: restrict pages to authenticated users"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-gwD4nvKHK5M/YJj2PWpH7wI/AAAAAAABtAM/gMaOUYwjda0JLMNglR3yMOSrpt9FvxpEQCLcBGAsYHQ/s72-c/lock2.jpeg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-127531681378718392</id><published>2021-05-07T11:59:00.005+04:00</published><updated>2021-05-09T17:23:51.073+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="authentication"/><category scheme="http://www.blogger.com/atom/ns#" term="phone"/><category scheme="http://www.blogger.com/atom/ns#" term="redis"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby on Rails"/><category scheme="http://www.blogger.com/atom/ns#" term="Security"/><category scheme="http://www.blogger.com/atom/ns#" term="sms"/><title type="text">Phone Authentication in Ruby</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;div style=&quot;display: block; padding: 1em 0; text-align: center; clear: right; float: right;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; width=&quot;400&quot; data-original-height=&quot;386&quot; data-original-width=&quot;578&quot; src=&quot;https://1.bp.blogspot.com/-fcq-AQcSAvg/YJT0Hu7jOsI/AAAAAAABsdo/kBhuYyDwiyoLHk3aEgkp6JK9juGHqKOTgCLcBGAsYHQ/s400/sms.jpeg&quot;/&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;Using SMS to authenticate a user has the following benefits:&lt;/p&gt;&lt;ul&gt;    &lt;li&gt;Everybody has a phone.&lt;/li&gt;    &lt;li&gt;Users don't have to remember passwords.&lt;/li&gt;    &lt;li&gt;Protect against robots &amp; duplicate accounts.&lt;/li&gt;    &lt;li&gt;Familiarity.&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;em&gt;You should not use SMS a sole authentication method for systems that require high-security.&lt;/em&gt;&lt;/p&gt; &lt;p&gt;    What I am going to cover in this article is how to make an API that generates &quot;phone tokens&quot; that can be used to sign-in / sign-up. This way you don't need to create a user record before a phone is verified. &lt;/p&gt; &lt;h1&gt;User stories&lt;/h1&gt;&lt;p&gt;    Below is 2 user stories we are going to cover. &lt;/p&gt; &lt;p&gt;    As a returning user.     &lt;br&gt;    I want to &lt;strong&gt;sign-in&lt;/strong&gt;.     &lt;br&gt;    I go to the login screen and enter my &lt;strong&gt;phone&lt;/strong&gt;.     &lt;br&gt;    I receive an SMS with the verification code, enter the &lt;strong&gt;code&lt;/strong&gt;.     &lt;br&gt;    I am logged in. &lt;/p&gt; &lt;br&gt; &lt;p&gt;    As a new user.     &lt;br&gt;    I want to &lt;strong&gt;sign-up&lt;/strong&gt;.     &lt;br&gt;    I go to the login screen and enter my &lt;strong&gt;phone&lt;/strong&gt;.     &lt;br&gt;    I receive an SMS with the verification code, enter the &lt;strong&gt;code&lt;/strong&gt;.     &lt;br&gt;    I enter my &lt;strong&gt;name&lt;/strong&gt; and &lt;strong&gt;email&lt;/strong&gt; and hit submit.     &lt;br&gt;    I am registered and logged in. &lt;/p&gt; &lt;br&gt;&lt;br&gt;&lt;p&gt;    To make the 2nd story (sign up) work, upon phone verification we want to return a secure &lt;strong&gt;phone token&lt;/strong&gt; that, together with name and email can be exchanged to create a new account. &lt;/p&gt; &lt;p&gt;&lt;strong&gt;Phone token&lt;/strong&gt; is going to be an encoded &lt;strong&gt;phone&lt;/strong&gt; string signed by our secret key as proof that it originated from our system.&lt;/p&gt; &lt;h1&gt;Pseudo-code API &lt;em&gt;&lt;a href=&quot;https://github.com/TheRusskiy/rails-phone-auth/blob/master/app/controllers/phone_verification_controller.rb&quot; target=&quot;_blank&quot; style=&quot;font-size: 0.5em&quot;&gt;(Controller Code)&lt;/a&gt;&lt;/em&gt;&lt;/h1&gt; &lt;p&gt;An important bit is that both sign-in and sign-up flows start with entering a phone number and getting a phone token. Your app can then check if a user with such phone already exists, if it does, then simply login, otherwise proceed to sign up.&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;# ask user for a phone and send an SMS code&lt;br /&gt;POST /send-phone-verification { phone: '+19178456780' }&lt;br /&gt;PhoneVerification.send_verification(phone: params[:phone])&lt;br /&gt;=&gt; {}&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;# verify the phone entering the code from SMS,&lt;br /&gt;# get encoded phoneToken in return&lt;br /&gt;POST /verify-phone { phone: '+19178456780', code: '123456' }&lt;br /&gt;phone_token = PhoneVerification.code_to_phone_token(&lt;br /&gt;  phone: params[:phone],&lt;br /&gt;  code: params[:code]&lt;br /&gt;)&lt;br /&gt;=&gt; { phoneToken: phone_token }&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;# exchange the phoneToken to a user information&lt;br /&gt;POST /sign-in { phoneToken: 'xxxxxxxxxxxxx' }&lt;br /&gt;trusted_phone = PhoneVerification.phone_token_to_phone(params[:phone_token])&lt;br /&gt;user = User.find_by_phone(trusted_phone)&lt;br /&gt;=&gt; { user: user }&lt;br /&gt;&lt;br /&gt;# OR&lt;br /&gt;&lt;br /&gt;# use the phone token to create a new user with verified phone&lt;br /&gt;POST /sign-up { phoneToken: 'xxxxxxxxxxxxx', name: 'John Doe', email: 'john@example.com' }&lt;br /&gt;trusted_phone = PhoneVerification.phone_token_to_phone(params[:phone_token])&lt;br /&gt;user = User.find_or_create_by!(phone: trusted_phone) do |u|&lt;br /&gt;  u.name = params[:name]&lt;br /&gt;  u.email = params[:email]&lt;br /&gt;end&lt;br /&gt;=&gt; { user: user }&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;h1&gt;Implementation&lt;/h1&gt;&lt;p&gt;    In order to implement this we are going to need the following: &lt;/p&gt;&lt;ul&gt;    &lt;li&gt;Redis&lt;/li&gt;    &lt;li&gt;Service to send an SMS (e.g. Twilio)&lt;/li&gt;    &lt;li&gt;&lt;a href=&quot;https://www.dmitry-ishkov.com/2021/05/encrypt-decrypt-text-in-ruby.html&quot; target=&quot;_blank&quot;&gt;TextEncryptor&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;    Without further ado, let's jump into code &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/89207bedbd8751aa713bff3e2768ef50.js?file=phone_verification.rb&quot;&gt;&lt;/script&gt; &lt;p&gt;    You can read the full code at &lt;a href=&quot;https://github.com/TheRusskiy/rails-phone-auth&quot; target=&quot;_blank&quot;&gt;https://github.com/TheRusskiy/rails-phone-auth&lt;/a&gt;.     &lt;br&gt;    Thank you for reading! &lt;/p&gt; &lt;p&gt;p.s. I recommend &lt;em&gt;against&lt;/em&gt; using SMS as a sole means of authentication for security-critical apps such as banking, admin dashboards and other systems where gaining access to a single account can give a lot of value, only use it in conjunction with passwords. A dedicated attacker can spoof SMS of a specific user.&lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/127531681378718392"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/127531681378718392"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2021/05/phone-authentication-in-ruby.html" title="Phone Authentication in Ruby"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-fcq-AQcSAvg/YJT0Hu7jOsI/AAAAAAABsdo/kBhuYyDwiyoLHk3aEgkp6JK9juGHqKOTgCLcBGAsYHQ/s72-c/sms.jpeg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-8688111153761227517</id><published>2021-05-06T09:12:00.001+04:00</published><updated>2021-05-06T09:12:26.858+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Ruby"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby on Rails"/><category scheme="http://www.blogger.com/atom/ns#" term="Security"/><title type="text">Encrypt &amp; Decrypt text in Ruby</title><content type="html">&lt;p&gt;If you want to pass some information to a client that you don't want the client to read or temper with, read on!&lt;/p&gt; &lt;p&gt;    The usage of our TextEncryptor is straightforward: &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;data = { ... }&lt;br /&gt;serialized_data = JSON.dump(data)&lt;br /&gt;encoded_data = TextEncryptor.encrypt(serialized_data)&lt;br /&gt;&lt;br /&gt;# ...&lt;br /&gt;&lt;br /&gt;serialized_data = TextEncryptor.decrypt(encoded_data)&lt;br /&gt;data = JSON.parse(serialized_data)&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt;&lt;/p&gt; &lt;h3&gt;Implementation:&lt;/h3&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/e2dfb2b93464d864efa7b64ed7edee32.js&quot;&gt;&lt;/script&gt; &lt;br&gt; &lt;p&gt;    One of the ways I use this is to store a proof that a phone number is verified on client side and allow exchanging that encoded phone number token to login or signup. You can read more about this in one of the following blog posts. &lt;/p&gt;&lt;br&gt;&lt;p&gt;    Thank you for reading! &lt;/p&gt; </content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/8688111153761227517"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/8688111153761227517"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2021/05/encrypt-decrypt-text-in-ruby.html" title="Encrypt &amp; Decrypt text in Ruby"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-1115003466660524372</id><published>2021-05-04T13:35:00.007+04:00</published><updated>2021-05-06T08:50:41.067+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Google Maps"/><category scheme="http://www.blogger.com/atom/ns#" term="Javascript"/><category scheme="http://www.blogger.com/atom/ns#" term="Optimization"/><category scheme="http://www.blogger.com/atom/ns#" term="React"/><category scheme="http://www.blogger.com/atom/ns#" term="TypeScript"/><title type="text">Faster Google Maps load times</title><content type="html"> &lt;p&gt;Google Maps is notoriously slow. The moment you add a Google Map to your page you can cut your Lighthouse     performance score in half.&lt;/p&gt; &lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-CB-yAPeOHMk/YJEU_sJN9xI/AAAAAAABsIs/vNOMZ_Bnn7QRLzWp4bYcYvzq5PNWQNYmACLcBGAsYHQ/s447/Screenshot%2B2021-05-04%2Bat%2B17.30.36.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center; clear: right; float: right;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; width=&quot;300&quot; data-original-height=&quot;428&quot; data-original-width=&quot;447&quot; src=&quot;https://1.bp.blogspot.com/-CB-yAPeOHMk/YJEU_sJN9xI/AAAAAAABsIs/vNOMZ_Bnn7QRLzWp4bYcYvzq5PNWQNYmACLcBGAsYHQ/s400/Screenshot%2B2021-05-04%2Bat%2B17.30.36.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt; &lt;p&gt;    There are several ways you can fight with it: &lt;/p&gt;&lt;ul&gt;    &lt;li&gt;        Add &lt;code&gt;async/defer&lt;/code&gt; to your Google script - certainly helps, but no much. &lt;em&gt;This technique is very common         so I won't be talking about it.&lt;/em&gt;    &lt;/li&gt;    &lt;li&gt;        Loading the map only when a user scrolls to it. This works well the map is located below the fold. &lt;em&gt;&lt;a href=&quot;https://github.com/TheRusskiy/google-maps-optimizations/blob/master/src/ObserverMapPage/index.tsx&quot; target=&quot;_blank&quot;&gt;Code&lt;/a&gt;.&lt;/em&gt;    &lt;/li&gt;    &lt;li&gt;        Using a static google maps image. There are cases when you might not need an interactive map and an         image is all you need. The API for it is surprisingly versatile. &lt;em&gt;&lt;a href=&quot;https://github.com/TheRusskiy/google-maps-optimizations/blob/master/src/StaticImageMapPage/index.tsx&quot; target=&quot;_blank&quot;&gt;Code&lt;/a&gt;.&lt;/em&gt;    &lt;/li&gt;    &lt;li&gt;        Skipping fonts loading. Whenever you include Google maps script it automatically fetches a Roboto font. The map         works perfectly fine without it, you can shave off a decent amount of time if you know how to block the font. &lt;em&gt;&lt;a href=&quot;https://github.com/TheRusskiy/google-maps-optimizations/blob/master/src/SkipFontMapPage/index.tsx&quot; target=&quot;_blank&quot;&gt;Code&lt;/a&gt;.&lt;/em&gt;    &lt;/li&gt;    &lt;li&gt;        Using a static preview of the map and then loading a full version on click. Perhaps the best technique when a         map is located above the fold. &lt;em&gt;&lt;a href=&quot;https://github.com/TheRusskiy/google-maps-optimizations/blob/master/src/PlaceholderMapPage/index.tsx&quot; target=&quot;_blank&quot;&gt;Code&lt;/a&gt;.&lt;/em&gt;    &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;    By using these tricks you can achieve much better page performance (and SEO!) and save money on the costly Google Maps API. &lt;/p&gt; &lt;h3&gt;Loading map on scroll &lt;em&gt;&lt;a href=&quot;https://github.com/TheRusskiy/google-maps-optimizations/blob/master/src/ObserverMapPage/index.tsx&quot; target=&quot;_blank&quot;&gt;(Code)&lt;/a&gt;&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;    The idea here is to skip loading script until a user scrolls to it. This can be achieved using the IntersectionObserver API.     &lt;br&gt;    Below is an example implementation: &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/452045c864ac581d1155e27726c26567.js?file=ObserverExample.tsx&quot;&gt;&lt;/script&gt; &lt;h3&gt;Using Maps Static API &lt;em&gt;&lt;a href=&quot;https://github.com/TheRusskiy/google-maps-optimizations/blob/master/src/StaticImageMapPage/index.tsx&quot; target=&quot;_blank&quot;&gt;(Code)&lt;/a&gt;&lt;/em&gt;&lt;/h3&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-OVSGfQI4ZMM/YJETIpTya6I/AAAAAAABsIc/pxJOfIQt2Jgxce_nLIn-hVIDy59ytwrjgCLcBGAsYHQ/s800/Screenshot%2B2021-05-04%2Bat%2B17.24.09.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center; clear: left;&quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; width=&quot;600&quot; data-original-height=&quot;502&quot; data-original-width=&quot;800&quot; src=&quot;https://1.bp.blogspot.com/-OVSGfQI4ZMM/YJETIpTya6I/AAAAAAABsIc/pxJOfIQt2Jgxce_nLIn-hVIDy59ytwrjgCLcBGAsYHQ/s600/Screenshot%2B2021-05-04%2Bat%2B17.24.09.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;p&gt;    Instead of loading the heavy script, at times, we can get away with loading only an image of the map. Google provides a way to add markets to it as well.     &lt;br&gt;    One of the unpleasant gotchas is that image resolution cannot go above 640px (1280px for x2 scale). Which means that an image is blurry.     &lt;br&gt;    Another interesting observation is that while this API is fast, you can make the image load 2x as fast by placing it behind a CDN. You can save some money this way as well.     &lt;br&gt;    You can read more about this API &lt;a href=&quot;https://developers.google.com/maps/documentation/maps-static/overview&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;.     &lt;br&gt;    Below is an example implementation: &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/452045c864ac581d1155e27726c26567.js?file=MapsStaticApiExample.tsx&quot;&gt;&lt;/script&gt;  &lt;h3&gt;Skipping font load &lt;em&gt;&lt;a href=&quot;https://github.com/TheRusskiy/google-maps-optimizations/blob/master/src/SkipFontMapPage/index.tsx&quot; target=&quot;_blank&quot;&gt;(Code)&lt;/a&gt;&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;    Whenever you include the Google maps script it automatically loads Roboto fonts to load. IMHO maps looks just fine without them and the extra HTTP requests are not necessary when every byte and millisecond counts.     &lt;br&gt;    Below is an example implementation: &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/452045c864ac581d1155e27726c26567.js?file=SkipFontExample.tsx&quot;&gt;&lt;/script&gt; &lt;h3&gt;Using an image placeholder and loading the map on click &lt;em&gt;&lt;a href=&quot;https://github.com/TheRusskiy/google-maps-optimizations/blob/master/src/PlaceholderMapPage/index.tsx&quot; target=&quot;_blank&quot;&gt;(Code)&lt;/a&gt;&lt;/em&gt;&lt;/h3&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-arZFJHGx78c/YJETZSee-7I/AAAAAAABsIk/JKgUtp2ajQ4OaM5nw-8spCyCd42GNwf_gCLcBGAsYHQ/s812/Screenshot%2B2021-05-04%2Bat%2B17.23.38.png&quot; style=&quot;display: block; padding: 1em 0; text-align: center; &quot;&gt;&lt;img alt=&quot;&quot; border=&quot;0&quot; width=&quot;600&quot; data-original-height=&quot;526&quot; data-original-width=&quot;812&quot; src=&quot;https://1.bp.blogspot.com/-arZFJHGx78c/YJETZSee-7I/AAAAAAABsIk/JKgUtp2ajQ4OaM5nw-8spCyCd42GNwf_gCLcBGAsYHQ/s600/Screenshot%2B2021-05-04%2Bat%2B17.23.38.png&quot;/&gt;&lt;/a&gt;&lt;/div&gt;&lt;p&gt;    If you want to provide users with a dynamic map but also care about page performance you can go with a hybrid approach and show a static image with a button to load the full version     &lt;br&gt;    Below is an example implementation: &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/452045c864ac581d1155e27726c26567.js?file=PlaceholderExample.tsx&quot;&gt;&lt;/script&gt; &lt;p&gt;    These techniques can be combined any way you want to get even better results. For example, you can use observer API and use a static image as a placeholder.     &lt;br&gt;    You can read the full code at &lt;a href=&quot;https://github.com/TheRusskiy/google-maps-optimizations&quot; target=&quot;_blank&quot;&gt;https://github.com/TheRusskiy/google-maps-optimizations&lt;/a&gt;.     &lt;br&gt;    Thank you for reading! &lt;/p&gt; </content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/1115003466660524372"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/1115003466660524372"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2021/05/faster-google-maps-load-times.html" title="Faster Google Maps load times"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-CB-yAPeOHMk/YJEU_sJN9xI/AAAAAAABsIs/vNOMZ_Bnn7QRLzWp4bYcYvzq5PNWQNYmACLcBGAsYHQ/s72-c/Screenshot%2B2021-05-04%2Bat%2B17.30.36.png" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-3624605720411378312</id><published>2019-07-02T21:16:00.001+04:00</published><updated>2021-08-21T19:15:38.333+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Databases"/><category scheme="http://www.blogger.com/atom/ns#" term="Optimization"/><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby on Rails"/><category scheme="http://www.blogger.com/atom/ns#" term="SQL"/><title type="text">Ruby on Rails optimization techniques</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-SonlsnUrKNA/XRuO7yxMkhI/AAAAAAAA_lo/aQkw6Dq2iRsgWWJVERo8Hu4tZrqvK5GFwCLcBGAs/s1600/7504631998_393c144631_h.jpg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://2.bp.blogspot.com/-SonlsnUrKNA/XRuO7yxMkhI/AAAAAAAA_lo/aQkw6Dq2iRsgWWJVERo8Hu4tZrqvK5GFwCLcBGAs/s320/7504631998_393c144631_h.jpg&quot; width=&quot;320&quot; height=&quot;214&quot; data-original-width=&quot;1600&quot; data-original-height=&quot;1070&quot; /&gt;&lt;/a&gt;&lt;/div&gt; &lt;p&gt;There‚Äôs a reputation that Ruby on Rails apps are slow, however, because of its simplicity, readability and many good techniques and tools available out of the box, it‚Äôs easy to make ROR apps behave faster than other language frameworks.&lt;/p&gt;&lt;p&gt;So unless your app‚Äôs business model heavily depends on how much each transaction costs (e.g WhatsApp, Twitter, and other social networks) ROR can be the right tool for you.&lt;/p&gt; &lt;p&gt;Let‚Äôs begin!&lt;/p&gt; &lt;h1&gt;No Optimization&lt;/h1&gt; &lt;p&gt;No optimization article would be complete without mentioning premature optimization. So the first rule of optimization is that you shouldn‚Äôt optimize unless you have a problem, and unless you know for sure there‚Äôs going to be a bottleneck, you should focus on readability and business value instead of solving a problem that doesn‚Äôt exist.&lt;/p&gt; &lt;h1&gt;Measure&lt;/h1&gt; &lt;p&gt;The second rule is measure! How do you know you are making improvements unless you have numbers to back you up?&lt;/p&gt; &lt;p&gt;There are different tools available based on what you want to measure.&lt;/p&gt; &lt;p&gt;For optimizing specific methods you can use the inbuilt Benchmark module&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;require 'benchmark'&lt;br /&gt;puts Benchmark.measure { 10_000.times { your_code } }&lt;br /&gt;#        user     system      total        real&lt;br /&gt;# =&amp;gt; 1.500000   0.000000   1.500000 (  1.500000)&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;For measuring web requests you could use a handy gem called rack-mini-profiler: &lt;a href=&quot;https://github.com/MiniProfiler/rack-mini-profiler&quot; target=&quot;_blank&quot;&gt;https://github.com/MiniProfiler/rack-mini-profiler&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;Or you could use a very primitive combination of time and curl:&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;time curl https://google.com  &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;There are important details related to measuring execution time.&lt;/p&gt;&lt;p&gt;After you change your code make sure you don‚Äôt measure the first request to your server because the code is going to need a reload. The same goes for micro-optimizations, your processor caches need to be warmed first.&lt;/p&gt; &lt;p&gt;Once you have measured the execution time of your code you can begin thinking of different techniques to speed up your app.&lt;/p&gt; &lt;h1&gt;Database Optimizations&lt;/h1&gt;&lt;p&gt;We are going to start with database optimizations: the more data you have the easier it is to shoot yourself in the foot by not using optimal solutions. Thankfully by following a few simple techniques, we can reach 80% of the way to make our DB access fast.&lt;/p&gt;&lt;p&gt;We are going to talk about:&lt;/p&gt; &lt;ul&gt;    &lt;li&gt;Getting rid of N+1 requests&lt;/li&gt;    &lt;li&gt;Adding Indexes&lt;/li&gt;    &lt;li&gt;Rewriting ORM queries in plain SQL&lt;/li&gt;    &lt;li&gt;Denormalizing database&lt;/li&gt;    &lt;li&gt;Doing inserts in transaction&lt;/li&gt;&lt;/ul&gt; &lt;h3&gt;Getting rid of N+1 requests&lt;/h3&gt; &lt;p&gt;Usually, the first thing I look at when trying to optimize a web request is to try to get rid of N+1 SQL queries.&lt;/p&gt;&lt;p&gt;The easiest way to spot them is to open your logs, make a new HTTP request and see if there are many identical SQL queries being logged.&lt;/p&gt;&lt;p&gt;You can also use a handy bullet gem: &lt;a href=&quot;https://github.com/flyerhzm/bullet&quot; target=&quot;_blank&quot;&gt;https://github.com/flyerhzm/bullet&lt;/a&gt;&lt;/p&gt;&lt;p&gt;An example of N+1 is an application where you have many articles, each article has an author and many comments.&lt;/p&gt;&lt;p&gt;Say you want to display all articles, and each article shows its author and comments.&lt;/p&gt;&lt;p&gt;It takes 1 SQL request to load the article, however when your code iterates over them and tries to access its author or comments, it needs to make an SQL request for each one.&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;articles = Article.all&lt;br /&gt;articles.each do |a|&lt;br /&gt;    puts a.author.name&lt;br /&gt;    puts a.comments.map(&amp;amp;:text)&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;Given you have 100 articles, this code is going to make 201 SQL requests.&lt;/p&gt;&lt;p&gt;You could turn this into 1 SQL request by adding just a bit of code.&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;articles  = Article.eager_load(author: {}, comments: {})&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt;&lt;p&gt;However this makes database perform a huge join, a better alternative is to use &quot;includes&quot;:&lt;/p&gt;&lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;articles  = Article.includes(author: {}, comments: {})&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt;Includes is going to make 3 SQL queries.  &lt;pre&gt;&lt;br /&gt;&lt;code&gt;&lt;br /&gt;SELECT * FROM articles&lt;br /&gt;SELECT * FROM authors WHERE authors.article_id IN (...)&lt;br /&gt;SELECT * FROM comments WHERE comments.article_id IN (...)&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;In practice, this is faster than a huge join.&lt;/p&gt; &lt;p&gt;When serializing complex nested data structures you could use something like &lt;a href=&quot;https://github.com/TheRusskiy/json_dumper&quot; target=&quot;_blank&quot;&gt;https://github.com/TheRusskiy/json_dumper&lt;/a&gt; gem.&lt;/p&gt; &lt;h3&gt;Indexes&lt;/h3&gt; &lt;p&gt;If your table has more than 1000 records, it is vital to consider if it needs indexes.&lt;/p&gt;&lt;p&gt;An index can be created for a column to make SELECT queries that filter by this column faster.&lt;/p&gt;&lt;p&gt;Imagine a phone book, if you are searching for your friend‚Äôs number by a name, and names are not sorted, it is ok to list through maybe 50 contacts, but if you have more it becomes a nightmare, it is much easier to find your friend if contacts are sorted by names.&lt;/p&gt;&lt;p&gt;This is very close to what database does when you create an index, it creates a data structure where references to records are sorted by the specified column.&lt;/p&gt; &lt;p&gt;You need to analyze what columns are included in your SELECTs and create indexes for them.&lt;/p&gt;&lt;p&gt;It is better to have too many indexes than too few.&lt;/p&gt;&lt;p&gt;Downsides of indexes are extra storage usage and a bit slower UPDATE and INSERT queries on that table since indexes need to be rebuilt each time values in the indexed column change.&lt;/p&gt; &lt;h3&gt;Rewriting ORM queries in plain SQL&lt;/h3&gt; &lt;p&gt;ORMs are a controversial topic, some love them, some hate. Personally, I like them for the productivity boost, but it comes at a cost, especially in ROR, where every model is very smart and complex.&lt;/p&gt;&lt;p&gt;When you need to load many records at once, it might be a better idea to get the data you need via plain SQL.  Since instantiating ActiveRecord objects is costly, it can speed up your code several times.&lt;/p&gt; &lt;p&gt;For most of us writing business logic is more natural and convenient in our programming language, than in SQL, however, when you are loading a lot of data and then crunching it, if it‚Äôs slow, rewriting it in SQL can make your code significantly faster.&lt;/p&gt; &lt;h3&gt;Denormalizing database&lt;/h3&gt; &lt;p&gt;Denormalizing comes at the cost of maintainability but sometimes is inevitable to reach the necessary performance.&lt;/p&gt;&lt;p&gt;The main idea is that instead of calculating information every time on the fly, doing joins, you can store information in a database column.&lt;/p&gt;&lt;p&gt;E.g. when you want to show user rating of some shop, instead of going and loading all the ratings for it and taking an average on every request, you can calculate that average once a day and store in a column on that shop‚Äôs table.&lt;/p&gt;&lt;p&gt;The same can be done with counts, instead of doing queries to calculate how many comments each post in a blog has, you can store it in a column on that post.&lt;/p&gt; &lt;h3&gt;Doing inserts in transaction&lt;/h3&gt; &lt;p&gt;When you are inserting many records at once there‚Äôs a trick to make it faster: put all inserts inside a transaction. Besides helping with consistency, it can make inserts several times faster.&lt;/p&gt; &lt;h1&gt;Caching&lt;/h1&gt; &lt;p&gt;Perhaps the most powerful optimization technique, but also it can be hard to get right, it can cause many bugs (right away and later when you change your code).&lt;/p&gt; &lt;h3&gt;Caching views&lt;/h3&gt; &lt;p&gt;One of the highest levels of caching (ignoring HTTP) is caching HTML in your views.&lt;/p&gt; &lt;p&gt;You can either rely on rails &quot;magic&quot;:&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;&amp;lt;% @articles.each do |article| %&amp;gt;&lt;br /&gt;  &amp;lt;% cache article do %&amp;gt;&lt;br /&gt;    &amp;lt;your-html /&amp;gt;&lt;br /&gt;  &amp;lt;% end %&amp;gt;&lt;br /&gt;&amp;lt;% end %&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;Or generate cache keys yourself&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;&amp;lt;% @articles.each do |article| %&amp;gt;&lt;br /&gt;  &amp;lt;% Rails.cache.fetch(&lt;br /&gt;     &amp;quot;articles/#{article.id}-#{article.updated_at}/details&amp;quot;, expires_in: 1.hour) do %&amp;gt;&lt;br /&gt;    &amp;lt;your-html /&amp;gt;&lt;br /&gt;  &amp;lt;% end %&amp;gt;&lt;br /&gt;&amp;lt;% end %&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;On the one hand, you can avoid a whole lot of queries and HTML generation, on the other, you need to be very careful in what data you include in your HTML and make sure that data in the cache key uniquely identifies the content. E.g. if your HTML contains data specific to a user, you need to include this user‚Äôs id in the cache, otherwise, one user is going to see another users content, which is not only confusing but can be a gaping hole in your security.&lt;/p&gt; &lt;p&gt;It‚Äôs also important to think if your content always needs to be up to date.&lt;/p&gt;&lt;p&gt;E.g. if a new article was added and you are showing a new article list, how soon does it have to appear.&lt;/p&gt;&lt;p&gt;One way to deal with it is expiring cache every time a new article is created, but it can be very hard to track all the places where the article can be updated.&lt;/p&gt; &lt;p&gt;A common technique to deal with having user-specific content on cached pages is caching the whole fragment without user information, and then loading user info via AJAX upon page load.&lt;/p&gt;  &lt;h3&gt;Caching DB queries&lt;/h3&gt; &lt;p&gt;One level below view caching lies caching DB queries. Often they are slow and could use some speeding up.&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;Rails.cache.fetch(&amp;quot;user_articles_#{current_user.id}&amp;quot;, expires_in: 1.hour) do&lt;br /&gt;      Article.where(owner: current_user)&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;There‚Äôs actually a bug in the code above, it‚Äôs not going to be cached, because it only caches the relationship and not the actual records, it can be fixed by adding .load or .to_a which is going to actually load the records.&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;Rails.cache.fetch(&amp;quot;user_articles_#{current_user.id}&amp;quot;, expires_in: 1.hour) do&lt;br /&gt;      Article.where(owner: current_user).load&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;Caching DB queries has the same pitfalls as caching views. You need to be very careful!&lt;/p&gt; &lt;h3&gt;Not caching&lt;/h3&gt; &lt;p&gt;That sounds like a weird technique, but having too much caching can, in fact, slow your app down. In some cases a lot. Usually, your cache store (e.g. Redis) lives on a remote server, and making requests to it incurs quite a cost. To write to cache you need to calculate key, serialize content, send that content via a network. To read from the cache you need to calculate key, read content from the network and deserialize it.&lt;/p&gt; &lt;p&gt;You should never cache things like:&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;&amp;lt;% Rails.cache.fetch(&amp;quot;long_piece_of_html&amp;quot;) do %&amp;gt;&lt;br /&gt;    &amp;lt;h1&amp;gt;&lt;br /&gt;        This is a title&lt;br /&gt;    &amp;lt;/h1&amp;gt;&lt;br /&gt;    &amp;lt;!-- more plain html --&amp;gt;&lt;br /&gt;&amp;lt;% end %&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;Unless they have some DB queries inside or a lot of data crunching.&lt;/p&gt;&lt;p&gt;It‚Äôs much easier to generate a string locally than to make a network request for it.&lt;/p&gt; &lt;h1&gt;HTTP optimizations&lt;/h1&gt; &lt;p&gt;You can squeeze out more juice out of your app by correctly configuring Nginx and your assets.&lt;/p&gt;&lt;p&gt;Turning on HTTP 2 is fairly easy and provides a good performance boost for download speed, especially if you have many files living on your server since they can be downloaded in parallel.&lt;/p&gt; &lt;p&gt;It is very important to enable Gzip compression for your files, it can be done from Nginx.&lt;/p&gt;&lt;p&gt;Better yet use Brotli compression. It‚Äôs a new compression algorithm developed by Google that was specifically optimized for the web. It can be reduced your asset size by 14-20% when compared to Gzip. Sadly configuring it for Nginx is not very easy, but if you are using Cloudflare, you can enable it by simply toggling a checkbox.&lt;/p&gt; &lt;p&gt;Another optimization that you can include to your pages is adding different hints to the web browser.&lt;/p&gt;&lt;p&gt;There are prefetch, preconnect, preload, prerender.&lt;/p&gt;&lt;p&gt;Can be used like:&lt;/p&gt;&lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;&amp;lt;link rel=&amp;quot;prefetch&amp;quot; href=&amp;quot;//example.com&amp;quot;&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;This technique requires to carefully think about assets and helps browser load relevant content faster.&lt;/p&gt; &lt;h3&gt;Caching assets&lt;/h3&gt; &lt;p&gt;By assets I mean images, JS and CSS files.&lt;/p&gt; &lt;p&gt;It‚Äôs a huge topic in and of itself, but too important to skip.&lt;/p&gt; &lt;p&gt;Usually during deployment Rails generates files with unique names based on file content.&lt;/p&gt; &lt;p&gt;It runs a hash function over file content and adds it to the file name. So the file can become my_js_2086A9193BE7DD4E916989BFFACDB767.js. This way if file ever changes its name changes as well, so you can safely cache it.&lt;/p&gt; &lt;p&gt;You should never serve files via your ROR server, it‚Äôs just not meant for that.&lt;/p&gt;&lt;p&gt;A much better alternative is placing your ROR server behind a reverse proxy like Nginx, which would read these files from the filesystem and serve them for you. In this case, you need to make sure that Nginx adds correct header when serving these files:&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;location ^~ /assets/ {&lt;br /&gt;    gzip_static on;&lt;br /&gt;    expires max;&lt;br /&gt;    add_header 'Cache-Control' 'public';&lt;br /&gt;    ...&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;A better yet alternative is placing your server behind a proxy like CloudFlare, which would look at response headers and cache your content on their own servers and deliver it to your clients via a global CDN.&lt;/p&gt; &lt;h3&gt;Optimize your images&lt;/h3&gt; &lt;p&gt;Images are often the heaviest assets on your site. You battle to save 50kb from JS bundle only to add an image that weights 1mb without giving it a second thought.&lt;/p&gt;&lt;p&gt;You should add images in matching resolutions, if your designer gives you an image in 4k resolution, you shouldn‚Äôt use it as it.&lt;/p&gt;&lt;p&gt;Better yet, use &quot;srcset&quot; to specify images of different resolutions for different screen sizes.&lt;/p&gt;&lt;p&gt;Also, you need to remember, that 2 images with the same resolution can have a drastically different size based on how they were encoded. Most of the time you can sacrifice a bit of quality to get an image that is 10 times lighter.&lt;/p&gt;&lt;p&gt;Another easy optimization technique is lazy loading images, to only show them when the user scrolls and they appear on the screen.&lt;/p&gt;&lt;p&gt;Also, Chrome team promised lazy loading functionality to be available in Chrome 75.&lt;/p&gt;&lt;p&gt;It's going to be as easy as adding a &quot;loading&quot; attribute to your img tags:&lt;/p&gt;&lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;&amp;lt;img src=&amp;quot;example.jpg&amp;quot; loading=&amp;quot;lazy&amp;quot; /&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;h3&gt;Split your JavaScript&lt;/h3&gt; &lt;p&gt;This one requires a bit of thinking if you don‚Äôt have a SPA with chunk splitting, but can drastically reduce your JS bundle size. For example, you could split everything that requires interactivity from your main JS bundle and exclude it from your home page, which often has only marketing details.&lt;/p&gt; &lt;h1&gt;Move logic to background workers&lt;/h1&gt; &lt;p&gt;Much of the work that happens on web requests to your web application doesn‚Äôt have to complete before we show a user some response.&lt;/p&gt;&lt;p&gt;The classic example is emails.&lt;/p&gt;&lt;p&gt;Imagine that a user is buying a product. The code would look something like:&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;def buy_product &lt;br /&gt;  charge_user(user, product)&lt;br /&gt;  send_success_email(user, product)&lt;br /&gt;  return user.money_left&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;Sending the email could be slow, instead of waiting for it and slowing the user‚Äôs experience we can move it to a background worker.&lt;/p&gt; &lt;p&gt;There are other benefits to this technique besides speed:&lt;/p&gt; &lt;ul&gt;    &lt;li&gt;Worker code can be re-tried, especially if it‚Äôs a transient error&lt;/li&gt;    &lt;li&gt;Your app is much more resilient to sudden spikes of requests&lt;/li&gt;    &lt;li&gt;It is easier to separate your app into different services later&lt;/li&gt;&lt;/ul&gt;  &lt;h1&gt;DRY your code&lt;/h1&gt;&lt;p&gt;&lt;em&gt;DRY - don‚Äôt repeat yourself.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;By following this core software development practice, not only can you be more productive and reduce bugs related to changing code, but your code can be faster as well.&lt;/p&gt;&lt;p&gt;By making sure your code doesn‚Äôt repeat itself, you can spend time optimizing it in one place and anywhere it‚Äôs used is going to benefit from it.&lt;/p&gt;  &lt;h1&gt;The story continues&lt;/h1&gt; &lt;p&gt;There are infinite ways your code can be optimized, I only mentioned the ones I deem most impactful for an average Web app.&lt;/p&gt;&lt;p&gt;Make sure you follow these practices but make sure you don‚Äôt go overboard since the end goal of you as a developer is delivering business value, and not chasing numbers.&lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/3624605720411378312"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/3624605720411378312"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2019/07/ruby-on-rails-optimization-techniques.html" title="Ruby on Rails optimization techniques"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://2.bp.blogspot.com/-SonlsnUrKNA/XRuO7yxMkhI/AAAAAAAA_lo/aQkw6Dq2iRsgWWJVERo8Hu4tZrqvK5GFwCLcBGAs/s72-c/7504631998_393c144631_h.jpg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-9161882836352702880</id><published>2019-04-09T14:02:00.000+04:00</published><updated>2019-04-09T14:04:45.305+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="ActiveJob"/><category scheme="http://www.blogger.com/atom/ns#" term="Databases"/><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby on Rails"/><title type="text">Running ActiveJob after transaction</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-50k9Q7nnCE8/XKxte2or27I/AAAAAAAA7rA/DApLlgRVVMwplmxu6VYzMzW5Ja3q98DtACLcBGAs/s1600/catinabox.jpg.653x0_q80_crop-smart.jpg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://4.bp.blogspot.com/-50k9Q7nnCE8/XKxte2or27I/AAAAAAAA7rA/DApLlgRVVMwplmxu6VYzMzW5Ja3q98DtACLcBGAs/s320/catinabox.jpg.653x0_q80_crop-smart.jpg&quot; width=&quot;320&quot; height=&quot;214&quot; data-original-width=&quot;653&quot; data-original-height=&quot;436&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;h3&gt;Transactions!&lt;/h3&gt; &lt;p&gt;If you know how to cook them they can be a real life saver when it comes to dealing with inconsistent data.&lt;/p&gt; &lt;h3&gt;But...&lt;/h3&gt;&lt;p&gt;&lt;em&gt;There's always a &quot;but&quot;, am I right?&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Unfortunately at some point you add code to your system that has sideeffects outside of your database, and obviously transactions won't help you with that.&lt;/p&gt;&lt;p&gt;One of such things is Active Job (unless it's based on Delayed Job, which stores your jobs in the same database.&lt;/p&gt;&lt;p&gt;Imagine the following scenario:&lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/252166e61f872f112029af330dffd400.js?file=example_1.rb&quot;&gt;&lt;/script&gt; &lt;p&gt;What is wrong here? A lot actually!&lt;/p&gt;&lt;p&gt;First of all the &lt;em&gt;SendSmsJob&lt;/em&gt;. The SMS is sent regardless of whether a charge via &lt;em&gt;ChargeCustomer&lt;/em&gt; succeeds or not. If the charge fails the customer is still going to get the SMS, even though the whole transaction was rolled back. Confusing experience.&lt;/p&gt; &lt;p&gt;Second &lt;em&gt;PrepareForShippingJob&lt;/em&gt; (it could be any other job referencing the order). What happens if the job is executed before the transaction commits? Payment gateways are not the fastest kids on the block, and queues like &lt;em&gt;Sidekiq&lt;/em&gt; are pretty fast. So if the order does exist in one database session, it doesn't exist in the one that your Active Job is executing, so you get an annoying &lt;em&gt;RecordNotFound&lt;/em&gt; error. Yuck!&lt;/p&gt; &lt;h3&gt;Rails magic to the rescue&lt;/h3&gt; &lt;p&gt;Turns out ActiveRecord keeps a list of records which were a part of a transaction and calls &lt;em&gt;committed!&lt;/em&gt; on them. If we inspect &lt;a href=&quot;https://github.com/rails/rails/blob/master/activerecord/lib/active_record/transactions.rb&quot; target=&quot;_blank&quot;&gt;active_record/transactions.rb&lt;/a&gt; we can pretend to be one of those records.&lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/252166e61f872f112029af330dffd400.js?file=commitable.rb&quot;&gt;&lt;/script&gt; &lt;p&gt;Now all that is left is to add ourselves to the list of records in a transaction.&lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/252166e61f872f112029af330dffd400.js?file=after_transaction.rb&quot;&gt;&lt;/script&gt; &lt;p&gt;Let's see how our code is going to change.&lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/252166e61f872f112029af330dffd400.js?file=example_2.rb&quot;&gt;&lt;/script&gt; &lt;p&gt;Not bad, not bad all. With this change if the code is running within a transaction it's going to wait until the transaction is over and then perform actions with uncontrollable side effects.&lt;/p&gt; &lt;p&gt;Having said that, I have to note that this is not a silver bullet. Also the problem described above could be mitigated by restructuring our code. But nevertheless this is a very handy tool to have. Cheers!&lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/9161882836352702880"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/9161882836352702880"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2019/04/running-activejob-after-transaction.html" title="Running ActiveJob after transaction"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://4.bp.blogspot.com/-50k9Q7nnCE8/XKxte2or27I/AAAAAAAA7rA/DApLlgRVVMwplmxu6VYzMzW5Ja3q98DtACLcBGAs/s72-c/catinabox.jpg.653x0_q80_crop-smart.jpg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-2894232320155352758</id><published>2019-04-02T16:38:00.000+04:00</published><updated>2019-05-27T20:12:52.113+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Bash"/><category scheme="http://www.blogger.com/atom/ns#" term="Databases"/><category scheme="http://www.blogger.com/atom/ns#" term="Docker"/><category scheme="http://www.blogger.com/atom/ns#" term="MongoDB"/><title type="text">Importing Compose.IO MongoDB dump into local docker instance </title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-LjQjQCJ7bMA/XKTHuM9jMYI/AAAAAAAA7oQ/bPzynLSjXIMTVtwp-_iXMx1unxhrEwwDgCLcBGAs/s1600/fb60b1deba1d5239ab02d422b0ff3aac_composesocialicon-1.png&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://2.bp.blogspot.com/-LjQjQCJ7bMA/XKTHuM9jMYI/AAAAAAAA7oQ/bPzynLSjXIMTVtwp-_iXMx1unxhrEwwDgCLcBGAs/s320/fb60b1deba1d5239ab02d422b0ff3aac_composesocialicon-1.png&quot; width=&quot;320&quot; height=&quot;315&quot; data-original-width=&quot;273&quot; data-original-height=&quot;269&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;h1&gt;  Importing &lt;a href=&quot;https://www.compose.com/&quot; target=&quot;_blank&quot;&gt;Compose&lt;/a&gt; MongoDB dump into local docker instance  &lt;/h1&gt;Sometimes in order to easily test performance on your local machine or to test data migrations on real data you need to import production database. To make things a bit more complicated we are going to use docker. &lt;em&gt;In general I avoid making such tutorials, but I was surpised to find out there are no tutorials for this particular operation&lt;/em&gt;. &lt;br /&gt;If you inspect what contents of the dump that Compose provides you look like, it's something like that:&lt;br /&gt;&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-29DdbHPNo_o/XKNUsV6y_PI/AAAAAAAA7ns/RJdbzWlVUaMtyHAt7DHJ45qBf-W5p3RsACLcBGAs/s1600/Screenshot%2Bfrom%2B2019-04-02%2B16-24-43.png&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: left; margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; data-original-height=&quot;734&quot; data-original-width=&quot;213&quot; height=&quot;320&quot; src=&quot;https://2.bp.blogspot.com/-29DdbHPNo_o/XKNUsV6y_PI/AAAAAAAA7ns/RJdbzWlVUaMtyHAt7DHJ45qBf-W5p3RsACLcBGAs/s320/Screenshot%2Bfrom%2B2019-04-02%2B16-24-43.png&quot; width=&quot;93&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;&lt;br /&gt;What this folder contains is actually raw database data. So no need for mongorestore and such tools. Also keep in mind that even if your local Mongo uses WiredTiger format, this old format is still going to work.&lt;br /&gt;&lt;br /&gt;&lt;h3&gt;Just show me the code&lt;/h3&gt;&lt;br /&gt;Fine!&lt;br /&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;&lt;br /&gt;# tab 1&lt;br /&gt;# extract the backup&lt;br /&gt;tar -xvf backup.tar -C backup&lt;br /&gt;&lt;br /&gt;# stop running mongo instance&lt;br /&gt;docker-compose stop mongo&lt;br /&gt;&lt;br /&gt;# spin up mongo container and run a bash command in it&lt;br /&gt;docker-compose run mongo /bin/bash&lt;br /&gt;&lt;br /&gt;# executing code inside docker now!&lt;br /&gt;&lt;br /&gt;# Assuming you had /data/db persisted in a mounted volume, let's back I old data in case we screw up:&lt;br /&gt;cp /data/db /data/db_backup&lt;br /&gt;rm /data/db/*&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;Now let's open a new tab an copy backup data into our container:&lt;br /&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;&lt;br /&gt;# adjust container name if it's different&lt;br /&gt;CONTAINER_ID=$(docker ps -qf &quot;name=mongo&quot;)&lt;br /&gt;&lt;br /&gt;# copy backup data into your docker instance&lt;br /&gt;docker cp backup/* $CONTAINER_ID:/data/db&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;Back to the tab #1:&lt;br /&gt;&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;&lt;br /&gt;# tab #1, inside docker&lt;br /&gt;mongo&lt;br /&gt;&lt;br /&gt;# now inside mongo&lt;br /&gt;&lt;br /&gt;# rename database to whatever name you use locally&lt;br /&gt;db.copyDatabase('my_db_production', 'my_db_development')&lt;br /&gt;&lt;br /&gt;use my_db_production&lt;br /&gt;&lt;br /&gt;# drop the db we copied from&lt;br /&gt;db.dropDatabase()&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt; &lt;p&gt;Well, that was it. If you don't find it useful, I sure would be glad I wrote this for my later self. &lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/2894232320155352758"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/2894232320155352758"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2019/04/importing-composeio-mongodb-dump-into.html" title="Importing Compose.IO MongoDB dump into local docker instance "><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://2.bp.blogspot.com/-LjQjQCJ7bMA/XKTHuM9jMYI/AAAAAAAA7oQ/bPzynLSjXIMTVtwp-_iXMx1unxhrEwwDgCLcBGAs/s72-c/fb60b1deba1d5239ab02d422b0ff3aac_composesocialicon-1.png" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-8575187131067087503</id><published>2017-08-21T20:45:00.002+04:00</published><updated>2017-08-22T13:28:59.450+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby on Rails"/><title type="text">Better Ruby serialization into JSON</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-uDkGpVnQObg/WZn7seEI1RI/AAAAAAAAezE/ENuYtOMe1r05mCDwYFy6jWWpVLQ2OCECQCLcBGAs/s1600/rubyjson.png&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-uDkGpVnQObg/WZn7seEI1RI/AAAAAAAAezE/ENuYtOMe1r05mCDwYFy6jWWpVLQ2OCECQCLcBGAs/s320/rubyjson.png&quot; width=&quot;320&quot; height=&quot;320&quot; data-original-width=&quot;650&quot; data-original-height=&quot;650&quot; /&gt;&lt;/a&gt;&lt;/div&gt; &lt;h1&gt;  JsonDumper &lt;/h1&gt; &lt;h3&gt;  Serialize Ruby into JSON. Cleaner. Faster. &lt;/h3&gt; &lt;p&gt;  Rails is at its best when it comes to convention over configuration. Responders gem provides a nice way to serialize ruby objects into json using &lt;code class=&quot;ruby&quot;&gt;Object#as_json&lt;/code&gt;. Unfortunately this style of serialization crumbles when your app needs to present the same resource in different views, to different users with different permissions.   &lt;br&gt;  Of course we have jBuilder. But if you ask me its DSL looks a bit ugly and not intuitive. Also it cannot eager load needed associations so you have to handle this burden yourself. &lt;/p&gt;&lt;p&gt;  In this article I am going to explain how to work with &lt;a href=&quot;https://www.github.com/TheRusskiy/json_dumper&quot; target=&quot;_blank&quot;&gt;JsonDumper&lt;/a&gt; gem which hopefully solves former problems.   &lt;br&gt;  Its main goals are: &lt;/p&gt; &lt;ul&gt;  &lt;li&gt;help serialize Ruby objects and ActiveRecord objects into json&lt;/li&gt;  &lt;li&gt;help organize your code&lt;/li&gt;  &lt;li&gt;solve N+1 query problem&lt;/li&gt;&lt;/ul&gt; &lt;h3&gt;Usage&lt;/h3&gt; &lt;p&gt;  Let's say you want to serialize Human object, which has many Cars.   &lt;br&gt;  First define a class that is going to serialize Human: &lt;/p&gt;&lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;class HumanJson &lt; JsonDumper::Base&lt;br /&gt;  def preview&lt;br /&gt;    {&lt;br /&gt;      id: id,&lt;br /&gt;      first_name: first_name,&lt;br /&gt;      last_name: last_name,&lt;br /&gt;      born_at: created_at.strftime('%m/%d/%Y')&lt;br /&gt;    }&lt;br /&gt;  end&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt;&lt;p&gt;you can call it like that: &lt;/p&gt;&lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;john = Human.create(&lt;br /&gt;  first_name: 'John',&lt;br /&gt;  last_name: 'Doe',&lt;br /&gt;  created_at: 20.years.ago&lt;br /&gt;)&lt;br /&gt;&lt;br /&gt;json = HumanJson.preview(john)&lt;br /&gt;json == {&lt;br /&gt;  id: 1,&lt;br /&gt;  first_name: 'John',&lt;br /&gt;  last_name: 'Doe',&lt;br /&gt;  born_at: '09/19/1997'&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;  Whenever you invoke a method on a JsonDumper::Base instance and it is missing a similar method is invoked on the object you passed to the serializer.   For example in the snippet above a method &lt;code class=&quot;ruby&quot;&gt;id&lt;/code&gt; is going to be called on &lt;code class=&quot;ruby&quot;&gt;john&lt;/code&gt; object. &lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;{&lt;br /&gt;  id: id,&lt;br /&gt;  ...&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;Let's introduce an association into the mix:&lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;class CarJson &lt; JsonDumper::Base&lt;br /&gt;  def preview&lt;br /&gt;    {&lt;br /&gt;      id: id,&lt;br /&gt;      name: name,&lt;br /&gt;    }&lt;br /&gt;  end&lt;br /&gt;end&lt;br /&gt;&lt;br /&gt;class HumanJson &lt; JsonDumper::Base&lt;br /&gt;  # ...&lt;br /&gt;  def details&lt;br /&gt;    preview.merge(&lt;br /&gt;      car: CarJson.preview(car)&lt;br /&gt;    )&lt;br /&gt;  end&lt;br /&gt;end&lt;br /&gt;&lt;br /&gt;ferrari = Car.create(&lt;br /&gt;  name: 'Ferrari',&lt;br /&gt;)&lt;br /&gt;john.car = ferrari&lt;br /&gt;&lt;br /&gt;json = HumanJson.details(john)&lt;br /&gt;json == {&lt;br /&gt;  id: 1,&lt;br /&gt;  first_name: 'John',&lt;br /&gt;  last_name: 'Doe',&lt;br /&gt;  born_at: '09/19/1997',&lt;br /&gt;  car: {&lt;br /&gt;    id: 1,&lt;br /&gt;    name: 'Ferrari'&lt;br /&gt;  }&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;This structure provides a very clean way to specify dependencies for ActiveRecord preloader: &lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;class HumanJson &lt; JsonDumper::Base&lt;br /&gt;  def preview&lt;br /&gt;    # ...&lt;br /&gt;  end&lt;br /&gt;&lt;br /&gt;  def preview_preload&lt;br /&gt;    {}&lt;br /&gt;  end&lt;br /&gt;&lt;br /&gt;  def details&lt;br /&gt;    # ...&lt;br /&gt;  end&lt;br /&gt;&lt;br /&gt;  def details_preload&lt;br /&gt;    preview_preload.merge(car: [])&lt;br /&gt;  end&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt;&lt;p&gt;  Furthermore you can omit defining &lt;code class=&quot;ruby&quot;&gt;preview_preload&lt;/code&gt; because JsonDumper returns empty hashes (&lt;code class=&quot;ruby&quot;&gt;{}&lt;/code&gt;) whenever a method does not exist and its name ends with &lt;code class=&quot;ruby&quot;&gt;_preload&lt;/code&gt;. &lt;br&gt; You can utilize it in the following way: &lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;preloader = ActiveRecord::Base::Preloader.new&lt;br /&gt;preloader.preload(john, HumanJson.details_preload)&lt;br /&gt;json = HumanJson.details(john)&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;  Another cool feature that you can now do is to do both preloading and serialization in a single command via &lt;code class=&quot;ruby&quot;&gt;fetch_METHOD_NAME&lt;/code&gt;. This creates a special JsonDumper::Delayed object which delays its execution until it's time to render. This allows to do preloading at render time. &lt;br&gt;  Since this is a common operation you can include &lt;code class=&quot;ruby&quot;&gt;JsonDumper::Base&lt;/code&gt; in your controller. &lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;class HumansController &lt; ActionController::Base&lt;br /&gt;  include JsonDumper::Helper&lt;br /&gt;&lt;br /&gt;  def show&lt;br /&gt;    human = Human.find(params[:id])&lt;br /&gt;    json = dumper_json(&lt;br /&gt;      my_human: HumanJson.fetch_details(human)&lt;br /&gt;    )&lt;br /&gt;    render json: json&lt;br /&gt;  end&lt;br /&gt;&lt;br /&gt;  # OR&lt;br /&gt;&lt;br /&gt;  def show&lt;br /&gt;    human = Human.find(params[:id])&lt;br /&gt;    render_dumper_json(&lt;br /&gt;      my_human: HumanJson.fetch_details(human)&lt;br /&gt;    )&lt;br /&gt;  end&lt;br /&gt;end&lt;br /&gt;&lt;br /&gt;# going to render:&lt;br /&gt;{&lt;br /&gt;  myHuman: {&lt;br /&gt;    id: 1,&lt;br /&gt;    firstName: 'John',&lt;br /&gt;    lastName: 'Doe',&lt;br /&gt;    bornAt: '09/19/1997',&lt;br /&gt;    car: {&lt;br /&gt;      id: 1,&lt;br /&gt;      name: 'Ferrari'&lt;br /&gt;    }&lt;br /&gt;  }&lt;br /&gt;}&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt;&lt;p&gt;  Take a note that &lt;code class=&quot;ruby&quot;&gt;dumper_json&lt;/code&gt; also camelizes your keys. &lt;/p&gt; &lt;h3&gt;Usage with &lt;a href=&quot;https://github.com/gazay/gon&quot; target=&quot;_blank&quot;&gt;Gon&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;  This gem also provides a seamless integration with Gon gem.   &lt;br&gt;  The above example could be rewritten in the following way: &lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;class HumansController &lt; ActionController::Base&lt;br /&gt;  def show&lt;br /&gt;    human = Human.find(params[:id])&lt;br /&gt;    gon.my_human = HumanJson.fetch_details(human)&lt;br /&gt;  end&lt;br /&gt;end&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;  Later in your javascript: &lt;/p&gt; &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;ruby&quot;&gt;&lt;br /&gt;console.log(gon.myHuman);&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;If you have any questions / suggestions feel free to contact me. &lt;br&gt;Full code of JsonDumper can be found &lt;a href=&quot;https://www.github.com/TheRusskiy/json_dumper&quot; target=&quot;_blank&quot;&gt;here&lt;/a&gt;. &lt;/p&gt;  </content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/8575187131067087503"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/8575187131067087503"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2017/08/better-ruby-serialization-into-json.html" title="Better Ruby serialization into JSON"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-uDkGpVnQObg/WZn7seEI1RI/AAAAAAAAezE/ENuYtOMe1r05mCDwYFy6jWWpVLQ2OCECQCLcBGAs/s72-c/rubyjson.png" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-525902878065065241</id><published>2016-12-07T21:22:00.000+04:00</published><updated>2016-12-07T21:23:09.336+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby on Rails"/><title type="text">List all Rails helper methods</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://1.bp.blogspot.com/-4FuFbvkm3tI/WEhFMvRrXxI/AAAAAAAAVvM/bcKDqD_iqAUspFA8jzHbhbfzCkRy4ldsgCLcB/s1600/helper_banner.jpg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://1.bp.blogspot.com/-4FuFbvkm3tI/WEhFMvRrXxI/AAAAAAAAVvM/bcKDqD_iqAUspFA8jzHbhbfzCkRy4ldsgCLcB/s320/helper_banner.jpg&quot; width=&quot;320&quot; height=&quot;130&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;p&gt;Just wanted to share a snippet of code to get all Rails helper methods: &lt;/p&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/26a2552148d3cd2a798555081cab5a62.js?file=list_helper_methods.rb&quot;&gt;&lt;/script&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/525902878065065241"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/525902878065065241"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2016/12/list-all-rails-helper-methods.html" title="List all Rails helper methods"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://1.bp.blogspot.com/-4FuFbvkm3tI/WEhFMvRrXxI/AAAAAAAAVvM/bcKDqD_iqAUspFA8jzHbhbfzCkRy4ldsgCLcB/s72-c/helper_banner.jpg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-774785144060732817</id><published>2016-10-08T23:53:00.000+04:00</published><updated>2016-10-08T23:53:11.870+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Javascript"/><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><category scheme="http://www.blogger.com/atom/ns#" term="Pusher"/><category scheme="http://www.blogger.com/atom/ns#" term="React"/><category scheme="http://www.blogger.com/atom/ns#" term="Redux"/><title type="text">Pusher with Redux</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://2.bp.blogspot.com/-lpKlIZZxGTM/V_lOku3WpNI/AAAAAAAAUxs/syGR-15eU_gCe9w2W03did9LFEQHiYbTACLcB/s1600/pusher-logo.jpg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://2.bp.blogspot.com/-lpKlIZZxGTM/V_lOku3WpNI/AAAAAAAAUxs/syGR-15eU_gCe9w2W03did9LFEQHiYbTACLcB/s320/pusher-logo.jpg&quot; width=&quot;320&quot; height=&quot;147&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;p&gt;You might have heard about a wonderful service called &lt;a href=&quot;https://pusher.com/&quot; target=&quot;_blank&quot;&gt;Pusher&lt;/a&gt;. It is a service which allows you to make live updates without handling infrastructure on your own. &lt;/p&gt;&lt;p&gt;When I wanted to add it into my React - Redux application I was surprised to find out that there are no libraries which help you. So I decided to write my own. I called it  &lt;a href=&quot;https://github.com/TheRusskiy/pusher-redux&quot; target=&quot;_blank&quot;&gt;pusher-redux&lt;/a&gt;. &lt;/p&gt;&lt;p&gt;I think it turned out to have a very convenient API you can call anywhere from your Redux application. Let me explain how to use it below. &lt;/p&gt; &lt;p&gt;First you need to configure Pusher in your app.js: &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/48e877e20b969cbf4ee107df3b2d98f4.js?file=app.js&quot;&gt;&lt;/script&gt; &lt;p&gt;Then you need to subscribe to it in your component: &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/48e877e20b969cbf4ee107df3b2d98f4.js?file=page.js&quot;&gt;&lt;/script&gt; &lt;p&gt;This is how you handle it in your reducer &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/48e877e20b969cbf4ee107df3b2d98f4.js?file=reducer.js&quot;&gt;&lt;/script&gt; &lt;p&gt;Pusher-redux dispatches actions of the following format, you can find data you send in action.data: &lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/48e877e20b969cbf4ee107df3b2d98f4.js?file=action_format.js&quot;&gt;&lt;/script&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/774785144060732817"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/774785144060732817"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2016/10/pusher-with-redux.html" title="Pusher with Redux"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://2.bp.blogspot.com/-lpKlIZZxGTM/V_lOku3WpNI/AAAAAAAAUxs/syGR-15eU_gCe9w2W03did9LFEQHiYbTACLcB/s72-c/pusher-logo.jpg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-5649373347466225189</id><published>2016-10-08T23:48:00.000+04:00</published><updated>2016-10-09T04:02:55.549+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby on Rails"/><title type="text">Smart page titles in Ruby on Rails</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-UDXzxGxAxoc/V_AZt0zxa4I/AAAAAAAAUhs/8zfdqhbyH18Fti4kiqwvi7pjKakE_JXDACLcB/s1600/stock-photo--d-rendering-of-blank-signs-pointing-in-opposite-directions-89593438.jpg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://4.bp.blogspot.com/-UDXzxGxAxoc/V_AZt0zxa4I/AAAAAAAAUhs/8zfdqhbyH18Fti4kiqwvi7pjKakE_JXDACLcB/s320/stock-photo--d-rendering-of-blank-signs-pointing-in-opposite-directions-89593438.jpg&quot; width=&quot;300&quot; height=&quot;280&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;p&gt;Having separate titles for each page in Rails application is a very common requirement and yet RoR does not provide any built in ways to deal with it. I am going to present you with some handy code that can solve this problem without use of gems.&lt;/p&gt;&lt;p&gt;There are going to be 3 ways to define a page title: &lt;ul&gt; &lt;li&gt;For tho whole controller.&lt;/li&gt; &lt;li&gt;For a specific action inside a controller.&lt;/li&gt; &lt;li&gt;Implicitly from a controller name.&lt;/li&gt;&lt;/ul&gt;Last is gonna be especially useful, you can just drop the following code into your application and have reasonably good titles. &lt;/p&gt; &lt;p&gt;So lets add code to our parent ApplicationController:&lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/1a3949b55fdb3a82c5c007ec1273c612.js?file=application_controller.rb&quot;&gt;&lt;/script&gt; &lt;p&gt;And reference page title in our layout:&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/1a3949b55fdb3a82c5c007ec1273c612.js?file=application_layout.html.erb&quot;&gt;&lt;/script&gt; &lt;p&gt;After that setting pages titles is extremely easy. You don't even have to do it if you are naming your controllers properly.&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/1a3949b55fdb3a82c5c007ec1273c612.js?file=orders_controller.rb&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/1a3949b55fdb3a82c5c007ec1273c612.js?file=order_notes_controller.rb&quot;&gt;&lt;/script&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/5649373347466225189"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/5649373347466225189"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2016/10/smart-page-titles-in-ruby-on-rails.html" title="Smart page titles in Ruby on Rails"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://4.bp.blogspot.com/-UDXzxGxAxoc/V_AZt0zxa4I/AAAAAAAAUhs/8zfdqhbyH18Fti4kiqwvi7pjKakE_JXDACLcB/s72-c/stock-photo--d-rendering-of-blank-signs-pointing-in-opposite-directions-89593438.jpg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-9088801773643462724</id><published>2016-09-30T07:29:00.000+04:00</published><updated>2016-10-08T23:36:41.469+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="DNS"/><category scheme="http://www.blogger.com/atom/ns#" term="Go"/><category scheme="http://www.blogger.com/atom/ns#" term="Security"/><title type="text">DNS over HTTPS</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://4.bp.blogspot.com/-UuKo_3D6rOA/V-3atvIlWSI/AAAAAAAAUg0/MbSp5ccsA7czQnuyvPMLwZnuRDdfdaILwCLcB/s1600/bender.jpg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://4.bp.blogspot.com/-UuKo_3D6rOA/V-3atvIlWSI/AAAAAAAAUg0/MbSp5ccsA7czQnuyvPMLwZnuRDdfdaILwCLcB/s320/bender.jpg&quot; width=&quot;320&quot; height=&quot;320&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;p&gt; In the land of Russia where your freedom is becoming ever more limited goverment is trying to censor the Internet. Those who are not content with website bans have to find ways how to get around this problem. One way to get around the block is to use Google's DNS instead of the DNS provided by your ISP. After reading Hacker News today I stumbled on an intersting arcticle. The gist is that Google provides an encrypted way to access DNS (unlike traditional UDP which can be easily monitored by your ISP). &lt;/p&gt; &lt;p&gt;Unfortunately there's no way to just point your router or computer to it because DNS has a protocol and since Google secure DNS doesn't conform to it existing programs can't access it directly. So in this article we are going to set up our own DNS server, and yes, it can have blackjack and promiscuous women.&lt;/p&gt; &lt;p&gt; Some kind soul has written a Go package to interact with this secure DNS server. It is located here: https://github.com/wrouesnel/dns-over-https-proxy .  We are going to need Go language in order to run that package. Details of how to install and run Go are outside of this article but you can refer to this page https://golang.org/doc/install . &lt;/p&gt; &lt;p&gt;After package was downloaded you need to execute is using the following command (we add debug there to see output):&lt;/p&gt; &lt;pre&gt;&lt;br /&gt; &lt;code class=&quot;bash&quot;&gt;&lt;br /&gt;sudo ./bin/dns-over-https-proxy -debug=true -address=127.0.0.1:53 -log.level=debug&lt;br /&gt; &lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;In order to test if it's working we need to go into OS network settings and add DNS servers there. We can't do it via router because ISP often adds their own DNS and not all routers have options to ignore it. &lt;/p&gt; &lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;https://3.bp.blogspot.com/-6w3fcFTp6FE/V-3b3EpUbDI/AAAAAAAAUg8/HCzkZpTh6AIb9wbKIXpUKtjXi0XZ_WKvwCLcB/s1600/Screen%2BShot%2B2016-09-30%2Bat%2B06.56.31.png&quot; imageanchor=&quot;1&quot; style=&quot;margin-left: 1em; margin-right: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://3.bp.blogspot.com/-6w3fcFTp6FE/V-3b3EpUbDI/AAAAAAAAUg8/HCzkZpTh6AIb9wbKIXpUKtjXi0XZ_WKvwCLcB/s320/Screen%2BShot%2B2016-09-30%2Bat%2B06.56.31.png&quot; width=&quot;320&quot; height=&quot;263&quot; /&gt;&lt;/a&gt;&lt;/div&gt; &lt;p&gt;There's one more issue. The go script which is running DNS uses a domain name itself. Go to your /etc/hosts file and add the following line:&lt;/p&gt; &lt;pre&gt;&lt;br /&gt; &lt;code class=&quot;bash&quot;&gt;&lt;br /&gt;8.8.4.4 dns.google.com&lt;br /&gt; &lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;We can check if it's working or not by executing the following command&lt;/p&gt;&lt;pre&gt;&lt;br /&gt; &lt;code class=&quot;bash&quot;&gt;&lt;br /&gt;dig -p 53 @127.0.0.1 google.com&lt;br /&gt; &lt;/code&gt;&lt;br /&gt;&lt;/pre&gt; &lt;p&gt;Now unfortunately some resources are not just banned by DNS but also by IP. For those you will have to use a proxy in addition to DNS. I highly recommend FoxyProxy browser plugin. Also make sure to connect via HTTPS to these websites otherwise your ISP will be able to inspect the information you are sending to your proxy and will still be able to stop your requests.&lt;/p&gt; &lt;p&gt;P.s. original article by Google: https://developers.google.com/speed/public-dns/docs/dns-over-https&lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/9088801773643462724"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/9088801773643462724"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2016/09/dns-over-https.html" title="DNS over HTTPS"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://4.bp.blogspot.com/-UuKo_3D6rOA/V-3atvIlWSI/AAAAAAAAUg0/MbSp5ccsA7czQnuyvPMLwZnuRDdfdaILwCLcB/s72-c/bender.jpg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-4873240673885843246</id><published>2016-01-07T22:21:00.000+04:00</published><updated>2019-07-02T19:58:21.670+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby on Rails"/><title type="text">Easy error handling in Rails</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://3.bp.blogspot.com/-qzJG-vLGUAo/Vo6sbP7_RtI/AAAAAAAAHxk/0Bk-4Y0sykk/s1600/exceptions.jpg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;https://3.bp.blogspot.com/-qzJG-vLGUAo/Vo6sbP7_RtI/AAAAAAAAHxk/0Bk-4Y0sykk/s320/exceptions.jpg&quot; /&gt;&lt;/a&gt;&lt;/div&gt;  &lt;p&gt; Let me start by asking what do you think about errors? Many people hate errors and are trying to avoid them as much as possible. &lt;/p&gt; &lt;p&gt; But today I want to show how errors can make your life easier! &lt;/p&gt; &lt;p&gt;   Let's say user submitted some form in your application. Where do you check if it's valid? In the controller? Controller's should not be concerned with all that is going on in our models. Should the controller ask a model if data is valid or not? Model should be already checking incoming data.What is you introduce some change deep inside your code, you can't expect to know all the place where it's used! &lt;/p&gt; &lt;p&gt; In Java World (and in others) errors are not actually called &quot;errors&quot;, they are called &quot;exceptions&quot; and they can help you to handle exceptional situations. Ruby language has similar exception system. Errors can be raised and rescued. &lt;/p&gt; &lt;p&gt; Let's distinguish between 2 types or errors. 1) Ones that we can actually anticipate and fix. 2) All those bug induced errors, memory errors etc. &lt;/p&gt; &lt;p&gt; First type of error can be fixed by users. Second usually can only be fixed by programmers. &lt;/p&gt; &lt;p&gt; So where should we handle exceptions? Many agree that the most suitable is at system boundaries. We are going to handle it in UI. &lt;/p&gt; &lt;p&gt; First of all, let's define our new class that can be handled. &lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/0689762fa6de2418c58b.js?file=user_error.rb&quot;&gt;&lt;/script&gt; &lt;p&gt; Second, let's think how we would like our code to look. &lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/0689762fa6de2418c58b.js?file=usage.rb&quot;&gt;&lt;/script&gt; &lt;p&gt; Now let's place this method into application controller. &lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/0689762fa6de2418c58b.js?file=handle_exceptions_1.rb&quot;&gt;&lt;/script&gt; &lt;p&gt; And make it handle optional redirect path. &lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/0689762fa6de2418c58b.js?file=handle_exceptions_2.rb&quot;&gt;&lt;/script&gt; &lt;p&gt; Let's see how javascript code may look like (jQuery example) &lt;/p&gt; &lt;script src=&quot;https://gist.github.com/TheRusskiy/0689762fa6de2418c58b.js?file=ajax.js&quot;&gt;&lt;/script&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/4873240673885843246"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/4873240673885843246"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2016/01/easy-error-handling-in-rails.html" title="Easy error handling in Rails"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://3.bp.blogspot.com/-qzJG-vLGUAo/Vo6sbP7_RtI/AAAAAAAAHxk/0Bk-4Y0sykk/s72-c/exceptions.jpg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-7639588108807992266</id><published>2015-08-24T01:36:00.000+04:00</published><updated>2016-10-08T23:38:43.971+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Ruby"/><title type="text">Subscribing to your VK friends Instagram</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://3.bp.blogspot.com/--8hdD67gCns/VdpCecvqsKI/AAAAAAAAFJk/j3aaanzP6HI/s1600/insta.jpeg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/--8hdD67gCns/VdpCecvqsKI/AAAAAAAAFJk/j3aaanzP6HI/s320/insta.jpeg&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;h3&gt;Story&lt;/h3&gt;&lt;p&gt;So I decided to create an Instagram account. There you can do 2 things: post photos and watch photos of others. While I do not have an answer for you what to post (you may photograph your food or big abs in a mirror), I do have one on whom to follow. Probably if you are Russian like me you have a VK account and chances are your friends have linked Instagram on their pages. I have 300+ friends so you can see why programmer in me decided to automate this process.&lt;/p&gt; &lt;h3&gt;Technical&lt;/h3&gt;&lt;p&gt;There isn't much to it, we need a headless browser and a pretty straightforward Ruby script. Code can be found on Github, just open my &lt;a href=&quot;https://github.com/TheRusskiy/vk_to_instagram&quot;&gt;vk_to_instagram&lt;/a&gt; repository.&lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/7639588108807992266"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/7639588108807992266"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2015/08/subscribing-to-your-vk-friends-instagram.html" title="Subscribing to your VK friends Instagram"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://3.bp.blogspot.com/--8hdD67gCns/VdpCecvqsKI/AAAAAAAAFJk/j3aaanzP6HI/s72-c/insta.jpeg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-1114622316875348126</id><published>2015-06-21T05:01:00.001+04:00</published><updated>2016-10-08T23:38:59.468+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Books"/><category scheme="http://www.blogger.com/atom/ns#" term="Networks"/><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><title type="text">High Performance Browser Networking - Book Review</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://3.bp.blogspot.com/-8M2krMFGhcY/VYYJm5zk4xI/AAAAAAAAD1Q/eZkf0UhZUO4/s1600/hpbncover.jpg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-8M2krMFGhcY/VYYJm5zk4xI/AAAAAAAAD1Q/eZkf0UhZUO4/s320/hpbncover.jpg&quot; /&gt;&lt;/a&gt;&lt;/div&gt; &lt;p&gt;I will try to make it concise and give my personal opinion.  &lt;ul&gt;  &lt;li&gt;Author: Ilya Grigorik, a Web performance engineer at Google&lt;/li&gt;  &lt;li&gt;Pages: 408&lt;/li&gt;  &lt;li&gt;Published: September 2013&lt;/li&gt;  &lt;li&gt;&lt;a href=&quot;http://www.amazon.com/High-Performance-Browser-Networking-performance/dp/1449344763&quot;&gt;Amazon rating: 4.6/5&lt;/a&gt;&lt;/li&gt;  &lt;li&gt;My rating: 4.1/5&lt;/li&gt; &lt;/ul&gt;&lt;/p&gt;&lt;p&gt; This piece of writing has many levels to it. Ilya goes over all the building blocks which play part in Web performance. He briefly describes work mechanisms for each block and then based on acquired knowledge shows how to squeeze as much as possible out of it. &lt;/p&gt;&lt;p&gt; The fact that Ilya goes all the way from TCP / Mobile network work principles to Javascript API is both an upside and a downside. Many Web developers don't care about such level of detail and are only worried about steps they can do at the top of the stack, not server side TCP tweaks and peculiarities of different Mobile networks.  &lt;/p&gt;&lt;p&gt; Nevertheless, if you are like me and you prefer deeper knowledge I advise you to read the whole book. If what interests you is only the top of the stack and you have few coins to spare then go ahead and read just the latter part of the book. I guarantee that you can find of lot of juicy revelations in there. &lt;/p&gt; &lt;div&gt;&lt;h3&gt;Brief summary of book contents:&lt;/h3&gt;&lt;p&gt; &lt;b&gt;1. Effects of latency and bandwidth&lt;/b&gt; &lt;br&gt; While bandwidth keeps increasing and all ISPs advertise it latency for the most part remains unchanged and it is latency that is often a speed bottleneck. &lt;/p&gt; &lt;p&gt; &lt;b&gt;2. TCP&lt;/b&gt; &lt;br&gt; Describes basics of TCP and how we can tweak our servers to provide best performance &lt;/p&gt; &lt;p&gt; &lt;b&gt;3. UDP&lt;/b&gt; &lt;br&gt; Tells about UDP and when we should use it over TCP.  &lt;br&gt; Also covers STUN, TURN and ICE, techniques allowing to establish a connection between 2 peers even if they are behind NAT. &lt;/p&gt; &lt;p&gt; &lt;b&gt;4. TLS&lt;/b&gt; &lt;br&gt; History, basic principals and performance implications of using a secure connection. &lt;/p&gt; &lt;p&gt; &lt;b&gt;5. Wireless networks&lt;/b&gt; &lt;br&gt; Intro to wireless networks &lt;/p&gt; &lt;p&gt; &lt;b&gt;6. WiFi&lt;/b&gt; &lt;br&gt; Performance characteristics of WiFi connections &lt;/p&gt; &lt;p&gt; &lt;b&gt;7. Mobile Networks&lt;/b&gt; &lt;br&gt; History, all the different types of mobile connections and their performance.  &lt;/p&gt; &lt;p&gt; &lt;b&gt;8. Optimizing for Mobile Networks&lt;/b&gt; &lt;br&gt; Being energy efficient for mobile networks is perhaps as important as being fast.  &lt;br&gt; Keep update checks and uploads to a minimum. Batch your uploads. Make your application work well both with good and bad networks. &lt;/p&gt; &lt;p&gt; &lt;b&gt;9. HTTP history&lt;/b&gt; &lt;br&gt; Well... HTTP history &lt;/p&gt; &lt;p&gt; &lt;b&gt;10. Primer on Web Performance&lt;/b&gt; &lt;br&gt; Human perception of speed. How browsers render pages. Different optimizations browser does to make loading process faster. The way we can give tips to a browser on what resources to load. &lt;/p&gt; &lt;p&gt; &lt;b&gt;11. HTTP 1.x&lt;/b&gt; &lt;br&gt; Principles of HTTP 1.x. Protocol imperfections and the way Web developers overcome them (optimizations). &lt;/p&gt; &lt;p&gt; &lt;b&gt;12. HTTP 2.0&lt;/b&gt; &lt;br&gt; Principles of HTTP 2.0. HTTP 2.0 usages in the wild (or more precisely usage of SPDY). &lt;/p&gt; &lt;p&gt; &lt;b&gt;13. Optimizing Application Delivery&lt;/b&gt; &lt;br&gt; Universal optimization tips (apply to all protocols)  &lt;br&gt; Optimizing for HTTP 2.0. Making applications work with both HTTP 2.0 and HTTP 1.x clients. &lt;/p&gt; &lt;p&gt; &lt;b&gt;14. Primer on Browser Networking&lt;/b&gt; &lt;br&gt; Building blocks of a browser &lt;/p&gt; &lt;p&gt; &lt;b&gt;15. XMLHttpRequest&lt;/b&gt; &lt;br&gt; History, use cases, performance, limitations &lt;/p&gt; &lt;p&gt; &lt;b&gt;16. Server Sent Events&lt;/b&gt; &lt;br&gt; SSE API, use cases and performance &lt;/p&gt; &lt;p&gt; &lt;b&gt;17. WebSocket&lt;/b&gt; &lt;br&gt; WebSocket API, use cases and performance.  &lt;br&gt; What makes WebSocket different from other transports and it's flexibility &lt;/p&gt; &lt;p&gt; &lt;b&gt;18. WebRTC&lt;/b&gt; &lt;br&gt; Use cases, work principles, API, possible complications. Delivery audio/video + custom data over WebRTC. &lt;/p&gt;&lt;/div&gt; &lt;p&gt;&lt;em&gt;Not sure how useful it is, quickly wrote it at 4 AM :-)&lt;/em&gt;&lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/1114622316875348126"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/1114622316875348126"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2015/06/high-performance-browser-networking.html" title="High Performance Browser Networking - Book Review"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://3.bp.blogspot.com/-8M2krMFGhcY/VYYJm5zk4xI/AAAAAAAAD1Q/eZkf0UhZUO4/s72-c/hpbncover.jpg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-7332154005964656035</id><published>2015-03-01T22:50:00.001+04:00</published><updated>2016-10-08T23:39:09.817+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Databases"/><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><category scheme="http://www.blogger.com/atom/ns#" term="Ruby on Rails"/><title type="text">Seamless ActiveRecord Model extension</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://3.bp.blogspot.com/-GPAuJ7K9Zms/VPNeDASB6rI/AAAAAAAADHo/zWQIABhRjnA/s1600/link-icon.jpg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://3.bp.blogspot.com/-GPAuJ7K9Zms/VPNeDASB6rI/AAAAAAAADHo/zWQIABhRjnA/s200/link-icon.jpg&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;h3&gt;The Problem&lt;/h3&gt;&lt;p&gt;What if you have one very bloated model, like User, that has a ton of fields you use only once or twice in your whole application and yet paying price for it every time you fetch / create a new one.&lt;/p&gt;&lt;p&gt;In this case what you want is to move some of these fields to another model (e.g. profile or user details).&lt;/p&gt; &lt;h3&gt;The Solution&lt;/h3&gt;&lt;p&gt;First step is to generate another model, let's name it UserProfile and link it to User model.&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/49a4e5086944286cd5cf.js?file=user_and_profile.rb&quot;&gt;&lt;/script&gt;&lt;p&gt;You would also have to run a migration that adds UserProfile to all existing users. Now what you can do is to write something like:&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/49a4e5086944286cd5cf.js?file=example1.rb&quot;&gt;&lt;/script&gt;&lt;p&gt;Now, of course, we could stop there, but why miss all the fun? What we want to do instead is:&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/49a4e5086944286cd5cf.js?file=example2.rb&quot;&gt;&lt;/script&gt;&lt;p&gt;So how do we do that?&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/49a4e5086944286cd5cf.js?file=implemenation.rb&quot;&gt;&lt;/script&gt; &lt;h3&gt;Performance&lt;/h3&gt;&lt;p&gt;When I measured how speed and memory footprint correspond to number of columns I found that both increase roughly linear as number of columns grows.&lt;/p&gt;&lt;h3&gt;Precautions&lt;/h3&gt;&lt;p&gt;When mass-assigning attributes from controller while using CanCan gem (tested in Rails 3.2), e.g. (User.new(params[:user])), CanCan tries to be smart and in &quot;load_and_authorize_resource&quot; tries to clean up all the unknown attributes from params[:user]. Solution is to set @user instance variable before &quot;load_and_authorize_resource&quot; is called.&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/49a4e5086944286cd5cf.js?file=cancan.rb&quot;&gt;&lt;/script&gt;&lt;p&gt;p.s. in retrospective that blog post has a very ambiguous title, but that's the best I could come up with.&lt;/p&gt;&lt;p&gt;p.p.s. Happy Spring everyone!&lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/7332154005964656035"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/7332154005964656035"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2015/03/seamless-activerecord-model-extension.html" title="Seamless ActiveRecord Model extension"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://3.bp.blogspot.com/-GPAuJ7K9Zms/VPNeDASB6rI/AAAAAAAADHo/zWQIABhRjnA/s72-c/link-icon.jpg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-2384090867566963810</id><published>2015-01-19T04:02:00.000+04:00</published><updated>2016-10-08T23:39:26.498+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Angular"/><category scheme="http://www.blogger.com/atom/ns#" term="Javascript"/><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><title type="text">Parsing HTML generated outside of Angular</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://2.bp.blogspot.com/-Wkk6ws30CYk/VLxJDyGffWI/AAAAAAAADCk/DxitBuPrT20/s1600/AngularJS_thumb_1008B166%5B1%5D.jpg&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://2.bp.blogspot.com/-Wkk6ws30CYk/VLxJDyGffWI/AAAAAAAADCk/DxitBuPrT20/s320/AngularJS_thumb_1008B166%5B1%5D.jpg&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;p&gt;It often happens that you have to work on some old project using jQuery. But in modern Web Development jQuery just doesn't cut it. So you write new features in Angular. But sometimes you have to modify existing code.&lt;/p&gt;&lt;p&gt;It's not a problem as long as HTML is static, but if it's generated on server side Rails+jQuery style, then Angular won't know anything about it when it arrives to a browser.&lt;/p&gt;&lt;p&gt;So we have make Angular parse this HTML. I remember a long time ago when I first encountered that problem I googled quite a lot but came up empty handed. So I had to find a way myself. Recently my colleagues stumbled on the same problem so I decided to share this little piece of code on the internets.&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/ffd658167125969ae5dd.js&quot;&gt;&lt;/script&gt;&lt;p&gt;Well... That's pretty much it. You shouldn't try running your angular app again. It's going to create a separate application.&lt;/p&gt;&lt;p&gt;Also I want to share an interesting gotcha. If you inline your angular templates with &lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;html&quot;&gt;&lt;br /&gt;&amp;lt;script type=&amp;quot;text/ng-template&amp;quot; id=&amp;quot;the-template&amp;quot; &amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt;and they are in dynamically generated HTML you have parse this HTML. Strangely enough Angular doesn't use selectors to get this template. Rather it puts this template into template cache when encounters it during parsing.&lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/2384090867566963810"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/2384090867566963810"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2015/01/parsing-html-generated-outside-of.html" title="Parsing HTML generated outside of Angular"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://2.bp.blogspot.com/-Wkk6ws30CYk/VLxJDyGffWI/AAAAAAAADCk/DxitBuPrT20/s72-c/AngularJS_thumb_1008B166%5B1%5D.jpg" height="72" width="72"/></entry><entry><id>tag:blogger.com,1999:blog-636187583995536423.post-8006412922375735444</id><published>2014-08-02T22:55:00.001+04:00</published><updated>2016-10-08T23:39:35.993+04:00</updated><category scheme="http://www.blogger.com/atom/ns#" term="Angular"/><category scheme="http://www.blogger.com/atom/ns#" term="Javascript"/><category scheme="http://www.blogger.com/atom/ns#" term="Programming"/><title type="text">AngularJS directive for slide-down animation with lazy rendering</title><content type="html">&lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;a href=&quot;http://1.bp.blogspot.com/-a7WcZ0cPYTw/U9XkjTDCDtI/AAAAAAAACgY/4adxtnOHHeA/s320/out_14-56.gif&quot; imageanchor=&quot;1&quot; style=&quot;clear: right; float: right; margin-bottom: 1em; margin-left: 1em;&quot;&gt;&lt;img border=&quot;0&quot; src=&quot;http://1.bp.blogspot.com/-a7WcZ0cPYTw/U9XkjTDCDtI/AAAAAAAACgY/4adxtnOHHeA/s320/out_14-56.gif&quot; /&gt;&lt;/a&gt;&lt;/div&gt;&lt;p&gt;AngularJS directive for slide-down animation with lazy rendering&lt;/p&gt;&lt;p&gt;In this blog post I am going to talk about a directive I created earlier that is available in my &lt;a href=&quot;https://github.com/TheRusskiy/ng-slide-down&quot;&gt;ng-slide-down&lt;/a&gt; Github repository.&lt;/p&gt;&lt;p&gt;In the company I am working for we have a lot of widgets that are expanded via jQuery &quot;slideToggle&quot; function, thus when I make new components I have to adhere to existing style. As you have probably guessed new parts are written in Angular.&lt;/p&gt;&lt;p&gt;Another requirement I had to satisfy is that we can have a lot of these widgets on a single and rendering them all in Angular would be wildly inefficient, so it had to only render HTML if widget was expanded.&lt;/p&gt;&lt;p&gt;In order to use resulting directive all you need to is to add a directive &lt;i&gt;ng-slide-down&lt;/i&gt; to your HTML element and pass a variable that is going to control it:&lt;/p&gt;&lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;html&quot;&gt;&lt;br /&gt;&amp;lt;div ng-slide-down=&amp;quot;slideDown&amp;quot;&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt;&lt;h3&gt;Code&lt;/h3&gt;&lt;p&gt;So let's start writing the code (&lt;a href=&quot;http://jsfiddle.net/therusskiy/JR3C7/4/&quot;&gt;fiddle&lt;/a&gt;).&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/c909dc15cc63576d55a0.js?file=ng-slide-down0.coffee&quot;&gt;&lt;/script&gt;&lt;/br&gt;&lt;h3&gt;Lazy rendering&lt;/h3&gt;&lt;p&gt;In the next step we are going to add an option to stop angular from rendering HTML unless element is expanded&lt;/p&gt;&lt;pre&gt;&lt;br /&gt;&lt;code class=&quot;html&quot;&gt;&lt;br /&gt;&amp;lt;div ng-slide-down=&amp;quot;slideDown&amp;quot; lazy-render&amp;gt;&lt;br /&gt;&lt;/code&gt;&lt;br /&gt;&lt;/pre&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/c909dc15cc63576d55a0.js?file=ng-slide-down1.coffee&quot;&gt;&lt;/script&gt;&lt;/br&gt;&lt;h3&gt;Final steps&lt;/h3&gt;&lt;p&gt;Now we need to take care of a few extra details. Like, for example, what should we do if user closes widget before it's been fully expanded? In this case we should cancel promise. Another case we need to take care of is change in children's height. Final code looks as following&lt;/p&gt;&lt;script src=&quot;https://gist.github.com/TheRusskiy/c909dc15cc63576d55a0.js?file=ng-slide-down2.coffee&quot;&gt;&lt;/script&gt; &lt;p&gt;P.S.&lt;/p&gt;&lt;p&gt;Make sure to update your Angular JS because older versions contain &lt;a href=&quot;https://github.com/angular/angular.js/pull/7499&quot;&gt;bug (fixed)&lt;/a&gt; in the way ng-transclude and ng-if directives interact.&lt;/p&gt;&lt;p&gt;Be careful in general when you are using &lt;i&gt;ng-if&lt;/i&gt; because it creates new scope.&lt;/p&gt;</content><link rel="edit" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/8006412922375735444"><link rel="self" type="application/atom+xml" href="https://www.blogger.com/feeds/636187583995536423/posts/default/8006412922375735444"><link rel="alternate" type="text/html" href="https://www.dmitry-ishkov.com/2014/08/angularjs-directive-for-slide-down.html" title="AngularJS directive for slide-down animation with lazy rendering"><author><name>Dmitry Ishkov</name><uri>http://www.blogger.com/profile/01039072079704189792</uri><email>noreply@blogger.com</email><gd:image rel="http://schemas.google.com/g/2005#thumbnail" width="16" height="16" src="https://img1.blogblog.com/img/b16-rounded.gif"/></author><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://1.bp.blogspot.com/-a7WcZ0cPYTw/U9XkjTDCDtI/AAAAAAAACgY/4adxtnOHHeA/s72-c/out_14-56.gif" height="72" width="72"/></entry></feed>