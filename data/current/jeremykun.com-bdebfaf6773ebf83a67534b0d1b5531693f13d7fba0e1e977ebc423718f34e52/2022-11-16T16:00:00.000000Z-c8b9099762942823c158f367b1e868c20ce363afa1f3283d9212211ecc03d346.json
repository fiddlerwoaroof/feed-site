{
  "title":"Polynomial Multiplication Using the FFT",
  "date":"2022-11-16T16:00:00.000000Z",
  "author":null,
  "id":"https://jeremykun.com/?p=118895",
  "link":"https://jeremykun.com/2022/11/16/polynomial-multiplication-using-the-fft/",
  "content":"\n<p><strong>Problem:</strong> Compute the product of two polynomials efficiently.</p>\n\n\n\n<p><strong>Solution:</strong></p>\n\n\n<div class=\"wp-block-syntaxhighlighter-code \"><pre class=\"brush: python; title: ; notranslate\">\nimport numpy\nfrom numpy.fft import fft, ifft\n\n\ndef poly_mul(p1, p2):\n    &quot;&quot;&quot;Multiply two polynomials.\n\n    p1 and p2 are arrays of coefficients in degree-increasing order.\n    &quot;&quot;&quot;\n    deg1 = p1.shape[0] - 1\n    deg2 = p1.shape[0] - 1\n    # Would be 2*(deg1 + deg2) + 1, but the next-power-of-2 handles the +1\n    total_num_pts = 2 * (deg1 + deg2)\n    next_power_of_2 = 1 &lt;&lt; (total_num_pts - 1).bit_length()\n\n    ff_p1 = fft(numpy.pad(p1, (0, next_power_of_2 - p1.shape[0])))\n    ff_p2 = fft(numpy.pad(p2, (0, next_power_of_2 - p2.shape[0])))\n    product = ff_p1 * ff_p2\n    inverted = ifft(product)\n    rounded = numpy.round(numpy.real(inverted)).astype(numpy.int32)\n    return numpy.trim_zeros(rounded, trim='b')\n</pre></div>\n\n\n<p><strong>Discussion:</strong> The <a href=\"https://jeremykun.com/2012/05/27/the-fourier-transform-a-primer/\">Fourier Transform</a> has a lot of applications to science, and I’ve covered it on this blog before, see the Signal Processing section of <a href=\"http://Signal Processing\">Main Content</a>. But it also has applications to fast computational mathematics.</p>\n\n\n\n<p>The naive algorithm for multiplying two polynomials is the “grade-school” algorithm most readers will already be familiar with (see e.g., <a href=\"https://brilliant.org/wiki/polynomial-multiplication/\">this page</a>), but for large polynomials that algorithm is slow. It requires $O(n^2)$ arithmetic operations to multiply two polynomials of degree $n$.</p>\n\n\n\n<p>This short tip shows a different approach, which is based on the idea of <em>polynomial interpolation</em>. As a side note, I show the basic theory of polynomial interpolation in chapter 2 of my book, <a href=\"https://pimbook.org\">A Programmer’s Introduction to Mathematics</a>, along with an application to cryptography called “<a href=\"https://jeremykun.com/2014/06/23/the-mathematics-of-secret-sharing/\">Secret Sharing</a>.”</p>\n\n\n\n<p>The core idea is that given $n+1$ distinct evaluations of a polynomial $p(x)$ (i.e., points $(x, p(x))$ with different $x$ inputs), you can reconstruct the coefficients of $p(x)$ exactly. And if you have two such point sets for two different polynomials $p(x), q(x)$, a valid point set of the product $(pq)(x)$ is the product of the points that have the same $x$ inputs.</p>\n\n\n\n<p class=\"has-text-align-center\">\\[ \\begin{aligned} p(x) &amp;= \\{ (x_0, p(x_0)), (x_1, p(x_1)), \\dots, (x_n, p(x_n))  \\} \\\\ q(x) &amp;= \\{ (x_0, q(x_0)), (x_1, q(x_1)), \\dots, (x_n, q(x_n))  \\} \\\\ (pq)(x) &amp;= \\{ (x_0, p(x_0)q(x_0)), (x_1, p(x_1)q(x_1)), \\dots, (x_n, p(x_n)q(x_n))  \\} \\end{aligned} \\]</p>\n\n\n\n<p>The above uses $=$ loosely to represent that the polynomial $p$ can be represented by the point set on the right hand side.</p>\n\n\n\n<p>So given two polynomials $p(x), q(x)$ in their coefficient forms, one can first convert them to their point forms, multiply the points, and then reconstruct the resulting product.</p>\n\n\n\n<p>The problem is that the two conversions, both to and from the coefficient form, are inefficient for arbitrary choices of points $x_0, \\dots, x_n$. The trick comes from choosing special points, in such a way that the intermediate values computed in the conversion steps can be reused. This is where the Fourier Transform comes in: choose $x_0 = \\omega_{N}$, the complex-N-th root of unity, and $x_k = \\omega_N^k$ as its exponents. $N$ is required to be large enough so that $\\omega_N$’s exponents have at least $2n+1$ distinct values required for interpolating a degree-at-most-$2n$ polynomial, and because we’re doing the Fourier Transform, it will naturally be “the next largest power of 2” bigger than the degree of the product polynomial.</p>\n\n\n\n<p>Then one has to observe that, by its very formula, the Fourier Transform <em>is exactly</em> the evaluation of a polynomial at the powers of the $N$-th root of unity! In formulas: if $a = (a_0, \\dots, a_{n-1})$ is a list of real numbers define $p_a(x) = a_0 + a_1x + \\dots + a_{n-1}x^{n-1}$. Then $\\mathscr{F}(a)(k)$, the Fourier Transform of $a$ at index $k$, is equal to $p_a(\\omega_n^k)$. <a href=\"http://www.cs.toronto.edu/~denisp/csc373/docs/tutorial3-adv-writeup.pdf\">These notes</a> by Denis Pankratov have more details showing that the Fourier Transform formula is a polynomial evaluation (see Section 3), and <a href=\"https://www.youtube.com/watch?v=h7apO7q16V0\">this YouTube video by Reducible</a> also has a nice exposition. This interpretation of the FT as polynomial evaluation seems to inspire quite a few additional techniques for computing the Fourier Transform that I plan to write about in the future.</p>\n\n\n\n<p>The last step is to reconstruct the product polynomial from the product of the two point sets, but because the Fourier Transform is an invertible function (and linear, too), the inverse Fourier Transform does exactly that: given a list of the $n$ evaluations of a polynomial at $\\omega_n^k, k=0, \\dots, n-1$, return the coefficients of the polynomial.</p>\n\n\n\n<p>This all fits together into the code above:</p>\n\n\n\n<ol>\n<li>Pad the input coefficient lists with zeros, so that the lists are a power of 2 and at least 1 more than the degree of the output product polynomial.</li>\n\n\n\n<li>Compute the FFT of the two padded polynomials.</li>\n\n\n\n<li>Multiply the result pointwise.</li>\n\n\n\n<li>Compute the IFFT of the product.</li>\n\n\n\n<li>Round the resulting (complex) values back to integers.</li>\n</ol>\n\n\n\n<p>Hey, wait a minute! What about precision issues?</p>\n\n\n\n<p>They are a problem when you have large numbers or large polynomials, because the intermediate values in steps 2-4 can lose precision due to the floating point math involved. <a href=\"https://people.eecs.berkeley.edu/~fateman/papers/shortfft\">This short note</a> of Richard Fateman discusses some of those issues, and two paths forward include: deal with it somehow, or use an integer-exact analogue called the <a href=\"https://en.wikipedia.org/wiki/Discrete_Fourier_transform_over_a_ring#Number-theoretic_transform\">Number Theoretic Transform</a> (which itself has issues I’ll discuss in a future, longer article).</p>\n\n\n\n<p>Postscript: I’m not sure how widely this technique is used. It appears the <a href=\"https://libntl.org/\">NTL library</a> uses the polynomial version of <a href=\"https://en.wikipedia.org/wiki/Karatsuba_algorithm\">Karatsuba multiplication</a> instead (though it implements FFT elsewhere). However, I know for sure that much software involved in doing <a href=\"https://en.wikipedia.org/wiki/Homomorphic_encryption\">fully homomorphic encryption</a> rely on the FFT for performance reasons, and the ones that don’t instead use the NTT.</p>\n"
}