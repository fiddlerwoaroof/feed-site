{
  "title":"RSpec story about disappearing classes",
  "date":"2022-11-12T16:30:20.000000Z",
  "author":null,
  "id":"https://mensfeld.pl/?p=5489",
  "link":"https://mensfeld.pl/2022/11/rspec-story-about-disappearing-classes/",
  "content":"<p><code>ActiveSupport#descendants</code> can be slow. In a bigger system with layers of descendants, finding all of them can be time-consuming:</p>\n<pre><code class=\"language-ruby\">puts Benchmark.measure do\n  100.times { Dispatchers::Base.descendants }\nend\n\n# 5.235370   0.015754   5.251124 (  5.251069)</code></pre>\n<p>In the code I've been working on, it meant that a single lookup was taking around <strong>50ms</strong>. That is <strong>a lot</strong>, especially if used extensively.</p>\n<p>To mitigate this, I've implemented a simple caching layer on top of the lookup that would make things fast:</p>\n<pre><code class=\"language-ruby\">module Mixins\n  module CachedDescendants\n    extend ActiveSupport::Concern\n\n    cattr_accessor :descendants_map\n\n    self.descendants_map = Concurrent::Hash.new\n\n    class &lt;&lt; self\n      # Clears the descendants map cache - can be hooked to Rails reloader\n      def reload!\n        descendants_map.clear\n      end\n    end\n\n    included do\n      class &lt;&lt; self\n        # @return [Array&lt;Class&gt;] array with descendants classes\n        def cached_descendants\n          ::Mixins::CachedDescendants.descendants_map[self] ||= descendants\n        end\n      end\n    end\n  end\nend</code></pre>\n<p>When included and used, it would give great results:</p>\n<pre><code class=\"language-ruby\">puts Benchmark.measure do\n  100.times { Dispatchers::Base.cached_descendants }\nend\n\n# 0.000023   0.000001   0.000024 (  0.000024)</code></pre>\n<p><strong>99,99956%</strong> faster!</p>\n<p>Such code, like any other, deserves to be tested. I wrote some specs for it, including a relatively simple one:</p>\n<pre><code class=\"language-ruby\">  context 'when there are two independent bases' do\n    let(:base1) do\n      Class.new do\n        include ::Mixins::CachedDescendants\n      end\n    end\n\n    let(:base2) do\n      Class.new do\n        include ::Mixins::CachedDescendants\n      end\n    end\n\n    before do\n      Array.new(5) { Class.new(base1) }\n      Array.new(5) { Class.new(base2) }\n    end\n\n    it 'expect for them not to interact' do\n      expect(base1.cached_descendants.size).to eq(5)\n      expect(base2.cached_descendants.size).to eq(5)\n      expect(base1.cached_descendants &amp; base2.cached_descendants).to be_empty\n    end\n  end</code></pre>\n<p>It would just ensure that the way we cache does not create collisions for independent descendants trees.</p>\n<p>But once in a while, this code would randomly fail:</p>\n<pre><code class=\"language-ruby\">  1) Mixins::CachedDescendants when there are two independent bases expect for them not to interact\n     Failure/Error: expect(base1.cached_descendants.size).to eq(4)\n       expected: 5\n            got: 4\n       (compared using ==)</code></pre>\n<p>How can I create five classes and suddenly have only 4? I initially thought something was wrong with the descendants lookup for anonymous classes. However, this functionality is heavily used by many, including me, and it never created any problems. On top of that, why would it fail only once in a while?</p>\n<p>When something fails randomly, it usually means that there's an external factor to it. One that operates under the hood. It wasn't different in this case.</p>\n<p>After some investigation, I was able to reproduce it:</p>\n<pre><code class=\"language-ruby\">GC.disable\n\nputs &quot;Total classes before: #{ObjectSpace.count_objects[:T_CLASS]}&quot; \nputs &quot;String subclasses count before: #{String.subclasses.count}&quot; \n\n100.times { Class.new(String) }\n\nputs &quot;Total classes after defining: #{ObjectSpace.count_objects[:T_CLASS]}&quot; \nputs &quot;String subclasses count after defining: #{String.subclasses.count}&quot; \n\nGC.enable\nGC.start\n\nputs &quot;Total classes after GC: #{ObjectSpace.count_objects[:T_CLASS]}&quot; \nputs &quot;String subclasses count after GC: #{String.subclasses.count}&quot; \n\n# Total classes after defining: 1324\n# String subclasses count after defining: 102\n# Running GC...\n# Total classes after GC: 1124\n# String subclasses count after GC: 2</code></pre>\n<p>Boom! Anonymous classes <strong>are</strong> being garbage collected! Classes that are not referenced anywhere are subject to garbage collection like other objects, and this code was not memoizing them:</p>\n<pre><code class=\"language-ruby\">before do\n  Array.new(5) { Class.new(base1) }\n  Array.new(5) { Class.new(base2) }\nend</code></pre>\n<p>Hence, the spec would fail if GC kicked in <strong>exactly</strong> between the classes definitions and the spec execution. This is why it would only fail once in a while.</p>\n<p>Fixing such an issue required only minimal changes to the spec:</p>\n<pre><code class=\"language-ruby\">    let(:descendants) do\n      # This needs to be memorized, otherwise Ruby GC may remove those in between assertions\n      [\n        Array.new(5) { Class.new(base1) },\n        Array.new(5) { Class.new(base2) }\n      ]\n    end\n\n    before { descendants }</code></pre>\n<p>That way, the anonymous classes would be referenced throughout the lifetime of this spec.</p>\n<h3>Summary (TL;DR)</h3>\n<p>Anonymous classes and modules are a subject of garbage collection like any other object. Unless you reference them, they may be gone before wanting to use them via <code>#descendants</code> or similar lookups. Always reference them in some way or face the unexpected.</p>\n<h2>Afterword</h2>\n<p>It was pointed to me by Jean Boussier, that there's an <a href=\"https://api.rubyonrails.org/classes/ActiveSupport/DescendantsTracker.html\"><code>ActiveSupport::DescendantsTracker</code></a> that can also be used to improve the lookup performance and that Ruby <code>3.1</code> has a <code>#subclasses</code> that also is much faster than iterating over <code>ObjectSpace</code>. While their performance is several times faster than the &quot;old&quot; lookup, it is still a magnitude slower than caching the descendants in dev but has similar performance in production.</p>\n<p><code>0.002020</code> vs. <code>0.000023</code> in dev and <code>0.000039</code> vs. <code>0.000042</code> in production.</p>\n<p>The best code is no code, so now I can deprecate my code. The strong class references, however, are still valid and worth keeping in mind.</p>\n<hr>\n<p>Cover photo by <a href=\"https://www.flickr.com/photos/eorus/15254853522/\">Alper Orus</a> on Attribution-NonCommercial-ShareAlike 2.0 Generic (CC BY-NC-SA 2.0). Image has been cropped.</p>\n<p>The post <a rel=\"nofollow\" href=\"https://mensfeld.pl/2022/11/rspec-story-about-disappearing-classes/\">RSpec story about disappearing classes</a> appeared first on <a rel=\"nofollow\" href=\"https://mensfeld.pl\">Closer to Code</a>.</p>\n"
}