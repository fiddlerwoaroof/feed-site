{
  "title":"Treat Rails for What it Is and Organize Code By Structural Purpose",
  "date":"2022-10-25T09:00:00.000000Z",
  "author":null,
  "id":"https://naildrivin5.com/blog/2022/10/25/treat-rails-for-what-it-is-and-organize-code-by-structural-purpose",
  "link":"https://naildrivin5.com/blog/2022/10/25/treat-rails-for-what-it-is-and-organize-code-by-structural-purpose.html",
  "content":"<p>If I had one piece of advice for using Rails, it is to treat Rails for what it <em>is</em>, not what you might like it to be.  This was the subject of my talk at Rails Conf 2022, but it has a few practical implications for, among other things, how to organize the code in your Rails app.</p>\n\n\n\n<p>No matter how simple your app is, it will have business logic, and you will have a boundary\nbetween your controllers/jobs/mailboxes/tasks and that logic.  The code that defines that\nboundary is called a <em>service layer</em>. It should go in <code class=\"language-plaintext highlighter-rouge\">app/services</code>, because Rails organizes\ncode by <em>structural</em> purpose, not domain purpose.  Following Rails conventions will make\ndevelopment of your app easier to sustain over time.</p>\n\n<h2 id=\"an-apps-architecture-starts-with-code-organization\">An App’s Architecture Starts with Code Organization</h2>\n\n<p>The reason the question “where does this code go?” is important to answer is because it’s\nthe foundation of the application’s architecture.  If developers don’t know (or can’t agree on) where code is supposed to go, sustained development is going to be difficult.</p>\n\n<p>Rails is a framework that will manage <em>most</em> of the classes you need to build an app: HTTP, Email, database, background jobs, etc.  Rails does not provide any specific way to manage your core domain or business logic.  The only feature it provides is the ability to auto-load classes in <code class=\"language-plaintext highlighter-rouge\">app/«whatever»</code>.</p>\n\n<div></div>\n\n<p>The easier it is to answer the question “where does the code go?” the easier it will be to work\non your app over time and through change (in requirements, team, etc). If answering this question\nis difficult, change is harder. Questions that are difficult to answer create more friction than\nquestions that are easy to answer, and you want to reduce friction, <em>especially</em> around questions\nthat must be answered before coding can start.</p>\n\n<p>Fortunately, Rails <em>does</em> provide an easier answer for <em>almost</em> all of the code you have to\nwrite: controllers go in <code class=\"language-plaintext highlighter-rouge\">app/controllers</code>, Active Records go in <code class=\"language-plaintext highlighter-rouge\">app/models</code>, Mailers go in <code class=\"language-plaintext highlighter-rouge\">app/mailers</code>, and so on.  Developers don’t need to do a lot of analysis to figure out where that sort of code goes. So it should be with business logic.</p>\n\n<p>Business (or perhaps <em>domain</em>) logic doesn’t fit into any of the Rails-managed classes, and Rails\ndoesn’t provide an answer for where this code goes.  I find it useful to acknowledge the boundary\nbetween Rails-managed classes and business logic, and I find the best term for this boundary to\nbe <em>service layer</em>.</p>\n\n<h2 id=\"business-logic-should-be-encapsulated\">Business Logic Should be Encapsulated</h2>\n\n<p>Even if you don’t explicitly define a boundary between your controllers and business logic, it\ndoesn’t mean it doesn’t exist, at least conceptually.  This boundary is called a <em>service layer</em>, which <a href=\"https://martinfowler.com/eaaCatalog/serviceLayer.html\">Martin Fowler</a> defines thusly, emphasis mine:</p>\n\n<blockquote>\n  <p>A Service Layer defines an application’s boundary and its set of available operations from the perspective of interfacing client layers. It <em>encapsulates the application’s business logic</em>, controlling transactions and coordinating responses in the implementation of its operations.</p>\n</blockquote>\n\n<p>The highlighted section is important.  The service layer <em>encapsulates</em> the business logic from\n“clients”. In a Rails app, a client is a controller, mailbox, task, or background job.  They\ninvoke business logic and interpret its results.  The service layer is where this happens.</p>\n\n<aside class=\"pullquote\">\nThe service layer encapsulates the business logic.\n</aside>\n\n<p>This does <em>not</em> imply that the service layer contain all the logic.  It is just a boundary.  It encapsulate whatever the logic is.</p>\n\n<p>Rails developers often fail to create an explicit service layer, and have methods littered all\nover the place—often on Active Records—that trigger (and implement) business logic.  This is needlessly confusing and hard to manage over time.  Having instead a single place where business logic is invoked makes everything easier.</p>\n\n<p><em>Inside</em> <code class=\"language-plaintext highlighter-rouge\">app/services</code>, because of encapsulation, you are free to organize the code however you\nlike. If you prefer stateless procedures, you can do that.  If you prefer a rich collection of\nobjects passing messages, you can do that, too.  If you need to create subdirectories for domain\nconcepts, you can do that as well.  This is the primary benefit of encapsulation and, because\nthis code is tucked into <code class=\"language-plaintext highlighter-rouge\">app/services</code>, it also is consistent with Rails’ conventions.</p>\n\n<h2 id=\"what-about-decorators-and-other-classes\">What About Decorators and Other Classes?</h2>\n\n<p>Most apps should not need more than <code class=\"language-plaintext highlighter-rouge\">app/services</code> plus what Rails gives you, but if you do end\nup having a lot of classes that conform to some structural purpose, you can certainly create a\ndirectory in <code class=\"language-plaintext highlighter-rouge\">app</code> to store them.</p>\n\n<p>This is what Rails intends you to do, and creating a directory like <code class=\"language-plaintext highlighter-rouge\">app/decorators</code> is a clear way to communicate that there is a concept of a decorator, and that the way it is constructed is important to be consistent.</p>\n\n<p>This provides an easy answer to “where do decorators go?” and is also consistent with how Rails\nwants you to structure your code.  The more easy answers your architecture provides, the better.</p>\n\n<h2 id=\"what-about-lib\">What About <code class=\"language-plaintext highlighter-rouge\">lib</code>?</h2>\n\n<p>There is a second type of code that is particular to your app but doesn’t fall into a\nRails-managed class <em>or</em> business logic, and <em>that</em> is the code that should go in <code class=\"language-plaintext highlighter-rouge\">lib</code>.  This\ncode is often infrastructure-type code like middleware or plugins.  <code class=\"language-plaintext highlighter-rouge\">lib</code> can also hold code you\nintend to extract as a gem in the future.</p>\n\n<p>This convention follows the policy we’ve been discussing: easy answer to where code goes.  If you\nneed to create some code that is not business logic and does not go in a Rails-managed class, it\ngoes in <code class=\"language-plaintext highlighter-rouge\">lib</code>.</p>\n\n<h2 id=\"what-about-organizing-by-domain-concept\">What About Organizing by Domain Concept?</h2>\n\n<p>There are advantages to organizing code by domain concept instead of structural purpose.  For\nexample, you might want <code class=\"language-plaintext highlighter-rouge\">app/shopping</code> to contain all the code about purchasing from your store\nand <code class=\"language-plaintext highlighter-rouge\">app/reporting</code> to contain all the reporting.</p>\n\n<p>To entirely organize your app this way requires quite the configuration feat with Rails and would\nobviate may of Rails’ benefits.  It also creates a far more difficult-to-answer to the question of\nwhere code goes.  Is there an existing concept where this new code should go?  I there an\nexisting concept that is close, and if we rename it would this code go there?  Or, does adding\nthis code to an existing concept make that concept too complex such that it requires splitting up\ninto two smaller concepts?</p>\n\n<aside class=\"pullquote\">\nIt creates a far more difficult-to-answer question of where code goes.\n</aside>\n\n<p>These questions can be hard to answer, especially if the app is undergoing rapid change. You may\nnot know what concepts the app will need or if a concept will be developed beyond the initial\nfeature. When organizing by structural purpose you can always safely put the code in\n<code class=\"language-plaintext highlighter-rouge\">app/controllers</code> or <code class=\"language-plaintext highlighter-rouge\">app/services</code> or wherever, and organize it later.</p>\n\n<p>The ability to organize later is powerful: it’s much easier to organize code that exists and is\ntested than it is to try to predict where code should go in the future.  The contents of your\nstructurally-based folders will show you exactly what concepts are important and which ones\naren’t.</p>\n\n<p>When <code class=\"language-plaintext highlighter-rouge\">app</code> contains structurally-organized directories and <em>those</em> directories contain\ndomain-organized code, you get the best of both worlds.  You can group by domain concept, but\nalso easily answer the question of where code goes.  You also have an escape hatch if the\nquestion is too hard to answer: put it in the top of the relevant directory.</p>\n\n<h2 id=\"treat-rails-for-what-it-is\">Treat Rails for What it Is</h2>\n\n<p>Rails is a web framework that organizes code by structural purpose. It provides rudimentary tools\nfor adding your own new structural purposes, and does not prescribe how the code inside should be\norganized.  Thus, define your service layer explicitly in <code class=\"language-plaintext highlighter-rouge\">app/services</code>, then organize the code\nin there—as well as your domain logic—however you see fit. If you always try to treat Rails for\nwhat it is—not what you might like it to be—your app’s architecture will provide a solid\nfoundation for sustainable development.</p>\n"
}