{
  "title":"RSpec Examples are, well, Examples",
  "date":"2022-11-09T08:00:00.000000Z",
  "author":null,
  "id":"https://naildrivin5.com/blog/2022/11/09/rspec-examples-are--well--examples",
  "link":"https://naildrivin5.com/blog/2022/11/09/rspec-examples-are-well-examples.html",
  "content":"<p>RSpec’s internal DSL allows creating some difficult-to-sustain structures and code, but there is one guiding principle that has helped me avoid making tests that are <em>too</em> weird:</p>\n\n<p>RSpec tests should be examples of how the code under test would be used.</p>\n\n<p>Let’s see a few examples: using <code class=\"language-plaintext highlighter-rouge\">subject</code> and avoiding predicate matchers.</p>\n\n\n\n<h2 id=\"subject-is-the-heart-of-your-test\"><code class=\"language-plaintext highlighter-rouge\">subject</code> is the heart of your test</h2>\n\n<p>RSpec provides the <code class=\"language-plaintext highlighter-rouge\">subject</code> method, which it documents to <a href=\"https://relishapp.com/rspec/rspec-core/v/3-11/docs/subject/explicit-subject\">allow all kinds of odd stuff</a>, but at it’s core:</p>\n\n<blockquote>\n  <p>Use <code class=\"language-plaintext highlighter-rouge\">subject</code> in the group scope to explicitly define the value that is returned by the <code class=\"language-plaintext highlighter-rouge\">subject</code> method in the example scope.</p>\n</blockquote>\n\n<p>The problem is, you would never call your object <code class=\"language-plaintext highlighter-rouge\">subject</code> in your regular code:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\"># Yes, naming is hard, but it's not THIS hard</span>\n<span class=\"n\">subject</span> <span class=\"o\">=</span> <span class=\"n\">user</span><span class=\"p\">.</span><span class=\"nf\">orders</span><span class=\"p\">.</span><span class=\"nf\">last</span>\n\n<span class=\"c1\"># You would almost certainly do this</span>\n<span class=\"n\">order</span> <span class=\"o\">=</span> <span class=\"n\">user</span><span class=\"p\">.</span><span class=\"nf\">orders</span><span class=\"p\">.</span><span class=\"nf\">last</span>\n\n<span class=\"c1\"># or maybe this</span>\n<span class=\"n\">last_order</span> <span class=\"o\">=</span> <span class=\"n\">user</span><span class=\"p\">.</span><span class=\"nf\">orders</span><span class=\"p\">.</span><span class=\"nf\">last</span>\n</code></pre></div></div>\n\n<p>You would call the object being tested ideally the name that would be used in most common scenarios where the object is being used.  RSpec even recommends this (despite spending the rest of the docs explaining how to not follow this recommendation):</p>\n\n<blockquote>\n  <p>We recommend using the named helper method over subject in examples</p>\n</blockquote>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">subject</span><span class=\"p\">(</span><span class=\"ss\">:order</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">described_class</span><span class=\"p\">.</span><span class=\"nf\">new</span> <span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>This is better than <code class=\"language-plaintext highlighter-rouge\">let</code> because it indicates that this particular variable is special: it’s the object under test.</p>\n\n<p>Another use of <code class=\"language-plaintext highlighter-rouge\">subject</code> is to enable the <a href=\"https://relishapp.com/rspec/rspec-core/v/3-11/docs/subject/one-liner-syntax\">one-liner syntax</a>, which hides a ton of information about what is being tested inside implicit behavior (<em>note</em>: a previous version of this post erroneously claimed you could not use this syntax with a named subject):</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">it</span> <span class=\"p\">{</span> <span class=\"n\">is_expected_to</span> <span class=\"n\">be_empty</span> <span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>Absolutely none of that is an example of the code you would write, meaning you have to mentally translate this code into what would actually happen in order to understand what is being tested. That it reads like English—”it is expected to be empty”—is not nearly as useful as knowing what code is being tested.</p>\n\n<p>Aside from the <code class=\"language-plaintext highlighter-rouge\">is_expected_to</code>, the <code class=\"language-plaintext highlighter-rouge\">be_empty</code> can be used in other contexts, however it is still problematic.</p>\n\n<h2 id=\"predicate-matchers-mask-behavior-for-no-real-benefit\">Predicate Matchers mask Behavior For No Real Benefit</h2>\n\n<p><a href=\"https://relishapp.com/rspec/rspec-expectations/v/3-12/docs/built-in-matchers/predicate-matchers\">Predicate matchers</a> allow you to write an expectation in a pidgen-like English:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"n\">order</span><span class=\"p\">).</span><span class=\"nf\">not_to</span> <span class=\"n\">be_sent</span>\n</code></pre></div></div>\n\n<p>What is being tested here?  Sure, we can say that the order is expected not to have been sent, but this is a test, not documentation. We need to understand exactly what invocations of what code should have what behavior. If the test isn’t the place where that goes, I’m not sure what is.</p>\n\n<p>This is better:</p>\n\n<div class=\"language-ruby highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">expect</span><span class=\"p\">(</span><span class=\"n\">order</span><span class=\"p\">.</span><span class=\"nf\">sent?</span><span class=\"p\">).</span><span class=\"nf\">to</span> <span class=\"n\">eq</span><span class=\"p\">(</span><span class=\"kp\">true</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p><em>This</em> test shows the actual code being tested. This is good (it also tests precisely the behavior, which the predicate matcher does not. Read on).</p>\n\n<p>A commonly-cited benefit of the predict matcher form is that it produces a better error message, something like</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>expected order.sent? to be truthy\n</code></pre></div></div>\n\n<p>The more explicit version would produce this:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>expected false to be true\n</code></pre></div></div>\n\n<p>In both cases, the default error formatter would also show the line of code in the test that failed, so in both cases you would see the call to <code class=\"language-plaintext highlighter-rouge\">.sent?</code> in the error output.  To me, this is fine. While “expected false to be true” is not a great message, since it’s shown right next to the line of code being executed, it’s not a problem for me to sort out what went wrong.</p>\n\n<p>But note also what the predicate matcher is testing. It’s not testing that <code class=\"language-plaintext highlighter-rouge\">.send?</code> returned <code class=\"language-plaintext highlighter-rouge\">true</code>. It’s testing that it <em>didn’t return false or nil</em>.  If that is not\nwhat <code class=\"language-plaintext highlighter-rouge\">.sent?</code> is supposed to do, the predicate-based test is <em>wrong</em>.  I like to assert the test results to be precisely what I mean them to be, and for Ruby that means\nyou have to use <code class=\"language-plaintext highlighter-rouge\">eq(true)</code> if you want to test that a predicate method returned true (or false).</p>\n\n<p>For me, the predicate matcher is all downside - it makes it hard to understand what code is actually being tested, it does not assert precisely the value you may think\nit does, and the error message for the <em>non</em> predicate test has all the information the predicate one does.</p>\n\n<p>There are a ton of other ways in which writing tests as <em>examples</em> of the code under test can lead to explicit, yet clear code.  It does mean you won’t use several RSpec features, but this is fine.</p>\n\n"
}