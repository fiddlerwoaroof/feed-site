{
  "title":"A Guide To Keyboard Accessibility: HTML And CSS (Part 1)",
  "date":"2022-11-14T14:00:00.000000Z",
  "author":null,
  "id":"https://smashingmagazine.com/2022/11/guide-keyboard-accessibility-html-css-part1/",
  "link":"https://smashingmagazine.com/2022/11/guide-keyboard-accessibility-html-css-part1/",
  "content":"<p>Keyboard accessibility is an important part of the user experience. There are multiple criteria in <strong>Web Content Accessibility Guidelines (WCAG)</strong> about this topic. Still, it’s somehow overlooked, affecting the experience of many users, mainly people with motor disabilities  — any condition that limits movement or coordination.</p>\n<p>Certain conditions like having a broken arm, the loss or damage of a limb, muscular dystrophy, arthritis, and some others can make it impossible for a person to use a mouse to navigate a site. So, making a site navigable via keyboard is a very important part of ensuring the accessibility and usability of our websites.</p>\n<p>The importance of making a site accessible for users with motor disabilities becomes even more evident when you learn that they have access to more assistive technology options. Keyboards are not even the main focus of motor disability assistance! There are tools like switches that you use with your hand (or even with your head) to work with any device, which helps a lot for people with more severe motor disabilities. You can see how those technologies work in <a href=\"https://www.youtube.com/watch?v=V1yoOLhx_qA\">this demonstration made by Rob Dodson</a> or in <a href=\"https://www.youtube.com/watch?v=cSSgndQ5mVs\">this video of Christopher Hills</a>.</p>\n<p>In this article, I’ll cover how to use HTML and CSS to create an accessible experience for keyboard users while mentioning what WCAG criteria we should keep into consideration.</p>\nHTML\n<p>One of the basics of creating a website accessible site for keyboard users is knowing what elements should be navigable via keyboard. For this, a good HTML semantic is crucial because it’ll indicate the kind of elements we want to focus on with keyboard navigation.</p>\n<h3>The Basics</h3>\n<p>When a user presses the Tab key, it’ll let them select the next focusable element in the HTML, and when they press the keys Shift + Tab, it’ll take them to the last focusable element. With that said, what elements need to be focusable? Anything that requires user interaction. Between them, you can find the elements <code>button</code>, <code>a</code>, <code>input</code>, <code>summary</code>, <code>textarea</code>, <code>select</code>, and the controls of elements <code>audio</code>, and <code>video</code> (when you add the attribute <code>controls</code> to them). Additionally, certain attributes can make an element keyboard navigable, such as <code>contenteditable</code> or <code>tabindex</code>. In the case of Firefox, any area with a scroll will also be keyboard focusable.</p>\n<p>Additionally to that, you can:</p>\n<ul>\n<li>Activate the <code>button</code>, <code>select</code>, <code>summary</code>, and <code>a</code> elements using the Enter Key. Keep in mind that except for the <code>a</code> element, you can activate them with the Space Key as well.</li>\n<li>Use the arrow keys to navigate between different <code>input</code> with the type <code>radio</code> if they share the same <code>name</code> attribute.</li>\n<li>Check those inputs using the Space key (keep in mind that when you navigate with the arrow keys <code>radio</code> inputs, it’ll be checked once the keyboard is focused, but that doesn’t happen with <code>checkbox</code> inputs).</li>\n<li>Use the up and down keys to navigate between the different options of a <code>select</code> element.</li>\n<li>Close the <code>select</code> element displayed list and multiple <code>input</code> popups.</li>\n<li>Use the arrow keys to scroll vertically or horizontally a document.</li>\n</ul>\n<p>There are probably more interactions, some of which depend on differences between operating systems and browsers, but that covers mostly what you can do with the keyboard.</p>\n<p>Does that mean those elements are automatically keyboard-accessible by default? A good HTML structure is very helpful, and it makes content <strong>mostly</strong> accessible by default, but you still need to cover some issues.</p>\n<p>For example, certain input types like <code>date</code>, <code>datetime-local</code>, <code>week</code>, <code>time</code>, and <code>month</code> have popups that can work differently between browsers. Chrome, for example, allows you to open the date picker popup by pressing the Enter or Space key in a designated button in the input. However, with Firefox, you need to press Enter (or Space) in either the day, month, or year fields to open the popup and modify each field from there.</p>\n<p>This lack of consistency can be a bit off-putting, and maybe it’s just a matter of personal preference. Still, I feel that the Firefox experience is not very intuitive, which leads to thinking that, arguably, one of those experiences is more keyboard-accessible than the other. So if you want to create a good, accessible, and consistent keyboard experience between browsers, you’d need more than HTML for that. If you're going to try it yourself, check this <a href=\"https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#input_types\">compilation of input types by MDN</a> and navigate them by yourself.</p>\n<p>Additionally to the previous point, certain components require elements to be keyboard focusable without being natively selectable. In other cases, we need to manage keyboard focus manually, and our markup needs to help us with that. For both cases, we’ll need to use an HTML attribute that will help us with this task.</p>\n<h3><code>tabindex</code> Attribute</h3>\n<p>This attribute will greatly help us bring keyboard accessibility to more complex component patterns. This attribute receives an integer, and properly using it will help us make a DOM element keyboard focusable. With <code>tabindex</code>, we can find three different cases:</p>\n<h4><code>tabindex=&quot;0&quot;</code></h4>\n<p>It causes the element to be keyboard focusable. You usually don’t want to add keyboard focus to an element unless it is not interactive, but some scenarios will require it.</p>\n<p>One of them is when you have a component with a scroll beside the <code>body</code> element. Otherwise, keyboard users won’t be able to see the full extent of the content. Some components that could have this trouble are scroll-based carrousels, tables, and code snippets. Just to give an example, any code snippet created with the help of <a href=\"https://prismjs.com/\">prism.js</a> has the attribute <code>tabindex=&quot;0&quot;</code>. Open prism.js’ site and navigate it using the Tab key. You’ll be able to focus the snippets and control the vertical and horizontal scroll using the arrow keys.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/075fa253-5d60-4bf3-bf16-b6f6796a6b26/1-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p>Some people who start with web accessibility think it is a good idea to add the attribute <code>tabindex=&quot;0&quot;</code> to every element because they think it’ll help screen reader users navigate easily through a site. This is a terrible practice because of two reasons:</p>\n<ol>\n<li>Screen reader users have multiple ways to navigate a site. They can jump between headers, landmarks, or form elements, and they don’t need that extra help to create an accessible site as long as the markup is appropriate.</li>\n<li>It can make keyboard navigation difficult because a user will have to press the Tab key many times to arrive at the desired content, and for certain motor disabilities, having too many focusable elements can create a physically painful experience.</li>\n</ol>\n<p>So, to summarize: it’s a useful technique for some components, but most of the time, you’ll be alright if you don’t use it, and certainly, you <strong>must not</strong> use it in every single element of your site.</p>\n<h4>Negative <code>tabindex</code></h4>\n<p>Before we start this section, we need to keep in mind two concepts: a DOM element is at the same time <strong>focusable</strong> (that means, you can programmatically focus on it with JavaScript) and <strong>tabbable</strong> (that means, being able to be selected with the Tab Key).</p>\n<p>With that in mind, here is where negative <code>tabindex</code> comes into play because it’ll make an element unable to be tabbed (but you can still focus on it with JavaScript). This is important for specific components because, in some cases, we’ll need to make a normally tabbable element unable to be tabbed, or we’ll need an element to be focusable but not tabbable.</p>\n<p>One example of that is tabs. A recommended pattern for this component is ensuring that when you press the Tab key when you’re located in the active <code>tab</code>, it goes to the active <code>tabpanel</code> instead of bringing the focus to the next tab. We can achieve that by adding a negative <code>tabindex</code> to all non-active tabs like this:</p>\n<pre><code>&lt;ul role=&quot;tablist&quot;&gt;\n  &lt;li role=&quot;presentation&quot;&gt;\n    &lt;button role=&quot;tab&quot; href=&quot;#panel1&quot; id=&quot;tab1&quot; aria-selected=&quot;true&quot;&gt;Tab one&lt;/button&gt;\n  &lt;/li&gt;\n  &lt;li role=&quot;presentation&quot;&gt;\n    &lt;button role=&quot;tab&quot; href=&quot;#panel2&quot; id=&quot;tab2&quot; tabindex=&quot;-1&quot;&gt;Tab two&lt;/button&gt;\n  &lt;/li&gt;\n  &lt;li role=&quot;presentation&quot;&gt;\n    &lt;button role=&quot;tab&quot; href=&quot;#panel3&quot; id=&quot;tab3&quot; tabindex=&quot;-1&quot;&gt;Tab three&lt;/button&gt;\n  &lt;/li&gt;\n  &lt;li role=&quot;presentation&quot;&gt;\n    &lt;button role=&quot;tab&quot; href=&quot;#panel4&quot; id=&quot;tab4&quot; tabindex=&quot;-1&quot;&gt;Tab four&lt;/button&gt;\n  &lt;/li&gt;\n&lt;/ul&gt;\n</code></pre>\n\n<p>We’ll see more examples later about how a negative <code>tabindex</code> will help us to have more control over focus state management in different components, but keep in mind a negative <code>tabindex</code> will be important in those cases.</p>\n<p>Finally, you can put any negative integer in the <code>tabindex</code> property, and it’ll work the same. <code>tabindex=&quot;-1&quot;</code> and <code>tabindex=&quot;-1000&quot;</code> will make no difference, but my mere convention is that we tend to use <code>-1</code> when we use this attribute.</p>\n<h4>Positive <code>tabindex</code></h4>\n<p>A positive <code>tabindex</code> will make the element keyboard focusable, but the order will be defined according to the used integer. That means that first, the keyboard will navigate all elements with the attribute <code>tabindex=&quot;1&quot;</code>, then the ones with <code>tabindex=&quot;2&quot;</code>, and after <strong>all</strong> elements with a positive <code>tabindex</code> have been navigated, it’ll take into account all interactive elements by default and those with the attribute <code>tabindex=&quot;0&quot;</code>. This is known as the <a href=\"https://html.spec.whatwg.org/multipage/interaction.html#tabindex-ordered-focus-navigation-scope\">tabindex-ordered focus navigation scope</a>.</p>\n<p>Now, this is a pattern that you shouldn’t use. You’ll be better if you put the required focusable elements in your site in the order you need. Otherwise, you could create a very confusing experience for keyboard users, which would make a failure of the <a href=\"https://www.w3.org/WAI/WCAG21/Understanding/focus-order.html\">WCAG criterion 2.4.3: Focus order</a>.</p>\n<blockquote>“If a Web page can be navigated sequentially and the navigation sequences affect meaning or operation, focusable components receive focus in an order that preserves meaning and operability.”<br><br>— <a href=\"https://www.w3.org/WAI/WCAG21/Understanding/focus-order.html\">Success Criterion 2.4.3: Focus order</a></blockquote>\n\n<p>It might be useful if you want keyboard users to focus on widgets before they reach the page content, but that’d be a bit confusing for assistive technology users (like screen readers). So again, you’d be better by creating a logical order in the DOM.</p>\n<h4><code>inert</code> Attribute</h4>\n<p>I have to quickly note an incoming attribute that will help us a lot with keyboard accessibility called <code>inert</code>. This attribute will make the content inaccessible by assistive technologies.</p>\n<p>Now you might be asking yourself how this can be useful because if something removes keyboard accessibility, but in some cases, that’s a good thing! One component that will benefit from it is modals. Adding this attribute to all elements in the site except this modal will make it easy to create a focus trap. So you’ll ensure the user can’t accidentally navigate to other parts of the site using the Tab key unless they close that modal. Right now, creating a keyboard trap requires quite some thinking with JavaScript (I’ll explain how in the second part of this guide). So, having a way to make it easier with this attribute will be handy.</p>\n<p>Sounds pretty cool, right? Well, unfortunately, this attribute is not recommended to be used yet. If you check the <a href=\"https://caniuse.com/?search=inert\">caniuse.com entry about this attribute</a>, you’ll notice it’s very recent; Opera doesn’t have support for it yet. The most recent implementation of it was version 105 of Firefox, and at the moment of writing this article, it’s a beta version! So, it’s still very early to do it. There is a <a href=\"https://github.com/WICG/inert\">polyfill for <code>inert</code> attribute</a>, but right now, it’s a bit performance costly. So, I seriously suggest not using it now for production. But once we have adequate support for this attribute, some component patterns will be easier to create.</p>\nCSS\n<p>CSS is an essential tool for keyboard accessibility because it allows us to create a level of customization of the experience, which is important for compliance with WCAG 2.2 criteria. Additionally, CSS has multiple selectors with different uses that will help to create a good keyboard experience, but be careful because a bad use of certain properties can be counterproductive. Let’s start diving into the use of this language to create an accessible experience for keyboard users.</p>\n<h3>Focus Indicator</h3>\n<p>When you use a mouse, you can see which element you can interact with it thanks to the cursor, and you wouldn’t remove the cursor from your user, right? That’d make them unable to know what element they want to use!</p>\n<p>We have a similar concept for keyboard navigation, and it’s called a <strong>focus indicator</strong>, which by default is an outline that surrounds a keyboard-focusable element when it’s selected by it. Being sure all your keyboard-focusable elements have a focus indicator is essential to making a website keyboard accessible, according to WCAG criteria:</p>\n<blockquote>“Any keyboard operable user interface has a mode of operation where the keyboard focus indicator is visible.”<br><br>— <a href=\"https://www.w3.org/WAI/WCAG21/Understanding/focus-visible.html\">Success Criterion 2.4.7: Focus Visible</a></blockquote>\n\n<p>This style is different depending on the browser you’re using. You can see how it looks in the various browsers in those pictures by default and when you use the CSS property <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/color-scheme\"><code>color-scheme</code></a> set to <code>dark</code> just to check out how the default styles would behave in dark mode.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/5ed16ffc-94ab-49f3-b1d1-997c788d2a97/2-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/9faf6328-9f41-4dd7-a35b-f1a2e7c65141/3-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/390df019-6443-4d44-b241-acebc0d8f75c/4-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p>As you can notice, Chromium-based browsers like Chrome or Edge have a black and white outline, which works in light and dark mode. Firefox opted for a blue outline which is noticeable in both modes. And Safari (and Webkit-based browsers because right now, all iOS browsers use Webkit as their browser engine) looks almost the same as Firefox but with an even subtler outline for a dark color scheme.</p>\n<h4>WCAG Criterion 2.4.11</h4>\n<p>Now, default focus indicators are visible, but are they <em>enough</em>? The answer is “no”. While it can work in some cases, people with visual impairments will have problems noticing it, so WCAG created the <a href=\"https://w3c.github.io/wcag/understanding/focus-appearance.html\">Success Criterion 2.4.11 — Focus appearance</a> to make an accessible focus indicator. Right now, this criterion is part of WCAG 2.2, which is a Candidate Recommendation. So it’s quite unlikely it will change before the final release, but keep in mind that it’s still subject to changes.</p>\n<blockquote>When the keyboard focus indicator is visible, one or both of the following is true:<br><ol><li>The focus indicator:<ul><li>encloses the visual presentation of the user interface component, and</li><li>has a contrast ratio of at least 3:1 between the same pixels in the focused and unfocused states, and</li><li>has a contrast ratio of at least 3:1 against adjacent colors.</li></ul></li><li>An area of the focus indicator meets all the following:<ul><li>is at least as large as the area of a 1 CSS pixel thick perimeter of the unfocused component, or is at least as large as a 4 CSS pixel thick line along the shortest side of the minimum bounding box of the unfocused component, and</li><li>has a contrast ratio of at least 3:1 between the same pixels in the focused and unfocused states, and</li><li>has a contrast ratio of at least 3:1 against adjacent non-focus-indicator colors, or is no thinner than 2 CSS pixels.</li></ul></li></ol><br>Where a user interface component has active sub-components, if a sub-component receives a focus indicator, these requirements may be applied to the sub-component instead.<br><br>— <a href=\"https://w3c.github.io/wcag/understanding/focus-appearance.html\">Success Criterion 2.4.11 Focus Appearance</a></blockquote>\n\n<p>There is something important to consider here, and that’s the area of the focus indicator. This area needs to meet the contrast requirements of this criterion. To illustrate that, I’ll use an example Sara Soueidan made for her article “<a href=\"https://www.sarasoueidan.com/blog/focus-indicators/\">A guide to designing accessible, WCAG-compliant focus indicators</a>.”</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d19b2f9b-1f9f-40d3-8e8b-f89340ef3168/5-guide-keyboard-accessibility-html-css-part1.jpeg\"></p>\n<p>This example uses an outline, but remember that you can use other properties to determine the focus state, like <code>background-color</code> or some creative ways of using <code>box-shadow</code> as long as it’s compliant with the requirements. However, <strong>don’t use the property <code>outline: none</code> to eliminate the element’s outline.</strong></p>\n<p>That’s important for Windows High Contrast Mode because when it’s active, your website colors will be replaced with ones chosen by the user. So depending on properties like <code>background-color</code> will have no effect there. Instead, use the CSS declaration <code>outline-color: transparent</code> with the appropriate thickness to comply with WCAG criteria. You can see examples of how it works in <a href=\"https://www.smashingmagazine.com/2022/06/guide-windows-high-contrast-mode/\">my article about Windows High Contrast Mode</a>.</p>\n<h4>The Optimal Outline Size</h4>\n<p>An easy way to create a compliant focus indicator is using this method Stephanie Eckles suggested in her talk <a href=\"https://youtu.be/FfQ-JuaNO68\">Modern CSS Upgrades To Improve Accessibility</a>. First, we set custom properties in the interactive elements. Remember you can add more elements to the rule depending on the complexity of your project:</p>\n<pre><code>/* Add more selectors inside the :is rule if needed */\n\n:is(a, button, input, textarea, summary) {\n    --outline-size: max(2px, 0.08em);\n    --outline-style: solid;\n    --outline-color: currentColor;\n}\n</code></pre>\n\n<p>And then, we use those custom properties to add a global focus rule:</p>\n<pre><code>:is(a, button, input, textarea, summary):focus {\n    outline:\n      var(--outline-size)\n      var(--outline-style)\n      var(--outline-color);\n    outline-offset: var(--outline-offset, var(--outline-size));\n}\n</code></pre>\n\n<p>The use of <code>0.08em</code> here is to give it a bigger outline size if the font is bigger, helping to scale the element’s contrasting area better with the element’s font size.</p>\n<p>Keep in mind that even when WCAG mentions that the focusing area “is at least as large as the area of a <code>1</code> CSS pixel thick perimeter of the unfocused component”, it also mentions that it needs to have “a contrast ratio of at least <code>3:1</code> against adjacent non-focus-indicator colors, or is <strong>no thinner than <code>2</code> CSS pixels.</strong>” So, a minimum thickness of <code>2px</code> is necessary to comply with WCAG.</p>\n<p>Remember that you might need a thicker line if you use a negative <code>outline-offset</code> because it’ll reduce the perimeter of the outline. Also, using a dashed or dotted outline will reduce the focused area roughly by half, so you’ll need a thicker line to compensate for it.</p>\n<p>The outline’s ideal area is related to the perimeter of the element. Sara Soueidan once again did a great job explaining how this formula works in <a href=\"https://www.sarasoueidan.com/blog/focus-indicators/#2.-minimum-contrasting-area\">her article about focus indicators</a>. So check it out if you want to understand better the maths behind this matter and how to apply them.</p>\n<h3>CSS Focus-related Selectors</h3>\n<p>With CSS, you normally use the pseudo-class <code>:focus</code> to give style to an element when it’s being focused by a keyboard, and it does its job well. But modern CSS has given us two new pseudo-classes, one that helps us with a certain use case and the other that solves an issue that happens when we use the <code>focus</code> pseudo-class. Those pseudo-classes are <code>:focus-within</code> and <code>:focus-visible</code>. Let’s dive into what they do and how they can help us with keyboard accessibility:</p>\n<h4><code>:focus-within</code></h4>\n<p>This pseudo-class will add a style whenever the element is being focused <em>or</em> any of the element’s children is also being focused. Let’s make a quick example to show how it looks:</p>\n<pre><code>&lt;form&gt;\n  &lt;label for=&quot;name&quot;&gt;\n    Name: \n    &lt;input id=&quot;name&quot; type=&quot;text&quot;&gt;\n  &lt;/label&gt;\n  &lt;label for=&quot;email&quot;&gt;\n    Email:\n    &lt;input for=&quot;email&quot; type=&quot;email&quot;&gt;\n  &lt;/label&gt;\n  &lt;button&gt;Submit&lt;/button&gt;\n&lt;/form&gt;\n</code></pre>\n\n<p><strong>Very quick tangent note</strong>: <em>Consider not using <code>label</code> to wrap the <code>input</code> element. While it works in all browsers, it doesn’t work well with <a href=\"https://www.nuance.com/dragon.html\">Dragon speech recognition software</a> because it won’t be recognized appropriately.</em></p>\n<pre><code>form {\n  display: grid;\n  gap: 1em;\n}\n\nlabel {\n  display: grid;\n  gap: 1em;\n  padding: 1em;\n}\n\nlabel:focus-within {\n  background-color: rebeccapurple;\n  color: white\n}\n</code></pre>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/6b176acc-d35d-45a1-8d0e-4b14fae35c4a/6-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p>This pseudo-class is interesting to enrich the styles of certain components, as previously shown, but in others, it helps a lot to make content accessible for keyboard users. For example, I created a card for <a href=\"https://www.smashingmagazine.com/2022/03/guide-hover-pointer-media-queries/\">my article about media queries <code>hover</code>, <code>pointer</code>, <code>any-hover</code>, and <code>any-pointer</code></a>. This card shows the content when the user puts the cursor on it, but it also shows the content when you focus the button inside of it using the <code>:focus-within</code> pseudo-class by using the same rules that are triggered on hover. You can check out the code in the mentioned article as well as in this CodePen:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/132cf902-895d-42bf-9fea-1157e9c3636c/7-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p>If you use keyboard navigation, you’ll notice the order is pretty straightforward. It reads from left to right and from top to bottom, and the navigation will be the same. Now let’s use grid properties to make some changes:</p>\n<pre><code>ul li:where(:nth-child(1), :nth-child(5), :nth-child(7), :nth-child(9)) {\n  grid-row: span 2;\n  grid-column: span 2\n}\n\nul li:where(:nth-child(1), :nth-child(5)) {\n  order: 2;\n}\n\nul li:where(:nth-child(7), :nth-child(8)) {\n  order: -1;\n}\n\nul li:nth-child(4) {\n  grid-row: 3;\n  grid-column: 2 / span 2;\n}\n\nul li:nth-child(3) {\n  grid-row: 5 / span 3;\n  grid-column: 3;\n}\n</code></pre>\n\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/d2a69f43-4a91-436c-bd77-8e9d7a62c2d5/8-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p>Now it looks completely disarrayed. Sure, the layout looks funny, but when you start navigating it with the Tab key, it’ll have a very random order. There is some degree of predictability now because I used numbers as the button’s label, but what happens if they have different content? It’d be impossible to predict which would be the next button to be focused on with a keyboard.</p>\n<p>This is the kind of scenario that needs to be avoided. It doesn’t mean you can’t explicitly order an element within a grid or use the <code>order</code> property. That means you need to be careful with managing your layouts and be sure the visual and DOM order matches as much as possible.</p>\n<p>By the way, if you want to try it by yourself, you can see the demo of this code here and experience this chaotic keyboard navigation by yourself:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/b41a92da-7a91-4505-a849-83959f7d18a4/9-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/35f0308c-23dd-4d1a-9e6d-d2952304c742/10-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p>Now let’s start styling this component! By default, this element uses this triangle to indicate if the <code>details</code> element is opened or closed. We can remove that by adding this rule to the <code>summary</code> element.</p>\n<pre><code>summary {\n  list-style: none;\n}\n</code></pre>\n\n<p>But we’ll still need a visual indicator to show if it’s opened or closed. My solution is to add a second element as a child of <code>summary</code>. The important part is that this element will have the attribute <code>aria-hidden=&quot;true&quot;</code>:</p>\n<pre><code>&lt;summary&gt;\n  &lt;p&gt;\n    How much does shipping cost?\n  &lt;/p&gt;\n  &lt;span aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;\n&lt;/summary&gt;\n</code></pre>\n\n<p>The reason why I hid this <code>span</code> element is that we’ll be modifying its content with CSS modifying the pseudo-element <code>::before</code>, and the content we add will be read by a screen reader unless, of course, we hide it from them.</p>\n<p>With that said, we can change it because the browser manages the open state of the <code>details</code> element by adding the attribute <code>open</code> to the container. So we can add and change the content using those CSS rules:</p>\n<pre><code>summary span[aria-hidden=&quot;true&quot;]::before {\n  content: &quot;+&quot;;\n}\n\ndetails[open] summary span[aria-hidden=&quot;true&quot;]::before {\n  content: &quot;-&quot;;\n}\n</code></pre>\n\n<p>Now, you can add the styling you need to adapt it (remember to use adequate focus states!). You can check this demo I made to see how it works. Test it with a keyboard, and you’ll notice you can interact with it without a problem.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/dd9d381e-e1a8-4b18-a75e-6924849298d4/11-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p>But there can be multiple skip links in a site that will lead you to various parts of the site, as Smashing Magazine does. When you use the Tab Key to navigate this website, you’ll notice there are three skip links, all of them taking you to important points of the page:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3b05d3d1-3a09-4cfd-bc13-6c882db2febc/12-guide-keyboard-accessibility-html-css-part1.png\"></p>\n<p>They’re usually located on the site’s header, but it’s not always the case. You can add them where needed, as Manuel Matuzović shows in this tweet. He added an inline skip link to a project because the interactive map has a lot of keyboard-focusable elements.</p>\n<p></p><blockquote><p>Working on a feature that allows users to skip areas with many tab stops (inline skip link). \uD83D\uDD25<br><br>Video alt: A page with a bunch of links followed by an embedded map. Pressing the Tab key reveals a link that, when activated, moves focus to the next tabbable element after the map. <a href=\"https://t.co/utSPgzs2Kh\">pic.twitter.com/utSPgzs2Kh</a></p>— Manuel Matuzović (@mmatuzo) <a href=\"https://twitter.com/mmatuzo/status/1511744226463305733?ref_src=twsrc%5Etfw\">April 6, 2022</a></blockquote> <p></p>\n<p>Now, as the usefulness of skip links is clear, let’s create one. It’s very simple; we just need to create an <code>a</code> element that takes you to the desired element:</p>\n<pre><code>&lt;header&gt;\n  &lt;a class=&quot;skip-link&quot; href=&quot;#main-content&quot;&gt;Go to main content&lt;/a&gt;\n&lt;/header&gt;\n&lt;main id=&quot;main-content&quot;&gt;&lt;/main&gt;\n</code></pre>\n\n<p>Next, we need to hide visually the <code>a</code> element. What I do there is use the <code>transform</code> CSS property to remove it from the visual range:</p>\n<pre><code>.skip-link {\n    display: block;\n    transform: translate(-9999px);\n}\n</code></pre>\n\n<p>Then, we move it to the needed position when the element is being focused:</p>\n<pre><code>.skip-link:focus {\n  transform: translate(0)\n}\n</code></pre>\n\n<p>And that’s it! Creating a skip link is easy and offers a lot of help for keyboard accessibility.</p>\n<h3>Tooltips</h3>\n<p>Those little text bubbles that show extra information to an element can be done with pure CSS as well, but a little disclaimer here: it is suggested that you can close a tooltip by pressing the Escape key, which it’s only possible with JavaScript. I’ll explain how to add this feature in the second part of this article, but everything else can be done in a very simple way using HTML and CSS only.</p>\n<p>A common problem with tooltips is that a keyboard user cannot see them, so we need to ensure the component that triggers it is a keyboard-focusable element. Our best bet here is using the <code>button</code> element. The semantics is really simple, as Heydon Pickering shows in his book <a href=\"https://inclusive-components.design/tooltips-toggletips/\">Inclusive Components</a>.</p>\n<pre><code>&lt;div class=&quot;tooltip-container&quot;&gt;\n  &lt;button&gt;\n  &lt;/button&gt;\n  &lt;div role=&quot;tooltip&quot;&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>The container with the class <code>tooltip-container</code> is there just to allow us to manipulate the container’s position with the attribute <code>role=&quot;tooltip&quot;</code> later using CSS. Speaking of this element, you would think this role adds enough semantics to make it work, but as a matter of fact, it doesn’t, so we’ll have to rely upon a couple of <code>aria</code> attributes to link it to our <code>button</code>.</p>\n<p>This attribute depends of what’s the intention of the tooltip. If you are planning to use it to <strong>name</strong> an element, you need to use the attribute <code>aria-labelledby</code>:</p>\n<pre><code>&lt;div class=&quot;tooltip-container&quot;&gt;\n  &lt;button aria-labelledby=&quot;tooltip1&quot;&gt;\n    &lt;svg aria-hidden=&quot;true&quot;&gt;\n      &lt;!--  SVG Content  --&gt;\n    &lt;/svg&gt;\n  &lt;/button&gt;\n        &lt;div id=&quot;tooltip1&quot; role=&quot;tooltip&quot;&gt;Shopping cart&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>However, if you want to use the tooltip to <strong>describe</strong> what an element does, you’ll need to link it using the attribute <code>aria-describedby</code>:</p>\n<pre><code>&lt;div class=&quot;tooltip-container&quot;&gt;\n  &lt;button aria-label=&quot;Shopping cart&quot; aria-describedby=&quot;tooltip2&quot;&gt;\n    &lt;svg aria-hidden=&quot;true&quot;&gt;\n      &lt;!--  SVG Content  --&gt;\n    &lt;/svg&gt;\n  &lt;/button&gt;\n  &lt;div id=&quot;tooltip2&quot; role=&quot;tooltip&quot;&gt;Check, modify and finish your purchase&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Be careful with this approach; use it only to give auxiliary descriptions, not to give information that is absolutely necessary to understand what this element does. That’s because when a screen reader user generates a list of the form elements (including buttons) in the site, the description won’t be displayed unless the user is focusing on the element, as Adrian Roselli shows in <a href=\"https://adrianroselli.com/2022/04/accessible-description-exposure.html\">his test on <code>aria-description</code> attribute</a>.</p>\n<p>Now, it’s time to talk about what concerns us in this article — keyboard accessibility! For this, we need to hide the tooltip and show it until the user is either focusing the pointer on the element or when it’s being focused with a keyboard. For this, we’ll use the <code>:hover</code> and <code>:focus</code> pseudo-classes in tandem with the <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Adjacent_sibling_combinator\">adjacent sibling combinator</a>.</p>\n<p>Additionally, it’s important you can see the tooltip when you hover over it to comply with <a href=\"https://www.w3.org/TR/WCAG22/#content-on-hover-or-focus\">WCAG Criterion 1.4.13: Content on Hover or Focus</a>. With those considerations in mind, this is how our code should look:</p>\n<div>\n<pre><code>[role=&quot;tooltip&quot;] {\n  position: absolute;\n  bottom: 0;\n  left: 50%;\n  display: none;\n  transform: translate(-50%, 100%);<br>}\n\nbutton:hover + [role=&quot;tooltip&quot;], button:focus + [role=&quot;tooltip&quot;], [role=&quot;tooltip&quot;]:hover {\n  display: block;\n}\n</code></pre>\n</div>\n\n<p>And this is how you create a keyboard-accessible tooltip using HTML and CSS. You can check how both examples of tooltip behave in this demo. Remember, this is not fully ready for production. You need JavaScript to close the tooltip when you press the Esc key. We’ll cover that later in the next part of this article, so keep it in mind.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/Vwxdjbe\">Tooltip demo - CSS only [forked]</a> by <a href=\"https://codepen.io/ItsCrisDiaz\">Cristian Diaz</a>.</p>\n<p>As Heydon mentions in his book, tooltips have a problem when you use them for devices that don’t have a pointer, like cellphones or tablets, then a different approach for them is required. You can use CSS for that using the <a href=\"https://www.smashingmagazine.com/2022/03/guide-hover-pointer-media-queries/\">media queries <code>hover</code> and <code>pointer</code></a>, as I explain in my article.</p>\nWrapping Up\n<p>Keyboard accessibility is an essential part of accessibility. I hope this article has helped you understand how vital HTML and CSS are to make keyboard navigation a good and accessible user experience. That’s not the end of keyboard accessibility, though! I’ll be covering how we can use JavaScript to manipulate keyboard navigation and how we can use it in more complex component patterns.</p>\n"
}