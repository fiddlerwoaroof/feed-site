{
  "title":"Motion Controls In The Browser",
  "date":"2022-10-28T14:00:00.000000Z",
  "author":null,
  "id":"https://smashingmagazine.com/2022/10/motion-controls-browser/",
  "link":"https://smashingmagazine.com/2022/10/motion-controls-browser/",
  "content":"<p>In this article, I’m going to explain how to implement motion controls in the browser. That means you’ll be able to create an application where you can move your hand and make gestures, and the elements on the screen will respond.</p>\n<p>Here’s an example:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/8b928505-2b2a-40be-95c7-b40213077631/1-motion-controls-in-browser.png\"></p>\n<p>Here’s some boilerplate to get started (adapted from MediaPipe’s <a href=\"https://google.github.io/mediapipe/solutions/hands.html#javascript-solution-api\">JavaScript API example</a>):</p>\n<div>\n<pre><code>&lt;script src=&quot;<a href=\"https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js&quot;\">https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js&quot;</a> crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;<a href=\"https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js&quot;\">https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js&quot;</a> crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;<a href=\"https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js&quot;\">https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js&quot;</a> crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;\n&lt;script src=&quot;<a href=\"https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js&quot;\">https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js&quot;</a> crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt;\n\n&lt;video class=&quot;input_video&quot;&gt;&lt;/video&gt;\n&lt;canvas class=&quot;output_canvas&quot; width=&quot;1280px&quot; height=&quot;720px&quot;&gt;&lt;/canvas&gt;\n\n&lt;script&gt;\nconst videoElement = document.querySelector('.input_video');\nconst canvasElement = document.querySelector('.output_canvas');\nconst canvasCtx = canvasElement.getContext('2d');\n\nfunction onResults(handData) {\n  drawHandPositions(canvasElement, canvasCtx, handData);\n}\n\nfunction drawHandPositions(canvasElement, canvasCtx, handData) {\n  canvasCtx.save();\n  canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);\n  canvasCtx.drawImage(\n      handData.image, 0, 0, canvasElement.width, canvasElement.height);\n  if (handData.multiHandLandmarks) {\n    for (const landmarks of handData.multiHandLandmarks) {\n      drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS,\n                     {color: '#00FF00', lineWidth: 5});\n      drawLandmarks(canvasCtx, landmarks, {color: '#FF0000', lineWidth: 2});\n    }\n  }\n  canvasCtx.restore();\n}\n\nconst hands = new Hands({locateFile: (file) =&gt; {\n  return <code>https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}</code>;\n}});\nhands.setOptions({\n  maxNumHands: 1,\n  modelComplexity: 1,\n  minDetectionConfidence: 0.5,\n  minTrackingConfidence: 0.5\n});\nhands.onResults(onResults);\n\nconst camera = new Camera(videoElement, {\n  onFrame: async () =&gt; {\n    await hands.send({image: videoElement});\n  },\n  width: 1280,\n  height: 720\n});\ncamera.start();\n\n&lt;/script&gt;\n</code></pre>\n</div>\n\n<p>The above code does the following:</p>\n<ul>\n<li>Load the library code;</li>\n<li>Start recording the video frames;</li>\n<li>When the hand data comes in, draw the hand landmarks on a canvas.</li>\n</ul>\n<p>Let’s take a closer look at the <code>handData</code> object since that’s where the magic happens. Inside <code>handData</code> is <code>multiHandLandmarks</code>, a collection of 21 coordinates for the parts of each hand detected in the video feed. Here’s how those coordinates are structured:</p>\n<pre><code>{\n  multiHandLandmarks: [\n    // First detected hand.\n    [\n      {x: 0.4, y: 0.8, z: 4.5},\n      {x: 0.5, y: 0.3, z: -0.03},\n      // ...etc.\n    ],\n\n    // Second detected hand.\n    [\n      {x: 0.4, y: 0.8, z: 4.5},\n      {x: 0.5, y: 0.3, z: -0.03},\n      // ...etc.\n    ],\n\n    // More hands if other people participate.\n  ]\n}\n</code></pre>\n\n<p>A couple of notes:</p>\n<ul>\n<li>The first hand doesn’t necessarily mean the right or the left hand; it’s just whichever one the application happens to detect first. If you want to get a specific hand, you’ll need to check which hand is being detected using <code>handData.multiHandedness[0].label</code> and potentially swapping the values if your camera isn’t mirrored.</li>\n<li>For performance reasons, you can restrict the maximum number of hands to track, which we did earlier by setting <code>maxNumHands: 1</code>.</li>\n<li>The coordinates are set on a scale from <code>0</code> to <code>1</code> based on the size of the canvas.</li>\n</ul>\n<p>Here’s a visual representation of the hand coordinates:</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/be31d316-6994-408d-a5fa-b4288fbb7371/2-motion-controls-in-browser.jpg\"></p>\n<p>Now that you have the hand landmark coordinates, you can build a cursor to follow your index finger. To do that, you’ll need to get the index finger’s coordinates.</p>\n<p>You could use the array directly like this <code>handData.multiHandLandmarks[0][5]</code>, but I find that hard to keep track of, so I prefer labeling the coordinates like this:</p>\n<pre><code>const handParts = {\n  wrist: 0,\n  thumb: { base: 1, middle: 2, topKnuckle: 3, tip: 4 },\n  indexFinger: { base: 5, middle: 6, topKnuckle: 7, tip: 8 },\n  middleFinger: { base: 9, middle: 10, topKnuckle: 11, tip: 12 },\n  ringFinger: { base: 13, middle: 14, topKnuckle: 15, tip: 16 },\n  pinky: { base: 17, middle: 18, topKnuckle: 19, tip: 20 },\n};\n</code></pre>\n\n<p>And then you can get the coordinates like this:</p>\n<pre><code>const firstDetectedHand = handData.multiHandLandmarks[0];\nconst indexFingerCoords = firstDetectedHand[handParts.index.middle];\n</code></pre>\n\n<p>I found cursor movement more pleasant to use with the middle part of the index finger rather than the tip because the middle is more steady.</p>\n<p>Now you’ll need to make a DOM element to use as a cursor. Here’s the markup:</p>\n<pre><code>&lt;div class=&quot;cursor&quot;&gt;&lt;/div&gt;\n</code></pre>\n\n<p>And here are the styles:</p>\n<pre><code>.cursor {\n  height: 0px;\n  width: 0px;\n  position: absolute;\n  left: 0px;\n  top: 0px;\n  z-index: 10;\n  transition: transform 0.1s;\n}\n\n.cursor::after {\n  content: '';\n  display: block;\n  height: 50px;\n  width: 50px;\n  border-radius: 50%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  transform: translate(-50%, -50%);\n  background-color: #0098db;\n}\n</code></pre>\n\n<p>A few notes about these styles:</p>\n<ul>\n<li>The cursor is absolutely positioned so it can be moved without affecting the flow of the document.</li>\n<li>The visual part of the cursor is in the <code>::after</code> pseudo-element, and the <code>transform</code> makes sure the visual part of the cursor is centered around the cursor’s coordinates.</li>\n<li>The cursor has a <code>transition</code> to smooth out its movements.</li>\n</ul>\n<p>Now that we’ve created a cursor element, we can move it by converting the hand coordinates into page coordinates and applying those page coordinates to the cursor element.</p>\n<div>\n<pre><code>function getCursorCoords(handData) {\n  const { x, y, z } = handData.multiHandLandmarks[0][handParts.indexFinger.middle];\n  const mirroredXCoord = -x + 1; /* due to camera mirroring */\n  return { x: mirroredXCoord, y, z };\n}\n\nfunction convertCoordsToDomPosition({ x, y }) {\n  return {\n    x: <code>${x &amp;#42; 100}vw</code>,\n    y: <code>${y &amp;#42; 100}vh</code>,\n  };\n}\n\nfunction updateCursor(handData) {\n  const cursorCoords = getCursorCoords(handData);\n  if (!cursorCoords) { return; }\n  const { x, y } = convertCoordsToDomPosition(cursorCoords);\n  cursor.style.transform = <code>translate(${x}, ${y})</code>;\n}\n\nfunction onResults(handData) {\n  if (!handData) { return; }\n  updateCursor(handData);\n}\n</code></pre>\n</div>\n\n<p>Note that we’re using the CSS <code>transform</code> property to move the element rather than <code>left</code> and <code>top</code>. This is for performance reasons. When the browser renders a view, it goes through a <a href=\"https://web.dev/rendering-performance/#the-pixel-pipeline\">sequence of steps</a>. When the DOM changes, the browser has to start again at the relevant rendering step. The <code>transform</code> property responds quickly to changes because it is applied at the last step rather than one of the middle steps, and therefore the browser has less work to repeat.</p>\n<p>Now that we have a working cursor, we’re ready to move on.</p>\nStep 3: Detect Gestures\n<p>The next step in our journey is to detect gestures, specifically <strong>pinch gestures</strong>.</p>\n<p>First, what do we mean by a pinch? In this case, we’ll define a pinch as a gesture where the thumb and forefinger are close enough together.</p>\n<p>To designate a pinch in code, we can look at when the <code>x</code>, <code>y</code>, and <code>z</code> coordinates of the thumb and forefinger have a small enough difference between them. “Small enough” can vary depending on the use case, so feel free to experiment with different ranges. Personally, I found <code>0.08</code>, <code>0.08</code>, and <code>0.11</code> to be comfortable for the <code>x</code>, <code>y</code>, and <code>z</code> coordinates, respectively. Here’s how that looks:</p>\n<div>\n<pre><code>function isPinched(handData) {\n  const fingerTip = handData.multiHandLandmarks[0][handParts.indexFinger.tip];\n  const thumbTip = handData.multiHandLandmarks[0][handParts.thumb.tip];\n  const distance = {\n    x: Math.abs(fingerTip.x - thumbTip.x),\n    y: Math.abs(fingerTip.y - thumbTip.y),\n    z: Math.abs(fingerTip.z - thumbTip.z),\n  };\n  const areFingersCloseEnough = distance.x &lt; 0.08 &amp;&amp; distance.y &lt; 0.08 &amp;&amp; distance.z &lt; 0.11;\n\n  return areFingersCloseEnough;\n}\n</code></pre>\n</div>\n\n<p>It would be nice if that’s all we had to do, but alas, it’s never that simple.</p>\n<p>What happens when your fingers are on the edge of a pinch position? If we’re not careful, the answer is chaos.</p>\n<p>With slight finger movements as well as fluctuations in coordinate detection, our program can rapidly alternate between pinched and not pinched states. If you’re trying to use a pinch gesture to “pick up” an item on the screen, you can imagine how chaotic it would be for the item to rapidly alternate between being picked up and dropped.</p>\n<p>In order to prevent our pinch gestures from causing chaos, we’ll need to introduce a slight delay before registering a change from a pinched state to an unpinched state or vice versa. This technique is called a <a href=\"https://davidwalsh.name/javascript-debounce-function\"><code>debounce</code></a>, and the logic goes like this:</p>\n<ul>\n<li>When the fingers enter a pinched state, start a timer.</li>\n<li>If the fingers have stayed in the pinched state uninterrupted for long enough, register a change.</li>\n<li>If the pinched state gets interrupted too soon, stop the timer and don’t register a change.</li>\n</ul>\n<p>The trick is that the delay must be long enough to be reliable but short enough to feel quick.</p>\n<p>We’ll get to the debounce code soon, but first, we need to prepare by tracking the state of our gestures:</p>\n<pre><code>const OPTIONS = {\n  PINCH_DELAY_MS: 60,\n};\n\nconst state = {\n  isPinched: false,\n  pinchChangeTimeout: null,\n};\n</code></pre>\n\n<p>Next, we’ll prepare some <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\">custom events</a> to make it convenient to respond to gestures:</p>\n<pre><code>const PINCH_EVENTS = {\n  START: 'pinch_start',\n  MOVE: 'pinch_move',\n  STOP: 'pinch_stop',\n};\n\nfunction triggerEvent({ eventName, eventData }) {\n  const event = new CustomEvent(eventName, { detail: eventData });\n  document.dispatchEvent(event);\n}\n</code></pre>\n\n<p>Now we can write a function to update the pinched state:</p>\n<pre><code>function updatePinchState(handData) {\n  const wasPinchedBefore = state.isPinched;\n  const isPinchedNow = isPinched(handData);\n  const hasPassedPinchThreshold = isPinchedNow !== wasPinchedBefore;\n  const hasWaitStarted = !!state.pinchChangeTimeout;\n\n  if (hasPassedPinchThreshold &amp;&amp; !hasWaitStarted) {\n    registerChangeAfterWait(handData, isPinchedNow);\n  }\n\n  if (!hasPassedPinchThreshold) {\n    cancelWaitForChange();\n    if (isPinchedNow) {\n      triggerEvent({\n        eventName: PINCH_EVENTS.MOVE,\n        eventData: getCursorCoords(handData),\n      });\n    }\n  }\n}\n\nfunction registerChangeAfterWait(handData, isPinchedNow) {\n  state.pinchChangeTimeout = setTimeout(() =&gt; {\n    state.isPinched = isPinchedNow;\n    triggerEvent({\n      eventName: isPinchedNow ? PINCH_EVENTS.START : PINCH_EVENTS.STOP,\n      eventData: getCursorCoords(handData),\n    });\n  }, OPTIONS.PINCH_DELAY_MS);\n}\n\nfunction cancelWaitForChange() {\n  clearTimeout(state.pinchChangeTimeout);\n  state.pinchChangeTimeout = null;\n}\n</code></pre>\n\n<p>Here's what <code>updatePinchState()</code> is doing:</p>\n<ul>\n<li>If the fingers have passed the pinch threshold by starting or stopping a pinch, we’ll start a timer to wait and see if we can register a legitimate pinch state change.</li>\n<li>If the wait is interrupted, that means the change was just a fluctuation, so we can cancel the timer.</li>\n<li>However, if the timer is <em>not</em> interrupted, we can update the pinched state and trigger the correct custom change event, namely, <code>pinch_start</code> or <code>pinch_stop</code>.</li>\n<li>If the fingers have not passed the pinch change threshold and are currently pinched, we can dispatch a custom <code>pinch_move</code> event.</li>\n</ul>\n<p>We can run <code>updatePinchState(handData)</code> each time we get hand data so that we can put it in our <code>onResults</code> function like this:</p>\n<pre><code>function onResults(handData) {\n  if (!handData) { return; }\n  updateCursor(handData);\n  updatePinchState(handData);\n}\n</code></pre>\n\n<p>Now that we can reliably detect a pinch state change, we can use our custom events to define whatever behavior we want when a pinch is started, moved, or stopped. Here’s an example:</p>\n<pre><code>document.addEventListener(PINCH_EVENTS.START, onPinchStart);\ndocument.addEventListener(PINCH_EVENTS.MOVE, onPinchMove);\ndocument.addEventListener(PINCH_EVENTS.STOP, onPinchStop);\n\nfunction onPinchStart(eventInfo) {\n  const cursorCoords = eventInfo.detail;\n  console.log('Pinch started', cursorCoords);\n}\n\nfunction onPinchMove(eventInfo) {\n  const cursorCoords = eventInfo.detail;\n  console.log('Pinch moved', cursorCoords);\n}\n\nfunction onPinchStop(eventInfo) {\n  const cursorCoords = eventInfo.detail;\n  console.log('Pinch stopped', cursorCoords);\n}\n</code></pre>\n\n<p>Now that we’ve covered how to respond to movements and gestures, we have everything we need to build an application that can be controlled with hand motions.</p>\n<p>Here are some examples:</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/WNybveM\">Beam Sword - Fun with motion controls! [forked]</a> by <a href=\"https://codepen.io/yaphi1\">Yaphi</a>.</p>\n<p>See the Pen <a href=\"https://codepen.io/smashingmag/pen/OJEPVJj\">Magic Quill - Air writing with motion controls [forked]</a> by <a href=\"https://codepen.io/yaphi1\">Yaphi</a>.</p>\n<p>I’ve also put together some other motion control demos, including <a href=\"https://magic-hand.vercel.app/cards.html\">movable playing cards</a> and an <a href=\"https://magic-hand.vercel.app/floor_plan.html\">apartment floor plan</a> with movable images of the furniture, and I’m sure you can think of other ways to experiment with this technology.</p>\nConclusion\n<p>If you’ve made it this far, you’ve seen how to implement motion controls with a browser and a webcam. You’ve read camera data using browser APIs, you’ve gotten hand coordinates via machine learning, and you’ve detected hand motions with JavaScript. With these ingredients, you can create all sorts of motion-controlled applications.</p>\n<p>What use cases will you come up with? Let me know in the comments!</p>\n"
}