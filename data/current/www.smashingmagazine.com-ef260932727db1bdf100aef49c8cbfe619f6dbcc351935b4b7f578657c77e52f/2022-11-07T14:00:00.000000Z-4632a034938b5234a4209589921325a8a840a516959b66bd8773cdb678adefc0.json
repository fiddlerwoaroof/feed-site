{
  "title":"What’s New In Next.js 13?",
  "date":"2022-11-07T14:00:00.000000Z",
  "author":null,
  "id":"https://smashingmagazine.com/2022/11/whats-new-nextjs-13/",
  "link":"https://smashingmagazine.com/2022/11/whats-new-nextjs-13/",
  "content":"<p>October has come and gone, and with it, Next.js has released a new major version packed (pun intended) with tons of new features — some of which can be seamlessly adopted from your Next.js 12 app, while others not so much.</p>\n<p>If you’re just jumping on the bandwagon, it may be confusing to distinguish the hype, the misinformation, and what’s stable for your production apps, but fear not! I’m here to give you a nice overview and get you up to speed.</p>\nWhat Misinformation?\n<p>As with all Next.js releases, there are a few APIs that are moved into the stable core and for recommended use, and there are others still in the experimental channel. “Experimental” APIs are still up for debate. The main functionality is there, but the question of <strong>how these APIs behave and how they can be used</strong> is still susceptible to change as there may be bugs or unexpected side effects.</p>\n<p>In version 13, the experimental releases were big and took over the spotlight. This caused many people to consider the whole release unstable and experimental — but it’s not. Next.js 13 is actually quite stable and <strong>allows for a smooth upgrade from version 12</strong> if you don’t intend to adopt any experimental API. Most changes can be incrementally adopted, which we’ll get into detail later in this post.</p>\nReleases Summary\n<p>Before we dig deeper into what each announcement entails, let’s check on a quick list and balance experiments and stable features.</p>\n<h4>Experimental</h4>\n<ul>\n<li>App Directory;</li>\n<li>New Bundler (Turbopack);</li>\n<li>Font Optimization.</li>\n</ul>\n<h4>Stable</h4>\n<ul>\n<li>“New” Image Component to replace legacy <code>Image</code> component as default;</li>\n<li>ES Module Support for <code>next.config.mjs</code>;</li>\n<li>“New” <code>Link</code> component.</li>\n</ul>\nThe App Directory\n<p>This feature is actually a big architectural rewrite. It puts React Server Components front and center, leverages a whole new routing system and router hooks (under <code>next/navigation</code> instead of <code>next/router</code>), and flips the entire data-fetching story.</p>\n<p>This is all meant to enable big performance improvements, like eagerly rendering each part of your view which doesn’t depend on data while <strong>suspending</strong> (you read that right!) the pieces which are fetching data and getting rendered on the server.</p>\n<p>As a consequence, this also brings a huge mental model change to how you architect your Next.js app.</p>\n<p>Let’s compare how things were versus how they will work in the App directory. When using the <code>/pages</code> directory (the architecture we have been using up to now), data is fetched from the page level and is cascaded down toward the leaf components.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/2baebac0-1cfe-4ca8-a180-d3828a764978/visualization-architecture-app-directory-feature.png\"></p>\n<p>In contrast, given that the app directory is powered by Server Components, <strong>each component is in charge of its own data</strong>, meaning you can now <em>fetch-then-render</em> every component you need and cache them individually, performing <a href=\"https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration\">Incremental Static Regeneration (ISR)</a> at a much more granular level.</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/647ff188-e91c-4864-9059-39f8455b1e61/visualization-fetch-then-render.png\"></p>\n<p>Additionally, Next.js will carry on optimizations: Requests will be deduped (not allowing different components to fire the same request in parallel), thanks to a change in how the <code>fetch</code> runtime method works with the cache. By default, all requests will use strong cache heuristics (“force-cache”), which can be opted out via configuration.</p>\n<blockquote>You read it right. Next.js and React Server Components both interfere with the <code>fetch</code> standard in order to provide resource-fetching optimisations.</blockquote>\n\n<h3>You Don’t Need To Go &quot;All-In&quot;</h3>\n<p>It is important to point out that the transition from the <code>/pages</code> architecture to <code>/app</code> can be done incrementally, and both solutions can coexist as long as routes don’t overlap. There’s currently <strong>no mention</strong> in Next.js’ roadmap about deprecating support for <code>/pages</code>.</p>\n<p><strong>Recommended Reading</strong>: <em><a href=\"https://www.smashingmagazine.com/2021/07/isr-dpr-explained/\">ISR vs DPR: Big Words, Quick Explanation</a> by Cassidy Williams</em></p>\nNew Bundler And Benchmarks\n<p>Since its first release, Next.js has used <a href=\"https://webpack.js.org/\">webpack</a> under the hood. This year, we have watched a new generation of bundlers, written in low-level languages, popping up, such as ESBuild (which powers Vite), Parcel 2 (Rust), and others. We have also watched Vercel setting the stage for a big change in Next.js. In version 12, they added <a href=\"https://swc.rs/\">SWC</a> to their build and transpilation process as a step to replacing both <a href=\"https://babeljs.io/\">Babel</a> and <a href=\"https://github.com/terser/terser\">Terser</a>.  </p>\n<p>In version 13, they announced Turbopack, a new bundler written in Rust with very <a href=\"https://nextjs.org/blog/next-13#introducing-turbopack-alpha\">bold performance claims</a>. Yes, there has been controversy on Twitter about which bundler is the fastest overall and how those benchmarks were measured. Still, it’s beyond debate how much Turbopack can actually help large projects written in Next.js with way better ergonomics than any other tool (for starters, with built-in configuration).</p>\n<blockquote>This feature is not only experimental but actually only works with <code>next dev</code>. You should not (and as of now <strong> can’t </strong>) use it for a production build.</blockquote>\n\n\n\nFont Optimization\n<p>The new <code>@next/font</code> module allows making performance optimization to your Web Fonts during build time. It will download the font assets during build-time and host them in your very own <code>/public</code> folder. This will save a round-trip to a further server, avoid an additional handshake, and ultimately deliver your font in the fastest way possible and cache it properly with the rest of your resources.</p>\n<p>Remember that when using this package, the it's important to have a working internet connection when you run your development build the first time so it can cache it properly, otherwise it will fallback to system fonts if <a href=\"https://nextjs.org/docs/api-reference/next/font#adjustfontfallback\"><code>adjustFontFallback</code> is not set</a>.</p>\n<p>Additionally, <code>@next/font</code> has a special module for Google Web Fonts, conveniently available as they are widely used:</p>\n<pre><code>import { Jost } from '@next/font/google';\n// get an object with font styles:\nconst jost = Jost();\n// define them in your component:\n&lt;html className={jost.className}&gt;\n</code></pre>\n\n<p>The module will also work in case you use custom fonts:</p>\n<pre><code>import localFont from '@next/font/local';\n</code></pre>\n\n<pre><code>const myFont = localFont({ src: './my-font.woff2' });\n</code></pre>\n\n<pre><code>&lt;html className={myFont.className}&gt;\n</code></pre>\n\n<p>Even though this feature is still in Beta, it is considered stable enough for you to use in production.</p>\nNew Image And Link Components\n<p>Arguably the most important components within the Next.js package have received a slight overhaul. Next <code>Image</code> has been living a double life since Next.js 12 in <code>@next/image</code> and <code>@next/future/image</code>. In Next.js 13, the default component is switched:</p>\n<ul>\n<li><code>next/image</code> moves to <code>next/legacy/image</code>;</li>\n<li><code>next/future/image</code> moves to <code>next/image</code>.</li>\n</ul>\n<p>This change comes with a codemod, a command that attempts to automigrate the code in your app. This allows for a smooth migration when upgrading Next.js:</p>\n<pre><code>npx @next/codemod next-image-to-legacy-image ./pages\n</code></pre>\n\n<p>If you make this change and do not have visual regression tests set up, I'd recommend taking a good look at your pages in every major browser to see if everything looks correct.</p>\n<p>For the new Link component, the change should also be smooth. The <code>&lt;a&gt;</code> element within <code>&lt;Link&gt;</code> is not necessary <em>nor recommended</em> anymore. The codemod will either remove it or add a <code>legacyBehavior</code> prop to your component.</p>\n<pre><code>npx @next/codemod new-link ./pages\n</code></pre>\n\n<p>In case the codemod fails, you will receive a linting warning on dev, so keep an eye on your terminal!</p>\nES Modules and Automatic Module Transpilation\n<p>There two upgrades have passed under the radar for most, but I consider them <strong>especially useful for people working with Monorepos</strong>. Up until now, it was not very ergonomic to share configuration between configuration files and other files that may be used in runtime. That’s because <code>next.config.js</code> is written with CommonJS as the module system, which can't import from ESM files. Now, Next.js supports ESM simply by adding <code>type: &quot;module&quot;</code> to your <code>package.json</code> and renaming <code>next.config.js</code> → <code>next.config.mjs</code>.</p>\n<p><strong>Note</strong>: <em>The “m” stands for “module” and is part of the Node.js spec for ESM support.</em></p>\n<p>For Monorepos using internal packages (JavaScript packages that are not published to NPM but instead are consumed from source by sibling apps within the monorepo), a special plugin was necessary to transpile those modules on build-time when consuming them. From Next.js 13 onwards, <strong>this can be arranged without a plugin</strong> by simply passing an (experimental) property to your <code>next.config.mjs</code>:</p>\n<pre><code>const nextConfig = {\n  experimental: {\n    transpilePackages: ['@my-org/internal-package'],\n  },\n};\n</code></pre>\n\n<p>You can see an example in the <a href=\"https://github.com/atilafassina/apex-monorepo/blob/main/apps/web/next.config.mjs#L8\">Apex-Monorepo template</a>. With these settings, it is possible to develop both the dependency component and your app simultaneously without any publishing or workaround.</p>\nWhat’s <em>Next</em>?\n<p>If you’re still interested in playing around and talking more about these features, I’ll be running a <a href=\"https://smashingconf.com/online-workshops/workshops/advanced-nextjs-atila-fassina\">Advanced Next.js Masterclass</a> from Nov 30 – Dec 15, 2022 — I’d be super happy to welcome you there and answer all of your questions!</p>\n<p><img src=\"https://cloud.netlifyusercontent.com/assets/344dbf88-fdf9-42bb-adb4-46f01eedd629/3109fc33-fce0-412e-99c2-da019c2eb6bb/workshops-advanced-nextjs-atila-fassina.png\"></p>\n<p>Until then, let me know in the comments below or tweet over to me at <a href=\"https://atila.io/twitter\">@AtilaFassina</a> on how your migration has been and your thoughts on the experimental features.</p>\n"
}