{
  "title":"Namespaced De Bruijn indices",
  "date":"2021-08-14T13:01:54.620000-07:00",
  "author":"Gabriel Gonzalez",
  "id":"tag:blogger.com,1999:blog-1777990983847811806.post-6319221858421997722",
  "link":"https://www.haskellforall.com/2021/08/namespaced-de-bruijn-indices.html",
  "content":"<!DOCTYPE html><html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\"><head>            </head><body><p>In this post I share a trick I use for dealing with bound variables in <a href=\"https://dhall-lang.org/\">Dhall</a> that I thought might be useful for other interpreted programming languages. I have no idea if this trick has been introduced before but if it has then just let me know and I’ll acknowledge any prior art here.</p><p>Edit: Todd Wilson points out that Mark-Oliver Stehr’s <a href=\"https://www.sciencedirect.com/science/article/pii/S1571066105801252\">CINNI</a> originally introduced this idea.</p><p>The brief explanation of the trick is: instead of choosing between a named or a nameless representation for bound variables you can get the best of both worlds by namespacing De Bruijn indices by variable names. This simplifies the implementation and in some cases improves the end user’s experience.</p><p>The rest of this post is a longer explanation of the above summary, starting with an explanation of the trick and followed by a review of the benefits of this approach.</p><h4 id=\"background\">Background</h4><p>I’d like to first explain what I mean by “named” and “nameless” representations before I explain the trick.</p><p>A named representation of the lambda calculus syntax tree typically looks something like this:</p><div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" tabindex=\"-1\"/><span class=\"kw\">data</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb1-2\"><a href=\"#cb1-2\" tabindex=\"-1\"/>    <span class=\"ot\">=</span> <span class=\"dt\">Variable</span> <span class=\"dt\">String</span></span><br><span id=\"cb1-3\"><a href=\"#cb1-3\" tabindex=\"-1\"/>    <span class=\"op\">|</span> <span class=\"dt\">Lambda</span> <span class=\"dt\">String</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb1-4\"><a href=\"#cb1-4\" tabindex=\"-1\"/>    <span class=\"op\">|</span> <span class=\"dt\">Apply</span> <span class=\"dt\">Syntax</span> <span class=\"dt\">Syntax</span></span></code></pre></div><p>For example, if the user wrote the following Haskell-like code:</p><div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb2-1\"><a href=\"#cb2-1\" tabindex=\"-1\"/>\\f <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> f x</span></code></pre></div><p>… then that would correspond to this syntax tree:</p><div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb3-1\"><a href=\"#cb3-1\" tabindex=\"-1\"/><span class=\"ot\">example ::</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb3-2\"><a href=\"#cb3-2\" tabindex=\"-1\"/>example <span class=\"ot\">=</span> <span class=\"dt\">Lambda</span> <span class=\"st\">&quot;f&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Apply</span> (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;f&quot;</span>) (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;x&quot;</span>)))</span></code></pre></div><p>The named representation has the nice property that it preserves the original variable names … well, sort of. This representation definitely preserves the variable names when you initially parse the code into the syntax tree, but if you β-reduce an expression you can potentially run into problems.</p><p>For example, consider this expression:</p><div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb4-1\"><a href=\"#cb4-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> (\\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> y) x</span></code></pre></div><p>… which corresponds to this syntax tree:</p><div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb5-1\"><a href=\"#cb5-1\" tabindex=\"-1\"/><span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Apply</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;y&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;y&quot;</span>))) (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;x&quot;</span>))</span></code></pre></div><p>If you try to β-reduce <code>(\\y -&gt; \\x -&gt; y) x</code> without renaming any variables then you get the following incorrect result:</p><div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb6-1\"><a href=\"#cb6-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x</span></code></pre></div><p>This bug is known as “name capture” and capture-avoiding substitution requires renaming one of the variables named <code>x</code> so that the inner <code>x</code> does not shadow the outer <code>x</code>. For example, we could fix the problem by renaming the outer <code>x</code> to <code>x1</code> like this:</p><div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb7-1\"><a href=\"#cb7-1\" tabindex=\"-1\"/>\\x1 <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x1</span></code></pre></div><p>A nameless representation tries to work around these name capture issues by replacing the variable names with numeric indices (known as <a href=\"https://en.wikipedia.org/wiki/De_Bruijn_index\">De Bruijn indices</a>):</p><div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb8-1\"><a href=\"#cb8-1\" tabindex=\"-1\"/><span class=\"kw\">data</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb8-2\"><a href=\"#cb8-2\" tabindex=\"-1\"/>    <span class=\"ot\">=</span> <span class=\"dt\">Variable</span> <span class=\"dt\">Int</span></span><br><span id=\"cb8-3\"><a href=\"#cb8-3\" tabindex=\"-1\"/>    <span class=\"op\">|</span> <span class=\"dt\">Lambda</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb8-4\"><a href=\"#cb8-4\" tabindex=\"-1\"/>    <span class=\"op\">|</span> <span class=\"dt\">Apply</span> <span class=\"dt\">Syntax</span> <span class=\"dt\">Syntax</span></span></code></pre></div><p>For example, code like this:</p><div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb9-1\"><a href=\"#cb9-1\" tabindex=\"-1\"/>\\f <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> f x</span></code></pre></div><p>… corresponds to this nameless representation:</p><div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb10-1\"><a href=\"#cb10-1\" tabindex=\"-1\"/><span class=\"ot\">example ::</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb10-2\"><a href=\"#cb10-2\" tabindex=\"-1\"/>example <span class=\"ot\">=</span> <span class=\"dt\">Lambda</span> (<span class=\"dt\">Lambda</span> (<span class=\"dt\">Apply</span> (<span class=\"dt\">Variable</span> <span class=\"dv\">1</span>) (<span class=\"dt\">Variable</span> <span class=\"dv\">0</span>)))</span></code></pre></div><p>Carefully note that the <code>Lambda</code> constructor now has no field for the bound variable name, so it’s as if the user had instead written:</p><div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb11-1\"><a href=\"#cb11-1\" tabindex=\"-1\"/>\\ <span class=\"ot\">-&gt;</span> \\ <span class=\"ot\">-&gt;</span> <span class=\"op\">@</span><span class=\"dv\">1</span> <span class=\"op\">@</span><span class=\"dv\">0</span></span></code></pre></div><p>… using <code>@n</code> to represent the variable whose De Bruijn index is <code>n</code>.</p><p>The numeric De Bruijn indices refer to bound variables. Specifically, the numeric index <code>0</code> refers to the “closest” or “innermost” variable bound by a lambda:</p><div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb12-1\"><a href=\"#cb12-1\" tabindex=\"-1\"/><span class=\"co\">--                This 0 index …</span></span><br><span id=\"cb12-2\"><a href=\"#cb12-2\" tabindex=\"-1\"/><span class=\"co\">--                ↓</span></span><br><span id=\"cb12-3\"><a href=\"#cb12-3\" tabindex=\"-1\"/>    \\ <span class=\"ot\">-&gt;</span> \\ <span class=\"ot\">-&gt;</span> <span class=\"op\">@</span><span class=\"dv\">1</span> <span class=\"op\">@</span><span class=\"dv\">0</span></span><br><span id=\"cb12-4\"><a href=\"#cb12-4\" tabindex=\"-1\"/><span class=\"co\">--       ↑ … refers to the variable bound by this lambda</span></span></code></pre></div><p>… and incrementing the index moves to the next outermost lambda:</p><div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb13-1\"><a href=\"#cb13-1\" tabindex=\"-1\"/><span class=\"co\">--             This 1 index …</span></span><br><span id=\"cb13-2\"><a href=\"#cb13-2\" tabindex=\"-1\"/><span class=\"co\">--             ↓</span></span><br><span id=\"cb13-3\"><a href=\"#cb13-3\" tabindex=\"-1\"/>    \\ <span class=\"ot\">-&gt;</span> \\ <span class=\"ot\">-&gt;</span> <span class=\"op\">@</span><span class=\"dv\">1</span> <span class=\"op\">@</span><span class=\"dv\">0</span></span><br><span id=\"cb13-4\"><a href=\"#cb13-4\" tabindex=\"-1\"/><span class=\"co\">--  ↑ … refers to the variable bound by this lambda</span></span></code></pre></div><p>De Bruijn indices avoid name collisions between bound variables, but they require you to do additional work if you wish to preserve the original variable names. There are several ways to do so, and I’ll present my preferred approach.</p><h4 id=\"the-trick---part-1\">The trick - Part 1</h4><p>We can get the best of both worlds by combining the named and nameless representations into a hybrid representation like this:</p><div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb14-1\"><a href=\"#cb14-1\" tabindex=\"-1\"/><span class=\"kw\">data</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb14-2\"><a href=\"#cb14-2\" tabindex=\"-1\"/>    <span class=\"ot\">=</span> <span class=\"dt\">Variable</span> <span class=\"dt\">String</span> <span class=\"dt\">Int</span></span><br><span id=\"cb14-3\"><a href=\"#cb14-3\" tabindex=\"-1\"/>    <span class=\"op\">|</span> <span class=\"dt\">Lambda</span> <span class=\"dt\">String</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb14-4\"><a href=\"#cb14-4\" tabindex=\"-1\"/>    <span class=\"op\">|</span> <span class=\"dt\">Apply</span> <span class=\"dt\">Syntax</span> <span class=\"dt\">Syntax</span></span></code></pre></div><p>I call this representation “namespaced De Bruijn indices”.</p><p>This is almost the exact same as our named representation, except that we have now added an <code>Int</code> field to the <code>Variable</code> constructor. This <code>Int</code> field is morally the same as the De Bruijn index in the nameless representation, except that this time the De Bruijn index is “namespaced” to a specific variable name.</p><p>The easiest way to explain this is with a few examples.</p><p>The following expression:</p><div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb15-1\"><a href=\"#cb15-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x<span class=\"op\">@</span><span class=\"dv\">0</span></span></code></pre></div><p>… corresponds to this syntax tree:</p><div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb16-1\"><a href=\"#cb16-1\" tabindex=\"-1\"/><span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;y&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;x&quot;</span> <span class=\"dv\">0</span>)))</span></code></pre></div><p>… and this curried function returns the third function argument:</p><div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb17-1\"><a href=\"#cb17-1\" tabindex=\"-1\"/><span class=\"co\">--                    This …</span></span><br><span id=\"cb17-2\"><a href=\"#cb17-2\" tabindex=\"-1\"/><span class=\"co\">--                    ↓</span></span><br><span id=\"cb17-3\"><a href=\"#cb17-3\" tabindex=\"-1\"/>    \\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x<span class=\"op\">@</span><span class=\"dv\">0</span></span><br><span id=\"cb17-4\"><a href=\"#cb17-4\" tabindex=\"-1\"/><span class=\"co\">--               ↑ … refers to this bound variable</span></span></code></pre></div><p>… because that is the innermost bound variable named <code>x</code>.</p><p>Similarly, the following expression:</p><div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb18-1\"><a href=\"#cb18-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> y<span class=\"op\">@</span><span class=\"dv\">0</span></span></code></pre></div><p>… corresponds to this syntax tree:</p><div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb19-1\"><a href=\"#cb19-1\" tabindex=\"-1\"/><span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;y&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;y&quot;</span> <span class=\"dv\">0</span>)))</span></code></pre></div><p>… which returns the second function argument:</p><div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb20-1\"><a href=\"#cb20-1\" tabindex=\"-1\"/><span class=\"co\">--                    This …</span></span><br><span id=\"cb20-2\"><a href=\"#cb20-2\" tabindex=\"-1\"/><span class=\"co\">--                    ↓</span></span><br><span id=\"cb20-3\"><a href=\"#cb20-3\" tabindex=\"-1\"/>    \\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> y<span class=\"op\">@</span><span class=\"dv\">0</span></span><br><span id=\"cb20-4\"><a href=\"#cb20-4\" tabindex=\"-1\"/><span class=\"co\">--         ↑ … refers to this bound variable</span></span></code></pre></div><p>… because that is the innermost bound variable named <code>y</code>.</p><p>Carefully note that our variable still has a De Bruijn index of 0, but we ignore the innermost bound variable named <code>x</code> because we also pair our De Bruijn index with name of the variable we are referring to (<code>y</code>) so we only count bound variables named <code>y</code> when resolving the De Bruijn index.</p><p>Finally, the following expression:</p><div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb21-1\"><a href=\"#cb21-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x<span class=\"op\">@</span><span class=\"dv\">1</span></span></code></pre></div><p>… corresponds to this syntax tree:</p><div class=\"sourceCode\" id=\"cb22\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb22-1\"><a href=\"#cb22-1\" tabindex=\"-1\"/><span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;y&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;x&quot;</span> <span class=\"dv\">1</span>)))</span></code></pre></div><p>… which returns the first function argument:</p><div class=\"sourceCode\" id=\"cb23\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb23-1\"><a href=\"#cb23-1\" tabindex=\"-1\"/><span class=\"co\">--                    This …</span></span><br><span id=\"cb23-2\"><a href=\"#cb23-2\" tabindex=\"-1\"/><span class=\"co\">--                    ↓</span></span><br><span id=\"cb23-3\"><a href=\"#cb23-3\" tabindex=\"-1\"/>    \\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x<span class=\"op\">@</span><span class=\"dv\">1</span></span><br><span id=\"cb23-4\"><a href=\"#cb23-4\" tabindex=\"-1\"/><span class=\"co\">--   ↑ … refers to this bound variable</span></span></code></pre></div><p>The De Bruijn index is 1, which means that it refers to the second innermost (0-indexed) bound variable named <code>x</code>.</p><p>Notice how this representation lets us refer to <a href=\"https://en.wikipedia.org/wiki/Variable_shadowing\">shadowed variables</a> by their index. These De Bruijn indices are not an internal implementation detail, but are actually available to the user as part of the surface syntax of the language.</p><p>However, we want to avoid littering the code with these De Bruijn indices, which brings us to the second part of the trick.</p><h4 id=\"the-trick---part-2\">The trick - Part 2</h4><p>The next step is to add syntactic sugar to the language by allowing users to omit the index in the source code, which defaults the index to <code>0</code>. This means that an expression that never references shadowed variables never needs to specify a De Bruijn index.</p><p>For example, instead of writing this:</p><div class=\"sourceCode\" id=\"cb24\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb24-1\"><a href=\"#cb24-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x<span class=\"op\">@</span><span class=\"dv\">0</span></span></code></pre></div><p>… we can elide the index to simplify the code to:</p><div class=\"sourceCode\" id=\"cb25\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb25-1\"><a href=\"#cb25-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x</span></code></pre></div><p>… which will still parse as:</p><div class=\"sourceCode\" id=\"cb26\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb26-1\"><a href=\"#cb26-1\" tabindex=\"-1\"/><span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;y&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;x&quot;</span> <span class=\"dv\">0</span>)))</span></code></pre></div><p>Similarly, we can simplify this:</p><div class=\"sourceCode\" id=\"cb27\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb27-1\"><a href=\"#cb27-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> y<span class=\"op\">@</span><span class=\"dv\">0</span></span></code></pre></div><p>… to this:</p><div class=\"sourceCode\" id=\"cb28\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb28-1\"><a href=\"#cb28-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> y</span></code></pre></div><p>… which will still parse as:</p><div class=\"sourceCode\" id=\"cb29\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb29-1\"><a href=\"#cb29-1\" tabindex=\"-1\"/><span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;y&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;y&quot;</span> <span class=\"dv\">0</span>)))</span></code></pre></div><p>However, we cannot use this syntactic sugar to simplify the final example:</p><div class=\"sourceCode\" id=\"cb30\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb30-1\"><a href=\"#cb30-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x<span class=\"op\">@</span><span class=\"dv\">1</span></span></code></pre></div><p>… since the index is non-zero. Any code that references a shadowed variable still needs to use an explicit De Bruijn index to do so.</p><p>Vice versa, we also omit zero indices when pretty-printing code. When we pretty-print this syntax tree:</p><div class=\"sourceCode\" id=\"cb31\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb31-1\"><a href=\"#cb31-1\" tabindex=\"-1\"/><span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;y&quot;</span> (<span class=\"dt\">Lambda</span> <span class=\"st\">&quot;x&quot;</span> (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;x&quot;</span> <span class=\"dv\">0</span>)))</span></code></pre></div><p>… we don’t include the index:</p><div class=\"sourceCode\" id=\"cb32\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb32-1\"><a href=\"#cb32-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x</span></code></pre></div><p>This syntactic sugar ensures that most users do not need to be aware that indices exist at all when writing code. The user only encounters the indices in two scenarios:</p><ul><li><p>The user wishes to explicitly reference a shadowed variable</p><p>For example, in the following expression:</p><div class=\"sourceCode\" id=\"cb33\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb33-1\"><a href=\"#cb33-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x<span class=\"op\">@</span><span class=\"dv\">1</span></span></code></pre></div><p>… the user might prefer to use the built-in language support for disambiguating variables of the same name rather than renaming one of the two variables named <code>x</code>.</p></li><li><p>The indices appear in a β-reduced result</p><p>For example, this expression has no user-visible De Bruijn indices:</p><div class=\"sourceCode\" id=\"cb34\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb34-1\"><a href=\"#cb34-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> (\\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> y) x</span></code></pre></div><p>… but if you β-reduce the expression (I’ll cover how in the <a href=\"#appendix---implementation\">Appendix</a>) and pretty-print the β-reduced expression then the result will introduce a non-zero De Bruijn index to disambiguate the two variables named <code>x</code>:</p><div class=\"sourceCode\" id=\"cb35\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb35-1\"><a href=\"#cb35-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x<span class=\"op\">@</span><span class=\"dv\">1</span></span></code></pre></div></li></ul><p>In fact, the latter scenario is the reason I originally adopted this trick: I wanted to be able to display β-reduced functions to the end user while preserving the original variable names as much as possible.</p><p>Note that De Bruijn indices don’t appear when a β-reduced expression does not reference any shadowed variables. For example, if you β-reduce this expression:</p><div class=\"sourceCode\" id=\"cb36\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb36-1\"><a href=\"#cb36-1\" tabindex=\"-1\"/>(\\f <span class=\"ot\">-&gt;</span> f f) (\\x <span class=\"ot\">-&gt;</span> x)</span></code></pre></div><p>… the result has no De Bruijn index (because the index is 0 and is therefore elided by the pretty-printer):</p><div class=\"sourceCode\" id=\"cb37\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb37-1\"><a href=\"#cb37-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> x</span></code></pre></div><h4 id=\"the-trick---part-3\">The trick - Part 3</h4><p>One of the benefits of the traditional nameless representation using (non-namespaced) De Bruijn indices is that you get α-equivalence for free. Two nameless expressions are α-equivalent if they are syntactically identical. We can build upon this useful property to derive a compact algorithm for α-equivalence of “namespaced De Bruijn indices”.</p><p>The trick is to recognize that namespaced De Bruijn indices reduce to ordinary De Bruijn indices in the degenerate case when you rename all variables to the same name. I’ll call this renaming process “α-reduction”.</p><p>For example, if we α-reduce the following expression by renaming all of the: variables to <code>_</code>:</p><div class=\"sourceCode\" id=\"cb38\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb38-1\"><a href=\"#cb38-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> \\y <span class=\"ot\">-&gt;</span> \\x <span class=\"ot\">-&gt;</span> x<span class=\"op\">@</span><span class=\"dv\">1</span></span></code></pre></div><p>… then we get this result:</p><div class=\"sourceCode\" id=\"cb39\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb39-1\"><a href=\"#cb39-1\" tabindex=\"-1\"/>\\_ <span class=\"ot\">-&gt;</span> \\_ <span class=\"ot\">-&gt;</span> \\_ <span class=\"ot\">-&gt;</span> _<span class=\"op\">@</span><span class=\"dv\">2</span></span></code></pre></div><p>See the <a href=\"#appendix---implementation\">Appendix</a> for the α-reduction algorithm.</p><p>Equipped with α-reduction, then we can derive α-equivalence: two expressions are α-equivalent if their α-reduced forms are syntactically identical.</p><p>For example, this expression:</p><div class=\"sourceCode\" id=\"cb40\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb40-1\"><a href=\"#cb40-1\" tabindex=\"-1\"/>\\x <span class=\"ot\">-&gt;</span> x</span></code></pre></div><p>… and this expression:</p><div class=\"sourceCode\" id=\"cb41\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb41-1\"><a href=\"#cb41-1\" tabindex=\"-1\"/>\\y <span class=\"ot\">-&gt;</span> y</span></code></pre></div><p>… both α-reduce to:</p><div class=\"sourceCode\" id=\"cb42\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb42-1\"><a href=\"#cb42-1\" tabindex=\"-1\"/>\\_ <span class=\"ot\">-&gt;</span> _</span></code></pre></div><p>… so they are α-equivalent.</p><h4 id=\"benefits\">Benefits</h4><p>There are a few benefits of using this trick that motivate me to use this in all of my interpreted languages:</p><ul><li><p>This trick improves the readability of β-reduced functions</p><p>β-reduced functions preserve the original variable names and this trick doesn’t suffer from the rename-related name pollution that plagues other capture-avoiding substitution algorithms. In particular, β-reduced expressions only display De Bruijn indices when absolutely necessary (if they reference a shadowed variable) and they otherwise use the original pristine variable names.</p></li><li><p>This trick simplifies the internal implementation</p><p>You don’t need to maintain two separate syntax trees for a named and nameless representation. You can use the same syntax tree for both since any named syntax tree can be α-reduced to give the equivalent nameless syntax tree.</p></li><li><p>This trick enables userland support for referencing shadowed variables</p><p>I know some people think that referencing shadowed variable names is a misfeature. However, I personally feel that resolving name collisions by adding <code>'</code> or <code>_</code> characters to the end of variable names is less principled than having language support for resolving name collisions using optional De Bruijn indices.</p></li><li><p>(Not shown) This trick can sometimes improve type errors</p><p>To be precise, this trick improves the inferred types displayed in error messages when using explicit universal quantification.</p><p>Type variables also have to avoid name collisions, so if you use the same namespaced De Bruijn representation for your types then you avoid polluting your inferred types and error messages with junk type variables like <code>a14</code>.</p><p>This post doesn’t cover the equivalent type-level trick, but you can refer to the <a href=\"https://github.com/dhall-lang/dhall-lang/tree/master/standard\">Dhall standard</a> if you need an example of a language that uses this trick.</p></li></ul><h4 id=\"conclusion\">Conclusion</h4><p>I believe that namespaced De Bruijn indices are most appropriate for languages that are (A) strongly normalizing (like Dhall) and (B) interpreted, because such languages tend to support pretty-printing β-reduced functions.</p><p>I think this trick is also useful to a lesser extent for all interpreted languages, if only because the implementation is (in my opinion) simpler and more elegant than other algorithms for capture-avoiding substitution (See the <a href=\"#appendix---implementation\">Appendix</a> below).</p><p>On the other hand, compiled languages will likely not benefit much from this trick since they typically have no need to preserve the original variable names and they also will use an intermediate representation that is very different from the concrete syntax tree.</p><h4 id=\"appendix---implementation\">Appendix - Implementation</h4><p>This section provides Haskell code specifying how to α-reduce and β-reduce a syntax tree that uses namespaced De Bruijn indices.</p><p>This reference implementation is not the most efficient implementation, but it’s the simplest one which I use for pedagogical purposes. If you’re interested in efficiency then check out my <a href=\"https://github.com/Gabriel439/grace\">Grace</a> project, which mixes this trick with the more efficient <a href=\"https://en.wikipedia.org/wiki/Normalisation_by_evaluation\">normalization-by-evaluation</a> algorithm.</p><p>I also don’t include code for the parser or pretty-printer, because the only interesting part is the syntactic sugar for handling variables with a De Bruijn index of <code>0</code>. Again, check out <a href=\"https://github.com/Gabriel439/grace\">Grace</a> if you want to refer to a more complete implementation.</p><div class=\"sourceCode\" id=\"cb43\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb43-1\"><a href=\"#cb43-1\" tabindex=\"-1\"/><span class=\"co\">-- | Syntax tree</span></span><br><span id=\"cb43-2\"><a href=\"#cb43-2\" tabindex=\"-1\"/><span class=\"kw\">data</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb43-3\"><a href=\"#cb43-3\" tabindex=\"-1\"/>    <span class=\"ot\">=</span> <span class=\"dt\">Variable</span> <span class=\"dt\">String</span> <span class=\"dt\">Int</span></span><br><span id=\"cb43-4\"><a href=\"#cb43-4\" tabindex=\"-1\"/>    <span class=\"op\">|</span> <span class=\"dt\">Lambda</span> <span class=\"dt\">String</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb43-5\"><a href=\"#cb43-5\" tabindex=\"-1\"/>    <span class=\"op\">|</span> <span class=\"dt\">Apply</span> <span class=\"dt\">Syntax</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb43-6\"><a href=\"#cb43-6\" tabindex=\"-1\"/>    <span class=\"kw\">deriving</span> (<span class=\"dt\">Eq</span>, <span class=\"dt\">Show</span>)</span><br><span id=\"cb43-7\"><a href=\"#cb43-7\" tabindex=\"-1\"/></span><br><span id=\"cb43-8\"><a href=\"#cb43-8\" tabindex=\"-1\"/><span class=\"co\">{-| Increase the index of all bound variables matching the given variable name</span></span><br><span id=\"cb43-9\"><a href=\"#cb43-9\" tabindex=\"-1\"/></span><br><span id=\"cb43-10\"><a href=\"#cb43-10\" tabindex=\"-1\"/><span class=\"co\">    This is modified from the Shifting definition in Pierce's \\&quot;Types and</span></span><br><span id=\"cb43-11\"><a href=\"#cb43-11\" tabindex=\"-1\"/><span class=\"co\">    Programming Languages\\&quot; by adding an additional argument for the namespace</span></span><br><span id=\"cb43-12\"><a href=\"#cb43-12\" tabindex=\"-1\"/><span class=\"co\">    to shift</span></span><br><span id=\"cb43-13\"><a href=\"#cb43-13\" tabindex=\"-1\"/><span class=\"co\">-}</span></span><br><span id=\"cb43-14\"><a href=\"#cb43-14\" tabindex=\"-1\"/>shift</span><br><span id=\"cb43-15\"><a href=\"#cb43-15\" tabindex=\"-1\"/><span class=\"ot\">    ::</span> <span class=\"dt\">Int</span></span><br><span id=\"cb43-16\"><a href=\"#cb43-16\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ The amount to shift by</span></span><br><span id=\"cb43-17\"><a href=\"#cb43-17\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">String</span></span><br><span id=\"cb43-18\"><a href=\"#cb43-18\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ The variable name to match (a.k.a. the namespace)</span></span><br><span id=\"cb43-19\"><a href=\"#cb43-19\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></span><br><span id=\"cb43-20\"><a href=\"#cb43-20\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ The minimum bound for which indices to shift</span></span><br><span id=\"cb43-21\"><a href=\"#cb43-21\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb43-22\"><a href=\"#cb43-22\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ The expression to shift</span></span><br><span id=\"cb43-23\"><a href=\"#cb43-23\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb43-24\"><a href=\"#cb43-24\" tabindex=\"-1\"/>shift offset namespace minIndex syntax <span class=\"ot\">=</span></span><br><span id=\"cb43-25\"><a href=\"#cb43-25\" tabindex=\"-1\"/>    <span class=\"kw\">case</span> syntax <span class=\"kw\">of</span></span><br><span id=\"cb43-26\"><a href=\"#cb43-26\" tabindex=\"-1\"/>        <span class=\"dt\">Variable</span> name <span class=\"fu\">index</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Variable</span> name index'</span><br><span id=\"cb43-27\"><a href=\"#cb43-27\" tabindex=\"-1\"/>          <span class=\"kw\">where</span></span><br><span id=\"cb43-28\"><a href=\"#cb43-28\" tabindex=\"-1\"/>            index'</span><br><span id=\"cb43-29\"><a href=\"#cb43-29\" tabindex=\"-1\"/>                <span class=\"op\">|</span> name <span class=\"op\">==</span> namespace <span class=\"op\">&amp;&amp;</span> minIndex <span class=\"op\">&lt;=</span> <span class=\"fu\">index</span> <span class=\"ot\">=</span> <span class=\"fu\">index</span> <span class=\"op\">+</span> offset</span><br><span id=\"cb43-30\"><a href=\"#cb43-30\" tabindex=\"-1\"/>                <span class=\"op\">|</span> <span class=\"fu\">otherwise</span>                              <span class=\"ot\">=</span> <span class=\"fu\">index</span></span><br><span id=\"cb43-31\"><a href=\"#cb43-31\" tabindex=\"-1\"/></span><br><span id=\"cb43-32\"><a href=\"#cb43-32\" tabindex=\"-1\"/>        <span class=\"dt\">Lambda</span> name body <span class=\"ot\">-&gt;</span> <span class=\"dt\">Lambda</span> name body'</span><br><span id=\"cb43-33\"><a href=\"#cb43-33\" tabindex=\"-1\"/>          <span class=\"kw\">where</span></span><br><span id=\"cb43-34\"><a href=\"#cb43-34\" tabindex=\"-1\"/>            minIndex'</span><br><span id=\"cb43-35\"><a href=\"#cb43-35\" tabindex=\"-1\"/>                <span class=\"op\">|</span> name <span class=\"op\">==</span> namespace <span class=\"ot\">=</span> minIndex <span class=\"op\">+</span> <span class=\"dv\">1</span></span><br><span id=\"cb43-36\"><a href=\"#cb43-36\" tabindex=\"-1\"/>                <span class=\"op\">|</span> <span class=\"fu\">otherwise</span>         <span class=\"ot\">=</span> minIndex</span><br><span id=\"cb43-37\"><a href=\"#cb43-37\" tabindex=\"-1\"/></span><br><span id=\"cb43-38\"><a href=\"#cb43-38\" tabindex=\"-1\"/>            body' <span class=\"ot\">=</span> shift offset namespace minIndex' body</span><br><span id=\"cb43-39\"><a href=\"#cb43-39\" tabindex=\"-1\"/></span><br><span id=\"cb43-40\"><a href=\"#cb43-40\" tabindex=\"-1\"/>        <span class=\"dt\">Apply</span> function argument <span class=\"ot\">-&gt;</span> <span class=\"dt\">Apply</span> function' argument'</span><br><span id=\"cb43-41\"><a href=\"#cb43-41\" tabindex=\"-1\"/>          <span class=\"kw\">where</span></span><br><span id=\"cb43-42\"><a href=\"#cb43-42\" tabindex=\"-1\"/>            function' <span class=\"ot\">=</span> shift offset namespace minIndex function</span><br><span id=\"cb43-43\"><a href=\"#cb43-43\" tabindex=\"-1\"/></span><br><span id=\"cb43-44\"><a href=\"#cb43-44\" tabindex=\"-1\"/>            argument' <span class=\"ot\">=</span> shift offset namespace minIndex argument</span><br><span id=\"cb43-45\"><a href=\"#cb43-45\" tabindex=\"-1\"/></span><br><span id=\"cb43-46\"><a href=\"#cb43-46\" tabindex=\"-1\"/><span class=\"co\">{-| Substitute the given variable name and index with an expression</span></span><br><span id=\"cb43-47\"><a href=\"#cb43-47\" tabindex=\"-1\"/></span><br><span id=\"cb43-48\"><a href=\"#cb43-48\" tabindex=\"-1\"/><span class=\"co\">    This is modified from the Substitution definition in Pierce's \\&quot;Types and</span></span><br><span id=\"cb43-49\"><a href=\"#cb43-49\" tabindex=\"-1\"/><span class=\"co\">    Programming Languages\\&quot; by adding an additional argument for the variable</span></span><br><span id=\"cb43-50\"><a href=\"#cb43-50\" tabindex=\"-1\"/><span class=\"co\">    index</span></span><br><span id=\"cb43-51\"><a href=\"#cb43-51\" tabindex=\"-1\"/><span class=\"co\">-}</span></span><br><span id=\"cb43-52\"><a href=\"#cb43-52\" tabindex=\"-1\"/>substitute</span><br><span id=\"cb43-53\"><a href=\"#cb43-53\" tabindex=\"-1\"/><span class=\"ot\">    ::</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb43-54\"><a href=\"#cb43-54\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ The expression to substitute into</span></span><br><span id=\"cb43-55\"><a href=\"#cb43-55\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">String</span></span><br><span id=\"cb43-56\"><a href=\"#cb43-56\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ The name of the variable to replace</span></span><br><span id=\"cb43-57\"><a href=\"#cb43-57\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">Int</span></span><br><span id=\"cb43-58\"><a href=\"#cb43-58\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ The index of the variable to replace</span></span><br><span id=\"cb43-59\"><a href=\"#cb43-59\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb43-60\"><a href=\"#cb43-60\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ The expression to substitute in place of the given variable</span></span><br><span id=\"cb43-61\"><a href=\"#cb43-61\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb43-62\"><a href=\"#cb43-62\" tabindex=\"-1\"/>substitute expression name <span class=\"fu\">index</span> replacement <span class=\"ot\">=</span></span><br><span id=\"cb43-63\"><a href=\"#cb43-63\" tabindex=\"-1\"/>    <span class=\"kw\">case</span> expression <span class=\"kw\">of</span></span><br><span id=\"cb43-64\"><a href=\"#cb43-64\" tabindex=\"-1\"/>        <span class=\"dt\">Variable</span> name' index'</span><br><span id=\"cb43-65\"><a href=\"#cb43-65\" tabindex=\"-1\"/>            <span class=\"op\">|</span> name <span class=\"op\">==</span> name' <span class=\"op\">&amp;&amp;</span> <span class=\"fu\">index</span> <span class=\"op\">==</span> index' <span class=\"ot\">-&gt;</span> replacement</span><br><span id=\"cb43-66\"><a href=\"#cb43-66\" tabindex=\"-1\"/>            <span class=\"op\">|</span> <span class=\"fu\">otherwise</span>                        <span class=\"ot\">-&gt;</span> <span class=\"dt\">Variable</span> name' index'</span><br><span id=\"cb43-67\"><a href=\"#cb43-67\" tabindex=\"-1\"/></span><br><span id=\"cb43-68\"><a href=\"#cb43-68\" tabindex=\"-1\"/>        <span class=\"dt\">Lambda</span> name' body <span class=\"ot\">-&gt;</span> <span class=\"dt\">Lambda</span> name' body'</span><br><span id=\"cb43-69\"><a href=\"#cb43-69\" tabindex=\"-1\"/>          <span class=\"kw\">where</span></span><br><span id=\"cb43-70\"><a href=\"#cb43-70\" tabindex=\"-1\"/>            index'</span><br><span id=\"cb43-71\"><a href=\"#cb43-71\" tabindex=\"-1\"/>                <span class=\"op\">|</span> name <span class=\"op\">==</span> name' <span class=\"ot\">=</span> <span class=\"fu\">index</span> <span class=\"op\">+</span> <span class=\"dv\">1</span></span><br><span id=\"cb43-72\"><a href=\"#cb43-72\" tabindex=\"-1\"/>                <span class=\"op\">|</span> <span class=\"fu\">otherwise</span>     <span class=\"ot\">=</span> <span class=\"fu\">index</span></span><br><span id=\"cb43-73\"><a href=\"#cb43-73\" tabindex=\"-1\"/></span><br><span id=\"cb43-74\"><a href=\"#cb43-74\" tabindex=\"-1\"/>            shiftedBody <span class=\"ot\">=</span> shift <span class=\"dv\">1</span> name' <span class=\"dv\">0</span> replacement</span><br><span id=\"cb43-75\"><a href=\"#cb43-75\" tabindex=\"-1\"/></span><br><span id=\"cb43-76\"><a href=\"#cb43-76\" tabindex=\"-1\"/>            body' <span class=\"ot\">=</span> substitute body name index' shiftedBody</span><br><span id=\"cb43-77\"><a href=\"#cb43-77\" tabindex=\"-1\"/></span><br><span id=\"cb43-78\"><a href=\"#cb43-78\" tabindex=\"-1\"/>        <span class=\"dt\">Apply</span> function argument <span class=\"ot\">-&gt;</span> <span class=\"dt\">Apply</span> function' argument'</span><br><span id=\"cb43-79\"><a href=\"#cb43-79\" tabindex=\"-1\"/>          <span class=\"kw\">where</span></span><br><span id=\"cb43-80\"><a href=\"#cb43-80\" tabindex=\"-1\"/>            function' <span class=\"ot\">=</span> substitute function name <span class=\"fu\">index</span> replacement</span><br><span id=\"cb43-81\"><a href=\"#cb43-81\" tabindex=\"-1\"/></span><br><span id=\"cb43-82\"><a href=\"#cb43-82\" tabindex=\"-1\"/>            argument' <span class=\"ot\">=</span> substitute argument name <span class=\"fu\">index</span> replacement</span><br><span id=\"cb43-83\"><a href=\"#cb43-83\" tabindex=\"-1\"/></span><br><span id=\"cb43-84\"><a href=\"#cb43-84\" tabindex=\"-1\"/><span class=\"co\">-- | β-reduce an expression</span></span><br><span id=\"cb43-85\"><a href=\"#cb43-85\" tabindex=\"-1\"/><span class=\"ot\">betaReduce ::</span> <span class=\"dt\">Syntax</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb43-86\"><a href=\"#cb43-86\" tabindex=\"-1\"/>betaReduce syntax <span class=\"ot\">=</span></span><br><span id=\"cb43-87\"><a href=\"#cb43-87\" tabindex=\"-1\"/>    <span class=\"kw\">case</span> syntax <span class=\"kw\">of</span></span><br><span id=\"cb43-88\"><a href=\"#cb43-88\" tabindex=\"-1\"/>        <span class=\"dt\">Variable</span> name <span class=\"fu\">index</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Variable</span> name <span class=\"fu\">index</span></span><br><span id=\"cb43-89\"><a href=\"#cb43-89\" tabindex=\"-1\"/></span><br><span id=\"cb43-90\"><a href=\"#cb43-90\" tabindex=\"-1\"/>        <span class=\"dt\">Lambda</span> name body <span class=\"ot\">-&gt;</span> <span class=\"dt\">Lambda</span> name body'</span><br><span id=\"cb43-91\"><a href=\"#cb43-91\" tabindex=\"-1\"/>          <span class=\"kw\">where</span></span><br><span id=\"cb43-92\"><a href=\"#cb43-92\" tabindex=\"-1\"/>            body' <span class=\"ot\">=</span> betaReduce body</span><br><span id=\"cb43-93\"><a href=\"#cb43-93\" tabindex=\"-1\"/></span><br><span id=\"cb43-94\"><a href=\"#cb43-94\" tabindex=\"-1\"/>        <span class=\"dt\">Apply</span> function argument <span class=\"ot\">-&gt;</span></span><br><span id=\"cb43-95\"><a href=\"#cb43-95\" tabindex=\"-1\"/>            <span class=\"kw\">case</span> function' <span class=\"kw\">of</span></span><br><span id=\"cb43-96\"><a href=\"#cb43-96\" tabindex=\"-1\"/>                <span class=\"dt\">Lambda</span> name body <span class=\"ot\">-&gt;</span> body'</span><br><span id=\"cb43-97\"><a href=\"#cb43-97\" tabindex=\"-1\"/>                  <span class=\"kw\">where</span></span><br><span id=\"cb43-98\"><a href=\"#cb43-98\" tabindex=\"-1\"/>                    shiftedArgument <span class=\"ot\">=</span> shift <span class=\"dv\">1</span> name <span class=\"dv\">0</span> argument</span><br><span id=\"cb43-99\"><a href=\"#cb43-99\" tabindex=\"-1\"/></span><br><span id=\"cb43-100\"><a href=\"#cb43-100\" tabindex=\"-1\"/>                    substitutedBody <span class=\"ot\">=</span> substitute body name <span class=\"dv\">0</span> shiftedArgument</span><br><span id=\"cb43-101\"><a href=\"#cb43-101\" tabindex=\"-1\"/></span><br><span id=\"cb43-102\"><a href=\"#cb43-102\" tabindex=\"-1\"/>                    unshiftedBody <span class=\"ot\">=</span> shift (<span class=\"op\">-</span><span class=\"dv\">1</span>) name <span class=\"dv\">0</span> substitutedBody</span><br><span id=\"cb43-103\"><a href=\"#cb43-103\" tabindex=\"-1\"/></span><br><span id=\"cb43-104\"><a href=\"#cb43-104\" tabindex=\"-1\"/>                    body' <span class=\"ot\">=</span> betaReduce unshiftedBody</span><br><span id=\"cb43-105\"><a href=\"#cb43-105\" tabindex=\"-1\"/></span><br><span id=\"cb43-106\"><a href=\"#cb43-106\" tabindex=\"-1\"/>                _ <span class=\"ot\">-&gt;</span> <span class=\"dt\">Apply</span> function' argument'</span><br><span id=\"cb43-107\"><a href=\"#cb43-107\" tabindex=\"-1\"/>          <span class=\"kw\">where</span></span><br><span id=\"cb43-108\"><a href=\"#cb43-108\" tabindex=\"-1\"/>            function' <span class=\"ot\">=</span> betaReduce function</span><br><span id=\"cb43-109\"><a href=\"#cb43-109\" tabindex=\"-1\"/></span><br><span id=\"cb43-110\"><a href=\"#cb43-110\" tabindex=\"-1\"/>            argument' <span class=\"ot\">=</span> betaReduce argument</span><br><span id=\"cb43-111\"><a href=\"#cb43-111\" tabindex=\"-1\"/></span><br><span id=\"cb43-112\"><a href=\"#cb43-112\" tabindex=\"-1\"/><span class=\"co\">-- | α-reduce an expression</span></span><br><span id=\"cb43-113\"><a href=\"#cb43-113\" tabindex=\"-1\"/><span class=\"ot\">alphaReduce ::</span> <span class=\"dt\">Syntax</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Syntax</span></span><br><span id=\"cb43-114\"><a href=\"#cb43-114\" tabindex=\"-1\"/>alphaReduce syntax <span class=\"ot\">=</span></span><br><span id=\"cb43-115\"><a href=\"#cb43-115\" tabindex=\"-1\"/>    <span class=\"kw\">case</span> syntax <span class=\"kw\">of</span></span><br><span id=\"cb43-116\"><a href=\"#cb43-116\" tabindex=\"-1\"/>        <span class=\"dt\">Variable</span> name <span class=\"fu\">index</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Variable</span> name <span class=\"fu\">index</span></span><br><span id=\"cb43-117\"><a href=\"#cb43-117\" tabindex=\"-1\"/></span><br><span id=\"cb43-118\"><a href=\"#cb43-118\" tabindex=\"-1\"/>        <span class=\"dt\">Lambda</span> name body <span class=\"ot\">-&gt;</span> <span class=\"dt\">Lambda</span> <span class=\"st\">&quot;_&quot;</span> body'</span><br><span id=\"cb43-119\"><a href=\"#cb43-119\" tabindex=\"-1\"/>          <span class=\"kw\">where</span></span><br><span id=\"cb43-120\"><a href=\"#cb43-120\" tabindex=\"-1\"/>            shiftedBody <span class=\"ot\">=</span> shift <span class=\"dv\">1</span> <span class=\"st\">&quot;_&quot;</span> <span class=\"dv\">0</span> body</span><br><span id=\"cb43-121\"><a href=\"#cb43-121\" tabindex=\"-1\"/></span><br><span id=\"cb43-122\"><a href=\"#cb43-122\" tabindex=\"-1\"/>            substitutedBody <span class=\"ot\">=</span> substitute shiftedBody name <span class=\"dv\">0</span> (<span class=\"dt\">Variable</span> <span class=\"st\">&quot;_&quot;</span> <span class=\"dv\">0</span>)</span><br><span id=\"cb43-123\"><a href=\"#cb43-123\" tabindex=\"-1\"/></span><br><span id=\"cb43-124\"><a href=\"#cb43-124\" tabindex=\"-1\"/>            unshiftedBody <span class=\"ot\">=</span> shift (<span class=\"op\">-</span><span class=\"dv\">1</span>) name <span class=\"dv\">0</span> substitutedBody</span><br><span id=\"cb43-125\"><a href=\"#cb43-125\" tabindex=\"-1\"/></span><br><span id=\"cb43-126\"><a href=\"#cb43-126\" tabindex=\"-1\"/>            body' <span class=\"ot\">=</span> alphaReduce unshiftedBody</span><br><span id=\"cb43-127\"><a href=\"#cb43-127\" tabindex=\"-1\"/></span><br><span id=\"cb43-128\"><a href=\"#cb43-128\" tabindex=\"-1\"/>        <span class=\"dt\">Apply</span> function argument <span class=\"ot\">-&gt;</span> <span class=\"dt\">Apply</span> function' argument'</span><br><span id=\"cb43-129\"><a href=\"#cb43-129\" tabindex=\"-1\"/>          <span class=\"kw\">where</span></span><br><span id=\"cb43-130\"><a href=\"#cb43-130\" tabindex=\"-1\"/>            function' <span class=\"ot\">=</span> alphaReduce function</span><br><span id=\"cb43-131\"><a href=\"#cb43-131\" tabindex=\"-1\"/></span><br><span id=\"cb43-132\"><a href=\"#cb43-132\" tabindex=\"-1\"/>            argument' <span class=\"ot\">=</span> alphaReduce argument</span><br><span id=\"cb43-133\"><a href=\"#cb43-133\" tabindex=\"-1\"/></span><br><span id=\"cb43-134\"><a href=\"#cb43-134\" tabindex=\"-1\"/><span class=\"co\">-- | Returns `True` if the two input expressions are α-equivalent</span></span><br><span id=\"cb43-135\"><a href=\"#cb43-135\" tabindex=\"-1\"/><span class=\"ot\">alphaEquivalent ::</span> <span class=\"dt\">Syntax</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Syntax</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Bool</span></span><br><span id=\"cb43-136\"><a href=\"#cb43-136\" tabindex=\"-1\"/>alphaEquivalent left right <span class=\"ot\">=</span> alphaReduce left <span class=\"op\">==</span> alphaReduce right</span></code></pre></div><h4 id=\"appendix---history\">Appendix - History</h4><p>I actually first introduced this feature in <a href=\"https://github.com/Gabriel439/Haskell-Morte-Library\">Morte</a>, not Dhall. The idea originated from the discussion on this <a href=\"https://github.com/Gabriel439/Haskell-Morte-Library/issues/1\">issue</a>.</p></body></html>"
}