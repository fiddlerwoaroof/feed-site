{
  "title":"Naming function arguments in Dhall",
  "date":"2021-08-27T08:22:33.127000-07:00",
  "author":"Gabriel Gonzalez",
  "id":"tag:blogger.com,1999:blog-1777990983847811806.post-7712329497884133684",
  "link":"https://www.haskellforall.com/2021/08/naming-function-arguments-in-dhall.html",
  "content":"<!DOCTYPE html><html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\"><head>            </head><body><p>This post showcases some neat <a href=\"https://dhall-lang.org/\">Dhall</a> language features for improving the readability of types that I think other languages should steal.</p><p>To motivate this post, consider the following Haskell type for <a href=\"https://hackage.haskell.org/package/text-1.2.5.0/docs/Data-Text.html#v:replace\"><code>Data.Text.replace</code></a>:</p><div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" tabindex=\"-1\"/><span class=\"ot\">replace ::</span> <span class=\"dt\">Text</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Text</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Text</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Text</span></span></code></pre></div><p>This function replaces all occurrences of a substring with another substring, but you wouldn’t be able to easily guess which argument is which from the type alone.</p><p>Fortunately, the function does have Haddock-level documentation in the form of comments for each function argument:</p><div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb2-1\"><a href=\"#cb2-1\" tabindex=\"-1\"/>replace</span><br><span id=\"cb2-2\"><a href=\"#cb2-2\" tabindex=\"-1\"/><span class=\"ot\">    ::</span> <span class=\"dt\">Text</span></span><br><span id=\"cb2-3\"><a href=\"#cb2-3\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ @needle@ to search for.  If this string is empty, an</span></span><br><span id=\"cb2-4\"><a href=\"#cb2-4\" tabindex=\"-1\"/>    <span class=\"co\">-- error will occur.</span></span><br><span id=\"cb2-5\"><a href=\"#cb2-5\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">Text</span></span><br><span id=\"cb2-6\"><a href=\"#cb2-6\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ @replacement@ to replace @needle@ with.</span></span><br><span id=\"cb2-7\"><a href=\"#cb2-7\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">Text</span></span><br><span id=\"cb2-8\"><a href=\"#cb2-8\" tabindex=\"-1\"/>    <span class=\"co\">-- ^ @haystack@ in which to search.</span></span><br><span id=\"cb2-9\"><a href=\"#cb2-9\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"dt\">Text</span></span></code></pre></div><p>… but what if you could provide a hint to what each argument does within the type itself?</p><h4 id=\"naming-function-arguments-using-forall\">Naming function arguments using <code>∀</code> / <code>forall</code></h4><p>Well, in Dhall you can, and here is the equivalent Dhall type:</p><div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb3-1\"><a href=\"#cb3-1\" tabindex=\"-1\"/><span class=\"op\">$</span> dhall repl</span><br><span id=\"cb3-2\"><a href=\"#cb3-2\" tabindex=\"-1\"/>⊢ <span class=\"op\">:</span><span class=\"kw\">type</span> <span class=\"dt\">Text</span><span class=\"op\">/</span>replace</span><br><span id=\"cb3-3\"><a href=\"#cb3-3\" tabindex=\"-1\"/></span><br><span id=\"cb3-4\"><a href=\"#cb3-4\" tabindex=\"-1\"/>∀(needle <span class=\"op\">:</span> <span class=\"dt\">Text</span>) → ∀(replacement <span class=\"op\">:</span> <span class=\"dt\">Text</span>) → ∀(haystack <span class=\"op\">:</span> <span class=\"dt\">Text</span>) → <span class=\"dt\">Text</span></span></code></pre></div><p>… or if you prefer ASCII syntax then that is the same as this type:</p><div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb4-1\"><a href=\"#cb4-1\" tabindex=\"-1\"/><span class=\"kw\">forall</span> (needle <span class=\"op\">:</span> <span class=\"dt\">Text</span>) <span class=\"ot\">-&gt;</span></span><br><span id=\"cb4-2\"><a href=\"#cb4-2\" tabindex=\"-1\"/><span class=\"kw\">forall</span> (replacement <span class=\"op\">:</span> <span class=\"dt\">Text</span>) <span class=\"ot\">-&gt;</span></span><br><span id=\"cb4-3\"><a href=\"#cb4-3\" tabindex=\"-1\"/><span class=\"kw\">forall</span> (haystack <span class=\"op\">:</span> <span class=\"dt\">Text</span>) <span class=\"ot\">-&gt;</span></span><br><span id=\"cb4-4\"><a href=\"#cb4-4\" tabindex=\"-1\"/>  <span class=\"dt\">Text</span></span></code></pre></div><p>Here we’ve tagged each function argument with the argument’s name. In fact, you don’t need to do this explicitly. Dhall will automatically infer named function argument types when you create user-defined functions:</p><div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb5-1\"><a href=\"#cb5-1\" tabindex=\"-1\"/>⊢ <span class=\"op\">:</span><span class=\"kw\">type</span> λ(name <span class=\"op\">:</span> <span class=\"dt\">Text</span>) → <span class=\"st\">&quot;Hello, ${name}&quot;</span></span><br><span id=\"cb5-2\"><a href=\"#cb5-2\" tabindex=\"-1\"/></span><br><span id=\"cb5-3\"><a href=\"#cb5-3\" tabindex=\"-1\"/>∀(name <span class=\"op\">:</span> <span class=\"dt\">Text</span>) → <span class=\"dt\">Text</span></span></code></pre></div><p>In many cases these names are “cosmetic”, meaning that they have no effect on type-checking. For example, as far as the type-checker is concerned the following function type:</p><div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb6-1\"><a href=\"#cb6-1\" tabindex=\"-1\"/>∀(name <span class=\"op\">:</span> <span class=\"dt\">Text</span>) → <span class=\"dt\">Text</span></span></code></pre></div><p>… is the exact same as the following simpler function type (they are α-equivalent):</p><div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb7-1\"><a href=\"#cb7-1\" tabindex=\"-1\"/><span class=\"dt\">Text</span> → <span class=\"dt\">Text</span></span></code></pre></div><p>However, sometimes these names are not cosmetic! The simplest example is a polymorphic function (a.k.a. a “generic” function), like the following polymorphic identity function:</p><div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb8-1\"><a href=\"#cb8-1\" tabindex=\"-1\"/><span class=\"kw\">let</span> identity</span><br><span id=\"cb8-2\"><a href=\"#cb8-2\" tabindex=\"-1\"/>      <span class=\"op\">:</span> ∀(a <span class=\"op\">:</span> <span class=\"dt\">Type</span>) → a → a</span><br><span id=\"cb8-3\"><a href=\"#cb8-3\" tabindex=\"-1\"/>      <span class=\"ot\">=</span> λ(a <span class=\"op\">:</span> <span class=\"dt\">Type</span>) → λ(x <span class=\"op\">:</span> a) → x</span><br><span id=\"cb8-4\"><a href=\"#cb8-4\" tabindex=\"-1\"/></span><br><span id=\"cb8-5\"><a href=\"#cb8-5\" tabindex=\"-1\"/><span class=\"kw\">in</span>  identity</span></code></pre></div><p>Here we’ve used the <code>∀</code> to name the first function argument <code>a</code>, which lets us reference that name downstream within the same type.</p><div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb9-1\"><a href=\"#cb9-1\" tabindex=\"-1\"/><span class=\"kw\">let</span> identity</span><br><span id=\"cb9-2\"><a href=\"#cb9-2\" tabindex=\"-1\"/>       <span class=\"co\">-- We're naming our first function argument `a` …</span></span><br><span id=\"cb9-3\"><a href=\"#cb9-3\" tabindex=\"-1\"/>       <span class=\"co\">-- ↓</span></span><br><span id=\"cb9-4\"><a href=\"#cb9-4\" tabindex=\"-1\"/>      <span class=\"op\">:</span> ∀(a <span class=\"op\">:</span> <span class=\"dt\">Type</span>) → a → a</span><br><span id=\"cb9-5\"><a href=\"#cb9-5\" tabindex=\"-1\"/>                   <span class=\"co\">-- ↑   ↑</span></span><br><span id=\"cb9-6\"><a href=\"#cb9-6\" tabindex=\"-1\"/>                   <span class=\"co\">-- … so that we can reference the value of the first function</span></span><br><span id=\"cb9-7\"><a href=\"#cb9-7\" tabindex=\"-1\"/>                   <span class=\"co\">-- argument downstream within the same type</span></span><br><span id=\"cb9-8\"><a href=\"#cb9-8\" tabindex=\"-1\"/>      <span class=\"ot\">=</span> λ(a <span class=\"op\">:</span> <span class=\"dt\">Type</span>) → λ(x <span class=\"op\">:</span> a) → x</span><br><span id=\"cb9-9\"><a href=\"#cb9-9\" tabindex=\"-1\"/></span><br><span id=\"cb9-10\"><a href=\"#cb9-10\" tabindex=\"-1\"/><span class=\"kw\">in</span>  identity</span></code></pre></div><p>However, unlike other languages, Dhall also lets us name the second function argument using the exact same syntax, even though our second function argument is not a <code>Type</code>:</p><div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb10-1\"><a href=\"#cb10-1\" tabindex=\"-1\"/><span class=\"kw\">let</span> identity</span><br><span id=\"cb10-2\"><a href=\"#cb10-2\" tabindex=\"-1\"/>      <span class=\"op\">:</span> ∀(a <span class=\"op\">:</span> <span class=\"dt\">Type</span>) → ∀(x <span class=\"op\">:</span> a) → a</span><br><span id=\"cb10-3\"><a href=\"#cb10-3\" tabindex=\"-1\"/>      <span class=\"ot\">=</span> λ(a <span class=\"op\">:</span> <span class=\"dt\">Type</span>) → λ(x <span class=\"op\">:</span> a) → x</span></code></pre></div><p>In fact, this is actually the type that the interpreter would have inferred if we had omitted the type annotation. The name of this second function argument is cosmetic, though.</p><p>Another example where the argument name is not cosmetic is the following hypothetical Dhall type for a safe division function that rejects <code>0</code> denominators at type-checking time:</p><div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb11-1\"><a href=\"#cb11-1\" tabindex=\"-1\"/>divide</span><br><span id=\"cb11-2\"><a href=\"#cb11-2\" tabindex=\"-1\"/>    <span class=\"op\">:</span> ∀(<span class=\"fu\">denominator</span> <span class=\"op\">:</span> <span class=\"dt\">Natural</span>) →</span><br><span id=\"cb11-3\"><a href=\"#cb11-3\" tabindex=\"-1\"/>      ∀(proof <span class=\"op\">:</span> <span class=\"dt\">Natural</span><span class=\"op\">/</span>isZero <span class=\"fu\">denominator</span> ≡ <span class=\"dt\">False</span>) →</span><br><span id=\"cb11-4\"><a href=\"#cb11-4\" tabindex=\"-1\"/>      ∀(<span class=\"fu\">numerator</span> <span class=\"op\">:</span> <span class=\"dt\">Natural</span>) →</span><br><span id=\"cb11-5\"><a href=\"#cb11-5\" tabindex=\"-1\"/>        <span class=\"dt\">Natural</span></span></code></pre></div><p>This division function takes three arguments instead of the usual two:</p><ul><li><p>The first argument is the denominator</p><p>… as you may have guessed from the helpful type-level name</p></li><li><p>The second function argument requires a proof that <code>denominator</code> is non-zero</p><blockquote><p>Side note: This proof obligation is satisfied by <code>assert : False ≡ False</code> so long as <code>denominator</code> is not <code>0</code></p></blockquote></li><li><p>The third argument is the numerator</p></li></ul><p>By naming the first argument <code>denominator</code>, we can refer to the <em>value</em> of the first argument within the <em>type</em> of the second argument:</p><div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb12-1\"><a href=\"#cb12-1\" tabindex=\"-1\"/>divide</span><br><span id=\"cb12-2\"><a href=\"#cb12-2\" tabindex=\"-1\"/>    <span class=\"co\">--  We're referring to the value of the first argument …</span></span><br><span id=\"cb12-3\"><a href=\"#cb12-3\" tabindex=\"-1\"/>    <span class=\"co\">--  ↓</span></span><br><span id=\"cb12-4\"><a href=\"#cb12-4\" tabindex=\"-1\"/>    <span class=\"op\">:</span> ∀(<span class=\"fu\">denominator</span> <span class=\"op\">:</span> <span class=\"dt\">Natural</span>) →</span><br><span id=\"cb12-5\"><a href=\"#cb12-5\" tabindex=\"-1\"/>    <span class=\"co\">--                         … within the type of the second argument</span></span><br><span id=\"cb12-6\"><a href=\"#cb12-6\" tabindex=\"-1\"/>    <span class=\"co\">--                         ↓</span></span><br><span id=\"cb12-7\"><a href=\"#cb12-7\" tabindex=\"-1\"/>      ∀(proof <span class=\"op\">:</span> <span class=\"dt\">Natural</span><span class=\"op\">/</span>isZero <span class=\"fu\">denominator</span> ≡ <span class=\"dt\">False</span>) →</span><br><span id=\"cb12-8\"><a href=\"#cb12-8\" tabindex=\"-1\"/>    <span class=\"co\">--  ↑</span></span><br><span id=\"cb12-9\"><a href=\"#cb12-9\" tabindex=\"-1\"/>    <span class=\"co\">--  These names are still cosmetic, though</span></span><br><span id=\"cb12-10\"><a href=\"#cb12-10\" tabindex=\"-1\"/>    <span class=\"co\">--  ↓</span></span><br><span id=\"cb12-11\"><a href=\"#cb12-11\" tabindex=\"-1\"/>      ∀(<span class=\"fu\">numerator</span> <span class=\"op\">:</span> <span class=\"dt\">Natural</span>) →</span><br><span id=\"cb12-12\"><a href=\"#cb12-12\" tabindex=\"-1\"/>        <span class=\"dt\">Natural</span></span></code></pre></div><p>You might wonder why Dhall uses the <code>∀</code> / <code>forall</code> keyword for this purpose, since typically most languages only use <code>forall</code> to create polymorphic (a.k.a. “generic”) functions. This is because Dhall is implemented as a <a href=\"https://en.wikipedia.org/wiki/Pure_type_system\">pure type system</a>, meaning that Dhall uniformly handles term-level function arguments and type-level function arguments in the exact same way. They’re both special cases of <a href=\"https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type\">Π types</a>.</p><p>The following paper does a really good job explaining pure type systems and Π types:</p><ul><li><a href=\"https://www.microsoft.com/en-us/research/wp-content/uploads/1997/01/henk.pdf\">Henk: a typed intermediate language</a>,</li></ul><p>… and that’s actually where I stole this trick from.</p><p>Really the correct symbol to use is <code>Π</code> and not <code>∀</code>, but there isn’t a great way to input <code>Π</code> as ASCII. The Henk paper suggests using <code>|~|</code> as the ASCII counterpart to <code>Π</code>, but that didn’t seem right to me. I went with <code>∀</code> / <code>forall</code> because there’s already prior art for using those for type arguments.</p><h4 id=\"anonymous-record-types\">Anonymous record types</h4><p>There is another approach to naming function arguments that doesn’t require a pure type system at all: anonymous record types.</p><p>For example, we could have changed the <code>Text/replace</code> function to have this type:</p><div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb13-1\"><a href=\"#cb13-1\" tabindex=\"-1\"/>{ needle <span class=\"op\">:</span> <span class=\"dt\">Text</span>, replacement <span class=\"op\">:</span> <span class=\"dt\">Text</span>, haystack <span class=\"op\">:</span> <span class=\"dt\">Text</span> } → <span class=\"dt\">Text</span></span></code></pre></div><p>That’s pretty clear, too, and can be done in any language that supports anonymous record types, including Dhall, <a href=\"https://fsharp.org/\">F#</a>, <a href=\"https://www.purescript.org/\">PureScript</a>, <a href=\"https://elm-lang.org/\">Elm</a>, and <a href=\"https://ocaml.org/\">OCaml</a>.</p><h4 id=\"naming-type-parameters\">Naming type parameters</h4><p>You can also use the above two tricks to name type arguments for type constructors, too.</p><p>For example, we can define a <code>Map</code> type constructor to be a list of key-value pairs:</p><div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb14-1\"><a href=\"#cb14-1\" tabindex=\"-1\"/><span class=\"kw\">let</span> <span class=\"dt\">Map</span> <span class=\"ot\">=</span></span><br><span id=\"cb14-2\"><a href=\"#cb14-2\" tabindex=\"-1\"/>      λ(key <span class=\"op\">:</span> <span class=\"dt\">Type</span>) →</span><br><span id=\"cb14-3\"><a href=\"#cb14-3\" tabindex=\"-1\"/>      λ(value <span class=\"op\">:</span> <span class=\"dt\">Type</span>) →</span><br><span id=\"cb14-4\"><a href=\"#cb14-4\" tabindex=\"-1\"/>        <span class=\"dt\">List</span> { mapKey <span class=\"op\">:</span> key, mapValue <span class=\"op\">:</span> value }</span></code></pre></div><p>… which we would use like this:</p><div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb15-1\"><a href=\"#cb15-1\" tabindex=\"-1\"/>⊢ <span class=\"dt\">Map</span> <span class=\"dt\">Text</span> <span class=\"dt\">Natural</span></span><br><span id=\"cb15-2\"><a href=\"#cb15-2\" tabindex=\"-1\"/></span><br><span id=\"cb15-3\"><a href=\"#cb15-3\" tabindex=\"-1\"/><span class=\"dt\">List</span> { mapKey <span class=\"op\">:</span> <span class=\"dt\">Text</span>, mapValue <span class=\"op\">:</span> <span class=\"dt\">Natural</span> }</span></code></pre></div><p>… and the inferred type names the arguments to our <code>Map</code> type constructor:</p><div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb16-1\"><a href=\"#cb16-1\" tabindex=\"-1\"/>⊢ <span class=\"op\">:</span><span class=\"kw\">type</span> <span class=\"dt\">Map</span></span><br><span id=\"cb16-2\"><a href=\"#cb16-2\" tabindex=\"-1\"/></span><br><span id=\"cb16-3\"><a href=\"#cb16-3\" tabindex=\"-1\"/>∀(key <span class=\"op\">:</span> <span class=\"dt\">Type</span>) → ∀(value <span class=\"op\">:</span> <span class=\"dt\">Type</span>) → <span class=\"dt\">Type</span></span></code></pre></div><p>We can also use anonymous records to name type arguments, too! For example, we could have instead defined <code>Map</code> as:</p><div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb17-1\"><a href=\"#cb17-1\" tabindex=\"-1\"/><span class=\"kw\">let</span> <span class=\"dt\">Map</span> <span class=\"ot\">=</span></span><br><span id=\"cb17-2\"><a href=\"#cb17-2\" tabindex=\"-1\"/>      λ(args <span class=\"op\">:</span> { key <span class=\"op\">:</span> <span class=\"dt\">Type</span>, value <span class=\"op\">:</span> <span class=\"dt\">Type</span> }) →</span><br><span id=\"cb17-3\"><a href=\"#cb17-3\" tabindex=\"-1\"/>        <span class=\"dt\">List</span> { mapKey <span class=\"op\">:</span> args<span class=\"op\">.</span>key, mapValue <span class=\"op\">:</span> args<span class=\"op\">.</span>value }</span></code></pre></div><p>… which we would use like this:</p><div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb18-1\"><a href=\"#cb18-1\" tabindex=\"-1\"/>⊢ <span class=\"dt\">Map</span> { key <span class=\"ot\">=</span> <span class=\"dt\">Text</span>, value <span class=\"ot\">=</span> <span class=\"dt\">Natural</span> }</span><br><span id=\"cb18-2\"><a href=\"#cb18-2\" tabindex=\"-1\"/></span><br><span id=\"cb18-3\"><a href=\"#cb18-3\" tabindex=\"-1\"/><span class=\"dt\">List</span> { mapKey <span class=\"op\">:</span> <span class=\"dt\">Text</span>, mapValue <span class=\"op\">:</span> <span class=\"dt\">Natural</span> }</span></code></pre></div><p>… and this latter <code>Map</code> would have an inferred type of:</p><div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb19-1\"><a href=\"#cb19-1\" tabindex=\"-1\"/>⊢ <span class=\"op\">:</span><span class=\"kw\">type</span> <span class=\"dt\">Map</span></span><br><span id=\"cb19-2\"><a href=\"#cb19-2\" tabindex=\"-1\"/></span><br><span id=\"cb19-3\"><a href=\"#cb19-3\" tabindex=\"-1\"/>∀(args <span class=\"op\">:</span> { key <span class=\"op\">:</span> <span class=\"dt\">Type</span>, value <span class=\"op\">:</span> <span class=\"dt\">Type</span> }) → <span class=\"dt\">Type</span></span></code></pre></div><p>Pretty neat! Not many languages can pass type constructor arguments as named fields of a record.</p><h4 id=\"conclusion\">Conclusion</h4><p>Hopefully this gives language designers some ideas for how they can add language support for naming function arguments.</p><p>Unfortunately, my favorite language (<a href=\"https://www.haskell.org/\">Haskell</a>) does not exactly support these features, so sometimes people work around this by using <code>newtype</code>s to name function arguments. I’ve never been of fan of this approach, especially if the newtype is not opaque and this post does a good job of explaining why:</p><ul><li><a href=\"https://lexi-lambda.github.io/blog/2020/11/01/names-are-not-type-safety/\">Names are not type safety</a></li></ul><p>However, you can simulate this trick in Haskell using something like what the <code>vulkan</code> package does, which is to use <code>DataKinds</code> and <code>TypeOperators</code> to create a type-level operator that lets you associate arbitrary name data with types:</p><div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb20-1\"><a href=\"#cb20-1\" tabindex=\"-1\"/><span class=\"kw\">type</span> (<span class=\"ot\">name ::</span> k) <span class=\"op\">:::</span> a <span class=\"ot\">=</span> a</span></code></pre></div><p>… which the package uses like this:</p><div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb21-1\"><a href=\"#cb21-1\" tabindex=\"-1\"/>cmdDraw</span><br><span id=\"cb21-2\"><a href=\"#cb21-2\" tabindex=\"-1\"/><span class=\"ot\">    ::</span> <span class=\"kw\">forall</span> io <span class=\"op\">.</span> (<span class=\"dt\">MonadIO</span> io)</span><br><span id=\"cb21-3\"><a href=\"#cb21-3\" tabindex=\"-1\"/>    <span class=\"ot\">=&gt;</span> <span class=\"co\">-- | @commandBuffer@ is the command buffer into which the command is</span></span><br><span id=\"cb21-4\"><a href=\"#cb21-4\" tabindex=\"-1\"/>       <span class=\"co\">-- recorded.</span></span><br><span id=\"cb21-5\"><a href=\"#cb21-5\" tabindex=\"-1\"/>       <span class=\"dt\">CommandBuffer</span></span><br><span id=\"cb21-6\"><a href=\"#cb21-6\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"co\">-- | @vertexCount@ is the number of vertices to draw.</span></span><br><span id=\"cb21-7\"><a href=\"#cb21-7\" tabindex=\"-1\"/>       (<span class=\"st\">&quot;vertexCount&quot;</span> <span class=\"op\">:::</span> <span class=\"dt\">Word32</span>)</span><br><span id=\"cb21-8\"><a href=\"#cb21-8\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"co\">-- | @instanceCount@ is the number of instances to draw.</span></span><br><span id=\"cb21-9\"><a href=\"#cb21-9\" tabindex=\"-1\"/>       (<span class=\"st\">&quot;instanceCount&quot;</span> <span class=\"op\">:::</span> <span class=\"dt\">Word32</span>)</span><br><span id=\"cb21-10\"><a href=\"#cb21-10\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"co\">-- | @firstVertex@ is the index of the first vertex to draw.</span></span><br><span id=\"cb21-11\"><a href=\"#cb21-11\" tabindex=\"-1\"/>       (<span class=\"st\">&quot;firstVertex&quot;</span> <span class=\"op\">:::</span> <span class=\"dt\">Word32</span>)</span><br><span id=\"cb21-12\"><a href=\"#cb21-12\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> <span class=\"co\">-- | @firstInstance@ is the instance ID of the first instance to draw.</span></span><br><span id=\"cb21-13\"><a href=\"#cb21-13\" tabindex=\"-1\"/>       (<span class=\"st\">&quot;firstInstance&quot;</span> <span class=\"op\">:::</span> <span class=\"dt\">Word32</span>)</span><br><span id=\"cb21-14\"><a href=\"#cb21-14\" tabindex=\"-1\"/>    <span class=\"ot\">-&gt;</span> io ()</span></code></pre></div><p>These names are ignored by the type-checker, just like the equivalent cosmetic names in Dhall.</p></body></html>"
}