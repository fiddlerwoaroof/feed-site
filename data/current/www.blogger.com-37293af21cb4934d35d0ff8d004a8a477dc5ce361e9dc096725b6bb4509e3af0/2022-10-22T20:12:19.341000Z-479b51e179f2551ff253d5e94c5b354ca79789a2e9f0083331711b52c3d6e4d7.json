{
  "title":"What does \"isomorphic\" mean (in Haskell)?",
  "date":"2022-10-22T20:12:19.341000Z",
  "author":"Gabriella Gonzalez",
  "id":"tag:blogger.com,1999:blog-1777990983847811806.post-5833984871945391183",
  "link":"https://www.haskellforall.com/2022/10/what-does-isomorphic-mean-in-haskell.html",
  "content":"<!DOCTYPE html><html xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"\"><head>                  </head><body><p>Sometimes you’ll hear someone describe two things as being “isomorphic” to one another and I wanted to explain what that means.</p><p>You might have already guessed that “isomorphic” is a synonym for “equivalent”, and that would have been a pretty good guess. Really, the main difference between the two words is that “isomorphic” has a more precise and more general definition than “equivalent”.</p><p>In this post I will introduce a more precise definition of “isomorphic”, using Haskell code. This definition won’t be the fully general definition, but I still hope to give you some taste of how “isomorphic” can denote something more than just “equivalent”.</p><h4 id=\"the-simple-version\">The simple version</h4><p>The simplest and least general definition of “isomorphic” (in Haskell) is:</p><blockquote><p>Two types, <code>A</code>, and <code>B</code>, are isomorphic if there exist two functions, <code>forward</code> and <code>backward</code> of the following types:</p><div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb1-1\"><a href=\"#cb1-1\" tabindex=\"-1\"></a><span class=\"ot\">forward ::</span> <span class=\"dt\">A</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">B</span></span><br><span id=\"cb1-2\"><a href=\"#cb1-2\" tabindex=\"-1\"></a></span><br><span id=\"cb1-3\"><a href=\"#cb1-3\" tabindex=\"-1\"></a><span class=\"ot\">backward ::</span> <span class=\"dt\">B</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">A</span></span></code></pre></div><p>… such that the following two equations (which I will refer to as the “isomorphism laws”) are true:</p><div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb2-1\"><a href=\"#cb2-1\" tabindex=\"-1\"></a>forward <span class=\"op\">.</span> backward <span class=\"ot\">=</span> <span class=\"fu\">id</span></span><br><span id=\"cb2-2\"><a href=\"#cb2-2\" tabindex=\"-1\"></a></span><br><span id=\"cb2-3\"><a href=\"#cb2-3\" tabindex=\"-1\"></a>backward <span class=\"op\">.</span> forward <span class=\"ot\">=</span> <span class=\"fu\">id</span></span></code></pre></div></blockquote><p><code>id</code> here is the identity function from Haskell’s Prelude, defined like this:</p><div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb3-1\"><a href=\"#cb3-1\" tabindex=\"-1\"></a><span class=\"fu\">id</span><span class=\"ot\"> ::</span> a <span class=\"ot\">-&gt;</span> a</span><br><span id=\"cb3-2\"><a href=\"#cb3-2\" tabindex=\"-1\"></a><span class=\"fu\">id</span> x <span class=\"ot\">=</span> x</span></code></pre></div><p>… and <code>(.)</code> is the function composition operator (also from Haskell’s Prelude), defined like this:</p><div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb4-1\"><a href=\"#cb4-1\" tabindex=\"-1\"></a><span class=\"ot\">(.) ::</span> (b <span class=\"ot\">-&gt;</span> c) <span class=\"ot\">-&gt;</span> (a <span class=\"ot\">-&gt;</span> b) <span class=\"ot\">-&gt;</span> (a <span class=\"ot\">-&gt;</span> c)</span><br><span id=\"cb4-2\"><a href=\"#cb4-2\" tabindex=\"-1\"></a>(f <span class=\"op\">.</span> g) x <span class=\"ot\">=</span> f (g x)</span></code></pre></div><p>According to the above definition, the types <code>Bool -&gt; a</code> and <code>(a, a)</code> are isomorphic, because we can define two functions:</p><div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb5-1\"><a href=\"#cb5-1\" tabindex=\"-1\"></a><span class=\"ot\">forward ::</span> (<span class=\"dt\">Bool</span> <span class=\"ot\">-&gt;</span> a) <span class=\"ot\">-&gt;</span> (a, a)</span><br><span id=\"cb5-2\"><a href=\"#cb5-2\" tabindex=\"-1\"></a>forward function <span class=\"ot\">=</span> (function <span class=\"dt\">False</span>, function <span class=\"dt\">True</span>)</span><br><span id=\"cb5-3\"><a href=\"#cb5-3\" tabindex=\"-1\"></a></span><br><span id=\"cb5-4\"><a href=\"#cb5-4\" tabindex=\"-1\"></a><span class=\"ot\">backward ::</span> (a, a) <span class=\"ot\">-&gt;</span> (<span class=\"dt\">Bool</span> <span class=\"ot\">-&gt;</span> a)</span><br><span id=\"cb5-5\"><a href=\"#cb5-5\" tabindex=\"-1\"></a>backward (first, second) <span class=\"dt\">False</span> <span class=\"ot\">=</span> first</span><br><span id=\"cb5-6\"><a href=\"#cb5-6\" tabindex=\"-1\"></a>backward (first, second) <span class=\"dt\">True</span>  <span class=\"ot\">=</span> second</span></code></pre></div><p>… and we can prove that those two functions satisfy the isomorphism laws using <a href=\"https://www.haskellforall.com/2013/12/equational-reasoning.html\">equational reasoning</a>.</p><details><summary>Proof of the isomorphism laws (click to expand) </summary><p>Here’s the proof of the first isomorphism law:</p><div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb6-1\"><a href=\"#cb6-1\" tabindex=\"-1\"></a>forward <span class=\"op\">.</span> backward</span><br><span id=\"cb6-2\"><a href=\"#cb6-2\" tabindex=\"-1\"></a></span><br><span id=\"cb6-3\"><a href=\"#cb6-3\" tabindex=\"-1\"></a><span class=\"co\">-- (f . g) = \\x -&gt; f (g x)</span></span><br><span id=\"cb6-4\"><a href=\"#cb6-4\" tabindex=\"-1\"></a><span class=\"co\">--</span></span><br><span id=\"cb6-5\"><a href=\"#cb6-5\" tabindex=\"-1\"></a><span class=\"co\">-- … where:</span></span><br><span id=\"cb6-6\"><a href=\"#cb6-6\" tabindex=\"-1\"></a><span class=\"co\">--</span></span><br><span id=\"cb6-7\"><a href=\"#cb6-7\" tabindex=\"-1\"></a><span class=\"co\">-- f = forward</span></span><br><span id=\"cb6-8\"><a href=\"#cb6-8\" tabindex=\"-1\"></a><span class=\"co\">-- g = backward</span></span><br><span id=\"cb6-9\"><a href=\"#cb6-9\" tabindex=\"-1\"></a><span class=\"ot\">=</span> \\x <span class=\"ot\">-&gt;</span> forward (backward x)</span><br><span id=\"cb6-10\"><a href=\"#cb6-10\" tabindex=\"-1\"></a></span><br><span id=\"cb6-11\"><a href=\"#cb6-11\" tabindex=\"-1\"></a><span class=\"co\">-- x = (first, second)</span></span><br><span id=\"cb6-12\"><a href=\"#cb6-12\" tabindex=\"-1\"></a><span class=\"ot\">=</span> \\(first, second) <span class=\"ot\">-&gt;</span> forward (backward (first, second))</span><br><span id=\"cb6-13\"><a href=\"#cb6-13\" tabindex=\"-1\"></a></span><br><span id=\"cb6-14\"><a href=\"#cb6-14\" tabindex=\"-1\"></a><span class=\"co\">-- forward function = (function False, function True)</span></span><br><span id=\"cb6-15\"><a href=\"#cb6-15\" tabindex=\"-1\"></a><span class=\"ot\">=</span> \\(first, second) <span class=\"ot\">-&gt;</span></span><br><span id=\"cb6-16\"><a href=\"#cb6-16\" tabindex=\"-1\"></a>    (backward (first, second) <span class=\"dt\">False</span>, backward (first, second) <span class=\"dt\">True</span>)</span><br><span id=\"cb6-17\"><a href=\"#cb6-17\" tabindex=\"-1\"></a></span><br><span id=\"cb6-18\"><a href=\"#cb6-18\" tabindex=\"-1\"></a><span class=\"co\">-- backward (first, second) False = first</span></span><br><span id=\"cb6-19\"><a href=\"#cb6-19\" tabindex=\"-1\"></a><span class=\"co\">-- backward (first, second) True  = second</span></span><br><span id=\"cb6-20\"><a href=\"#cb6-20\" tabindex=\"-1\"></a><span class=\"ot\">=</span> \\(first, second) <span class=\"ot\">-&gt;</span> (first, second)</span><br><span id=\"cb6-21\"><a href=\"#cb6-21\" tabindex=\"-1\"></a></span><br><span id=\"cb6-22\"><a href=\"#cb6-22\" tabindex=\"-1\"></a><span class=\"co\">-- x = (first, second)</span></span><br><span id=\"cb6-23\"><a href=\"#cb6-23\" tabindex=\"-1\"></a><span class=\"co\">--</span></span><br><span id=\"cb6-24\"><a href=\"#cb6-24\" tabindex=\"-1\"></a><span class=\"co\">-- … in reverse</span></span><br><span id=\"cb6-25\"><a href=\"#cb6-25\" tabindex=\"-1\"></a><span class=\"ot\">=</span> \\x <span class=\"ot\">-&gt;</span> x</span><br><span id=\"cb6-26\"><a href=\"#cb6-26\" tabindex=\"-1\"></a></span><br><span id=\"cb6-27\"><a href=\"#cb6-27\" tabindex=\"-1\"></a><span class=\"co\">-- id x = x</span></span><br><span id=\"cb6-28\"><a href=\"#cb6-28\" tabindex=\"-1\"></a><span class=\"co\">--</span></span><br><span id=\"cb6-29\"><a href=\"#cb6-29\" tabindex=\"-1\"></a><span class=\"co\">-- … in reverse</span></span><br><span id=\"cb6-30\"><a href=\"#cb6-30\" tabindex=\"-1\"></a><span class=\"ot\">=</span> \\x <span class=\"ot\">-&gt;</span> <span class=\"fu\">id</span> x</span><br><span id=\"cb6-31\"><a href=\"#cb6-31\" tabindex=\"-1\"></a></span><br><span id=\"cb6-32\"><a href=\"#cb6-32\" tabindex=\"-1\"></a><span class=\"co\">-- η-reduction</span></span><br><span id=\"cb6-33\"><a href=\"#cb6-33\" tabindex=\"-1\"></a><span class=\"ot\">=</span> <span class=\"fu\">id</span></span></code></pre></div><p>… and here is the proof of the second isomorphism law:</p><div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb7-1\"><a href=\"#cb7-1\" tabindex=\"-1\"></a>backward <span class=\"op\">.</span> forward</span><br><span id=\"cb7-2\"><a href=\"#cb7-2\" tabindex=\"-1\"></a></span><br><span id=\"cb7-3\"><a href=\"#cb7-3\" tabindex=\"-1\"></a><span class=\"co\">-- (f . g) = \\x -&gt; f (g x)</span></span><br><span id=\"cb7-4\"><a href=\"#cb7-4\" tabindex=\"-1\"></a><span class=\"co\">--</span></span><br><span id=\"cb7-5\"><a href=\"#cb7-5\" tabindex=\"-1\"></a><span class=\"co\">-- … where:</span></span><br><span id=\"cb7-6\"><a href=\"#cb7-6\" tabindex=\"-1\"></a><span class=\"co\">--</span></span><br><span id=\"cb7-7\"><a href=\"#cb7-7\" tabindex=\"-1\"></a><span class=\"co\">-- f = backward</span></span><br><span id=\"cb7-8\"><a href=\"#cb7-8\" tabindex=\"-1\"></a><span class=\"co\">-- g = forward</span></span><br><span id=\"cb7-9\"><a href=\"#cb7-9\" tabindex=\"-1\"></a><span class=\"co\">-- x = function</span></span><br><span id=\"cb7-10\"><a href=\"#cb7-10\" tabindex=\"-1\"></a><span class=\"ot\">=</span> \\function <span class=\"ot\">-&gt;</span> backward (forward function)</span><br><span id=\"cb7-11\"><a href=\"#cb7-11\" tabindex=\"-1\"></a></span><br><span id=\"cb7-12\"><a href=\"#cb7-12\" tabindex=\"-1\"></a><span class=\"co\">-- forward function = (function False, function True)</span></span><br><span id=\"cb7-13\"><a href=\"#cb7-13\" tabindex=\"-1\"></a><span class=\"ot\">=</span> \\function <span class=\"ot\">-&gt;</span> backward (function <span class=\"dt\">False</span>, function <span class=\"dt\">True</span>)</span><br><span id=\"cb7-14\"><a href=\"#cb7-14\" tabindex=\"-1\"></a></span><br><span id=\"cb7-15\"><a href=\"#cb7-15\" tabindex=\"-1\"></a><span class=\"co\">-- η-expand</span></span><br><span id=\"cb7-16\"><a href=\"#cb7-16\" tabindex=\"-1\"></a><span class=\"ot\">=</span> \\function bool <span class=\"ot\">-&gt;</span> backward (function <span class=\"dt\">False</span>, function <span class=\"dt\">True</span>) bool</span><br><span id=\"cb7-17\"><a href=\"#cb7-17\" tabindex=\"-1\"></a></span><br><span id=\"cb7-18\"><a href=\"#cb7-18\" tabindex=\"-1\"></a><span class=\"co\">-- There are two possible cases:</span></span><br><span id=\"cb7-19\"><a href=\"#cb7-19\" tabindex=\"-1\"></a><span class=\"co\">--</span></span><br><span id=\"cb7-20\"><a href=\"#cb7-20\" tabindex=\"-1\"></a><span class=\"co\">-- Case #0: bool = False</span></span><br><span id=\"cb7-21\"><a href=\"#cb7-21\" tabindex=\"-1\"></a><span class=\"co\">-- Case #1: bool = True</span></span><br><span id=\"cb7-22\"><a href=\"#cb7-22\" tabindex=\"-1\"></a></span><br><span id=\"cb7-23\"><a href=\"#cb7-23\" tabindex=\"-1\"></a><span class=\"co\">-- Proof for case #0: bool = False</span></span><br><span id=\"cb7-24\"><a href=\"#cb7-24\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> \\function bool <span class=\"ot\">-&gt;</span> backward (function <span class=\"dt\">False</span>, function <span class=\"dt\">True</span>) <span class=\"dt\">False</span></span><br><span id=\"cb7-25\"><a href=\"#cb7-25\" tabindex=\"-1\"></a></span><br><span id=\"cb7-26\"><a href=\"#cb7-26\" tabindex=\"-1\"></a>  <span class=\"co\">-- backward (first, second) False = first</span></span><br><span id=\"cb7-27\"><a href=\"#cb7-27\" tabindex=\"-1\"></a>  <span class=\"co\">--</span></span><br><span id=\"cb7-28\"><a href=\"#cb7-28\" tabindex=\"-1\"></a>  <span class=\"co\">-- … where:</span></span><br><span id=\"cb7-29\"><a href=\"#cb7-29\" tabindex=\"-1\"></a>  <span class=\"co\">--</span></span><br><span id=\"cb7-30\"><a href=\"#cb7-30\" tabindex=\"-1\"></a>  <span class=\"co\">-- first  = function False</span></span><br><span id=\"cb7-31\"><a href=\"#cb7-31\" tabindex=\"-1\"></a>  <span class=\"co\">-- second = function True</span></span><br><span id=\"cb7-32\"><a href=\"#cb7-32\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> \\function bool <span class=\"ot\">-&gt;</span> function <span class=\"dt\">False</span></span><br><span id=\"cb7-33\"><a href=\"#cb7-33\" tabindex=\"-1\"></a></span><br><span id=\"cb7-34\"><a href=\"#cb7-34\" tabindex=\"-1\"></a>  <span class=\"co\">-- bool = False</span></span><br><span id=\"cb7-35\"><a href=\"#cb7-35\" tabindex=\"-1\"></a>  <span class=\"co\">--</span></span><br><span id=\"cb7-36\"><a href=\"#cb7-36\" tabindex=\"-1\"></a>  <span class=\"co\">-- … in reverse</span></span><br><span id=\"cb7-37\"><a href=\"#cb7-37\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> \\function bool <span class=\"ot\">-&gt;</span> function bool</span><br><span id=\"cb7-38\"><a href=\"#cb7-38\" tabindex=\"-1\"></a></span><br><span id=\"cb7-39\"><a href=\"#cb7-39\" tabindex=\"-1\"></a>  <span class=\"co\">-- η-reduction</span></span><br><span id=\"cb7-40\"><a href=\"#cb7-40\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> \\function <span class=\"ot\">-&gt;</span> function</span><br><span id=\"cb7-41\"><a href=\"#cb7-41\" tabindex=\"-1\"></a></span><br><span id=\"cb7-42\"><a href=\"#cb7-42\" tabindex=\"-1\"></a>  <span class=\"co\">-- id x = x</span></span><br><span id=\"cb7-43\"><a href=\"#cb7-43\" tabindex=\"-1\"></a>  <span class=\"co\">--</span></span><br><span id=\"cb7-44\"><a href=\"#cb7-44\" tabindex=\"-1\"></a>  <span class=\"co\">-- … in reverse</span></span><br><span id=\"cb7-45\"><a href=\"#cb7-45\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> \\function <span class=\"ot\">-&gt;</span> <span class=\"fu\">id</span> function</span><br><span id=\"cb7-46\"><a href=\"#cb7-46\" tabindex=\"-1\"></a></span><br><span id=\"cb7-47\"><a href=\"#cb7-47\" tabindex=\"-1\"></a>  <span class=\"co\">-- η-reduction</span></span><br><span id=\"cb7-48\"><a href=\"#cb7-48\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> <span class=\"fu\">id</span></span><br><span id=\"cb7-49\"><a href=\"#cb7-49\" tabindex=\"-1\"></a></span><br><span id=\"cb7-50\"><a href=\"#cb7-50\" tabindex=\"-1\"></a><span class=\"co\">-- Proof for case #1: bool = True</span></span><br><span id=\"cb7-51\"><a href=\"#cb7-51\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> \\function bool <span class=\"ot\">-&gt;</span> backward (function <span class=\"dt\">False</span>, function <span class=\"dt\">True</span>) <span class=\"dt\">True</span></span><br><span id=\"cb7-52\"><a href=\"#cb7-52\" tabindex=\"-1\"></a></span><br><span id=\"cb7-53\"><a href=\"#cb7-53\" tabindex=\"-1\"></a>  <span class=\"co\">-- backward (first, second) True = second</span></span><br><span id=\"cb7-54\"><a href=\"#cb7-54\" tabindex=\"-1\"></a>  <span class=\"co\">--</span></span><br><span id=\"cb7-55\"><a href=\"#cb7-55\" tabindex=\"-1\"></a>  <span class=\"co\">-- … where:</span></span><br><span id=\"cb7-56\"><a href=\"#cb7-56\" tabindex=\"-1\"></a>  <span class=\"co\">--</span></span><br><span id=\"cb7-57\"><a href=\"#cb7-57\" tabindex=\"-1\"></a>  <span class=\"co\">-- first  = function False</span></span><br><span id=\"cb7-58\"><a href=\"#cb7-58\" tabindex=\"-1\"></a>  <span class=\"co\">-- second = function True</span></span><br><span id=\"cb7-59\"><a href=\"#cb7-59\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> \\function bool <span class=\"ot\">-&gt;</span> function <span class=\"dt\">True</span></span><br><span id=\"cb7-60\"><a href=\"#cb7-60\" tabindex=\"-1\"></a></span><br><span id=\"cb7-61\"><a href=\"#cb7-61\" tabindex=\"-1\"></a>  <span class=\"co\">-- b = True</span></span><br><span id=\"cb7-62\"><a href=\"#cb7-62\" tabindex=\"-1\"></a>  <span class=\"co\">--</span></span><br><span id=\"cb7-63\"><a href=\"#cb7-63\" tabindex=\"-1\"></a>  <span class=\"co\">-- … in reverse</span></span><br><span id=\"cb7-64\"><a href=\"#cb7-64\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> \\function bool <span class=\"ot\">-&gt;</span> function bool</span><br><span id=\"cb7-65\"><a href=\"#cb7-65\" tabindex=\"-1\"></a></span><br><span id=\"cb7-66\"><a href=\"#cb7-66\" tabindex=\"-1\"></a>  <span class=\"co\">-- η-reduction</span></span><br><span id=\"cb7-67\"><a href=\"#cb7-67\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> \\function <span class=\"ot\">-&gt;</span> function</span><br><span id=\"cb7-68\"><a href=\"#cb7-68\" tabindex=\"-1\"></a></span><br><span id=\"cb7-69\"><a href=\"#cb7-69\" tabindex=\"-1\"></a>  <span class=\"co\">-- id x = x</span></span><br><span id=\"cb7-70\"><a href=\"#cb7-70\" tabindex=\"-1\"></a>  <span class=\"co\">--</span></span><br><span id=\"cb7-71\"><a href=\"#cb7-71\" tabindex=\"-1\"></a>  <span class=\"co\">-- … in reverse</span></span><br><span id=\"cb7-72\"><a href=\"#cb7-72\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> \\function <span class=\"ot\">-&gt;</span> <span class=\"fu\">id</span> function</span><br><span id=\"cb7-73\"><a href=\"#cb7-73\" tabindex=\"-1\"></a></span><br><span id=\"cb7-74\"><a href=\"#cb7-74\" tabindex=\"-1\"></a>  <span class=\"co\">-- η-reduction</span></span><br><span id=\"cb7-75\"><a href=\"#cb7-75\" tabindex=\"-1\"></a>  <span class=\"ot\">=</span> <span class=\"fu\">id</span></span></code></pre></div></details><p>We’ll use the notation <code>A ≅ B</code> as a short-hand for “<code>A</code> is isomorphic to <code>B</code>”, so we can also write:</p><div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb8-1\"><a href=\"#cb8-1\" tabindex=\"-1\"></a><span class=\"dt\">Bool</span> <span class=\"ot\">-&gt;</span> a ≅ (a, a)</span></code></pre></div><p>Whenever we declare that two types are isomorphic we need to actually specify what the <code>forward</code> and <code>backward</code>conversion functions are and prove that they satisfy isomorphism laws. The existence of <code>forward</code> and <code>backward</code>functions of the correct input and output types is not enough to establish that the two types are isomorphic.</p><p>For example, suppose we changed the definition of <code>forward</code> to:</p><div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb9-1\"><a href=\"#cb9-1\" tabindex=\"-1\"></a><span class=\"ot\">forward ::</span> (<span class=\"dt\">Bool</span> <span class=\"ot\">-&gt;</span> a) <span class=\"ot\">-&gt;</span> (a, a)</span><br><span id=\"cb9-2\"><a href=\"#cb9-2\" tabindex=\"-1\"></a>forward function <span class=\"ot\">=</span> (function <span class=\"dt\">True</span>, function <span class=\"dt\">False</span>)</span></code></pre></div><p>Then <code>forward . backward</code> and <code>backward . forward</code> would still type-check and have the right type, but they would no longer be equal to <code>id</code>.</p><p>In other words, when discussing isomorphic types, it’s technically not enough that the two types are equivalent. The <em>way</em> in which they are equivalent matters, too, if we want to be pedantic. In practice, though, if there’s only one way to implement the two conversion functions then people won’t bother to explicitly specify them.</p><p>The reason why this is important is because an isomorphism also gives us an explicit way to convert between the two types.  We're not just declaring that they're equivalent, but we're spelling out exactly how to transform each type into the other type, which is very useful!</p><h4 id=\"more-examples\">More examples</h4><p>Let’s speedrun through a few more examples of isomorphic types, which all parallel the rules of arithmetic:</p><div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb10-1\"><a href=\"#cb10-1\" tabindex=\"-1\"></a><span class=\"co\">-- 0 + a = a</span></span><br><span id=\"cb10-2\"><a href=\"#cb10-2\" tabindex=\"-1\"></a><span class=\"dt\">Either</span> <span class=\"dt\">Void</span> a ≅ a</span><br><span id=\"cb10-3\"><a href=\"#cb10-3\" tabindex=\"-1\"></a></span><br><span id=\"cb10-4\"><a href=\"#cb10-4\" tabindex=\"-1\"></a><span class=\"co\">-- a + (b + c) = (a + b) + c</span></span><br><span id=\"cb10-5\"><a href=\"#cb10-5\" tabindex=\"-1\"></a><span class=\"dt\">Either</span> a (<span class=\"dt\">Either</span> b c) <span class=\"ot\">=</span> <span class=\"dt\">Either</span> (<span class=\"dt\">Either</span> a b) c</span><br><span id=\"cb10-6\"><a href=\"#cb10-6\" tabindex=\"-1\"></a></span><br><span id=\"cb10-7\"><a href=\"#cb10-7\" tabindex=\"-1\"></a><span class=\"co\">-- 1 × a = a</span></span><br><span id=\"cb10-8\"><a href=\"#cb10-8\" tabindex=\"-1\"></a>((), a) ≅ a</span><br><span id=\"cb10-9\"><a href=\"#cb10-9\" tabindex=\"-1\"></a></span><br><span id=\"cb10-10\"><a href=\"#cb10-10\" tabindex=\"-1\"></a><span class=\"co\">-- a × (b × c) = (a × b) × c</span></span><br><span id=\"cb10-11\"><a href=\"#cb10-11\" tabindex=\"-1\"></a>(a, (b, c)) ≅ ((a, b), c)</span><br><span id=\"cb10-12\"><a href=\"#cb10-12\" tabindex=\"-1\"></a></span><br><span id=\"cb10-13\"><a href=\"#cb10-13\" tabindex=\"-1\"></a><span class=\"co\">-- 0 × a = 0</span></span><br><span id=\"cb10-14\"><a href=\"#cb10-14\" tabindex=\"-1\"></a>(<span class=\"dt\">Void</span>, a) ≅ <span class=\"dt\">Void</span></span><br><span id=\"cb10-15\"><a href=\"#cb10-15\" tabindex=\"-1\"></a></span><br><span id=\"cb10-16\"><a href=\"#cb10-16\" tabindex=\"-1\"></a><span class=\"co\">-- a × (b + c) = (a × b) + (a × c)</span></span><br><span id=\"cb10-17\"><a href=\"#cb10-17\" tabindex=\"-1\"></a>(a, <span class=\"dt\">Either</span> b c) ≅ <span class=\"dt\">Either</span> (a, b) (a, c)</span><br><span id=\"cb10-18\"><a href=\"#cb10-18\" tabindex=\"-1\"></a></span><br><span id=\"cb10-19\"><a href=\"#cb10-19\" tabindex=\"-1\"></a><span class=\"co\">-- a ^ 1 = a</span></span><br><span id=\"cb10-20\"><a href=\"#cb10-20\" tabindex=\"-1\"></a>() <span class=\"ot\">-&gt;</span> a ≅ a</span><br><span id=\"cb10-21\"><a href=\"#cb10-21\" tabindex=\"-1\"></a></span><br><span id=\"cb10-22\"><a href=\"#cb10-22\" tabindex=\"-1\"></a><span class=\"co\">-- a ^ 0 = 1</span></span><br><span id=\"cb10-23\"><a href=\"#cb10-23\" tabindex=\"-1\"></a><span class=\"dt\">Void</span> <span class=\"ot\">-&gt;</span> a ≅ ()</span><br><span id=\"cb10-24\"><a href=\"#cb10-24\" tabindex=\"-1\"></a></span><br><span id=\"cb10-25\"><a href=\"#cb10-25\" tabindex=\"-1\"></a><span class=\"co\">-- (c ^ b) ^ a = (c ^ a) ^ b</span></span><br><span id=\"cb10-26\"><a href=\"#cb10-26\" tabindex=\"-1\"></a>a <span class=\"ot\">-&gt;</span> b <span class=\"ot\">-&gt;</span> c ≅ b <span class=\"ot\">-&gt;</span> a <span class=\"ot\">-&gt;</span> c</span><br><span id=\"cb10-27\"><a href=\"#cb10-27\" tabindex=\"-1\"></a></span><br><span id=\"cb10-28\"><a href=\"#cb10-28\" tabindex=\"-1\"></a><span class=\"co\">-- (c ^ b) ^ a = c ^ (a × b)</span></span><br><span id=\"cb10-29\"><a href=\"#cb10-29\" tabindex=\"-1\"></a>a <span class=\"ot\">-&gt;</span> b <span class=\"ot\">-&gt;</span> c ≅ (a, b) <span class=\"ot\">-&gt;</span> c</span></code></pre></div><p><strong>Exercise:</strong> implement the <code>forward</code> and <code>backward</code> functions for some of the above types and prove the isomorphism laws for each pair of functions. It will probably be very tedious to prove all of the above examples, so pick the ones that interest you the most.</p><h4 id=\"intermediate-tricks\">Intermediate tricks</h4><p>This section will introduce some more advanced tricks for proving that two types are isomorphic.</p><p>First, let’s start with a few ground rules for working with all isomorphisms:</p><ul><li><p>Reflexivity: <code>a ≅ a</code></p></li><li><p>Symmetry: If <code>a ≅ b</code> then <code>b ≅ a</code></p></li><li><p>Transitivity: If <code>a ≅ b</code> and <code>b ≅ c</code> then <code>a ≅ c</code></p></li></ul><p>Now let’s get into some Haskell-specific rules:</p><blockquote><p>a <code>newtype</code> in Haskell is isomorphic to the underlying type if the <code>newtype</code> constructor is public.</p></blockquote><p>For example, if we were to define:</p><div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb11-1\"><a href=\"#cb11-1\" tabindex=\"-1\"></a><span class=\"kw\">newtype</span> <span class=\"dt\">Name</span> <span class=\"ot\">=</span> <span class=\"dt\">Name</span> {<span class=\"ot\"> getName ::</span> <span class=\"dt\">String</span> }</span></code></pre></div><p>… then <code>Name</code> and <code>String</code> would be isomorphic (<code>Name ≅ String</code>), where:</p><div class=\"sourceCode\" id=\"cb12\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb12-1\"><a href=\"#cb12-1\" tabindex=\"-1\"></a><span class=\"ot\">forward ::</span> <span class=\"dt\">Name</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">String</span></span><br><span id=\"cb12-2\"><a href=\"#cb12-2\" tabindex=\"-1\"></a>forward <span class=\"ot\">=</span> getName</span><br><span id=\"cb12-3\"><a href=\"#cb12-3\" tabindex=\"-1\"></a></span><br><span id=\"cb12-4\"><a href=\"#cb12-4\" tabindex=\"-1\"></a><span class=\"ot\">backward ::</span> <span class=\"dt\">String</span> <span class=\"ot\">-&gt;</span> <span class=\"dt\">Name</span></span><br><span id=\"cb12-5\"><a href=\"#cb12-5\" tabindex=\"-1\"></a>backward <span class=\"ot\">=</span> <span class=\"dt\">Name</span></span></code></pre></div><p>One such <code>newtype</code> that shows up pretty often when reasoning about isomorphic types is the <a href=\"https://hackage.haskell.org/package/base/docs/Data-Functor-Identity.html#t:Identity\"><code>Identity</code></a>type constructor from <a href=\"https://hackage.haskell.org/package/base/docs/Data-Functor-Identity.html\"><code>Data.Functor.Identity</code></a>:</p><div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb13-1\"><a href=\"#cb13-1\" tabindex=\"-1\"></a><span class=\"kw\">newtype</span> <span class=\"dt\">Identity</span> a <span class=\"ot\">=</span> <span class=\"dt\">Identity</span> {<span class=\"ot\"> runIdentity ::</span> a }</span></code></pre></div><p>… where <code>Identity a ≅ a</code>.</p><p>To see why <code>Identity</code> is useful, consider the following two types:</p><div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb14-1\"><a href=\"#cb14-1\" tabindex=\"-1\"></a><span class=\"kw\">newtype</span> <span class=\"dt\">State</span> s a <span class=\"ot\">=</span> <span class=\"dt\">State</span> {<span class=\"ot\"> runState ::</span> s <span class=\"ot\">-&gt;</span> (a, s) }</span><br><span id=\"cb14-2\"><a href=\"#cb14-2\" tabindex=\"-1\"></a></span><br><span id=\"cb14-3\"><a href=\"#cb14-3\" tabindex=\"-1\"></a><span class=\"kw\">newtype</span> <span class=\"dt\">StateT</span> s m a <span class=\"ot\">=</span> <span class=\"dt\">StateT</span> {<span class=\"ot\"> runStateT ::</span> s <span class=\"ot\">-&gt;</span> m (a, s) }</span></code></pre></div><p>The latter <code>newtype</code> is from the <code>transformers</code>package, which is how we layer on the “state” effect within a monad transformer stack. If you don’t understand what that means, that’s okay; it’s not that relevant to the point.</p><p>However, the <code>transformers</code> package doesn’t define <code>State</code> as above. Instead, the <code>transformers</code>package defines <code>State</code> like this:</p><div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb15-1\"><a href=\"#cb15-1\" tabindex=\"-1\"></a><span class=\"kw\">type</span> <span class=\"dt\">State</span> s <span class=\"ot\">=</span> <span class=\"dt\">StateT</span> s <span class=\"dt\">Identity</span></span></code></pre></div><p>The latter <code>type</code> synonym definition for <code>State</code> is equivalent (“isomorphic”) to the <code>newtype</code> definition for <code>State</code> I provided above. In order to prove that though I’ll need to distinguish between the two <code>State</code> type constructors, so I’ll use a numeric subscript to distinguish them:</p><div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb16-1\"><a href=\"#cb16-1\" tabindex=\"-1\"></a><span class=\"kw\">import</span> <span class=\"dt\">Data.Functor.Identity</span> (<span class=\"dt\">Identity</span>)</span><br><span id=\"cb16-2\"><a href=\"#cb16-2\" tabindex=\"-1\"></a></span><br><span id=\"cb16-3\"><a href=\"#cb16-3\" tabindex=\"-1\"></a><span class=\"kw\">newtype</span> <span class=\"dt\">State</span>₀ s a <span class=\"ot\">=</span> <span class=\"dt\">State</span>₀ {<span class=\"ot\"> runState ::</span> s <span class=\"ot\">-&gt;</span> (a, s) }</span><br><span id=\"cb16-4\"><a href=\"#cb16-4\" tabindex=\"-1\"></a></span><br><span id=\"cb16-5\"><a href=\"#cb16-5\" tabindex=\"-1\"></a><span class=\"kw\">newtype</span> <span class=\"dt\">StateT</span> s m a <span class=\"ot\">=</span> <span class=\"dt\">StateT</span> {<span class=\"ot\"> runStateT ::</span> s <span class=\"ot\">-&gt;</span> m (a, s) }</span><br><span id=\"cb16-6\"><a href=\"#cb16-6\" tabindex=\"-1\"></a></span><br><span id=\"cb16-7\"><a href=\"#cb16-7\" tabindex=\"-1\"></a><span class=\"kw\">type</span> <span class=\"dt\">State</span>₁ s <span class=\"ot\">=</span> <span class=\"dt\">StateT</span> s <span class=\"dt\">Identity</span></span></code></pre></div><p>… and then we can prove that <code>State₀</code> is isomorphic to <code>State₁</code> like this:</p><ul><li><p><code>State₀ s a ≅ s -&gt; (a, s)</code></p><p>… because the <code>State₀</code> <code>newtype</code> is isomorphic to the underlying type</p></li><li><p><code>s -&gt; (a, s) ≅ s -&gt; Identity (a, s)</code></p><p>… because the <code>Identity</code> newtype is isomorphic to the underlying type</p></li><li><p><code>s -&gt; Identity (a, s) ≅ StateT s Identity a</code></p><p>… because the <code>StateT</code> newtype is isomorphic to the underlying type</p></li><li><p><code>StateT s Identity a = State₁ s a</code></p><p>… because of how the <code>State₁</code> type synonym is defined.</p></li></ul><p>Therefore, by transitivity, we can conclude:</p><ul><li><code>State₀ s a ≅ State₁ s a</code></li></ul><p>Okay, now let’s introduce an <strong>extremely useful</strong> rule related to isomorphic types:</p><blockquote><p>If <code>f</code> is a <code>Functor</code> then <code>forall r . (a -&gt; r) -&gt; f r</code> is isomorphic to <code>f a</code>.</p></blockquote><p>Or in other words:</p><div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb17-1\"><a href=\"#cb17-1\" tabindex=\"-1\"></a><span class=\"dt\">Functor</span> f <span class=\"ot\">=&gt;</span> (<span class=\"kw\">forall</span> r <span class=\"op\">.</span> (a <span class=\"ot\">-&gt;</span> r) <span class=\"ot\">-&gt;</span> f r) ≅ f a</span></code></pre></div><p>… and here are the two conversion functions:</p><div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb18-1\"><a href=\"#cb18-1\" tabindex=\"-1\"></a><span class=\"ot\">{-# LANGUAGE RankNTypes #-}</span></span><br><span id=\"cb18-2\"><a href=\"#cb18-2\" tabindex=\"-1\"></a></span><br><span id=\"cb18-3\"><a href=\"#cb18-3\" tabindex=\"-1\"></a><span class=\"ot\">forward ::</span> <span class=\"dt\">Functor</span> f <span class=\"ot\">=&gt;</span> (<span class=\"kw\">forall</span> r <span class=\"op\">.</span> (a <span class=\"ot\">-&gt;</span> r) <span class=\"ot\">-&gt;</span> f r) <span class=\"ot\">-&gt;</span> f a</span><br><span id=\"cb18-4\"><a href=\"#cb18-4\" tabindex=\"-1\"></a>forward f <span class=\"ot\">=</span> f <span class=\"fu\">id</span></span><br><span id=\"cb18-5\"><a href=\"#cb18-5\" tabindex=\"-1\"></a></span><br><span id=\"cb18-6\"><a href=\"#cb18-6\" tabindex=\"-1\"></a><span class=\"ot\">backward ::</span> <span class=\"dt\">Functor</span> f <span class=\"ot\">=&gt;</span> f a <span class=\"ot\">-&gt;</span> (<span class=\"kw\">forall</span> r <span class=\"op\">.</span> (a <span class=\"ot\">-&gt;</span> r) <span class=\"ot\">-&gt;</span> f r)</span><br><span id=\"cb18-7\"><a href=\"#cb18-7\" tabindex=\"-1\"></a>backward fa k <span class=\"ot\">=</span> <span class=\"fu\">fmap</span> k fa</span></code></pre></div><p>This is essentially the <a href=\"https://en.wikipedia.org/wiki/Yoneda_lemma\">Yoneda lemma</a> in Haskell form, which is actually a bit tricky to prove. If you don’t believe me, try proving the isomorphism laws for the above <code>forward</code> and <code>backward</code> functions and see how far you get. It’s much easier to rely on the fact that someone else already did the hard work of proving those isomorphism laws for us.</p><p>Here’s a concrete example of the Yoneda lemma in action. Suppose that I want to prove that there is only one implementation of the identity function, <code>id</code>. I can do so by proving that the type of the identity function (<code>forall a . a -&gt; a</code>) is isomorphic to the <code>()</code> type (a type inhabited by exactly one value):</p><div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb19-1\"><a href=\"#cb19-1\" tabindex=\"-1\"></a>(<span class=\"kw\">forall</span> a <span class=\"op\">.</span> a <span class=\"ot\">-&gt;</span> a) ≅ ()</span></code></pre></div><p>Here’s how you prove that by chaining together several isomorphic types:</p><div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb20-1\"><a href=\"#cb20-1\" tabindex=\"-1\"></a>  (<span class=\"kw\">forall</span> a <span class=\"op\">.</span> a <span class=\"ot\">-&gt;</span> a)</span><br><span id=\"cb20-2\"><a href=\"#cb20-2\" tabindex=\"-1\"></a>  <span class=\"co\">-- a ≅ () -&gt; a</span></span><br><span id=\"cb20-3\"><a href=\"#cb20-3\" tabindex=\"-1\"></a>≅ (<span class=\"kw\">forall</span> a <span class=\"op\">.</span> (() <span class=\"ot\">-&gt;</span> a) <span class=\"ot\">-&gt;</span> a)</span><br><span id=\"cb20-4\"><a href=\"#cb20-4\" tabindex=\"-1\"></a>  <span class=\"co\">-- a ≅ Identity a</span></span><br><span id=\"cb20-5\"><a href=\"#cb20-5\" tabindex=\"-1\"></a>≅ (<span class=\"kw\">forall</span> a <span class=\"op\">.</span> (() <span class=\"ot\">-&gt;</span> a) <span class=\"ot\">-&gt;</span> <span class=\"dt\">Identity</span> a)</span><br><span id=\"cb20-6\"><a href=\"#cb20-6\" tabindex=\"-1\"></a>  <span class=\"co\">-- ✨ Yoneda lemma (where f = Identity) ✨</span></span><br><span id=\"cb20-7\"><a href=\"#cb20-7\" tabindex=\"-1\"></a>≅ <span class=\"dt\">Identity</span> ()</span><br><span id=\"cb20-8\"><a href=\"#cb20-8\" tabindex=\"-1\"></a>≅ ()</span></code></pre></div><p>… so since the <code>()</code> type is inhabited by exactly one value (the <code>()</code> term) and the <code>()</code> type is isomorphic to the type of <code>id</code>, then there is exactly one way to implement <code>id</code> (which is <code>id x = x</code>).</p><blockquote><p>Note: To be totally pedantic, there is exactly one way to implement <code>id</code> “up to isomorphism”. This is how we say that there might be several syntactically different ways of implementing <code>id</code>, such as:</p><div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb21-1\"><a href=\"#cb21-1\" tabindex=\"-1\"></a><span class=\"fu\">id</span> x <span class=\"ot\">=</span> x</span><br><span id=\"cb21-2\"><a href=\"#cb21-2\" tabindex=\"-1\"></a></span><br><span id=\"cb21-3\"><a href=\"#cb21-3\" tabindex=\"-1\"></a><span class=\"fu\">id</span> y <span class=\"ot\">=</span> y</span><br><span id=\"cb21-4\"><a href=\"#cb21-4\" tabindex=\"-1\"></a></span><br><span id=\"cb21-5\"><a href=\"#cb21-5\" tabindex=\"-1\"></a><span class=\"fu\">id</span> <span class=\"ot\">=</span> \\x <span class=\"ot\">-&gt;</span> x</span><br><span id=\"cb21-6\"><a href=\"#cb21-6\" tabindex=\"-1\"></a></span><br><span id=\"cb21-7\"><a href=\"#cb21-7\" tabindex=\"-1\"></a><span class=\"fu\">id</span> x <span class=\"ot\">=</span> y</span><br><span id=\"cb21-8\"><a href=\"#cb21-8\" tabindex=\"-1\"></a>  <span class=\"kw\">where</span></span><br><span id=\"cb21-9\"><a href=\"#cb21-9\" tabindex=\"-1\"></a>    y <span class=\"ot\">=</span> x</span></code></pre></div><p>… but all of those ways of implementing <code>id</code> are isomorphic to one another (in a slightly different sense that I have not covered), so there is essentially only one way of implementing <code>id.</code></p></blockquote><p>Similarly, we can prove that there are exactly two ways to implement a function of type <code>forall a . a -&gt; a -&gt; a</code> by showing that such a type is isomorphic to <code>Bool</code> (a type inhabited by exactly two values):</p><div class=\"sourceCode\" id=\"cb22\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb22-1\"><a href=\"#cb22-1\" tabindex=\"-1\"></a>  (<span class=\"kw\">forall</span> a <span class=\"op\">.</span> a <span class=\"ot\">-&gt;</span> a <span class=\"ot\">-&gt;</span> a)</span><br><span id=\"cb22-2\"><a href=\"#cb22-2\" tabindex=\"-1\"></a>  <span class=\"co\">-- a -&gt; b -&gt; c ≅ (a, b) -&gt; c</span></span><br><span id=\"cb22-3\"><a href=\"#cb22-3\" tabindex=\"-1\"></a>≅ (<span class=\"kw\">forall</span> a <span class=\"op\">.</span> (a, a) <span class=\"ot\">-&gt;</span> a)</span><br><span id=\"cb22-4\"><a href=\"#cb22-4\" tabindex=\"-1\"></a>  <span class=\"co\">-- (a, a) ≅ Bool -&gt; a</span></span><br><span id=\"cb22-5\"><a href=\"#cb22-5\" tabindex=\"-1\"></a>≅ (<span class=\"kw\">forall</span> a <span class=\"op\">.</span> (<span class=\"dt\">Bool</span> <span class=\"ot\">-&gt;</span> a) <span class=\"ot\">-&gt;</span> a)</span><br><span id=\"cb22-6\"><a href=\"#cb22-6\" tabindex=\"-1\"></a>  <span class=\"co\">-- a ≅ Identity a</span></span><br><span id=\"cb22-7\"><a href=\"#cb22-7\" tabindex=\"-1\"></a>≅ (<span class=\"kw\">forall</span> a <span class=\"op\">.</span> (<span class=\"dt\">Bool</span> <span class=\"ot\">-&gt;</span> a) <span class=\"ot\">-&gt;</span> <span class=\"dt\">Identity</span> a)</span><br><span id=\"cb22-8\"><a href=\"#cb22-8\" tabindex=\"-1\"></a>  <span class=\"co\">-- ✨ Yoneda lemma (where f = Identity) ✨</span></span><br><span id=\"cb22-9\"><a href=\"#cb22-9\" tabindex=\"-1\"></a>≅ <span class=\"dt\">Identity</span> <span class=\"dt\">Bool</span></span><br><span id=\"cb22-10\"><a href=\"#cb22-10\" tabindex=\"-1\"></a>≅ <span class=\"dt\">Bool</span></span></code></pre></div><p>… and in case you’re curious, here are the only two possible ways to implement that type (up to isomorphism):</p><div class=\"sourceCode\" id=\"cb23\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb23-1\"><a href=\"#cb23-1\" tabindex=\"-1\"></a><span class=\"ot\">{-# LANGUAGE ExplicitForAll #-}</span></span><br><span id=\"cb23-2\"><a href=\"#cb23-2\" tabindex=\"-1\"></a></span><br><span id=\"cb23-3\"><a href=\"#cb23-3\" tabindex=\"-1\"></a><span class=\"ot\">false ::</span> <span class=\"kw\">forall</span> a <span class=\"op\">.</span> a <span class=\"ot\">-&gt;</span> a <span class=\"ot\">-&gt;</span> a</span><br><span id=\"cb23-4\"><a href=\"#cb23-4\" tabindex=\"-1\"></a>false f t <span class=\"ot\">=</span> f</span><br><span id=\"cb23-5\"><a href=\"#cb23-5\" tabindex=\"-1\"></a></span><br><span id=\"cb23-6\"><a href=\"#cb23-6\" tabindex=\"-1\"></a><span class=\"ot\">true ::</span> <span class=\"kw\">forall</span> a <span class=\"op\">.</span> a <span class=\"ot\">-&gt;</span> a <span class=\"ot\">-&gt;</span> a</span><br><span id=\"cb23-7\"><a href=\"#cb23-7\" tabindex=\"-1\"></a>true f t <span class=\"ot\">=</span> t</span></code></pre></div><p>Here’s one last example of using the Yoneda lemma to prove that:</p><div class=\"sourceCode\" id=\"cb24\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb24-1\"><a href=\"#cb24-1\" tabindex=\"-1\"></a>(<span class=\"kw\">forall</span> r <span class=\"op\">.</span> (a <span class=\"ot\">-&gt;</span> r) <span class=\"ot\">-&gt;</span> r) ≅ a</span></code></pre></div><p>… which you can prove like this:</p><div class=\"sourceCode\" id=\"cb25\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb25-1\"><a href=\"#cb25-1\" tabindex=\"-1\"></a>  (<span class=\"kw\">forall</span> r <span class=\"op\">.</span> (a <span class=\"ot\">-&gt;</span> r) <span class=\"ot\">-&gt;</span> r)</span><br><span id=\"cb25-2\"><a href=\"#cb25-2\" tabindex=\"-1\"></a>  <span class=\"co\">-- Identity r ≅ r</span></span><br><span id=\"cb25-3\"><a href=\"#cb25-3\" tabindex=\"-1\"></a>≅ (<span class=\"kw\">forall</span> r <span class=\"op\">.</span> (a <span class=\"ot\">-&gt;</span> r) <span class=\"ot\">-&gt;</span> <span class=\"dt\">Identity</span> r)</span><br><span id=\"cb25-4\"><a href=\"#cb25-4\" tabindex=\"-1\"></a>  <span class=\"co\">-- ✨ Yoneda lemma (where f = Identity) ✨</span></span><br><span id=\"cb25-5\"><a href=\"#cb25-5\" tabindex=\"-1\"></a>≅ <span class=\"dt\">Identity</span> a</span><br><span id=\"cb25-6\"><a href=\"#cb25-6\" tabindex=\"-1\"></a>≅ a</span></code></pre></div><p><strong>Exercise:</strong> Prove that these two types are isomorphic:</p><div class=\"sourceCode\" id=\"cb26\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb26-1\"><a href=\"#cb26-1\" tabindex=\"-1\"></a>(<span class=\"kw\">forall</span> r <span class=\"op\">.</span> (b <span class=\"ot\">-&gt;</span> r) <span class=\"ot\">-&gt;</span> (a <span class=\"ot\">-&gt;</span> r)) ≅ a <span class=\"ot\">-&gt;</span> b</span></code></pre></div><details><summary>Solution (click to expand) </summary><div class=\"sourceCode\" id=\"cb27\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb27-1\"><a href=\"#cb27-1\" tabindex=\"-1\"></a>  (<span class=\"kw\">forall</span> r <span class=\"op\">.</span> (b <span class=\"ot\">-&gt;</span> r) <span class=\"ot\">-&gt;</span> (a <span class=\"ot\">-&gt;</span> r))</span><br><span id=\"cb27-2\"><a href=\"#cb27-2\" tabindex=\"-1\"></a>  <span class=\"co\">-- a -&gt; b -&gt; c ≅ b -&gt; a -&gt; c</span></span><br><span id=\"cb27-3\"><a href=\"#cb27-3\" tabindex=\"-1\"></a>≅ (<span class=\"kw\">forall</span> r <span class=\"op\">.</span> a <span class=\"ot\">-&gt;</span> (b <span class=\"ot\">-&gt;</span> r) <span class=\"ot\">-&gt;</span> r)</span><br><span id=\"cb27-4\"><a href=\"#cb27-4\" tabindex=\"-1\"></a>  <span class=\"co\">-- r ≅ Identity r</span></span><br><span id=\"cb27-5\"><a href=\"#cb27-5\" tabindex=\"-1\"></a>≅ (<span class=\"kw\">forall</span> r <span class=\"op\">.</span> a <span class=\"ot\">-&gt;</span> (b <span class=\"ot\">-&gt;</span> r) <span class=\"ot\">-&gt;</span> <span class=\"dt\">Identity</span> r)</span><br><span id=\"cb27-6\"><a href=\"#cb27-6\" tabindex=\"-1\"></a>  <span class=\"co\">-- ✨ Yoneda lemma (where f = Identity) ✨</span></span><br><span id=\"cb27-7\"><a href=\"#cb27-7\" tabindex=\"-1\"></a>≅ a <span class=\"ot\">-&gt;</span> <span class=\"dt\">Identity</span> b</span><br><span id=\"cb27-8\"><a href=\"#cb27-8\" tabindex=\"-1\"></a>  <span class=\"co\">-- Identity b ≅ b</span></span><br><span id=\"cb27-9\"><a href=\"#cb27-9\" tabindex=\"-1\"></a>≅ a <span class=\"ot\">-&gt;</span> b</span></code></pre></div></details><h4 id=\"isomorphism\">Isomorphism</h4><p>So far we’ve only used the word “isomorphic” but there is a related word we should cover: “isomorphism”.</p><p>In Haskell, if the types <code>A</code> and <code>B</code> are “isomorphic” then an “isomorphism” between them is the corresponding pair of functions converting between them (i.e. <code>forward</code> and <code>backward</code>).</p><p>The easiest way to explain this is to actually define an isomorphism type in Haskell:</p><div class=\"sourceCode\" id=\"cb28\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb28-1\"><a href=\"#cb28-1\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">Isomorphism</span> a b <span class=\"ot\">=</span> <span class=\"dt\">Isomorphism</span></span><br><span id=\"cb28-2\"><a href=\"#cb28-2\" tabindex=\"-1\"></a>    {<span class=\"ot\"> forward  ::</span> a <span class=\"ot\">-&gt;</span> b</span><br><span id=\"cb28-3\"><a href=\"#cb28-3\" tabindex=\"-1\"></a>    ,<span class=\"ot\"> backward ::</span> b <span class=\"ot\">-&gt;</span> a</span><br><span id=\"cb28-4\"><a href=\"#cb28-4\" tabindex=\"-1\"></a>    }</span></code></pre></div><p>For example:</p><div class=\"sourceCode\" id=\"cb29\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb29-1\"><a href=\"#cb29-1\" tabindex=\"-1\"></a><span class=\"ot\">exampleIsomorphism ::</span> <span class=\"dt\">Isomorphism</span> ((a, b) <span class=\"ot\">-&gt;</span> c) (a <span class=\"ot\">-&gt;</span> b <span class=\"ot\">-&gt;</span> c)</span><br><span id=\"cb29-2\"><a href=\"#cb29-2\" tabindex=\"-1\"></a>exampleIsomorphism <span class=\"ot\">=</span> <span class=\"dt\">Isomorphism</span>{ forward <span class=\"ot\">=</span> <span class=\"fu\">curry</span>, backward <span class=\"ot\">=</span> <span class=\"fu\">uncurry</span> }</span></code></pre></div><p>However, this is not the only way we can encode an isomorphism in Haskell. For example, the <code>lens</code> package has an <code>Iso</code> type which can also represent an isomorphism:</p><div class=\"sourceCode\" id=\"cb30\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb30-1\"><a href=\"#cb30-1\" tabindex=\"-1\"></a><span class=\"kw\">import</span> <span class=\"dt\">Control.Lens</span> (<span class=\"dt\">Iso'</span>, iso)</span><br><span id=\"cb30-2\"><a href=\"#cb30-2\" tabindex=\"-1\"></a></span><br><span id=\"cb30-3\"><a href=\"#cb30-3\" tabindex=\"-1\"></a><span class=\"ot\">exampleIso ::</span> <span class=\"dt\">Iso'</span> ((a, b) <span class=\"ot\">-&gt;</span> c) (a <span class=\"ot\">-&gt;</span> b <span class=\"ot\">-&gt;</span> c)</span><br><span id=\"cb30-4\"><a href=\"#cb30-4\" tabindex=\"-1\"></a>exampleIso <span class=\"ot\">=</span> iso <span class=\"fu\">curry</span> <span class=\"fu\">uncurry</span></span></code></pre></div><p>These two types are equivalent. In fact, you might even say they are … isomorphic \uD83D\uDC40.</p><div class=\"sourceCode\" id=\"cb31\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb31-1\"><a href=\"#cb31-1\" tabindex=\"-1\"></a><span class=\"ot\">{-# LANGUAGE NamedFieldPuns #-}</span></span><br><span id=\"cb31-2\"><a href=\"#cb31-2\" tabindex=\"-1\"></a></span><br><span id=\"cb31-3\"><a href=\"#cb31-3\" tabindex=\"-1\"></a><span class=\"kw\">import</span> <span class=\"dt\">Control.Lens</span> (<span class=\"dt\">AnIso'</span>, <span class=\"dt\">Iso'</span>, cloneIso, iso, review, view)</span><br><span id=\"cb31-4\"><a href=\"#cb31-4\" tabindex=\"-1\"></a></span><br><span id=\"cb31-5\"><a href=\"#cb31-5\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">Isomorphism</span> a b <span class=\"ot\">=</span> <span class=\"dt\">Isomorphism</span></span><br><span id=\"cb31-6\"><a href=\"#cb31-6\" tabindex=\"-1\"></a>    {<span class=\"ot\"> forward  ::</span> a <span class=\"ot\">-&gt;</span> b</span><br><span id=\"cb31-7\"><a href=\"#cb31-7\" tabindex=\"-1\"></a>    ,<span class=\"ot\"> backward ::</span> b <span class=\"ot\">-&gt;</span> a</span><br><span id=\"cb31-8\"><a href=\"#cb31-8\" tabindex=\"-1\"></a>    }</span><br><span id=\"cb31-9\"><a href=\"#cb31-9\" tabindex=\"-1\"></a></span><br><span id=\"cb31-10\"><a href=\"#cb31-10\" tabindex=\"-1\"></a><span class=\"co\">-- | We have to use `AnIso'` here instead of `Iso'` for reasons I won't go into</span></span><br><span id=\"cb31-11\"><a href=\"#cb31-11\" tabindex=\"-1\"></a><span class=\"ot\">isomorphismIsomorphism ::</span> <span class=\"dt\">Isomorphism</span> (<span class=\"dt\">Isomorphism</span> a b) (<span class=\"dt\">AnIso'</span> a b)</span><br><span id=\"cb31-12\"><a href=\"#cb31-12\" tabindex=\"-1\"></a>isomorphismIsomorphism <span class=\"ot\">=</span> <span class=\"dt\">Isomorphism</span>{ forward, backward }</span><br><span id=\"cb31-13\"><a href=\"#cb31-13\" tabindex=\"-1\"></a>  <span class=\"kw\">where</span></span><br><span id=\"cb31-14\"><a href=\"#cb31-14\" tabindex=\"-1\"></a><span class=\"ot\">    forward ::</span> <span class=\"dt\">Isomorphism</span> a b <span class=\"ot\">-&gt;</span> <span class=\"dt\">AnIso'</span> a b</span><br><span id=\"cb31-15\"><a href=\"#cb31-15\" tabindex=\"-1\"></a>    forward (<span class=\"dt\">Isomorphism</span> f b) <span class=\"ot\">=</span> iso f b</span><br><span id=\"cb31-16\"><a href=\"#cb31-16\" tabindex=\"-1\"></a></span><br><span id=\"cb31-17\"><a href=\"#cb31-17\" tabindex=\"-1\"></a><span class=\"ot\">    backward ::</span> <span class=\"dt\">AnIso'</span> a b <span class=\"ot\">-&gt;</span> <span class=\"dt\">Isomorphism</span> a b</span><br><span id=\"cb31-18\"><a href=\"#cb31-18\" tabindex=\"-1\"></a>    backward iso <span class=\"ot\">=</span></span><br><span id=\"cb31-19\"><a href=\"#cb31-19\" tabindex=\"-1\"></a>        <span class=\"dt\">Isomorphism</span></span><br><span id=\"cb31-20\"><a href=\"#cb31-20\" tabindex=\"-1\"></a>            { forward  <span class=\"ot\">=</span> view (cloneIso iso)</span><br><span id=\"cb31-21\"><a href=\"#cb31-21\" tabindex=\"-1\"></a>            , backward <span class=\"ot\">=</span> review (cloneIso iso)</span><br><span id=\"cb31-22\"><a href=\"#cb31-22\" tabindex=\"-1\"></a>            }</span></code></pre></div><h4 id=\"generalized-isomorphisms\">Generalized isomorphisms</h4><p>I mentioned earlier that the isomorphism definition we began with was not the fully general definition. In this section we’ll slightly generalize the definition, while still sticking to something ergonomic to express within Haskell:</p><blockquote><p>Two types, <code>A</code>, and <code>B</code>, are isomorphic if there exist two morphisms, <code>forward</code> and <code>backward</code> of the following types:</p><div class=\"sourceCode\" id=\"cb32\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb32-1\"><a href=\"#cb32-1\" tabindex=\"-1\"></a><span class=\"ot\">forward ::</span> cat <span class=\"dt\">A</span> <span class=\"dt\">B</span></span><br><span id=\"cb32-2\"><a href=\"#cb32-2\" tabindex=\"-1\"></a></span><br><span id=\"cb32-3\"><a href=\"#cb32-3\" tabindex=\"-1\"></a><span class=\"ot\">backward ::</span> cat <span class=\"dt\">B</span> <span class=\"dt\">A</span></span></code></pre></div><p>… such that <code>cat</code> is an instance of the <code>Category</code> type class and the following two equations (which I will refer to as the “isomorphism laws”) are true:</p><div class=\"sourceCode\" id=\"cb33\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb33-1\"><a href=\"#cb33-1\" tabindex=\"-1\"></a>forward <span class=\"op\">.</span> backward <span class=\"ot\">=</span> <span class=\"fu\">id</span></span><br><span id=\"cb33-2\"><a href=\"#cb33-2\" tabindex=\"-1\"></a></span><br><span id=\"cb33-3\"><a href=\"#cb33-3\" tabindex=\"-1\"></a>backward <span class=\"op\">.</span> forward <span class=\"ot\">=</span> <span class=\"fu\">id</span></span></code></pre></div><p>… where <code>(.)</code> and <code>id</code> are the methods of the <code>Category</code> type class and not necessarily the <code>(.)</code> and <code>id</code> from the Prelude.</p></blockquote><p>This definition is based on the <a href=\"https://hackage.haskell.org/package/base/docs/Control-Category.html#t:Category\"><code>Category</code></a>type class from the <a href=\"https://hackage.haskell.org/package/base/docs/Control-Category.html\"><code>Control.Category</code></a>module, which is defined like this:</p><div class=\"sourceCode\" id=\"cb34\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb34-1\"><a href=\"#cb34-1\" tabindex=\"-1\"></a><span class=\"kw\">class</span> <span class=\"dt\">Category</span> cat <span class=\"kw\">where</span></span><br><span id=\"cb34-2\"><a href=\"#cb34-2\" tabindex=\"-1\"></a>    <span class=\"co\">-- | the identity morphism</span></span><br><span id=\"cb34-3\"><a href=\"#cb34-3\" tabindex=\"-1\"></a><span class=\"ot\">    id ::</span> cat a a</span><br><span id=\"cb34-4\"><a href=\"#cb34-4\" tabindex=\"-1\"></a></span><br><span id=\"cb34-5\"><a href=\"#cb34-5\" tabindex=\"-1\"></a>    <span class=\"co\">-- | morphism composition</span></span><br><span id=\"cb34-6\"><a href=\"#cb34-6\" tabindex=\"-1\"></a><span class=\"ot\">    (.) ::</span> cat b c <span class=\"ot\">-&gt;</span> cat a b <span class=\"ot\">-&gt;</span> cat a c</span></code></pre></div><p>… and all instance of the <code>Category</code> class must satisfy the following three “category laws”:</p><div class=\"sourceCode\" id=\"cb35\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb35-1\"><a href=\"#cb35-1\" tabindex=\"-1\"></a>(f <span class=\"op\">.</span> g) <span class=\"op\">.</span> h <span class=\"ot\">=</span> f <span class=\"op\">.</span> (g <span class=\"op\">.</span> h)</span><br><span id=\"cb35-2\"><a href=\"#cb35-2\" tabindex=\"-1\"></a></span><br><span id=\"cb35-3\"><a href=\"#cb35-3\" tabindex=\"-1\"></a>f <span class=\"op\">.</span> <span class=\"fu\">id</span> <span class=\"ot\">=</span> f</span><br><span id=\"cb35-4\"><a href=\"#cb35-4\" tabindex=\"-1\"></a></span><br><span id=\"cb35-5\"><a href=\"#cb35-5\" tabindex=\"-1\"></a><span class=\"fu\">id</span> <span class=\"op\">.</span> f <span class=\"ot\">=</span> f</span></code></pre></div><p>In other words, you can think of the <code>Category</code> class as generalizing our notion of functions to become “morphisms” so that we replace values of type <code>a -&gt; b</code> (functions) with values of type <code>cat a b</code> (“morphisms”). When we generalize our notion of functions to morphisms then we can similarly generalize our notion of isomorphisms.</p><p>Of course, Haskell functions are one instance of this <code>Category</code> class:</p><div class=\"sourceCode\" id=\"cb36\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb36-1\"><a href=\"#cb36-1\" tabindex=\"-1\"></a><span class=\"kw\">instance</span> <span class=\"dt\">Category</span> (<span class=\"ot\">-&gt;</span>) <span class=\"kw\">where</span></span><br><span id=\"cb36-2\"><a href=\"#cb36-2\" tabindex=\"-1\"></a>    <span class=\"fu\">id</span> <span class=\"ot\">=</span> Prelude.id</span><br><span id=\"cb36-3\"><a href=\"#cb36-3\" tabindex=\"-1\"></a></span><br><span id=\"cb36-4\"><a href=\"#cb36-4\" tabindex=\"-1\"></a>    (<span class=\"op\">.</span>) <span class=\"ot\">=</span> (<span class=\"op\">Prelude..</span>)</span></code></pre></div><p>… so if we take our more general definition of isomorphisms and replace <code>cat</code> with <code>(-&gt;)</code> then we get back the less general definition of isomorphisms that we started with.</p><p>However, things other than functions can be instances of this <code>Category</code> class, too. For example, “monadic” functions of type <code>Monad m =&gt; a -&gt; m b</code> can implement <code>Category</code>, too, if we wrap them in a newtype:</p><div class=\"sourceCode\" id=\"cb37\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb37-1\"><a href=\"#cb37-1\" tabindex=\"-1\"></a><span class=\"kw\">import</span> <span class=\"dt\">Control.Category</span> (<span class=\"dt\">Category</span>(..))</span><br><span id=\"cb37-2\"><a href=\"#cb37-2\" tabindex=\"-1\"></a><span class=\"kw\">import</span> <span class=\"dt\">Control.Monad</span> ((&lt;=&lt;))</span><br><span id=\"cb37-3\"><a href=\"#cb37-3\" tabindex=\"-1\"></a></span><br><span id=\"cb37-4\"><a href=\"#cb37-4\" tabindex=\"-1\"></a><span class=\"co\">-- Note: This type and instance already exists in the `Control.Arrow` module</span></span><br><span id=\"cb37-5\"><a href=\"#cb37-5\" tabindex=\"-1\"></a><span class=\"kw\">newtype</span> <span class=\"dt\">Kleisli</span> m a b <span class=\"ot\">=</span> <span class=\"dt\">Kleisli</span>{<span class=\"ot\"> runKleisli ::</span> a <span class=\"ot\">-&gt;</span> m b }</span><br><span id=\"cb37-6\"><a href=\"#cb37-6\" tabindex=\"-1\"></a></span><br><span id=\"cb37-7\"><a href=\"#cb37-7\" tabindex=\"-1\"></a><span class=\"kw\">instance</span> <span class=\"dt\">Monad</span> m <span class=\"ot\">=&gt;</span> <span class=\"dt\">Category</span> (<span class=\"dt\">Kleisli</span> m) <span class=\"kw\">where</span></span><br><span id=\"cb37-8\"><a href=\"#cb37-8\" tabindex=\"-1\"></a>    <span class=\"fu\">id</span> <span class=\"ot\">=</span> <span class=\"dt\">Kleisli</span> <span class=\"fu\">return</span></span><br><span id=\"cb37-9\"><a href=\"#cb37-9\" tabindex=\"-1\"></a></span><br><span id=\"cb37-10\"><a href=\"#cb37-10\" tabindex=\"-1\"></a>    <span class=\"dt\">Kleisli</span> f <span class=\"op\">.</span> <span class=\"dt\">Kleisli</span> g <span class=\"ot\">=</span> <span class=\"dt\">Kleisli</span> (f <span class=\"op\">&lt;=&lt;</span> g)</span></code></pre></div><p>… and that satisfies the category laws because:</p><div class=\"sourceCode\" id=\"cb38\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb38-1\"><a href=\"#cb38-1\" tabindex=\"-1\"></a>(f <span class=\"op\">&lt;=&lt;</span> g) <span class=\"op\">&lt;=&lt;</span> h <span class=\"ot\">=</span> f <span class=\"op\">&lt;=&lt;</span> (g <span class=\"op\">&lt;=&lt;</span> h)</span><br><span id=\"cb38-2\"><a href=\"#cb38-2\" tabindex=\"-1\"></a></span><br><span id=\"cb38-3\"><a href=\"#cb38-3\" tabindex=\"-1\"></a>f <span class=\"op\">&lt;=&lt;</span> <span class=\"fu\">return</span> <span class=\"ot\">=</span> f</span><br><span id=\"cb38-4\"><a href=\"#cb38-4\" tabindex=\"-1\"></a></span><br><span id=\"cb38-5\"><a href=\"#cb38-5\" tabindex=\"-1\"></a><span class=\"fu\">return</span> <span class=\"op\">&lt;=&lt;</span> f <span class=\"ot\">=</span> f</span></code></pre></div><blockquote><p>Fun fact: The above category laws for the <code>Kleisli</code> type constructor are isomorphic to the monad laws (in a different sense of the world &quot;isomorphic&quot; that I have not covered).</p></blockquote><p>Once we begin to use <code>Category</code> instances other than functions we can begin to explore more interesting types of “morphisms” and “isomorphisms”. However, in order to do so we need to generalize our <code>Isomorphism</code> type like this:</p><div class=\"sourceCode\" id=\"cb39\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb39-1\"><a href=\"#cb39-1\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">Isomorphism</span> cat a b <span class=\"ot\">=</span> <span class=\"dt\">Isomorphism</span></span><br><span id=\"cb39-2\"><a href=\"#cb39-2\" tabindex=\"-1\"></a>    {<span class=\"ot\"> forward  ::</span> cat a b</span><br><span id=\"cb39-3\"><a href=\"#cb39-3\" tabindex=\"-1\"></a>    ,<span class=\"ot\"> backward ::</span> cat b a</span><br><span id=\"cb39-4\"><a href=\"#cb39-4\" tabindex=\"-1\"></a>    }</span></code></pre></div><p>… so that we can store morphisms that are not necessarily functions.</p><p>With that generalized <code>Isomorphism</code> type in hand we can now create a sample <code>Isomorphism</code> in a <code>Kleisli</code><code>Category</code>:</p><div class=\"sourceCode\" id=\"cb40\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb40-1\"><a href=\"#cb40-1\" tabindex=\"-1\"></a><span class=\"kw\">import</span> <span class=\"dt\">Data.Monoid</span> (<span class=\"dt\">Sum</span>(..))</span><br><span id=\"cb40-2\"><a href=\"#cb40-2\" tabindex=\"-1\"></a><span class=\"kw\">import</span> <span class=\"dt\">Control.Monad.Writer</span> (<span class=\"dt\">Writer</span>)</span><br><span id=\"cb40-3\"><a href=\"#cb40-3\" tabindex=\"-1\"></a></span><br><span id=\"cb40-4\"><a href=\"#cb40-4\" tabindex=\"-1\"></a><span class=\"ot\">writerIsomorphism ::</span> <span class=\"dt\">Isomorphism</span> (<span class=\"dt\">Kleisli</span> (<span class=\"dt\">Writer</span> (<span class=\"dt\">Sum</span> <span class=\"dt\">Integer</span>))) () ()</span><br><span id=\"cb40-5\"><a href=\"#cb40-5\" tabindex=\"-1\"></a>writerIsomorphism <span class=\"ot\">=</span> <span class=\"dt\">Isomorphism</span>{ forward, backward }</span><br><span id=\"cb40-6\"><a href=\"#cb40-6\" tabindex=\"-1\"></a>  <span class=\"kw\">where</span></span><br><span id=\"cb40-7\"><a href=\"#cb40-7\" tabindex=\"-1\"></a><span class=\"ot\">    forward ::</span> <span class=\"dt\">Kleisli</span> (<span class=\"dt\">Writer</span> (<span class=\"dt\">Sum</span> <span class=\"dt\">Integer</span>)) () ()</span><br><span id=\"cb40-8\"><a href=\"#cb40-8\" tabindex=\"-1\"></a>    forward <span class=\"ot\">=</span> <span class=\"dt\">Kleisli</span> (\\_ <span class=\"ot\">-&gt;</span> tell (<span class=\"dt\">Sum</span> <span class=\"dv\">1</span>))</span><br><span id=\"cb40-9\"><a href=\"#cb40-9\" tabindex=\"-1\"></a></span><br><span id=\"cb40-10\"><a href=\"#cb40-10\" tabindex=\"-1\"></a><span class=\"ot\">    backward ::</span> <span class=\"dt\">Kleisli</span> (<span class=\"dt\">Writer</span> (<span class=\"dt\">Sum</span> <span class=\"dt\">Integer</span>)) () ()</span><br><span id=\"cb40-11\"><a href=\"#cb40-11\" tabindex=\"-1\"></a>    backward <span class=\"ot\">=</span> <span class=\"dt\">Kleisli</span> (\\_ <span class=\"ot\">-&gt;</span> tell (<span class=\"dt\">Sum</span> (<span class=\"op\">-</span><span class=\"dv\">1</span>)))</span></code></pre></div><p>Like before, we still require that:</p><div class=\"sourceCode\" id=\"cb41\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb41-1\"><a href=\"#cb41-1\" tabindex=\"-1\"></a>forward <span class=\"op\">.</span> backward <span class=\"ot\">=</span> <span class=\"fu\">id</span></span><br><span id=\"cb41-2\"><a href=\"#cb41-2\" tabindex=\"-1\"></a></span><br><span id=\"cb41-3\"><a href=\"#cb41-3\" tabindex=\"-1\"></a>backward <span class=\"op\">.</span> forward <span class=\"ot\">=</span> <span class=\"fu\">id</span></span></code></pre></div><p>… but in this case the <code>(.)</code> and <code>id</code> in these two isomorphism laws will be the ones for our <code>Kleisli</code> type instead of the ones for functions.</p><details><summary>Proof of isomorphism laws (click to expand) </summary><p>I’ll skip over several steps for this proof to highlight the relevant parts:</p><div class=\"sourceCode\" id=\"cb42\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb42-1\"><a href=\"#cb42-1\" tabindex=\"-1\"></a>forward <span class=\"op\">.</span> backward</span><br><span id=\"cb42-2\"><a href=\"#cb42-2\" tabindex=\"-1\"></a></span><br><span id=\"cb42-3\"><a href=\"#cb42-3\" tabindex=\"-1\"></a><span class=\"ot\">=</span> <span class=\"dt\">Kleisli</span> (\\_ <span class=\"ot\">-&gt;</span> tell (<span class=\"dt\">Sum</span> <span class=\"dv\">1</span>)) <span class=\"op\">.</span> <span class=\"dt\">Kleisli</span> (\\_ <span class=\"ot\">-&gt;</span> tell (<span class=\"dt\">Sum</span> (<span class=\"op\">-</span><span class=\"dv\">1</span>)))</span><br><span id=\"cb42-4\"><a href=\"#cb42-4\" tabindex=\"-1\"></a></span><br><span id=\"cb42-5\"><a href=\"#cb42-5\" tabindex=\"-1\"></a><span class=\"ot\">=</span> <span class=\"dt\">Kleisli</span> ((\\_ <span class=\"ot\">-&gt;</span> tell (<span class=\"dt\">Sum</span> <span class=\"dv\">1</span>)) <span class=\"op\">&lt;=&lt;</span> (\\_ <span class=\"ot\">-&gt;</span> tell (<span class=\"dt\">Sum</span> (<span class=\"op\">-</span><span class=\"dv\">1</span>))))</span><br><span id=\"cb42-6\"><a href=\"#cb42-6\" tabindex=\"-1\"></a></span><br><span id=\"cb42-7\"><a href=\"#cb42-7\" tabindex=\"-1\"></a><span class=\"ot\">=</span> <span class=\"dt\">Kleisli</span> (\\_ <span class=\"ot\">-&gt;</span> tell (<span class=\"dt\">Sum</span> <span class=\"dv\">0</span>))</span><br><span id=\"cb42-8\"><a href=\"#cb42-8\" tabindex=\"-1\"></a></span><br><span id=\"cb42-9\"><a href=\"#cb42-9\" tabindex=\"-1\"></a><span class=\"ot\">=</span> <span class=\"dt\">Kleisli</span> <span class=\"fu\">return</span></span><br><span id=\"cb42-10\"><a href=\"#cb42-10\" tabindex=\"-1\"></a></span><br><span id=\"cb42-11\"><a href=\"#cb42-11\" tabindex=\"-1\"></a><span class=\"ot\">=</span> <span class=\"fu\">id</span></span></code></pre></div>The proof of <code>backward . forward = id</code> is essentially the same thing, except flipped. </details><p>Note our <code>Isomorphism</code> effectively says that the type <code>()</code> is isomorphic to the type <code>()</code> within this <code>Kleisli (Writer (Sum Integer))</code> <code>Category</code>, which is not a very interesting conclusion. Rather, for this <code>Isomorphism</code> the (slightly more) interesting bit is in the “morphisms” (the <code>forward</code> and <code>backward</code>definitions), which are inverses of one another.</p><p>Here is one last example of a non-trivial <code>Category</code>instance with an example isomorphism:</p><div class=\"sourceCode\" id=\"cb43\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb43-1\"><a href=\"#cb43-1\" tabindex=\"-1\"></a><span class=\"kw\">import</span> <span class=\"dt\">Prelude</span> <span class=\"kw\">hiding</span> ((.), id)</span><br><span id=\"cb43-2\"><a href=\"#cb43-2\" tabindex=\"-1\"></a></span><br><span id=\"cb43-3\"><a href=\"#cb43-3\" tabindex=\"-1\"></a><span class=\"co\">-- Note: This is not how the lens package works, but it's still a useful example</span></span><br><span id=\"cb43-4\"><a href=\"#cb43-4\" tabindex=\"-1\"></a><span class=\"kw\">data</span> <span class=\"dt\">Lens</span> a b <span class=\"ot\">=</span> <span class=\"dt\">Lens</span>{<span class=\"ot\"> view ::</span> a <span class=\"ot\">-&gt;</span> b,<span class=\"ot\"> over ::</span> (b <span class=\"ot\">-&gt;</span> b) <span class=\"ot\">-&gt;</span> (a <span class=\"ot\">-&gt;</span> a) }</span><br><span id=\"cb43-5\"><a href=\"#cb43-5\" tabindex=\"-1\"></a></span><br><span id=\"cb43-6\"><a href=\"#cb43-6\" tabindex=\"-1\"></a><span class=\"kw\">instance</span> <span class=\"dt\">Category</span> <span class=\"dt\">Lens</span> <span class=\"kw\">where</span></span><br><span id=\"cb43-7\"><a href=\"#cb43-7\" tabindex=\"-1\"></a>    <span class=\"fu\">id</span> <span class=\"ot\">=</span> <span class=\"dt\">Lens</span>{ view <span class=\"ot\">=</span> <span class=\"fu\">id</span>, over <span class=\"ot\">=</span> <span class=\"fu\">id</span> }</span><br><span id=\"cb43-8\"><a href=\"#cb43-8\" tabindex=\"-1\"></a></span><br><span id=\"cb43-9\"><a href=\"#cb43-9\" tabindex=\"-1\"></a>    <span class=\"dt\">Lens</span>{ view <span class=\"ot\">=</span> viewL, over <span class=\"ot\">=</span> overL } <span class=\"op\">.</span> <span class=\"dt\">Lens</span>{ view <span class=\"ot\">=</span> viewR, over <span class=\"ot\">=</span> overR } <span class=\"ot\">=</span></span><br><span id=\"cb43-10\"><a href=\"#cb43-10\" tabindex=\"-1\"></a>        <span class=\"dt\">Lens</span>{ view <span class=\"ot\">=</span> viewL <span class=\"op\">.</span> viewR, over <span class=\"ot\">=</span> overR <span class=\"op\">.</span> overL }</span><br><span id=\"cb43-11\"><a href=\"#cb43-11\" tabindex=\"-1\"></a></span><br><span id=\"cb43-12\"><a href=\"#cb43-12\" tabindex=\"-1\"></a><span class=\"ot\">lensIsomorphism ::</span> <span class=\"dt\">Isomorphism</span> <span class=\"dt\">Lens</span> <span class=\"dt\">Bool</span> <span class=\"dt\">Bool</span></span><br><span id=\"cb43-13\"><a href=\"#cb43-13\" tabindex=\"-1\"></a>lensIsomorphism <span class=\"ot\">=</span> <span class=\"dt\">Isomorphism</span>{ forward, backward }</span><br><span id=\"cb43-14\"><a href=\"#cb43-14\" tabindex=\"-1\"></a>  <span class=\"kw\">where</span></span><br><span id=\"cb43-15\"><a href=\"#cb43-15\" tabindex=\"-1\"></a><span class=\"ot\">    forward ::</span> <span class=\"dt\">Lens</span> <span class=\"dt\">Bool</span> <span class=\"dt\">Bool</span></span><br><span id=\"cb43-16\"><a href=\"#cb43-16\" tabindex=\"-1\"></a>    forward <span class=\"ot\">=</span> <span class=\"dt\">Lens</span>{ view <span class=\"ot\">=</span> <span class=\"fu\">not</span>, over <span class=\"ot\">=</span> \\f <span class=\"ot\">-&gt;</span> <span class=\"fu\">not</span> <span class=\"op\">.</span> f <span class=\"op\">.</span> <span class=\"fu\">not</span> }</span><br><span id=\"cb43-17\"><a href=\"#cb43-17\" tabindex=\"-1\"></a></span><br><span id=\"cb43-18\"><a href=\"#cb43-18\" tabindex=\"-1\"></a>    <span class=\"co\">-- There is no rule that the two morphisms can't be the same</span></span><br><span id=\"cb43-19\"><a href=\"#cb43-19\" tabindex=\"-1\"></a><span class=\"ot\">    backward ::</span> <span class=\"dt\">Lens</span> <span class=\"dt\">Bool</span> <span class=\"dt\">Bool</span></span><br><span id=\"cb43-20\"><a href=\"#cb43-20\" tabindex=\"-1\"></a>    backward <span class=\"ot\">=</span> forward</span></code></pre></div><p>Again, it’s not very interesting to say that <code>Bool</code> is isomorphic to <code>Bool</code>, but it is more to note that the <code>forward</code> lens is essentially its own inverse.</p><p>There’s one last category I want to quickly mention, which is … <code>Isomorphism</code>!</p><p>Yes, the <code>Isomorphism</code> type we introduced is itself an instance of the <code>Category</code> class:</p><div class=\"sourceCode\" id=\"cb44\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb44-1\"><a href=\"#cb44-1\" tabindex=\"-1\"></a><span class=\"kw\">instance</span> <span class=\"dt\">Category</span> cat <span class=\"ot\">=&gt;</span> <span class=\"dt\">Category</span> (<span class=\"dt\">Isomorphism</span> cat) <span class=\"kw\">where</span></span><br><span id=\"cb44-2\"><a href=\"#cb44-2\" tabindex=\"-1\"></a>    <span class=\"dt\">Isomorphism</span> forwardL backwardL <span class=\"op\">.</span> <span class=\"dt\">Isomorphism</span> forwardR backwardR <span class=\"ot\">=</span></span><br><span id=\"cb44-3\"><a href=\"#cb44-3\" tabindex=\"-1\"></a>        <span class=\"dt\">Isomorphism</span> (forwardL <span class=\"op\">.</span> forwardR) (backwardR <span class=\"op\">.</span> backwardL)</span><br><span id=\"cb44-4\"><a href=\"#cb44-4\" tabindex=\"-1\"></a></span><br><span id=\"cb44-5\"><a href=\"#cb44-5\" tabindex=\"-1\"></a>    <span class=\"fu\">id</span> <span class=\"ot\">=</span> <span class=\"dt\">Isomorphism</span> <span class=\"fu\">id</span> <span class=\"fu\">id</span></span></code></pre></div><p>You might even say that an “isomorphism” is a “morphism” in the above <code>Category</code>. An “iso”-“morphism”, if you will (where “iso” means “same”).</p><p>Furthermore, we can create an example <code>Isomorphism</code> in this <code>Category</code> of <code>Isomorphism</code>s:</p><div class=\"sourceCode\" id=\"cb45\"><pre class=\"sourceCode haskell\"><code class=\"sourceCode haskell\"><span id=\"cb45-1\"><a href=\"#cb45-1\" tabindex=\"-1\"></a><span class=\"ot\">nestedIsomorphism ::</span> <span class=\"dt\">Isomorphism</span> (<span class=\"dt\">Isomorphism</span> (<span class=\"ot\">-&gt;</span>)) <span class=\"dt\">Integer</span> <span class=\"dt\">Integer</span></span><br><span id=\"cb45-2\"><a href=\"#cb45-2\" tabindex=\"-1\"></a>nestedIsomorphism <span class=\"ot\">=</span></span><br><span id=\"cb45-3\"><a href=\"#cb45-3\" tabindex=\"-1\"></a>    <span class=\"dt\">Isomorphism</span></span><br><span id=\"cb45-4\"><a href=\"#cb45-4\" tabindex=\"-1\"></a>        { forward  <span class=\"ot\">=</span> <span class=\"dt\">Isomorphism</span>{ forward <span class=\"ot\">=</span> (<span class=\"op\">+</span> <span class=\"dv\">1</span>), backward <span class=\"ot\">=</span> <span class=\"fu\">subtract</span> <span class=\"dv\">1</span> }</span><br><span id=\"cb45-5\"><a href=\"#cb45-5\" tabindex=\"-1\"></a>        , backward <span class=\"ot\">=</span> <span class=\"dt\">Isomorphism</span>{ forward <span class=\"ot\">=</span> <span class=\"fu\">subtract</span> <span class=\"dv\">1</span>, backward <span class=\"ot\">=</span> (<span class=\"op\">+</span> <span class=\"dv\">1</span>) }</span><br><span id=\"cb45-6\"><a href=\"#cb45-6\" tabindex=\"-1\"></a>        }</span></code></pre></div><p>Okay, perhaps that’s going a bit too far, but I just wanted to end this post with a cute example of how you can keep chaining these ideas together in new ways.</p><h4 id=\"conclusion\">Conclusion</h4><p>In my experience, the more you train your ability to reason formally about isomorphisms the more you broaden your ability to recognize disparate things as equivalent and draw interesting connections between them.</p><p>For example, fluency with many common isomorphisms is a useful skill for API design because often there might be a way to take an API which is not very ergonomic and refactor it into an equivalent (isomorphic) API which is more ergonomic to use.</p></body></html>"
}