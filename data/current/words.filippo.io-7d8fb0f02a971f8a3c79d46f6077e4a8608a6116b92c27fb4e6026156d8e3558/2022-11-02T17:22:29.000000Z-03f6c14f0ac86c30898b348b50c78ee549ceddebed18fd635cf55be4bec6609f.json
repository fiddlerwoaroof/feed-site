{
  "title":"Why Did the OpenSSL Punycode Vulnerability Happen",
  "date":"2022-11-02T17:22:29.000000Z",
  "author":null,
  "id":"6362a08102604e003daf6b24",
  "link":"https://words.filippo.io/dispatches/openssl-punycode/",
  "content":"<p>Some room-temperature takes on yesterday's not-quite-RCE vulnerabilities in OpenSSL 3.0, and on what there is to learn about safe cryptography engineering.</p>\n<h2 id=\"a-recap\">A recap</h2>\n<p>Yesterday OpenSSL <a href=\"https://www.openssl.org/news/secadv/20221101.txt\">published</a> version 3.0.7, which was pre-announced to contain a fix for a CRITICAL vulnerability, the first one since 2016 and since Heartbleed before that. The vulnerability was downgraded to HIGH. You can read why <a href=\"https://www.openssl.org/blog/blog/2022/11/01/email-address-overflows/\">on the OpenSSL blog</a>.</p>\n<p>The vulnerability is a stack write overflow in certificate verification. You can choose to overflow an unlimited number of <code>.</code> bytes, or four arbitrary bytes. The four-byte overflow is a little subtler, but the <code>.</code> is fairly straightforward.</p>\n<p>There is a function, <code>ossl_punycode_decode</code> that decodes <a href=\"https://en.wikipedia.org/wiki/Punycode\">Punycode</a>. Punycode is a way to encode Unicode as ASCII, used to represent Unicode strings in the ASCII-only world of DNS. <code>ossl_punycode_decode</code> takes an output buffer, and if the buffer runs out it keeps parsing and verifying the Punycode but discards the rest of the output.</p>\n<p>I did not have the heart to figure out why it works like this. Maybe there's a good reason to do progressive parsing. Maybe it's an artifact of how C makes you do memory management or of OpenSSL's C style. Anyway.</p>\n<p>You can see where this is going. Sometimes the &quot;should we discard the output or add it to the buffer&quot; check is faulty, and the function keeps appending to the buffer past its end.</p>\n<p><a href=\"https://github.com/openssl/openssl/commit/680e65b94c916af259bfdc2e25f1ab6e0c7a97d6#diff-de2651c670dde92b08e86f386059436bee7f7271df21a18036e8b9d85b8070feL303-L307\">This is the relevant snippet of code.</a> The reading key is that <code>result</code> is both the eventual return value, and the thing that controls whether output gets added to <code>outbuf</code>. Once <code>outbuf</code> runs out <code>result</code> gets set to 0, but line 303 doesn't check <code>result</code> before adding a <code>.</code>.</p>\n<p>The crasher PoC is simply a domain with a lot of Punycode labels, like <code>xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a.xn--a</code>. All those <code>.</code>s end up on the stack even if the <code>outbuf</code> was smaller.</p>\n<p><code>ossl_punycode_decode</code> is finally used (only) in the process of enforcing an X.509 chain feature called Name Constraints on email addresses, which is how this is reachable from certificate verification.</p>\n<p><a href=\"https://github.com/colmmacc/CVE-2022-3602\">Colm has a nice writeup and a PoC repo.</a> I live-streamed some analysis and played with Colm's PoC to confirm our understanding of the vulnerability. <a href=\"https://www.twitch.tv/videos/1640540734\">You can watch the recording.</a></p>\n<h2 id=\"on-severity\">On severity</h2>\n<p>This was initially announced as a CRITICAL, and then downgraded to HIGH. Honestly, I think might even be a MEDIUM, because of <em>where</em> you need to put these strings to reach the parser.</p>\n<ol>\n<li>\n<p>The vulnerability is in certificate verification, so most TLS servers are not affected right off the bat. Only servers that accept client certificates do certificate verification.</p>\n</li>\n<li>\n<p>Name Constraints are only checked after a chain has been built to a trust anchor. The code is not part of certificate parsing itself. <strong>This is very good.</strong> The malicious certificates need to be part of a chain ultimately signed by a trusted root, and most environments trust their roots.</p>\n<ul>\n<li>I'm told Basic Constraints are checked before this, too, so you can't pull off a trick where you get a certificate from Let's Encrypt for <code>filippo.io</code> and then pretend it's an intermediate root and use it to sign a malicious certificate.</li>\n</ul>\n</li>\n<li>\n<p>IMHO most importantly, the malicious string must be in the <strong>intermediate root</strong>, not in the leaf. It's conceivable that there might be systems out there that issue untrusted parties leaf certificates for arbitrary email addresses, but I can't see an attacker getting their hands on an intermediate root with a custom Name Constraint that chains to a trusted root.</p>\n</li>\n</ol>\n<p>So yeah, not the end of the world.</p>\n<p>Lots of people criticized the OpenSSL project for causing alarm, but as someone who ran a vulnerability reporting program for a large project (Go) I think they did ok. Vulnerability triage is a high-pressure activity you do on a clock, and you have to make judgement calls. Upgrading the severity at the last moment is way worse than downgrading it, so they IMHO erred on the right side. Maybe it would have been nice to get a heads up of the downgrade, but you're sometimes doing analysis until the very last moment.</p>\n<p>It's also the first CRITICAL in more than five years, so it's not like they are constantly crying wolf.</p>\n<p>One thing I'll say about the process is that <a href=\"https://twitter.com/FiloSottile/status/1587376656594993154\">it would have been nice to know the CVE number in advance</a> so we could coordinate effectively instead of using made up names, which is the point of CVEs.</p>\n<h2 id=\"why-did-it-make-it-to-a-release\">Why did it make it to a release</h2>\n<p>There are process lessons to learn, though.</p>\n<p>Hanno, as always bridging the gap between available tools and concrete results, <a href=\"https://twitter.com/hanno/status/1587775675397726209\">pointed out that this vulnerability could be found in a second by LibFuzzer with the simplest possible fuzzing function</a>.</p>\n<p>I'm transcribing it here just to make a point about how simple it is. <code>ossl_punycode_decode</code> is not a carefully chosen internal function, it has <a href=\"https://github.com/openssl/openssl/blob/00e38edcfb95b556a59de96e0c18343828929c8f/doc/internal/man3/ossl_punycode_decode.pod\">a man page</a>.</p>\n<pre><code>#include &quot;crypto/punycode.h&quot;\n\nint LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    unsigned int out[32];\n    unsigned int outlen = 32;\n    ossl_punycode_decode((const char *)data, size, out, &amp;outlen);\n    return 0;\n}\n</code></pre>\n<p><strong>I'm a big fan of asking &quot;how could we have found this bug in advance without knowing anything about it?&quot;</strong> Sometimes the answer is complicated, like &quot;we would have had to write a fuzzer for all arithmetic operations that mixes values that we know in advance are likely to hit edge cases even if we don't know which ones and then compare against a known-good implementation&quot; (which is what we did in the Go standard library anyway!).</p>\n<p>This time it looks like the answer was &quot;we should have used a fuzzer at all&quot;. That's disappointing. This was <strong>newly added code</strong>. This was <strong>a parser written in C</strong>. This was a <em>perfect</em> match for fuzzing. It didn't require any novel tool or technique.</p>\n<p>We could talk about expanding tooling for fuzzing coverage reports, and I think we can do a lot in general to make fuzzer behavior more understandable. However here the issue would have been prevented by just having a policy of &quot;when fuzzing makes perfect sense and is very easy, use it&quot;.</p>\n<p>I'm not sure what the next step is or who should take it, but there seems to be a large margin for cheap process improvements that would yield a large security benefit in critical software infrastructure.</p>\n<h2 id=\"why-was-this-code-even-necessary\">Why was this code even necessary</h2>\n<p>There's an even wider scope to consider, though. Why is that code there? Could it have been even more secure by not existing?</p>\n<p>As <a href=\"https://twitter.com/bagder/status/1587777555121246209\">curl author Daniel Stenberg said</a>, &quot;I've never even considered to decode punycode. Why does something like OpenSSL need to decode this?&quot;</p>\n<p>The answer is: <strong>an explicit IETF design choice, that made punycode decoding part of X.509 verification, without even a line of acknowledgement in the Security Considerations</strong>.</p>\n<p>As we said, Punycode is about encoding Unicode in domain names. You might be tempted to say &quot;ah, why would we want Unicode in delicate cryptography stuff like this&quot;. I invite you to resist that urge. <strong>Internationalization is not the issue, internationalization is the job.</strong> We make things to serve users, and users (mostly outside the US and UK) communicate using more than ASCII, and their domain names and email addresses should be written in their language and work as well as English ones. The general effort to expand i18n is good.</p>\n<p>How did that lead to &quot;OpenSSL has a Punycode parser&quot; though? Well, folks (rightfully) wanted Unicode email addresses in X.509 certificates, but punycode is only defined for domain names. What if there's Unicode in the local part (the stuff before the <code>@</code>) of email addresses?</p>\n<p>There were a number of ways to solve this!</p>\n<p>One was to just define how to encode the local part in ASCII, staying true to the idea of punycode as the way to abstract encoding issues. <a href=\"https://datatracker.ietf.org/doc/html/draft-lbaudoin-iemax-02\">Here's a draft</a> that does just that by prepending a <code>:</code> and then encoding with Base64. Roughly one page long. No Name Constraints interactions, barely any new code path. We could have had nice things!</p>\n<p>But nope. Here's <a href=\"https://www.rfc-editor.org/rfc/rfc8398.html\">RFC 8398</a>. It adds a new Subject Alternative Name type that's a UTF-8 email address, <code>SmtpUTF8Mailbox</code>.<sup class=\"footnote-ref\"><a href=\"#fn1\" id=\"fnref1\">[1]</a></sup> But what if the issuer (i.e. the intermediate root) has a Name Constraint that says it can only issue for a certain domain? That Name Constraint will be encoded as Punycode... how does it apply to a <code>SmtpUTF8Mailbox</code> in a leaf? Well, <a href=\"https://www.rfc-editor.org/rfc/rfc8398.html#section-5\">you decode the Punycode before doing the comparison</a>, of course. The sections on matching and Name Constraints are longer than the whole alternative draft, and there's <a href=\"https://www.rfc-editor.org/rfc/rfc8399\">a whole other RFC</a> of amendments to path verification.<sup class=\"footnote-ref\"><a href=\"#fn2\" id=\"fnref2\">[2]</a></sup></p>\n<p>What's really short instead is the Security Considerations section with no mention of the fact that this adds a whole new parser to the critical path of certificate verification, so I'm not sure the risk and cost of software complexity was taken into account, making this as much an IETF specification failure as a C language failure.</p>\n<p>In conclusion, this is why we resist adding even trivial features to crypto/x509, Go's implementation of a X.509 parser and verifier. I seem to remember a feature request for exposing <code>otherName</code> fields of certificates, which includes <code>SmtpUTF8Mailbox</code>. It felt pretty innocuous: just another field we could add to the struct, five lines of code maybe. However, the moment we expose it we need to apply Name Constraints to it! Not doing so would be a security vulnerability. Without knowing it, we could have opted into all this complexity and ended up importing a Punycode parser in crypto/x509. Still, it would not have been written in C, I guess.</p>\n<h2 id=\"the-picture\">The picture</h2>\n<p>Florence is always pretty.</p>\n<p><img src=\"https://words.filippo.io/content/images/2022/11/IMG_9255.jpeg\" alt=\"\"></p>\n<hr class=\"footnotes-sep\">\n<section class=\"footnotes\">\n<ol class=\"footnotes-list\">\n<li id=\"fn1\" class=\"footnote-item\"><p>It's even more complex, actually: if there's Unicode in the local part, you use <code>SmtpUTF8Mailbox</code>, if there's Unicode only in the domain you're still expected to use punycode. You could end up with most certificates in the organization using punycode and only a few using <code>SmtpUTF8Mailbox</code>, which would surely work out great. <a href=\"https://www.rfc-editor.org/rfc/rfc8399#section-2.5\">RFC 8399, Section 2.5</a> summarizes the new logic X.509 verifiers need to apply. <a href=\"#fnref1\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n<li id=\"fn2\" class=\"footnote-item\"><p>There are some good choices in there, like deprecating NCs on the local parts of email addresses that no one was using, instead of defining UTF-8 constraints. But that also opened the door to keeping encoding issues entirely out of Name Constraints while still supporting international domains through Punycode, so it really feels like a missed opportunity. Punycode was supposed to be the abstraction layer, to keep encoding out of the rest of the stack. <a href=\"#fnref2\" class=\"footnote-backref\">↩︎</a></p>\n</li>\n</ol>\n</section>\n"
}