{
  "title":"Take All Your Pictures to the Cleaners, with Google Photos Noise and Blur Reduction",
  "date":"2021-08-27T13:16:51.112000-07:00",
  "author":"Google AI",
  "id":"tag:blogger.com,1999:blog-8474926331452026626.post-5159347988023824086",
  "link":"http://feedproxy.google.com/~r/blogspot/gJZg/~3/YzrGZK_H1dE/take-all-your-pictures-to-cleaners-with.html",
  "content":"<span class=\"byline-author\">Posted by Mauricio Delbracio, Research Scientist and Sungjoon Choi, Software Engineer, Google Research</span> <p>Despite recent leaps in imaging technology, <a href=\"https://arxiv.org/abs/2102.09000\">especially on mobile devices</a>, image noise and limited sharpness remain two of the most important levers for improving the visual quality of a photograph. These are particularly relevant when taking pictures in poor light conditions, where cameras may compensate by increasing the <a href=\"https://en.wikipedia.org/wiki/Film_speed#Digital_camera_ISO_speed_and_exposure_index\">ISO</a> or slowing the shutter speed, thereby exacerbating the presence of noise and, at times, increasing image blur. Noise can be associated with the particle nature of light (<a href=\"https://en.wikipedia.org/wiki/Shot_noise\">shot noise</a>) or be introduced by electronic components during the readout process (<a href=\"https://en.wikipedia.org/wiki/Image_noise#Read_noise\">read noise</a>). The captured noisy signal is then processed by the camera <a href=\"https://en.wikipedia.org/wiki/Image_processor\">image processor</a> (ISP) and later may be further enhanced, amplified, or distorted by a photographic editing process. Image blur can be caused by a wide variety of phenomena, from inadvertent camera shake during capture, an incorrect setting of the camera’s focus (automatic or not), or due to the <a href=\"https://en.wikipedia.org/wiki/Airy_disk\">finite lens aperture</a>, sensor resolution or the camera’s image processing.  </p><p>It is far easier to minimize the effects of noise and blur within a camera pipeline, where details of  the sensor, optical hardware and software blocks are understood. However, when presented with an image produced from an arbitrary (possibly unknown) camera, improving noise and sharpness becomes much more challenging due to the lack of detailed knowledge and access to the internal parameters of the camera. In most situations, these two problems are intrinsically related: noise reduction tends to eliminate fine structures along with unwanted details, while blur reduction seeks to boost structures and fine details. This interconnectedness increases the difficulty of developing image enhancement techniques that are computationally efficient to run on mobile devices. </p><p>Today, we present a new approach for <em>camera-agnostic</em> estimation and elimination of noise and blur that can improve the quality of most images.  We developed a <a href=\"https://ieeexplore.ieee.org/document/7532702\">pull-push denoising</a> algorithm that is paired with a deblurring method, called <a href=\"https://ieeexplore.ieee.org/document/9502555\">polyblur</a>. Both of these components are designed to maximize computational efficiency, so users can successfully enhance the quality of a multi-megapixel image in milliseconds on a mobile device. These noise and blur reduction strategies are critical components of the recent <a href=\"https://blog.google/products/photos/new-helpful-editor/\">Google Photos editor</a> updates, which includes “<em>Denoise</em>” and “<em>Sharpen</em>” tools that enable users to enhance images that may have been captured under less than ideal conditions, or with older devices that may have had more noisy sensors or less sharp optics.  </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-bblz9X-bJro/YNOlX2r8KtI/AAAAAAAAHxI/6HhG4EJDPIokKzB6DUtQh5pvDZLVIUgqwCLcBGAsYHQ/s1520/image3.gif\"><img border=\"0\" height=\"640\" src=\"https://1.bp.blogspot.com/-bblz9X-bJro/YNOlX2r8KtI/AAAAAAAAHxI/6HhG4EJDPIokKzB6DUtQh5pvDZLVIUgqwCLcBGAsYHQ/w304-h640/image3.gif\" width=\"304\"></a></td></tr><tr><td class=\"tr-caption\">A demonstration of the “Denoise” and “Sharpen” tools now available in the Google Photos editor.</td></tr></tbody></table><p><b>How Noisy is An Image? </b><br>In order to accurately process a photographic image and successfully reduce the unwanted effects of noise and blur, it is vitally important to first characterize the types and levels of noise and blur found in the image. So, a camera-agnostic approach for noise reduction begins by formulating  a method to gauge the strength of noise at the pixel level from any given image, regardless of the device that created it. The noise level is modeled as a function of the brightness of the underlying pixel. That is, for each possible brightness level, the model estimates a corresponding noise level in a manner agnostic to either the actual source of the noise or the processing pipeline.  </p><p>To estimate this brightness-based noise level, we sample a number of small patches across the image and measure the noise level within each patch, after roughly removing any underlying structure in the image. This process is repeated at multiple scales, making it robust to artifacts that may arise from compression, image resizing, or other non-linear camera processing operations. </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-6TDvzbLVI5o/YNOlghgNykI/AAAAAAAAHxM/qBnd7byMgRgPHY_xxM4PzwRzpmExTYRUACLcBGAsYHQ/s1999/image1.png\"><img border=\"0\" height=\"252\" src=\"https://1.bp.blogspot.com/-6TDvzbLVI5o/YNOlghgNykI/AAAAAAAAHxM/qBnd7byMgRgPHY_xxM4PzwRzpmExTYRUACLcBGAsYHQ/w640-h252/image1.png\" width=\"640\"></a></td></tr><tr><td class=\"tr-caption\">The two segments on the left illustrate signal-dependent noise present in the input image (<b>center</b>). The noise is more prominent in the bottom, darker crop and is unrelated to the underlying structure, but rather to the light level. Such image segments are sampled and processed to generate the spatially-varying noise map (<b>right</b>) where red indicates more noise is present.</td></tr></tbody></table><p><b>Reducing Noise Selectively with a Pull-Push Method</b><br>We take advantage of self-similarity of patches across the image to denoise with high fidelity. The general principle behind such so-called <a href=\"https://en.wikipedia.org/wiki/Non-local_means\">“non-local” denoising</a> is that noisy pixels can be denoised by averaging pixels with similar local structure. However, these approaches typically incur high computational costs because they require a brute force search for pixels with similar local structure, making them impractical for on-device use. In our “pull-push” approach<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\"><span>1</span></a></sup>, the algorithmic complexity is decoupled from the size of filter footprints thanks to effective information propagation across spatial scales. </p><p>The first step in pull-push is to build an image pyramid (i.e., multiscale representation) in which each successive level is generated recursively by a “pull” filter (analogous to <a href=\"https://en.wikipedia.org/wiki/Image_scaling\">downsampling</a>). This filter uses a per-pixel weighting scheme to <em>selectively</em> combine existing noisy pixels together based on their patch similarities and estimated noise, thus reducing the noise at each successive, “coarser” level. Pixels at coarser levels (i.e., with lower resolution) pull and aggregate only compatible pixels from higher resolution, “finer” levels. In addition to this, each merged pixel in the coarser layers also includes an estimated reliability measure computed from the similarity weights used to generate it. Thus, merged pixels provide a simple per-pixel, per-level characterization of the image and its local statistics. By efficiently propagating this information through each level (i.e., each spatial scale), we are able to track a model of the neighborhood statistics for increasingly larger regions in a multiscale manner. </p><p>After the pull stage is evaluated to the coarsest level, the “push” stage fuses the results, starting from the coarsest level and generating finer levels iteratively. At a given scale, the push stage generates “filtered” pixels following a process similar to that of the pull stage, but going from coarse to finer levels. The pixels at each level are fused with those of coarser levels by doing a weighted average of same-level pixels along with coarser-level filtered pixels using the respective reliability weights. This enables us to reduce pixel noise while preserving local structure, because only average reliable information is included. This selective filtering and reliability (i.e. information) multiscale propagation is what makes push-pull different from existing frameworks. </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-TD5fmjQFQyA/YNOlmsR7WPI/AAAAAAAAHxQ/ocx9gqSi4DM5Bhd5F0kYUyg_KoKtw8zfACLcBGAsYHQ/s1999/image6.png\"><img border=\"0\" height=\"392\" src=\"https://1.bp.blogspot.com/-TD5fmjQFQyA/YNOlmsR7WPI/AAAAAAAAHxQ/ocx9gqSi4DM5Bhd5F0kYUyg_KoKtw8zfACLcBGAsYHQ/w640-h392/image6.png\" width=\"640\"></a></td></tr><tr><td class=\"tr-caption\">This series of images shows how filtering progresses through the pull-push process. Coarser level pixels pull and aggregate only compatible pixels from finer levels, as opposed to the traditional multiscale approaches using a fixed (non-data dependent) kernel. Notice how the noise is reduced throughout the stages.</td></tr></tbody></table><p>The pull-push approach has a low computational cost, because the algorithm to selectively filter similar pixels over a very large neighborhood has a complexity that is only linear with the number of image pixels. In practice, the quality of this denoising approach is comparable to traditional non-local methods with much larger kernel footprints, but operates at a fraction of the computational cost. </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-BnzI4F32xGk/YNOlstli8gI/AAAAAAAAHxU/o1nIYzP05RgWID9v4LwfMXpzXBq-gBW1wCLcBGAsYHQ/s1999/image5.png\"><img border=\"0\" height=\"400\" src=\"https://1.bp.blogspot.com/-BnzI4F32xGk/YNOlstli8gI/AAAAAAAAHxU/o1nIYzP05RgWID9v4LwfMXpzXBq-gBW1wCLcBGAsYHQ/w640-h400/image5.png\" width=\"640\"></a></td></tr><tr><td><a href=\"https://1.bp.blogspot.com/-XBJuHvtX1Gg/YNOlwM4KmuI/AAAAAAAAHxY/k6WT7xZZ-_Qm54uGRgNwETW4VpBM71GhQCLcBGAsYHQ/s1999/image2.png\"><img border=\"0\" height=\"400\" src=\"https://1.bp.blogspot.com/-XBJuHvtX1Gg/YNOlwM4KmuI/AAAAAAAAHxY/k6WT7xZZ-_Qm54uGRgNwETW4VpBM71GhQCLcBGAsYHQ/w640-h400/image2.png\" width=\"640\"></a></td></tr><tr><td class=\"tr-caption\">Image enhanced using the pull-push denoising method.</td></tr></tbody></table><p><b>How Blurry Is an Image?</b><br>An image with poor sharpness can be thought of as being a more pristine latent image that was operated on by a blur kernel. So, if one can identify the blur kernel, it can be used to reduce the effect. This is referred to as “deblurring”, i.e., the removal or reduction of an undesired blur effect induced by a particular kernel on a particular image. In contrast, “sharpening”  refers to applying a sharpening filter, built from scratch and without reference to any particular image or blur kernel. Typical sharpening filters are also, in general, local operations that do not take account of any other information from other parts of the image, whereas deblurring algorithms estimate the blur from the whole image. Unlike arbitrary sharpening, which can result in worse image quality when applied to an image that is already sharp, deblurring a sharp image with a blur kernel accurately estimated from the image itself will have very little effect. </p><p>We specifically target relatively mild blur, as this scenario is more technically tractable, more computationally efficient, and produces consistent results. We model the blur kernel as an anisotropic (elliptical) Gaussian kernel, specified by three parameters that control the strength, direction and aspect ratio of the blur.   </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-NdigDKPMQqg/YNOl3zapNNI/AAAAAAAAHxk/nJrFTISkd3cqPsPh1BSQjWEy3XlIpHxBgCLcBGAsYHQ/s973/image9.png\"><img border=\"0\" height=\"354\" src=\"https://1.bp.blogspot.com/-NdigDKPMQqg/YNOl3zapNNI/AAAAAAAAHxk/nJrFTISkd3cqPsPh1BSQjWEy3XlIpHxBgCLcBGAsYHQ/w640-h354/image9.png\" width=\"640\"></a></td></tr><tr><td class=\"tr-caption\">Gaussian blur model and example blur kernels. Each row of the plot on the right represents possible combinations of <em>σ<sub>0</sub></em>, <em>ρ</em> and <em>θ</em>. We show three different <em>σ<sub>0</sub></em> values with three different <em>ρ</em> values for each.</td></tr></tbody></table><p>Computing and removing blur without noticeable delay for the user requires an algorithm that is much more computationally efficient than existing approaches, which typically cannot be executed on a mobile device. We rely on an intriguing empirical observation: the maximal value of the image gradient across all directions at any point in a sharp image follows a particular distribution. Finding the maximum gradient value is efficient, and can yield a reliable estimate of the strength of the blur in the given direction. With this information in hand, we can directly recover the parameters that characterize the blur.  </p><p><b>Polyblur: Removing Blur by Re-blurring</b><br>To recover the sharp image given the estimated blur, we would (in theory) need to solve a numerically unstable inverse problem (i.e., deblurring). The inversion problem grows exponentially more unstable with the strength of the blur. As such, we target the case of mild blur removal. That is, we <em>assume</em> that the image at hand is not so blurry as to be beyond practical repair. This enables a more practical approach — by carefully combining different re-applications of an operator we can approximate its inverse. </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-uq2YWo1rPnw/YNOl_OctgLI/AAAAAAAAHxs/_6Q3GKI47EcpFHonzjCOLBKzcIGEeSEeQCLcBGAsYHQ/s1999/image8.png\"><img border=\"0\" height=\"360\" src=\"https://1.bp.blogspot.com/-uq2YWo1rPnw/YNOl_OctgLI/AAAAAAAAHxs/_6Q3GKI47EcpFHonzjCOLBKzcIGEeSEeQCLcBGAsYHQ/w640-h360/image8.png\" width=\"640\"></a></td></tr><tr><td><a href=\"https://1.bp.blogspot.com/-UMJT4p3BfZo/YNOmD9BxfCI/AAAAAAAAHx0/jUQ3YWbmniUYV-m9lMWvLbZ9KwO_MBsqgCLcBGAsYHQ/s1999/image7.png\"><img border=\"0\" height=\"284\" src=\"https://1.bp.blogspot.com/-UMJT4p3BfZo/YNOmD9BxfCI/AAAAAAAAHx0/jUQ3YWbmniUYV-m9lMWvLbZ9KwO_MBsqgCLcBGAsYHQ/w640-h284/image7.png\" width=\"640\"></a></td></tr><tr><td class=\"tr-caption\">Mild blur, as shown in these examples, can be effectively removed by combining multiple applications of the estimated blur.</td></tr></tbody></table><p>This means, rather counterintuitively, that we can <em>deblur</em> an image by <em>re-blurring</em> it several times with the estimated blur kernel. Each application of the (estimated) blur corresponds to a first order polynomial, and the repeated applications (adding or subtracting) correspond to higher order terms in a polynomial. A key aspect of this approach, which we call <a href=\"https://ieeexplore.ieee.org/document/9502555\">polyblur</a>, is that it is very fast, because it only requires a few applications of the blur itself. This allows it to operate on megapixel images in a fraction of a second on a typical mobile device. The degree of the polynomial and its coefficients are set to invert the blur without boosting noise and other unwanted artifacts.  </p><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-YCtQk62teYY/YNOmJzVVlnI/AAAAAAAAHx8/69Vo-SFE2GEZvzLdz8fb9EcMUxvt7hpeQCLcBGAsYHQ/s788/image4.png\"><img border=\"0\" height=\"216\" src=\"https://1.bp.blogspot.com/-YCtQk62teYY/YNOmJzVVlnI/AAAAAAAAHx8/69Vo-SFE2GEZvzLdz8fb9EcMUxvt7hpeQCLcBGAsYHQ/w640-h216/image4.png\" width=\"640\"></a></td></tr><tr><td class=\"tr-caption\">The deblurred image is generated by adding and subtracting multiple re-applications of the estimated blur (polyblur).</td></tr></tbody></table><p><b>Integration with Google Photos</b><br>The innovations described here have been integrated and made available to users in the Google Photos image editor in two new adjustment sliders called “Denoise” and “Sharpen”.  These features allow users to improve the quality of everyday images, from any capture device. The features often complement each other, allowing both denoising to reduce unwanted artifacts, and sharpening to bring clarity to the image subjects. Try using this pair of  tools in tandem in your images for best results. To learn more about the details of the work described here, check out our papers on <a href=\"https://ieeexplore.ieee.org/document/9502555\">polyblur</a> and <a href=\"https://ieeexplore.ieee.org/document/7532702\">pull-push denoising</a>. To see some examples of the effect of our denoising and sharpening up close, have a look at the images in this <a href=\"https://photos.app.goo.gl/eV2HhMAXNGpS62ZYA\">album</a>.  </p><p><b>Acknowledgements</b><br><em>The authors gratefully acknowledge the contributions of Ignacio Garcia-Dorado, Ryan Campbell, Damien Kelly, Peyman Milanfar, and John Isidoro. We are also thankful for support and feedback from Navin Sarma, Zachary Senzer, Brandon Ruffin, and Michael Milne.</em></p> <hr width=\"80%\"></hr><p>  <span class=\"Apple-style-span\"><sup><a name=\"fn1\"><b>1</b></a></sup> The original <a href=\"https://cseweb.ucsd.edu/~ravir/6160/papers/p43-gortler.pdf\">pull-push algorithm</a> was developed as an efficient scattered data interpolation method to estimate and fill in the missing pixels in an image where only a subset of the pixels are specified. Here, we extend its methodology and present a data-dependent multiscale algorithm for denoising images efficiently. <a href=\"#fnref1\" rev=\"footnote\"><sup>↩</sup></a></span></p><div class=\"feedflare\">\r\n<a href=\"http://feeds.feedburner.com/~ff/blogspot/gJZg?a=YzrGZK_H1dE:kz2iSuHd3gs:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/blogspot/gJZg?d=yIl2AUoC8zA\" border=\"0\">&lt;img&gt;</a>\r\n</div><img src=\"http://feeds.feedburner.com/~r/blogspot/gJZg/~4/YzrGZK_H1dE\" height=\"1\" width=\"1\" alt=\"\">"
}