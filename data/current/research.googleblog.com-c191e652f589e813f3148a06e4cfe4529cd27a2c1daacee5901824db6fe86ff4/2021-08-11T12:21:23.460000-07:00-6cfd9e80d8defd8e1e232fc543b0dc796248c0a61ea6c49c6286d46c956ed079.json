{
  "title":"Demonstrating the Fundamentals of Quantum Error Correction",
  "date":"2021-08-11T12:21:23.460000-07:00",
  "author":"Google AI",
  "id":"tag:blogger.com,1999:blog-8474926331452026626.post-714439963092461349",
  "link":"http://feedproxy.google.com/~r/blogspot/gJZg/~3/Tel7R_hqJh8/demonstrating-fundamentals-of-quantum.html",
  "content":"<span class=\"byline-author\">Posted by Jimmy Chen, Quantum Research Scientist and Matt McEwen, Student Researcher, Google Quantum AI</span> <p>The <a href=\"https://quantumai.google/\">Google Quantum AI</a> team has been building quantum processors made of superconducting quantum bits (<a href=\"https://en.wikipedia.org/wiki/Qubit\">qubits</a>) that have achieved the first <a href=\"https://ai.googleblog.com/2019/10/quantum-supremacy-using-programmable.html\">beyond-classical computation</a>, as well as the <a href=\"https://ai.googleblog.com/2020/08/scaling-up-fundamental-quantum.html\">largest quantum chemical simulations</a> to date. However, current generation quantum processors still have high operational error rates — in the range of 10<sup>-3</sup> per operation, compared to the 10<sup>-12</sup> believed to be necessary for a variety of useful algorithms. Bridging this tremendous gap in error rates will require more than just making better qubits — quantum computers of the future will have to use <a href=\"https://en.wikipedia.org/wiki/Quantum_error_correction\">quantum error correction</a> (QEC). </p><p>The core idea of QEC is to make a <em>logical qubit</em> by distributing its quantum state across many physical data qubits. When a physical error occurs, one can detect it by repeatedly checking certain properties of the qubits, allowing it to be corrected, preventing any error from occurring on the logical qubit state. While logical errors may still occur if a series of physical qubits experience an error together, this error rate should exponentially decrease with the addition of more physical qubits (more physical qubits need to be involved to cause a logical error). This exponential scaling behavior relies on physical qubit errors being sufficiently rare <em>and</em> independent. In particular, it’s important to suppress <em>correlated errors</em>, where one physical error simultaneously affects many qubits at once or persists over many cycles of error correction. Such correlated errors produce more complex patterns of error detections that are more difficult to correct and more easily cause logical errors. </p><p>Our team has recently implemented the ideas of QEC in our Sycamore architecture using <em>quantum repetition codes</em>. These codes consist of one-dimensional chains of qubits that alternate between <em>data qubits, </em>which encode the logical qubit, and<em> measure qubits</em>, which we use to detect errors in the logical state. While these repetition codes can only correct for one kind of quantum error at a time<sup id=\"fnref1\"><a href=\"#fn1\" rel=\"footnote\"><span>1</span></a></sup>, they contain all of the same ingredients as more sophisticated error correction codes and require fewer physical qubits per logical qubit, allowing us to better explore how logical errors decrease as logical qubit size grows.  </p><p>In “<a href=\"https://www.nature.com/articles/s41467-021-21982-y\">Removing leakage-induced correlated errors in superconducting quantum error correction</a>”, published in <em><a href=\"https://www.nature.com/ncomms/\">Nature Communications</a></em>, we use these repetition codes to demonstrate a new technique for reducing the amount of correlated errors in our physical qubits. Then, in “<a href=\"https://www.nature.com/articles/s41586-021-03588-y\">Exponential suppression of bit or phase flip errors with repetitive error correction</a>”, published in <em><a href=\"https://www.nature.com/\">Nature</a></em>, we show that the logical errors of these repetition codes are exponentially suppressed as we add more and more physical qubits, consistent with expectations from QEC theory. </p>   <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-oVwpb0C4-k4/YRPTld47TKI/AAAAAAAAIAs/30GZI99UwdUSFTQI8J8sBu3VRUZJElu3wCLcBGAsYHQ/s456/image5.png\"><img border=\"0\" height=\"358\" src=\"https://1.bp.blogspot.com/-oVwpb0C4-k4/YRPTld47TKI/AAAAAAAAIAs/30GZI99UwdUSFTQI8J8sBu3VRUZJElu3wCLcBGAsYHQ/w400-h358/image5.png\" width=\"400\"></a></td></tr><tr><td class=\"tr-caption\">Layout of the repetition code (21 qubits, 1D chain) and distance-2 surface code (7 qubits) on the Sycamore device.</td></tr></tbody></table>  <p><b>Leaky Qubits</b><br>The goal of the repetition code is to detect errors on the data qubits without measuring their states directly. It does so by <a href=\"https://en.wikipedia.org/wiki/Quantum_entanglement\">entangling</a> each pair of data qubits with their shared measure qubit in a way that tells us whether those data qubit states are the same or different (i.e., their <em>parity)</em> without telling us the states themselves. We repeat this process over and over in <em>rounds</em> that last only one microsecond. When the measured parities change between rounds, we’ve detected an error. </p><p>However, one key challenge stems from how we make qubits out of superconducting circuits. While a qubit needs only two energy states, which are usually labeled 0 and 1, our devices feature a ladder of energy states, 0, 1, 2, 3, and so on. We use the two lowest energy states to encode our qubit with information to be used for computation (we call these the <em>computational states)</em>. We use the higher energy states (2, 3 and higher) to help achieve high-fidelity entangling operations, but these entangling operations can sometimes allow the qubit to “leak” into these higher states, earning them the name <em>leakage states.</em></p><p>Population in the leakage states builds up as operations are applied, which increases the error of subsequent operations and even causes other nearby qubits to leak as well — resulting in a particularly challenging source of correlated error. In our early <a href=\"https://ai.googleblog.com/2015/03/a-step-closer-to-quantum-computation.html\">2015 experiments</a> on error correction, we observed that as more rounds of error correction were applied, performance declined as leakage began to build. </p><p>Mitigating the impact of leakage required us to develop a new kind of qubit operation that could “empty out” leakage states, called <em>multi-level reset</em>. We manipulate the qubit to rapidly pump energy out into the structures used for readout, where it will quickly move off the chip, leaving the qubit cooled to the 0 state, even if it started in 2 or 3. Applying this operation to the data qubits would destroy the logical state we’re trying to protect, but we can apply it to the measure qubits without disturbing the data qubits. Resetting the measure qubits at the end of every round dynamically stabilizes the device so leakage doesn’t continue to grow and spread, allowing our devices to behave more like ideal qubits.  </p>   <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-bjLIFmu_yHw/YRPT4droTfI/AAAAAAAAIA0/frCb0p1tQwwvrgV0o0V2--BrjQNJrsSdwCLcBGAsYHQ/s686/image2.png\"><img border=\"0\" height=\"540\" src=\"https://1.bp.blogspot.com/-bjLIFmu_yHw/YRPT4droTfI/AAAAAAAAIA0/frCb0p1tQwwvrgV0o0V2--BrjQNJrsSdwCLcBGAsYHQ/w640-h540/image2.png\" width=\"640\"></a></td></tr><tr><td class=\"tr-caption\">Applying the multi-level reset gate to the measure qubits almost totally removes leakage, while also reducing the growth of leakage on the data qubits.</td></tr></tbody></table>   <p><b>Exponential Suppression</b><br>Having mitigated leakage as a significant source of correlated error, we next set out to test whether the repetition codes give us the predicted exponential reduction in error when increasing the number of qubits. Every time we run our repetition code, it produces a collection of error detections. Because the detections are linked to pairs of qubits rather than individual qubits, we have to look at all of the detections to try to piece together where the errors have occurred, a procedure known as <em>decoding</em>. Once we’ve decoded the errors, we then know which corrections we need to apply to the data qubits. However, decoding can fail if there are too many error detections for the number of data qubits used, resulting in a logical error.  </p><p>To test our repetition codes, we run codes with sizes ranging from 5 to 21 qubits while also varying the number of error correction rounds. We also run two different types of repetition codes — either a phase-flip code or bit-flip code — that are sensitive to different kinds of quantum errors. By finding the logical error probability as a function of the number of rounds, we can fit a logical error rate for each code size and code type. In our data, we see that the logical error rate does in fact get suppressed exponentially as the code size is increased. </p>   <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-k1hbFfMrFyM/YRPUCD8Yz1I/AAAAAAAAIA4/mXTgHD1kOrksK-UnO0KG4qTWm2dPRFIrwCLcBGAsYHQ/s960/image3.png\"><img border=\"0\" height=\"502\" src=\"https://1.bp.blogspot.com/-k1hbFfMrFyM/YRPUCD8Yz1I/AAAAAAAAIA4/mXTgHD1kOrksK-UnO0KG4qTWm2dPRFIrwCLcBGAsYHQ/w640-h502/image3.png\" width=\"640\"></a></td></tr><tr><td class=\"tr-caption\">Probability of getting a logical error after decoding versus number of rounds run, shown for various sizes of phase-flip repetition code.</td></tr></tbody></table>   <p>We can quantify the error suppression with the error scaling parameter Lambda (Λ), where a Lambda value of 2 means that we halve the logical error rate every time we add four data qubits to the repetition code. In our experiments, we find Lambda values of 3.18 for the phase-flip code and 2.99 for the bit-flip code. We can compare these experimental values to a numerical simulation of the expected Lambda based on a simple error model with no correlated errors, which predicts values of 3.34 and 3.78 for the bit- and phase-flip codes respectively. </p>    <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://1.bp.blogspot.com/-xh1usf6Um9I/YRPUKIXdf2I/AAAAAAAAIBA/1rORJ1sxFD4EmL7TldvFA10CQpk3StZYgCLcBGAsYHQ/s688/image4.png\"><img border=\"0\" height=\"470\" src=\"https://1.bp.blogspot.com/-xh1usf6Um9I/YRPUKIXdf2I/AAAAAAAAIBA/1rORJ1sxFD4EmL7TldvFA10CQpk3StZYgCLcBGAsYHQ/w640-h470/image4.png\" width=\"640\"></a></td></tr><tr><td class=\"tr-caption\">Logical error rate per round versus number of qubits for the phase-flip (X) and bit-flip (Z) repetition codes. The line shows an exponential decay fit, and Λ is the scale factor for the exponential decay.</td></tr></tbody></table>    <p>This is the first time Lambda has been measured in any platform while performing multiple rounds of error detection. We’re especially excited about how close the experimental and simulated Lambda values are, because it means that our system can be described with a fairly simple error model without many unexpected errors occurring. Nevertheless, the agreement is not perfect, indicating that there’s more research to be done in understanding the non-idealities of our QEC architecture, including additional sources of correlated errors. </p><p><b>What’s Next</b><br>This work demonstrates two important prerequisites for QEC: first, the Sycamore device can run many rounds of error correction without building up errors over time thanks to our new reset protocol, and second, we were able to validate QEC theory and error models by showing exponential suppression of error in a repetition code. These experiments were the largest stress test of a QEC system yet, using 1000 entangling gates and 500 qubit measurements in our largest test. We’re looking forward to taking what we learned from these experiments and applying it to our target QEC architecture, the 2D surface code, which will require even more qubits with even better performance.</p>   <hr width=\"80%\"></hr><p>  <span class=\"Apple-style-span\"><sup><a name=\"fn1\"><b>1</b></a></sup>A true quantum error correcting code would require a two dimensional array of qubits in order to correct for all of the errors that could occur. <a href=\"#fnref1\" rev=\"footnote\"><sup>↩</sup></a></span></p>       <div class=\"feedflare\">\r\n<a href=\"http://feeds.feedburner.com/~ff/blogspot/gJZg?a=Tel7R_hqJh8:mVJRq2VljN8:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/blogspot/gJZg?d=yIl2AUoC8zA\" border=\"0\">&lt;img&gt;</a>\r\n</div><img src=\"http://feeds.feedburner.com/~r/blogspot/gJZg/~4/Tel7R_hqJh8\" height=\"1\" width=\"1\" alt=\"\">"
}