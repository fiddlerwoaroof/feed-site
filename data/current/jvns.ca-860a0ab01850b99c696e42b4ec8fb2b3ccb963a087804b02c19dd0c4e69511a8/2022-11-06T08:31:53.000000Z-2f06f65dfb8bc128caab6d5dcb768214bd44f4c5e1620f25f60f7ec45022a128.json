{
  "title":"Making a DNS query in Ruby from scratch",
  "date":"2022-11-06T08:31:53.000000Z",
  "author":null,
  "id":"https://jvns.ca/blog/2022/11/06/making-a-dns-query-in-ruby-from-scratch/",
  "link":"https://jvns.ca/blog/2022/11/06/making-a-dns-query-in-ruby-from-scratch/",
  "content":"\n\n<p>Hello! A while back I wrote a post about <a href=\"https://jvns.ca/blog/2022/02/01/a-dns-resolver-in-80-lines-of-go/\">how to write a toy DNS resolver in Go</a>.</p>\n\n<p>In that post I left out “how to generate and parse DNS queries” because I\nthought it was boring, but a few people pointed out that they did not know how\nto parse and generate DNS queries and they were interested in how to do it.</p>\n\n<p>This made me curious – how much work <em>is</em> it do the DNS parsing? It turns out\nwe can do it in a pretty nice 120-line Ruby program, which is not that bad.</p>\n\n<p>So here’s a quick post on how to generate DNS queries and parse DNS responses!\nWe’re going to do it in Ruby because I’m giving a talk at a Ruby conference\nsoon, and this blog post is partly prep for that talk :). I’ve tried to keep it\nreadable for folks who don’t know Ruby though, I’ve only used pretty basic Ruby\ncode.</p>\n\n<p>At the end we’re going to have a very simple toy Ruby version of <code>dig</code> that can\nlook up domain names like this:</p>\n\n<pre><code>$ ruby dig.rb example.com\nexample.com\t   20314    A    93.184.216.34\n</code></pre>\n\n<p>The whole thing is about 120 lines of code, so it’s not <em>that</em> much.  (The\nfinal program is\n<a href=\"https://gist.github.com/jvns/1e5838a53520e45969687e2f90199770\">dig.rb</a> if you want to skip the explanations and just read some code.)\nWe won’t\nimplement the “how a DNS resolver works” from the previous post because, well,\nwe already did that. Let’s get into it!</p>\n\n<p>Along the way I’m going to try to explain how you could figure out some of this\nstuff yourself if you were trying to figure out how DNS queries are formatted from scratch. Mostly that’s “poke around in Wireshark” and “read RFC 1035, the DNS RFC”.</p>\n\n<h1 id=\"step-1-open-a-udp-socket\">step 1: open a UDP socket</h1>\n\n<p>We need to actually <em>send</em> our queries, so to do that we need to open a UDP\nsocket. We’ll send our queries to <code>8.8.8.8</code>, Google’s DNS server.</p>\n\n<p>Here’s the code to set up a UDP connection to <code>8.8.8.8</code>, port 53 (the DNS port).</p>\n\n<pre><code>require 'socket'\nsock = UDPSocket.new\n\nsock.bind('0.0.0.0', 12345)\nsock.connect('8.8.8.8', 53)\n</code></pre>\n\n<h3 id=\"a-quick-note-on-udp\">a quick note on UDP</h3>\n\n<p>I’m not going to say too much about UDP here, but I will say that the basic\nunit of computer networking is the “packet” (a packet is a string of bytes),\nand in this program we’re going to do the simplest possible thing you can do\nwith a computer network – send 1 packet and receive 1 packet in response.</p>\n\n<p>So UDP is a way to send packets in the simplest possible way.</p>\n\n<p>It’s the most common way to send DNS queries, though you can also use TCP or\nDNS-over-HTTPS instead.</p>\n\n<h3 id=\"step-2-copy-a-dns-query-from-wireshark\">step 2: copy a DNS query from Wireshark</h3>\n\n<p>Next: let’s say we have no idea how DNS works but we want to send a working\nquery as fast as possible. The easiest way to get a DNS query to play with and\nmake sure our UDP connection is working is to just copy one that already works!</p>\n\n<p>So that’s what we’re going to do, using Wireshark (an incredible packet analysis tool)</p>\n\n<p>The steps I used to this are roughly:</p>\n\n<ol>\n<li>Open Wireshark and click ‘capture’</li>\n<li>Enter <code>udp.port == 53</code> as a filter (in the search bar)</li>\n<li>Run <code>ping example.com</code> in my terminal (to generate a DNS query)</li>\n<li>Click on the DNS query (“Standard query A example.com”)</li>\n<li>Right click on “Domain Name System (query”) in the bottom left pane</li>\n<li>Click ‘Copy’ -&gt; ‘as a hex stream’</li>\n<li>Now I have “b96201000001000000000000076578616d706c6503636f6d0000010001” on my clipboard, to use in my Ruby program. Hooray!</li>\n</ol>\n\n<h3 id=\"step-3-decode-the-hex-stream-and-send-the-dns-query\">step 3: decode the hex stream and send the DNS query</h3>\n\n<p>Now we can send our DNS query to <code>8.8.8.8</code>! Here’s what that looks like: we just need to add 5 lines of code</p>\n\n<pre><code>hex_string = &quot;b96201000001000000000000076578616d706c6503636f6d0000010001&quot;\nbytes = [hex_string].pack('H*')\nsock.send(bytes, 0)\n\n# get the reply\nreply, _ = sock.recvfrom(1024)\nputs reply.unpack('H*')\n</code></pre>\n\n<p><code>[hex_string].pack('H*')</code> is translating our hex string into a byte string. At\nthis point we don’t really know what this data <em>means</em> but we’ll get there in a\nsecond.</p>\n\n<p>We can also take this opportunity to make sure our program is working and is sending valid data, using <code>tcpdump</code>. How I did that:</p>\n\n<ol>\n<li>Run <code>sudo tcpdump -ni any port 53 and host 8.8.8.8</code> in a terminal tab</li>\n<li>In a different terminal tab, run <a href=\"https://gist.github.com/jvns/aa202b1edd97ae261715c806b2ba7d39\">this Ruby program</a> (<code>ruby dns-1.rb</code>)</li>\n</ol>\n\n<p>Here’s what the output looks like:</p>\n\n<pre><code>$ sudo tcpdump -ni any port 53 and host 8.8.8.8\n08:50:28.287440 IP 192.168.1.174.12345 &gt; 8.8.8.8.53: 47458+ A? example.com. (29)\n08:50:28.312043 IP 8.8.8.8.53 &gt; 192.168.1.174.12345: 47458 1/0/0 A 93.184.216.34 (45)\n</code></pre>\n\n<p>This is really good - we can see the DNS request (“what’s the IP for\n<code>example.com</code>”) and the response (“it’s 93.184.216.34”). So everything is\nworking. Now we just need to, you know, figure out how to generate and decode this data ourselves.</p>\n\n<h3 id=\"step-4-learn-a-little-about-how-dns-queries-are-formatted\">step 4: learn a little about how DNS queries are formatted</h3>\n\n<p>Now that we have a DNS query for <code>example.com</code>, let’s learn about what it means.</p>\n\n<p>Here’s our query, formatted as hex.</p>\n\n<pre><code>b96201000001000000000000076578616d706c6503636f6d0000010001\n</code></pre>\n\n<p>If you poke around in Wireshark, you’ll see that this query has 2 parts:</p>\n\n<ul>\n<li>The <strong>header</strong> (<code>b96201000001000000000000</code>)</li>\n<li>The <strong>question</strong> (<code>076578616d706c6503636f6d0000010001</code>)</li>\n</ul>\n\n<h3 id=\"step-5-make-the-header\">step 5: make the header</h3>\n\n<p>Our goal in this step is to generate the byte string\n<code>b96201000001000000000000</code>, but with a Ruby function instead of hardcoding it.</p>\n\n<p>So: the header is 12 bytes. What do those 12 bytes mean? If you look at\nWireshark (or read <a href=\"https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.1\">RFC 1035</a>), you’ll see\nthat it’s 6 2-byte numbers concatenated together.</p>\n\n<p>The 6 numbers correspond to the query ID, the flags, and then the number of\nquestions, answer records, authoritative records, and additional records in the\npacket.</p>\n\n<p>We don’t need to worry about what all those things are yet though – we just need\nto put in 6 numbers.</p>\n\n<p>And luckily we know exactly which 6 numbers to put because our goal is to\nliterally generate the string <code>b96201000001000000000000</code>.</p>\n\n<p>So here’s a function to make the header. (note: there’s no <code>return</code> because you don’t need to write <code>return</code> in Ruby if it’s the last line of the function)</p>\n\n<pre><code class=\"language-ruby\">def make_question_header(query_id)\n  # id, flags, num questions, num answers, num auth, num additional\n  [query_id, 0x0100, 0x0001, 0x0000, 0x0000, 0x0000].pack('nnnnnn')\nend\n</code></pre>\n\n<p>This is very short because we’ve hardcoded everything except the query ID.</p>\n\n<h3 id=\"what-s-nnnnnn\">what’s <code>nnnnnn</code>?</h3>\n\n<p>You might be wondering what <code>nnnnnn</code> is in <code>.pack('nnnnnn')</code>. That’s a format\nstring telling <code>.pack()</code> how to convert that array of 6 numbers into a byte\nstring.</p>\n\n<p><a href=\"https://ruby-doc.org/core-3.0.0/Array.html#method-i-pack\">The documentation for <code>.pack</code> is here</a>, and it says that <code>n</code> means\n“represent it as “16-bit unsigned, network (big-endian) byte order”.</p>\n\n<p>16 bits is the same as 2 bytes, and we need to use network byte order because\nthis is computer networking. I’m not going to explain byte order right now\n(though I do have a <a href=\"https://wizardzines.com/comics/little-endian/\">comic attempting to explain\nit</a>)</p>\n\n<h3 id=\"test-the-header-code\">test the header code</h3>\n\n<p>Let’s quickly test that our <code>make_question_header</code> function works.</p>\n\n<pre><code>puts make_question_header(0xb962) == [&quot;b96201000001000000000000&quot;].pack(&quot;H*&quot;)\n</code></pre>\n\n<p>This prints out “true”, so we win and we can move on.</p>\n\n<h3 id=\"step-5-encode-the-domain-name\">step 5: encode the domain name</h3>\n\n<p>Next we need to generate the <strong>question</strong> (“what’s the IP for <code>example.com</code>?“). This has 3 parts:</p>\n\n<ul>\n<li>the <strong>domain name</strong> (for example “example.com”)</li>\n<li>the <strong>query type</strong> (for example “A” is for “IPv4 <strong>A</strong>ddress”</li>\n<li>the <strong>query class</strong> (which is always the same, 1 is for <strong>IN</strong> is for <strong>IN</strong>ternet)</li>\n</ul>\n\n<p>The hardest part of this is the domain name so let’s write a function to do that.</p>\n\n<p><code>example.com</code> is encoded in a DNS query, in hex, as <code>076578616d706c6503636f6d00</code>. What does that mean?</p>\n\n<p>Well, if we translate the bytes into ASCII, it looks like this:</p>\n\n<pre><code>076578616d706c6503636f6d00\n 7 e x a m p l e 3 c o m 0\n</code></pre>\n\n<p>So each segment (like <code>example</code>) has its length (like 7) in front of it.</p>\n\n<p>Here’s the Ruby code to translate <code>example.com</code> into <code>7 e x a m p l e 3 c o m 0</code>:</p>\n\n<pre><code>def encode_domain_name(domain)\n  domain\n    .split(&quot;.&quot;)\n    .map { |x| x.length.chr + x }\n    .join + &quot;\\0&quot;\nend\n</code></pre>\n\n<p>Other than that, to finish generating the question section we just need to\nappend the type and class onto the end of the domain name.</p>\n\n<h3 id=\"step-6-write-make-dns-query\">step 6: write <code>make_dns_query</code></h3>\n\n<p>Here’s the final function to make a DNS query:</p>\n\n<pre><code>def make_dns_query(domain, type)\n  query_id = rand(65535)\n  header = make_question_header(query_id)\n  question =  encode_domain_name(domain) + [type, 1].pack('nn')\n  header + question\nend\n</code></pre>\n\n<p><a href=\"https://gist.github.com/jvns/3587ea0b4a2a6c20dcfd8bf653fc11d9\">Here’s all the code we’ve written before in <code>dns-2.rb</code></a> –\nit’s still only 29 lines.</p>\n\n<h3 id=\"now-for-the-parsing\">now for the parsing</h3>\n\n<p>Now that we’ve managed to <em>generate</em> a DNS query, we get into the hard part:\nthe parsing. Again, we’ll split this into a bunch of different</p>\n\n<ul>\n<li>parse a DNS header</li>\n<li>parse a DNS name</li>\n<li>parse a DNS record</li>\n</ul>\n\n<p>The hardest part of this (maybe surprisingly) is going to be “parse a DNS\nname”.</p>\n\n<h3 id=\"step-7-parse-the-dns-header\">step 7: parse the DNS header</h3>\n\n<p>Let’s start with the easiest part: the DNS header. We already talked about how\nit’s 6 numbers concatenated together.</p>\n\n<p>So all we need to do is</p>\n\n<ul>\n<li>read the first 12 bytes</li>\n<li>convert that into an array of 6 numbers</li>\n<li>put those numbers in a class for convenience</li>\n</ul>\n\n<p>Here’s the Ruby code to do that.</p>\n\n<pre><code class=\"language-ruby\">class DNSHeader\n  attr_reader :id, :flags, :num_questions, :num_answers, :num_auth, :num_additional\n  def initialize(buf)\n    hdr = buf.read(12)\n    @id, @flags, @num_questions, @num_answers, @num_auth, @num_additional = hdr.unpack('nnnnnn')\n  end\nend\n</code></pre>\n\n<p><small>\nQuick Ruby note: <code>attr_reader</code> is a Ruby thing that means “make these instance\nvariables accessible as methods”. So you can call <code>header.flags</code> to look at the\n<code>@flags</code> variable.\n</small></p>\n\n<p>We can call this with <code>DNSHeader(buf)</code>. Not so bad.</p>\n\n<p>Let’s move on to the hardest part: parsing a domain name.</p>\n\n<h3 id=\"step-8-parse-a-domain-name\">step 8: parse a domain name</h3>\n\n<p>First, let’s write a partial version.</p>\n\n<pre><code>def read_domain_name_wrong(buf)\n  domain = []\n  loop do\n    len = buf.read(1).unpack('C')[0]\n    break if len == 0\n    domain &lt;&lt; buf.read(len)\n  end\n  domain.join('.')\nend\n</code></pre>\n\n<p>This repeatedly reads 1 byte and then reads that length into a string until the\nlength is 0.</p>\n\n<p>This works great, for the first time we see a domain name (<code>example.com</code>) in our DNS response.</p>\n\n<h3 id=\"trouble-with-domain-names-compression\">trouble with domain names: compression!</h3>\n\n<p>But the second time <code>example.com</code> appears, we run into trouble – in Wireshark,\nit says that the domain is represented cryptically as just the 2 bytes <code>c00c</code>.</p>\n\n<p>This is something called <strong>DNS compression</strong> and if we want to parse any DNS\nresponses we’re going to have to implement it.</p>\n\n<p>This is luckily not <strong>that</strong> hard. All <code>c00c</code> is saying is:</p>\n\n<ul>\n<li>The first 2 bits (<code>0b11.....</code>) mean “DNS compression ahead!”</li>\n<li>The remaining 14 bits are an integer. In this case that integer is <code>12</code>\n(<code>0x0c</code>), so that means “go back to the 12th byte in the packet and use the\ndomain name you find there”</li>\n</ul>\n\n<p>If you want to read more about DNS compression, I found the <a href=\"https://datatracker.ietf.org/doc/html/rfc1035#section-4.1.4\">explanation in the DNS RFC</a> relatively readable.</p>\n\n<h3 id=\"step-9-implement-dns-compression\">step 9: implement DNS compression</h3>\n\n<p>So we need a more complicated version of our <code>read_domain_name</code> function</p>\n\n<p>Here it is.</p>\n\n<pre><code class=\"language-ruby\">  domain = []\n  loop do\n    len = buf.read(1).unpack('C')[0]\n    break if len == 0\n    if len &amp; 0b11000000 == 0b11000000\n      # weird case: DNS compression!\n      second_byte = buf.read(1).unpack('C')[0]\n      offset = ((len &amp; 0x3f) &lt;&lt; 8) + second_byte\n      old_pos = buf.pos\n      buf.pos = offset\n      domain &lt;&lt; read_domain_name(buf)\n      buf.pos = old_pos\n      break\n    else\n      # normal case\n      domain &lt;&lt; buf.read(len)\n    end\n  end\n  domain.join('.')\n</code></pre>\n\n<p>Basically what’s happening is:</p>\n\n<ul>\n<li>if the first 2 bits are <code>0b11</code>, we need to do DNS compression. Then:\n\n<ul>\n<li>read the second byte and do a little bit arithmetic to convert that into the offset</li>\n<li>save the current position in the buffer</li>\n<li>read the domain name at the offset we calculated</li>\n<li>restore our position in the buffer</li>\n</ul></li>\n</ul>\n\n<p>This is kind of messy but it’s the most complicated part of parsing the DNS response, so we’re almost done!</p>\n\n<h3 id=\"a-dns-compression-exploit\">a DNS compression exploit</h3>\n\n<p>Someone pointed out that a malicious actor could exploit this code by sending a\nDNS response with a DNS compression entry that points to itself, so that\n<code>read_domain_name</code> would end up in an infinite loop. I won’t update it (the\ncode is already complicated enough!) but a real DNS parser would be\nsmarter and deal with that. For example <a href=\"https://github.com/miekg/dns/blob/b3dfea07155dbe4baafd90792c67b85a3bf5be23/msg.go#L430-L435\">here’s the code that avoids infinite loops in miekg/dns</a></p>\n\n<p>There are also probably other edge cases that would be problematic if this were\na real DNS parser.</p>\n\n<h3 id=\"step-10-parse-a-dns-query\">step 10: parse a DNS query</h3>\n\n<p>You might think “why do we need to parse a DNS query? This is the response!”.\nBut every DNS response has the original query in it, so we need to parse it.</p>\n\n<p>Here’s the code for parsing the DNS query.</p>\n\n<pre><code>class DNSQuery\n  attr_reader :domain, :type, :cls\n  def initialize(buf)\n    @domain = read_domain_name(buf)\n    @type, @cls = buf.read(4).unpack('nn')\n  end\nend\n</code></pre>\n\n<p>There’s not very much to it: the type and class are 2 bytes each.</p>\n\n<h3 id=\"step-11-parse-a-dns-record\">step 11: parse a DNS record</h3>\n\n<p>This is the exciting part – the DNS record is where our query data lives! The\n“rdata field” (“record data”) is where the IP address we’re going to get in\nresponse to our DNS query lives.</p>\n\n<p>Here’s the code:</p>\n\n<pre><code>class DNSRecord \n  attr_reader :name, :type, :class, :ttl, :rdlength, :rdata\n  def initialize(buf)\n    @name = read_domain_name(buf)\n    @type, @class, @ttl, @rdlength = buf.read(10).unpack('nnNn')\n    @rdata = buf.read(@rdlength)\n  end\n</code></pre>\n\n<p>We also need to do a little work to make the <code>rdata</code> field human readable. The\nmeaning of the record data depends on the record type  – for example for an\n“A” record it’s a 4-byte IP address, for but a “CNAME” record it’s a domain\nname.</p>\n\n<p>So here’s some code to make the request data human readable:</p>\n\n<pre><code>  def read_rdata(buf, length)\n    @type_name = TYPES[@type] || @type\n    if @type_name == &quot;CNAME&quot; or @type_name == &quot;NS&quot;\n      read_domain_name(buf)\n    elsif @type_name == &quot;A&quot;\n      buf.read(length).unpack('C*').join('.')\n    else\n      buf.read(length)\n    end\n  end\n</code></pre>\n\n<p>This function uses this <code>TYPES</code> hash to map the record type to a human-readable name:</p>\n\n<pre><code>TYPES = {\n  1 =&gt; &quot;A&quot;,\n  2 =&gt; &quot;NS&quot;,\n  5 =&gt; &quot;CNAME&quot;,\n  # there are a lot more but we don't need them for this example\n}\n</code></pre>\n\n<p>The most interesting part of <code>read_rdata</code> is probably the line <code>buf.read(length).unpack('C*').join('.')</code> – it’s saying “hey, an IP address is 4 bytes,\nso convert it into an array of 4 numbers and then join those with “.“s”.</p>\n\n<h3 id=\"step-12-finish-parsing-the-dns-response\">step 12: finish parsing the DNS response</h3>\n\n<p>Now we’re ready to parse the DNS response!</p>\n\n<p>Here’s some code to do that:</p>\n\n<pre><code class=\"language-ruby\">class DNSResponse\n  attr_reader :header, :queries, :answers, :authorities, :additionals\n  def initialize(bytes)\n    buf = StringIO.new(bytes)\n    @header = DNSHeader.new(buf)\n    @queries = (1..@header.num_questions).map { DNSQuery.new(buf) }\n    @answers = (1..@header.num_answers).map { DNSRecord.new(buf) }\n    @authorities = (1..@header.num_auth).map { DNSRecord.new(buf) }\n    @additionals = (1..@header.num_additional).map { DNSRecord.new(buf) }\n  end\nend\n</code></pre>\n\n<p>This mostly just calls the other functions we’ve written to parse the DNS response.</p>\n\n<p>It uses this cute <code>(1..@header.num_answers).map</code> construction to create an\narray of 2 DNS records if <code>@header.num_answers</code> is 2. (which is maybe a\n<em>little</em> bit of Ruby magic but I think it’s kind of fun and hopefully isn’t too hard\nto read)</p>\n\n<p>We can integrate this code into our main function like this:</p>\n\n<pre><code>sock.send(make_dns_query(&quot;example.com&quot;, 1), 0) # 1 is &quot;A&quot;, for IP address\nreply, _ = sock.recvfrom(1024)\nresponse = DNSResponse.new(reply) # parse the response!!!\nputs response.answers[0]\n</code></pre>\n\n<p>Printing out the records looks awful though (it says something like\n<code>#&lt;DNSRecord:0x00000001368e3118&gt;</code>). So we need to write some pretty printing\ncode to make it human readable.</p>\n\n<h3 id=\"step-13-pretty-print-our-dns-records\">step 13: pretty print our DNS records</h3>\n\n<p>We need to add a <code>.to_s</code> field to DNS records to make them have a nice string\nrepresentation. This is just a 1-line method in <code>DNSRecord</code>:</p>\n\n<pre><code>  def to_s\n    &quot;#{@name}\\t\\t#{@ttl}\\t#{@type_name}\\t#{@parsed_rdata}&quot;\n  end\n</code></pre>\n\n<p>You also might notice that I left out the <code>class</code> field of the DNS record. That’s because it’s\nalways the same (IN for “internet”) so I felt it was redundant. Most DNS tools\n(like real <code>dig</code>) will print out the class though.</p>\n\n<h3 id=\"and-we-re-done\">and we’re done!</h3>\n\n<p>Here’s our final <code>main</code> function:</p>\n\n<pre><code>def main\n  # connect to google dns\n  sock = UDPSocket.new\n  sock.bind('0.0.0.0', 0)\n  sock.connect('8.8.8.8', 53)\n\n  # send query\n  domain = ARGV[0]\n  sock.send(make_dns_query(domain, 1), 0)\n\n  # receive &amp; parse response\n  reply, _ = sock.recvfrom(1024)\n  response = DNSResponse.new(reply)\n  response.answers.each do |record|\n    puts record\n  end\n</code></pre>\n\n<p>I don’t think there’s too much to say about this – we connect, send a query,\nprint out each of the answers, and exit. Success!</p>\n\n<pre><code>$ ruby dig.rb example.com\nexample.com   18608   A   93.184.216.34\n</code></pre>\n\n<p>You can see the final program as a gist here:\n<a href=\"https://gist.github.com/jvns/1e5838a53520e45969687e2f90199770\">dig.rb</a>. You could add more features to it if you want, like</p>\n\n<ul>\n<li>pretty printing for other query types</li>\n<li>options to print out the “authority” and “additional” sections of the DNS response</li>\n<li>retries</li>\n<li>making sure that the DNS response we see is <em>actually</em> a response to the query we sent (the query ID has to match!</li>\n</ul>\n\n<p>Also <a href=\"https://twitter.com/b0rk\">you can let me know on Twitter</a> if I’ve made a mistake in this post somewhere\n– I wrote this pretty quickly so I probably got something wrong.</p>\n"
}