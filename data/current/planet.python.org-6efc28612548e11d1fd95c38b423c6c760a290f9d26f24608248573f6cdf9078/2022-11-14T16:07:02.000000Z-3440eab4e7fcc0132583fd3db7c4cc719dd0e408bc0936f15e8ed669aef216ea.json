{
  "title":"Luke Plant: Tools for rewriting Python code",
  "date":"2022-11-14T16:07:02.000000Z",
  "author":null,
  "id":"https://lukeplant.me.uk/blog/posts/tools-for-rewriting-python-code/",
  "link":"https://lukeplant.me.uk/blog/posts/tools-for-rewriting-python-code/",
  "content":"<p>When writing (or reviewing) code, you have better things to do than concern\nyourself with low-level details about coding style or other changes that are\nessentially mechanical in nature. Thankfully, the tooling ecosystem for doing\nthese kind of boring changes to Python code has become much stronger in the past\nfew years.</p>\n<p>Below is my collection, with some alternatives and recommendations. These all go\nbeyond being <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Lint_(software)\">linters</a>, which\nonly report problems, to being able to fix your code automatically. Most of\nthese work really well with tools like <a class=\"reference external\" href=\"https://pre-commit.com/\">pre-commit</a>\nso that by the time you come to code review, all the boring stuff is already\nfixed.</p>\n\n<h2>Formatting and coding style</h2>\n<ul>\n<li><p><a class=\"reference external\" href=\"https://github.com/psf/black\">Black</a> is probably the most populate Python\ncode formatter today.</p>\n<p><a class=\"reference external\" href=\"https://github.com/google/yapf\">YAPF</a> is another with a similar ethos to\nBlack, but less popular AFAIK, and I don’t use it.</p>\n</li>\n<li><p><a class=\"reference external\" href=\"https://github.com/hhatto/autopep8\">autopep8</a> doesn’t go as far as Black or\nYAPF - it fixes <a class=\"reference external\" href=\"https://pep8.org/\">PEP8</a> violations but otherwise leaves\nyour code alone. This is useful for cases where people aren’t quite ready for\nBlack yet.</p></li>\n<li><p><a class=\"reference external\" href=\"https://github.com/PyCQA/isort\">isort</a> and <a class=\"reference external\" href=\"https://github.com/asottile/reorder_python_imports\">reorder_python_imports</a> will sort your Python\nimports for you.</p>\n<p>I personally prefer the former, isort. <code class=\"docutils literal\">reorder_python_imports</code> has a much\nmore verbose style, resulting in many lines for imports. This is useful for\nreducing merge conflicts, but with the other tools listed here, I don’t find\nthose much of a problem — if you aren’t sure which imports are still needed,\ninclude them all and let isort remove the duplicates, and autoflake remove the\nunneeded ones.</p>\n</li>\n<li><p><a class=\"reference external\" href=\"https://github.com/spookylukey/table-format\">table-format</a> makes it easy\nto have aligned columns in your Python source code.</p></li>\n</ul>\n\n\n<h2>Upgrades</h2>\n<p>The following tools will do upgrades on your code:</p>\n<ul class=\"simple\">\n<li><p><a class=\"reference external\" href=\"https://github.com/asottile/pyupgrade\">pyupgrade</a> — moves code to the most modern Python idioms.</p></li>\n<li><p><a class=\"reference external\" href=\"https://github.com/PyCQA/isort\">flynt</a> — rewrites older string formatting\ncode using <code class=\"docutils literal\">%</code> to use <code class=\"docutils literal\">.format</code> and/or f-strings where possible.</p></li>\n<li><p><a class=\"reference external\" href=\"https://github.com/adamchainz/django-upgrade\">django-upgrade</a> and\n<a class=\"reference external\" href=\"https://github.com/browniebroke/django-codemod\">django-codemod</a> — include\nvarious fixes for breaking changes or new features in Django.</p></li>\n<li><p><a class=\"reference external\" href=\"https://github.com/asottile/setup-py-upgrade\">setup-py-upgrade</a> — upgrades\nyour <code class=\"docutils literal\">setup.py</code> to a <code class=\"docutils literal\">setup.cfg</code> file.</p></li>\n</ul>\n\n\n<h2>Type hints</h2>\n<ul>\n<li><p><a class=\"reference external\" href=\"https://github.com/instagram/MonkeyType\">Monkeytype</a> and <a class=\"reference external\" href=\"https://github.com/dropbox/pyannotate\">pyannotate</a> — add type hints based on\ninstrumented test suite runs.</p></li>\n<li><p><a class=\"reference external\" href=\"https://github.com/google/pytype\">pytype</a> — this does type checking and\nproduces <code class=\"docutils literal\">.pyi</code> files based on inference, and also includes a <code class=\"docutils literal\"><span class=\"pre\">merge-pyi</span></code>\ntool that can merge <code class=\"docutils literal\">.pyi</code> files into <code class=\"docutils literal\">.py</code> files.</p></li>\n<li><p><a class=\"reference external\" href=\"https://github.com/JelleZijlstra/autotyping\">autotyping</a> — a tool to add\ntype hints for various cases where this can be done automatically.</p>\n<p>(As a comment, I’m not wild about some of these automated changes. Annotating\n<code class=\"docutils literal\">__str__</code> with <code class=\"docutils literal\"><span class=\"pre\">-&gt;</span> str</code>, when <a class=\"reference external\" href=\"https://docs.python.org/3/reference/datamodel.html#object.__str__\">it is required to be a str</a>, seems\nlike a failure of our static typing tools, and it adds a lot of noise.)</p>\n</li>\n<li><p><a class=\"reference external\" href=\"https://github.com/hauntsaninja/no_implicit_optional\">no_implicit_optional</a>\n— a small tool to make some type hints more compliant with <a class=\"reference external\" href=\"https://peps.python.org/pep-0484/\">PEP 484</a>.</p></li>\n</ul>\n\n\n<h2>Refactoring</h2>\n<p>Many IDEs/editors provide a bunch of tools to rewrite Python code (for example\ndoing renames), often by integrating with <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Language_Server_Protocol\">language servers</a>.</p>\n<p>In VSCode, the default is <a class=\"reference external\" href=\"https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance\">Pylance</a>\nwhich is proprietary and can only be used with VSCode. However, <a class=\"reference external\" href=\"https://github.com/microsoft/pyright\">pyright</a> powers most of its functionality, and\nis Open Source. As well as being a command line static type checker, it also\nfunctions as a language server, and it’s the one I use from Emacs at the moment.</p>\n<p>One of the issues I find is that these is that they can be hard to use from the\ncommand line, to be able to do more automated refactoring — in fact I haven’t\nfound a good way to do so, other than scripting things using <a class=\"reference external\" href=\"https://en.wikipedia.org/wiki/Emacs_Lisp\">elisp</a>.</p>\n<p>So here are some other tools that are designed for more stand-alone use and have\nsome refactoring features:</p>\n<ul class=\"simple\">\n<li><p><a class=\"reference external\" href=\"https://github.com/python-rope/rope\">rope</a></p></li>\n<li><p><a class=\"reference external\" href=\"https://github.com/davidhalter/jedi/\">jedi</a></p></li>\n</ul>\n\n\n<h2>Other</h2>\n<ul class=\"simple\">\n<li><p><a class=\"reference external\" href=\"https://github.com/PyCQA/autoflake\">autoflake</a> — remove unused imports.</p></li>\n<li><p><a class=\"reference external\" href=\"https://github.com/Instagram/Fixit\">Fixit</a> — custom linting rules with automatic fixes.</p></li>\n<li><p><a class=\"reference external\" href=\"https://github.com/Zac-HD/shed\">shed</a> — bundles together a few of the above.</p></li>\n</ul>\n\n\n<h2>Write your own</h2>\n<p>Finally, there are great libraries like <a class=\"reference external\" href=\"https://libcst.readthedocs.io/en/latest/index.html\">libCST</a> that will help you to\nmanipulate Python code but without losing comments etc., so that writing your\nown tool to do this is no longer a massive task.</p>\n<p>Also looking for packages that depend on LibCST, <a class=\"reference external\" href=\"https://github.com/Instagram/LibCST/network/dependents?dependent_type=PACKAGE\">on GitHub</a>\nor on <a class=\"reference external\" href=\"https://libraries.io/pypi/libcst/dependents\">libraries.io</a>, is a great\nway to find more tools like this.</p>\n<p>Have fun writing code to fix your code!</p>"
}