{
  "title":"Joe Marshall: A Floating-point Problem",
  "date":"2021-08-27T06:47:00.000000-07:00",
  "author":null,
  "id":"http://funcall.blogspot.com/2021/08/a-floating-point-problem.html",
  "link":"http://funcall.blogspot.com/2021/08/a-floating-point-problem.html",
  "content":"<p>Here's a 2x2 matrix:<pre>[64919121   -159018721]\n[41869520.5 -102558961]</pre>We can multiply it by a 2 element vector like this:<pre>(defun mxv (a b\n            c d\n\n            x\n            y\n\n            receiver)\n  (funcall receiver\n           (+ (* a x) (* b y))\n           (+ (* c x) (* d y))))\n\n* (mxv 64919121     -159018721\n       41869520.5d0 -102558961\n \n       3\n       1\n\n       #'list)\n\n(35738642 2.30496005d7)</pre>Given a matrix and a result, we want to\n  find the 2 element vector that produces that result.  To do this, we\n  compute the inverse of the matrix:<pre>(defun m-inverse (a b\n                  c d\n\n                  receiver)\n  (let ((det (- (* a d) (* b c))))\n    (funcall receiver\n             (/ d det) (/ (- b) det)\n             (/ (- c) det) (/ a det))))</pre>and multiply the inverse\n  matrix by the result:<pre>(defun solve (a b\n              c d\n\n              x\n              y\n\n              receiver)\n  (m-inverse a b\n             c d\n             (lambda (ia ib\n                      ic id)\n               (mxv ia ib\n                    ic id\n\n                    x\n                    y\n                    receiver))))</pre>So we can try this on our matrix<pre>* (solve 64919121     -159018721\n         41869520.5d0 -102558961\n\n         1\n         0\n         #'list)\n\n(1.02558961d8 4.18695205d7)</pre>and we get the wrong answer.</p>\n<p>What's the right answer?<pre>* (solve 64919121         -159018721\n         (+ 41869520 1/2) -102558961\n\n         1\n         0\n         #'list)\n\n(205117922 83739041)</pre>If we use double precision floating point, we get\n  the wrong answer by a considerable margin.</p>\n\n<p>I'm used to floating point calculations being off a little in the least\n  significant digits, and I've seen how the errors can accumulate in an iterative\n  calculation, but here we've lost all the significant digits in a straightforward\n  non-iterative calculation.  Here's what happened:  The determinant of our matrix is\n  computed by subtracting the product of the two diagonals.  One\n  diagonal is <code>(* 64919121 -102558961) =\n  -6658037598793281</code>, where the other diagonal is <code>(* (+\n  41869520 1/2) -159018721) = -6658037598793280.5</code>  This second\n  diagonal product cannot be represented in double precision floating\n  point, so it is rounded down to -6658037598793280.  This is where\n  the error is introduced.  An error of .5 in a quantity of\n  -6658037598793281 is small indeed, but we amplify this error when we\n  subtract out the other diagonal.  We still have an absolute error of\n  .5, but now it occurs within a quantity of 1, which makes it\n  relatively huge.  This is called “catastrophic cancellation”\n  because the subtraction “cancelled” all the significant digits\n(the “catastrophe” is presumably the amplification of the error).</p>\n\n<p>I don't care for the term “catastrophic cancellation”\n  because it places the blame on the operation of subtraction.  But\n  the subtraction did nothing wrong.  The difference betweeen\n  -6658037598793280 and -6658037598793281 is 1 and that is the result\n  we got.  It was the rounding in the prior step that introduced an\n  incorrect value into the calculation.  The subtraction just exposed\n  this and made it obvious.</p>\n\n<p>One could be cynical and reject floating point operations as being too\n  unreliable.  When we used exact rationals, we got the exactly correct result.\n  But rational numbers are much slower than floating point and they have a tendancy\n  to occupy larger and larger amounts of memory as the computation continues.\n  Floating point is fast and efficient, but you have to be careful when you use it.</p>"
}