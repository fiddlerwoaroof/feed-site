{
  "title":"Robots That Write Their Own Code",
  "date":"2022-11-02T16:28:47.110000Z",
  "author":"Google AI",
  "id":"tag:blogger.com,1999:blog-8474926331452026626.post-5096531161675554410",
  "link":"http://ai.googleblog.com/2022/11/robots-that-write-their-own-code.html",
  "content":"<span class=\"byline-author\">Posted by Jacky Liang, Research Intern, and Andy Zeng, Research Scientist, Robotics at Google </span> <!--<img src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEixMObp6xEWLGL7v9THvcTNNRcWm84Zva-aITJP5L4uarQfLwjyurL5kgplTkPM3KG7dlihAAvj9ooaqCWn0Lu1BYVveA_X2aZ_thEQdXgidKc5GEsSc24TCEODiULY2P_frB1M4W0DRL4jv07zdkV4NSMEMjkiPQ8e5hKgoXgx4CiZPuWeg_nJbCSOpg/s1170/CodeAsPolicies.png\" style=\"display: none;\" />--><img src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgJs5xuCtPfu7bzm4c7-5osumFCp5bvKmguRmt_y3fgQbbUoc_37a-ezjjAEH0u1Nb4Am6-zDJi4-z5ZWOn1Io174DEYDNCjYnBQX_2izJloFoO3pbJI7ibYSz2q4_gDMmasq8YFTFdb-4UcObIZykvLviCh3TNIiAw5umN5dRg8V0ZblRQ4ibBvW2gKw/s1229/CodeAsPolicies-2.png\"> <p>A common approach used to control robots is to program them with code to detect objects, sequencing commands to move actuators, and feedback loops to specify how the robot should perform a task. While these programs can be <a href=\"https://homes.cs.washington.edu/~ztatlock/599z-17sp/papers/robot-programming-lozano-perez-83.pdf\">expressive</a>, re-programming policies for each new task can be time consuming, and requires domain expertise.</p><a name=\"more\"></a><p>What if when given instructions from people, robots could autonomously write their own code to interact with the world? It turns out that the latest generation of language models, such as <a href=\"https://ai.googleblog.com/2022/04/pathways-language-model-palm-scaling-to.html\">PaLM</a>, are capable of complex <a href=\"https://ai.googleblog.com/2022/05/language-models-perform-reasoning-via.html\">reasoning</a> and have also been trained on millions of lines of code. Given natural language instructions, current language models are <a href=\"https://dl.acm.org/doi/pdf/10.1145/3520312.3534862\">highly proficient</a> at writing not only <a href=\"https://arxiv.org/pdf/2107.03374.pdf\">generic code</a> but, as weâ€™ve discovered, code that can control robot actions as well. When provided with several example instructions (formatted as comments) paired with corresponding code (via <a href=\"http://ai.stanford.edu/blog/understanding-incontext/\">in-context learning</a>), language models can take in new instructions and autonomously generate new code that re-composes API calls, synthesizes new functions, and expresses feedback loops to assemble new behaviors at runtime. More broadly, this suggests an alternative approach to using machine learning for robots that (i) pursues generalization through modularity and (ii) leverages the abundance of open-source code and data available on the Internet. </p> <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiE55-x4Nq_pV-hdSw8M45MlYZFoyX9Q0nv7b0LgZ5V-0HBiBw-s_SvcIkKJ4tWoVxu0QgmPxO792fsZ0vg6qSU42ps8clbdCHzJoH_3dZRc8dZ9HtF6a1P3kjr0gKGfb581san33sLFuXlsrCYSk2_6l-1UssiePuUZny0LmIEd8WX1if6CShyYcEsHw/s1276/image4.png\"><img border=\"0\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiE55-x4Nq_pV-hdSw8M45MlYZFoyX9Q0nv7b0LgZ5V-0HBiBw-s_SvcIkKJ4tWoVxu0QgmPxO792fsZ0vg6qSU42ps8clbdCHzJoH_3dZRc8dZ9HtF6a1P3kjr0gKGfb581san33sLFuXlsrCYSk2_6l-1UssiePuUZny0LmIEd8WX1if6CShyYcEsHw/s16000/image4.png\"></a></td></tr><tr><td class=\"tr-caption\">Given code for an example task (<b>left</b>), language models can re-compose API calls to assemble new robot behaviors for new tasks (<b>right</b>) that use the same functions but in different ways.</td></tr></tbody></table>  <p>To explore this possibility, we developed <a href=\"https://code-as-policies.github.io/\">Code as Policies</a> (CaP), a robot-centric formulation of language model-generated programs executed on physical systems. CaP extends our <a href=\"https://ai.googleblog.com/2022/08/towards-helpful-robots-grounding.html\">prior work</a>, <a href=\"https://sites.research.google/palm-saycan\">PaLM-SayCan</a>, by enabling language models to complete even more complex robotic tasks with the full expression of general-purpose Python code. With CaP, we propose using language models to directly write robot code through few-shot prompting. Our experiments demonstrate that outputting code led to improved generalization and task performance over directly learning robot tasks and outputting natural language actions. CaP allows a single system to perform a variety of complex and varied robotic tasks without task-specific training. </p>  <br>  <br> <div class=\"separator\">  <video loop=\"\" width=\"70%\"><source src=\"https://code-as-policies.github.io/videos/tasks_2_5.mp4\" type=\"video/mp4\">&lt;source&gt;</video></div><br><table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td class=\"tr-caption\">We demonstrate, across several robot systems, including a robot from <a href=\"https://everydayrobots.com/\">Everyday Robots</a>, that language models can autonomously interpret language instructions to generate and execute CaPs that represent reactive low-level policies (e.g., <a href=\"https://en.wikipedia.org/wiki/PID_controller\">proportional-derivative</a> or <a href=\"https://en.wikipedia.org/wiki/Impedance_control\">impedance controllers</a>) and waypoint-based policies (e.g., <a href=\"https://ai.googleblog.com/2021/02/rearranging-visual-world.html\">vision-based pick and place</a>, <a href=\"https://peract.github.io/\">trajectory-based control</a>).</td></tr></tbody></table>  <div>    <br></div><h2>A Different Way to Think about Robot Generalization</h2><p>To generate code for a new task given natural language instructions, CaP uses a code-writing language model that, when prompted with hints (i.e., import statements that inform which APIs are available) and examples (instruction-to-code pairs that present few-shot &quot;demonstrations&quot; of how instructions should be converted into code), writes new code for new instructions. Central to this approach is <i>hierarchical code generation</i>, which prompts language models to recursively define new functions, accumulate their own libraries over time, and self-architect a dynamic codebase. Hierarchical code generation improves state-of-the-art on both robotics as well as standard code-gen benchmarks in natural language processing (NLP) subfields, with 39.8% <a href=\"https://arxiv.org/abs/2107.03374\">pass@1 on HumanEval</a>, a benchmark of hand-written coding problems used to measure the functional correctness of synthesized programs. </p> <p>Code-writing language models can express a variety of arithmetic operations and feedback loops grounded in language. Pythonic language model programs can use classic logic structures, e.g., sequences, selection (if/else), and loops (for/while), to assemble new behaviors at runtime. They can also use third-party libraries to interpolate points (<a href=\"https://numpy.org/\">NumPy</a>), analyze and generate shapes (<a href=\"https://shapely.readthedocs.io/en/stable/\">Shapely</a>) for spatial-geometric reasoning, etc. These models not only generalize to new instructions, but they can also translate precise values (e.g., velocities) to ambiguous descriptions (&quot;faster&quot; and &quot;to the left&quot;) depending on the context to elicit behavioral commonsense. </p>  <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg55A1wBMlb52PDrG7xhiw3ZwWZvwcjj-p6IR4d9UxKielgLwnqz9Pr0juFl3ZbIkxFr-7v2hku-v8zFJP6pR9G8ZvnWpgUNTiXl5TAxhYawXox-TBFge-G0VxPGuRrzcs-schpa-SnBCa_VM_r3tYC7BYa_MBO6eymXOyKHIigav8WWAxK0yubYo7_OQ/s1616/image3.png\"><img border=\"0\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg55A1wBMlb52PDrG7xhiw3ZwWZvwcjj-p6IR4d9UxKielgLwnqz9Pr0juFl3ZbIkxFr-7v2hku-v8zFJP6pR9G8ZvnWpgUNTiXl5TAxhYawXox-TBFge-G0VxPGuRrzcs-schpa-SnBCa_VM_r3tYC7BYa_MBO6eymXOyKHIigav8WWAxK0yubYo7_OQ/s16000/image3.png\"></a></td></tr><tr><td class=\"tr-caption\">Code as Policies uses code-writing language models to map natural language instructions to robot code to complete tasks. Generated code can call existing perception action APIs, third party libraries, or write new functions at runtime.</td></tr></tbody></table>  <p>CaP generalizes at a specific layer in the robot: interpreting natural language instructions, processing perception outputs (e.g., from off-the-shelf object detectors), and then parameterizing control primitives. This fits into systems with factorized perception and control, and imparts a degree of generalization (acquired from pre-trained language models) without the magnitude of data collection needed for <a href=\"https://ai.googleblog.com/2021/11/decisiveness-in-imitation-learning-for.html\">end-to-end robot learning</a>. CaP also inherits language model capabilities that are unrelated to code writing, such as supporting instructions with non-English languages and emojis. </p> <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh1hSkZCuIOL133ABYTricR_mN2eZfUUTn-N7CtjCqfFZYsRks_si09niSb8cgKmJFXLGzShrI3fxVCT5dtW95zsYAs1hYsIVGB0ged_IenhUx7fB2v20HehSJckAd0_NcLQuq99VYGnNcwt1cv_yDOPPgI1YdGB5KjCVczqQ5rGp7KmM4jHARbAdeUJg/s1096/image5.png\"><img border=\"0\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh1hSkZCuIOL133ABYTricR_mN2eZfUUTn-N7CtjCqfFZYsRks_si09niSb8cgKmJFXLGzShrI3fxVCT5dtW95zsYAs1hYsIVGB0ged_IenhUx7fB2v20HehSJckAd0_NcLQuq99VYGnNcwt1cv_yDOPPgI1YdGB5KjCVczqQ5rGp7KmM4jHARbAdeUJg/s16000/image5.png\"></a></td></tr><tr><td class=\"tr-caption\">CaP inherits the capabilities of language models, such as multilingual and emoji support.</td></tr></tbody></table>  <p>By characterizing the <a href=\"https://arxiv.org/abs/1908.08351\">types of generalization</a> encountered in code generation problems, we can also study how hierarchical code generation improves generalization. For example, &quot;<a href=\"https://arxiv.org/abs/1908.08351\">systematicity</a>&quot; evaluates the ability to recombine known parts to form new sequences, &quot;substitutivity&quot; evaluates robustness to synonymous code snippets, while &quot;productivity&quot; evaluates the ability to write policy code longer than those seen in the examples (e.g., for new long horizon tasks that may require defining and nesting new functions). Our <a href=\"https://arxiv.org/abs/2209.07753\">paper</a> presents a new open-source <a href=\"https://github.com/google-research/google-research/tree/master/code_as_policies\">benchmark</a> to evaluate language models on a set of robotics-related code generation problems. Using this benchmark, we find that, in general, bigger models perform better across most metrics, and that hierarchical code generation improves &quot;productivity&quot; generalization the most. </p>  <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgjdCuJbsXAprg3wz78KiJG9nTC_a1itNEEHgtHP9cdskIrO-WQgpBZ1WHCNTHtHMvYG5p53o1qx5EJsVbVHVdJQGryQPGawiCEGQE4DZET3wWVfXWyhGLLlNPY9gv3R5SOd9dBw2k7NldQShcZ713sZtdaY84c0mulLCbFxq3EoneoG5-_EEOGwdI3EA/s1999/image1.png\"><img border=\"0\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgjdCuJbsXAprg3wz78KiJG9nTC_a1itNEEHgtHP9cdskIrO-WQgpBZ1WHCNTHtHMvYG5p53o1qx5EJsVbVHVdJQGryQPGawiCEGQE4DZET3wWVfXWyhGLLlNPY9gv3R5SOd9dBw2k7NldQShcZ713sZtdaY84c0mulLCbFxq3EoneoG5-_EEOGwdI3EA/s16000/image1.png\"></a></td></tr><tr><td class=\"tr-caption\">Performance on our RoboCodeGen Benchmark across different generalization types. The larger model (<a href=\"https://beta.openai.com/docs/models/davinci\">Davinci</a>) performs better than the smaller model (<a href=\"https://openai.com/blog/openai-codex/\">Cushman</a>), with hierarchical code generation improving productivity the most.</td></tr></tbody></table>  <p>We're also excited about the potential for code-writing models to express cross-embodied plans for robots with different morphologies that perform the same task differently depending on the available APIs (perception action spaces), which is an important aspect of any robotics foundation model. </p> <table align=\"center\" cellpadding=\"0\" cellspacing=\"0\" class=\"tr-caption-container\"><tbody><tr><td><a href=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjGlv5NF0wNHS6vOId8jZsAyGIZgvtYgMtwHeRlfW9KpdlujQhHlyjXrn2ybzuaXd4w1fHj6qxsDnbZegDiGk78oyBeXT3QwJUfUvNEMKhvP9q_lMuTwQvgSsQcJ9cnGzvAKtWHhMH_Q8YXcRzgWV-Dc43CoO9ERw36hBAvLJ8P8DHu8WgSjkEyHFJrTQ/s1716/image2.jpeg\"><img border=\"0\" src=\"https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjGlv5NF0wNHS6vOId8jZsAyGIZgvtYgMtwHeRlfW9KpdlujQhHlyjXrn2ybzuaXd4w1fHj6qxsDnbZegDiGk78oyBeXT3QwJUfUvNEMKhvP9q_lMuTwQvgSsQcJ9cnGzvAKtWHhMH_Q8YXcRzgWV-Dc43CoO9ERw36hBAvLJ8P8DHu8WgSjkEyHFJrTQ/s16000/image2.jpeg\"></a></td></tr><tr><td class=\"tr-caption\">Language model code-generation exhibits cross-embodiment capabilities, completing the same task in different ways depending on the available APIs (that define perception action spaces).</td></tr></tbody></table>   <div>    <br></div><h2>Limitations</h2><p>Code as policies today are restricted by the scope of (i) what the perception APIs can describe (e.g., few visual-language models to date can describe whether a trajectory is &quot;bumpy&quot; or &quot;more C-shaped&quot;), and (ii) which control primitives are available. Only a handful of named primitive parameters can be adjusted without over-saturating the prompts. Our approach also assumes all given instructions are feasible, and we cannot tell if generated code will be useful <em>a priori</em>. CaPs also struggle to interpret instructions that are significantly more complex or operate at a different abstraction level than the few-shot examples provided to the language model prompts. Thus, for example, in the tabletop domain, it would be difficult for our specific instantiation of CaPs to &quot;build a house with the blocks&quot; since there are no examples of building complex 3D structures. These limitations point to avenues for future work, including extending visual language models to describe low-level robot behaviors (e.g., trajectories) or combining CaPs with exploration algorithms that can autonomously add to the set of control primitives. </p><div>    <br></div><h2>Open-Source Release</h2><p>We have released the code needed to reproduce our experiments and an interactive simulated robot demo on the <a href=\"https://code-as-policies.github.io/\">project website</a>, which also contains additional real-world demos with videos and generated code. </p><div>    <br></div><h2>Conclusion </h2><p>Code as policies is a step towards robots that can modify their behaviors and expand their capabilities accordingly. This can be enabling, but the flexibility also raises potential risks since synthesized programs (unless manually checked per runtime) may result in unintended behaviors with physical hardware. We can mitigate these risks with built-in safety checks that bound the control primitives that the system can access, but more work is needed to ensure new combinations of known primitives are equally safe. We welcome broad discussion on how to minimize these risks while maximizing the potential positive impacts towards more general-purpose robots. </p><div>    <br></div><h2>Acknowledgements</h2><p><i>This research was done by Jacky Liang, Wenlong Huang, Fei Xia, Peng Xu, Karol Hausman, Brian Ichter, Pete Florence, Andy Zeng. Special thanks to Vikas Sindhwani, Vincent Vanhoucke for helpful feedback on writing, Chad Boodoo for operations and hardware support. An early <a href=\"https://arxiv.org/abs/2209.07753\">preprint</a> is available on arXiv.</i></p>"
}