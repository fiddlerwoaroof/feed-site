<?xml version="1.0" encoding="UTF-8"?>
<!--Generated by Site-Server v6.0.0-2eca8b484ed5945cc7c967cd0c6ffb14a9b4e65d-1 (http://www.squarespace.com) on Wed, 09 Nov 2022 19:07:50 GMT
--><rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://www.rssboard.org/media-rss" version="2.0"><channel><title>Blog - Saturn Flyer</title><link>https://www.saturnflyer.com/blog/</link><lastBuildDate>Thu, 21 Jul 2022 20:10:20 +0000</lastBuildDate><language>en-US</language><generator>Site-Server v6.0.0-2eca8b484ed5945cc7c967cd0c6ffb14a9b4e65d-1 (http://www.squarespace.com)</generator><description><![CDATA[]]></description><item><title>How to build a Null Object library like Mimic</title><dc:creator>Jim Gay</dc:creator><pubDate>Tue, 30 Jul 2019 15:24:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/how-to-build-null-object-library-like-mimic</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:5d3dbe282657a30001706986</guid><description><![CDATA[Peek inside Mimic to figure out how to build your own Null Object]]></description><content:encoded><![CDATA[<p>If you're not familiar with the Null Object pattern, this will be an eye opener.
Before I jump into Mimic, let's just get on the same page...</p>
<p>I've written about this idea in: <a href="https://www.saturnflyer.com/blog/avoiding-errors-when-forwarding-to-missing-objects">Avoiding errors when forwarding to missing objects</a></p>
<p>BUT you don't need to jump off to read that. Here's a super quick explanation of a problem that could be solved with a Null Object.</p>
<p>You've used a method that returns an array of objects. Let's call ours <code>gimme</code>.</p>
<p>You run <code>gimme</code> and it shoots off to the internet or your database or somewhere and returns a collection of 3 people. Or so you think.</p>
<p>You want to iterate over those people and print out their names so you write some code to do it:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">gimme.each { |person|
  print person.name
}</code></pre>

<p>Unfortunately, when you run your code it blows up. One of those person objects doesn't respond to <code>name</code> and you get an error:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">NoMethodError (undefined method `name' for nil:NilClass)</code></pre>

<p>Ugh. One of those objects was <code>nil</code> and doesn't have a <code>name</code>.</p>
<p>Who knows where the problem is (it is made up after all) but something like a Null Object might make things work better for you.</p>
<p>A Null Object could stand in place of that <code>nil</code> object in your collection. Your solution would be that the Null Object instance would respond to <code>name</code> and return something useful. Perhaps it says "oopsie! this one is nil" or maybe it returns an empty string, or whatever makes sense for your application.</p>
<p>The solution could come in different ways but one might be to change the code to do <code>print PossiblyAPerson(person).name</code> ... or something like that. Wrap the object to make sure that <code>print</code> won't blow up when it tries to output <code>person.name</code>.</p>
<h2 id="enter-mimic">Enter Mimic</h2>
<p>Here's the description from the source code:</p>
<blockquote>
<p>Copy a class's instance interface to an anonymous, new object that acts as a substitutable mimic for the class</p>
</blockquote>
<p>This is telling us that Mimic will create a new object that acts just like another one; exactly what we want from a Null Object.</p>
<p>I wanted to see how it works. So I dived in to the source.</p>
<p>I started reading <a href="https://github.com/eventide-project/mimic/tree/f0ef642d351064f047fd07f1ef97dbb94bff15e6/lib">Mimic source code</a> as of commit <code>f0ef642d351064f047fd07f1ef97dbb94bff15e6</code>.</p>
<p>I first looked at mimic.rb, which was kind of boring.</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">require 'securerandom'

require 'mimic/preserved_methods'
require 'mimic/subject_methods'
require 'mimic/class'
require 'mimic/build'
require 'mimic/void'
require 'mimic/remove_methods'
require 'mimic/void_methods'
require 'mimic/mimic'</code></pre>

<p>It merely requires other files. This means I'll need to go hunting around to find the interesting stuff.</p>
<p>What I did find interesting about this file is that the project's namesake is required last: <code>'mimic/mimic'</code>. This means that it's likely that the <code>Mimic</code> module will be able to safely depend on things required above it.</p>
<p>Regardless, I started reading <code>mimic/preserved_methods.rb</code> and <code>mimic/subject_methods.rb</code> first.</p>
<p>They were not exciting. For example, I don't yet know why this code is relevant or how it's used:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">module Mimic
  def self.preserved_methods
    @preserved ||= (Object.instance_methods &lt;&lt; :method_missing).sort
  end
end</code></pre>

<p>Then I saw this in <code>mimic/subject_methods.rb</code> and at least something looked familiar from the first file I read:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">module Mimic
  def self.subject_methods(cls)
    instance_methods = cls.instance_methods.sort
    instance_methods - Mimic.preserved_methods
  end
end</code></pre>

<p>This one uses <code>Mimic.preserved_methods</code> which was the first one I read. So at least we're beginning to make a connection between the files.</p>
<p>Then I hit some interesting parts in <code>mimic/class.rb</code>.</p>
<p>Feel free to tag along and look at the source yourself but I'm going to break it into parts to figure out what's interesting and what we can learn.</p>
<p>First things first, the top of the file:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">module Mimic
  module Class
    def self.build(subject_class, &amp;blk)
      define_class(subject_class, &amp;blk)
    end</code></pre>

<p>This is a module definition. So it could mean we could <code>include</code> or <code>extend</code> using <code>Mimic::Class</code> elsewhere in this source code or perhaps the project that pulls this library in might do that.</p>
<p>But the first method we see uses <code>def self.build</code> which means we'll really only be using it with <code>Mimic::Class.build</code></p>
<p>It appears to be just a convenient name, however. The <code>build</code> method takes a class and a block and just passes it on to another method.</p>
<p>If you're familiar with the Forwardable library from Ruby's standard library (which I wrote about here in <a href="https://www.saturnflyer.com/blog/ruby-forwardable-deep-dive">Ruby Forwardable deep dive</a>) you'd know that you <em>could</em> also write this same method like this:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">require 'forwardable'
module Mimic
  module Class
    extend SingleForwardable
    single_delegate [:build] =&gt; self</code></pre>

<p>The array of forwarded methods could grow easily without needing to write each method out yourself. That's weird code, though. Forwarding a message to yourself might make you wonder why all that code is there in the first place, and it would just complicate this code.</p>
<p>Conveniently located below <code>build</code> is <code>define_class</code>:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">def self.define_class(subject_class, &amp;blk)
  mimic_class = ::Class.new(subject_class, &amp;blk)
  set_constant(mimic_class, subject_class)
  mimic_class
end</code></pre>

<p>And here's where we get into "metaprogramming"...</p>
<p>That <code>Class.new</code> means we're dealing with metaprogramming. It creates an anonymous class, or in other words a class constant with no name. "Metaprogramming" typically means that the program changes itself when it runs. Sometimes people shorten that and say "code that writes code."</p>
<p>There's not a whole lot to read in this <code>define_class</code> method beyond creating that anonymous class. But it does point us to a <code>set_constant</code> method, so let's look at that and see what we learn.</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">def self.set_constant(mimic_class, subject_class)
  class_id = mimic_class.object_id
  class_name = class_name(subject_class, class_id)

  unless self.const_defined?(class_name, false)
    self.const_set(class_name, mimic_class)
  end

  class_name
end</code></pre>

<p>The interesting things that stand out to me are a method called <code>class_name</code> and then the code checks if a constant is already defined. If it isn't defined the code will set one.</p>
<p>But because there are several references to the value for <code>class_name</code>, we should probably take a look at that:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">def self.class_name(cls, class_id)
      if cls.name.nil?
        return "C#{class_id}"
      else
        return "#{cls.name.gsub('::', '_')}_#{class_id}"
      end
    end
  end
end</code></pre>

<p>This method checks if the received <code>cls</code> has a <code>name</code> that is nil, and returns a value or if it is not nil, substitutes some parts of the string and adds the provided <code>class_id</code>.</p>
<p>When I read code, I often mentally pronounce it. So <code>cls</code> is a bit of a stumbling block for me. How do I pronounce that? That short name could also lack clarity if this were a longer method. If I were to write something similar to this I would likely use <code>klass</code>. We can't use <code>class</code> because that's a keyword in Ruby that would cause the interpreter to expect that it was defining a class. But we're just referencing a class that was passed into this method, so we've got to pick something that's clear and doesn't conflict with a keyword. And at least it doesn't say <code>clazz</code>. Blech.</p>
<p>So why is it checking if a class name is nil? When would that ever happen?</p>
<p>Anonymous classes have no name. Try running this code:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">Class.new.name</code></pre>

<p>The result of that will be <code>nil</code>.</p>
<p>If we jump back up through the methods we'll see that <code>set_constant</code> receives <code>subject_class</code> from where it is called in <code>define_class</code>. <code>Mimic::Class</code> doesn't have control over what objects will be sent to the <code>build</code> or <code>define_class</code> methods so it needs to protect itself against working with <code>nil</code> like the name of an anonymous class.</p>
<p>So the <code>class_name</code> method will return the combination of <code>"C"</code> and the provided <code>class_id</code> argument with something like <code>"C1234"</code>.</p>
<p>If the provided <code>cls</code> object does have a name, this method will return the name where <code>::</code> is replaced with <code>_</code> and the <code>class_id</code> appended to the end; from <code>My::Awesome::Stuff</code> to <code>My_Awesome_Stuff_1234</code>.</p>
<p>Let's jump back to <code>set_constant</code> again.</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">def self.set_constant(mimic_class, subject_class)
  class_id = mimic_class.object_id
  class_name = class_name(subject_class, class_id)

  unless self.const_defined?(class_name, false)
    self.const_set(class_name, mimic_class)
  end

  class_name
end</code></pre>

<p>Everything in Ruby has an <code>object_id</code>. It's a useful way to get a unique identifier for something.</p>
<p>The class passed in as the <code>mimic_class</code> argument is the anonymous class from <code>::Class.new</code> in <code>define_class</code>. </p>
<p>So the <code>class_id</code> will always refer to a new object. There's no worry that we'll generate a <code>class_name</code> that conflicts with an already existing one because each new object will have it's own <code>object_id</code>.</p>
<p>Next, that <code>const_defined?</code> check looks only in the current namespace. By default <code>const_defined?</code> will look for constants with the given name in the current namespace or any ancestor namespace. When you pass a second argument of <code>false</code> to <code>const_defined?</code> it will not search any ancestor namespaces.</p>
<p>Then <code>self.const_set</code> will set the constant for that anonymous <code>mimic_class</code> to the name from <code>class_name</code> in the current <code>Mimic::Class</code> namespace. This means that a generated name like <code>"C1234"</code> will live as <code>Mimic::Class::C1234</code>.</p>
<p>There's one last interesting thing to note about this <code>set_constant</code> method. It returns a string.</p>
<p>If you compare <code>set_constant</code> to <code>const_set</code>, the first returns a string but the latter returns the constant that was set. This could create a point of confusion. I have an early expectation that both of these methods will set constants but what they return may be critical to how I use them in my code. Without knowing the rest of the Mimic code well, it's difficult to say if this is a problem. But it is something to consider when building your own tools like this.</p>
<p>Now that we know how <code>set_constant</code> and <code>class_name</code> work, let's go back again, finally, to <code>define_class</code>.</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">def self.define_class(subject_class, &amp;blk)
  mimic_class = ::Class.new(subject_class, &amp;blk)
  set_constant(mimic_class, subject_class)
  mimic_class
end</code></pre>

<p>We've seen that the <code>mimic_class</code> is created with <code>::Class.new</code> but that <code>::</code> is important to note.</p>
<p>Without that <code>::</code> at the beginning of <code>Class</code>, Ruby would look for the first constant it finds named <code>Class</code> and use that. Unfortunately that would mean <code>Mimic::Class</code> because it would look in the current scope first. And in this case <code>Mimic::Class</code> is a module and not a class so not only would it be the wrong <code>Class</code> constant, but it also wouldn't respond to <code>new</code>.</p>
<p>One way to get around needing that would be to name this current module something else. Perhaps <code>Mimic::ClassBuilder</code> could work since that's what's happening here. Or maybe <code>Mimic::Classes</code> since this is the namespace used for the generated classes. Or maybe one <code>::</code> is just fine to get around figuring out a different name.</p>
<p>These decisions matter and weighing the pros and cons of each decision is an important part of building a useful library that communicates intent and purpose well.</p>
<p>The last bit to note here is that the arguments to <code>Class.new</code> provide a parent class and a place to define methods for the new class.</p>
<p>If Mimic could know the name of the class it needed to build AND the methods that needed to be defined in that block, the code <em>could</em> look like this:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">def self.define_class(subject_class, &amp;blk)
  class TheClassName &lt; subject_class
    def some_method_definition_from_the_block
      # ¯\_(ツ)_/¯
    end
  end
end</code></pre>

<p>Since Mimic has no way of knowing how you'll use it and what constant names it needs to create... metaprogramming to the rescue! Using <code>Class.new</code> with a parent class and a block of code is a fantastic way to build up the code that you need to exist when your program runs.</p>
<p>This is one of the things that makes Ruby so flexible and fun.</p>
<p>But there is a danger. The code we've seen in Mimic does a great job of making sure that constants are created in a way that is easy for you to debug later. Each generated class is given a name that makes sense and can be found in a particular namespace. It's important to think through the impact of the metaprogramming techniques that you use to create a program and what you leave behind to debug.</p>
<p>There's more to Mimic but we've gotten though some important aspects of building a Null Object library.</p>
<p>The only part left, after creating the class that you need, is to define what methods should do when called on a Null Object.</p>
<p>Should they return <code>nil</code>? Should they return an empty string? Should they return a placeholder value or a warning?</p>
<p>When we discussed this problem above we saw <code>PossiblyAPerson(person).name</code> which we could make return <code>"oopsie! this one is nil"</code>.</p>
<p>Here's a <code>NotAPerson</code> class and <code>PossiblyAPerson</code> method that can support this:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">class NotAPerson
  def method_missing(*args)
    return "oopsie! this one is nil"
  end
end
def PossiblyAPerson(object)
  if object.is_a?(Person)
    object
  else
    NotAPerson.new 
  end
end</code></pre>

<p>The problem with that is the <code>NotAPerson</code> object will respond to <em>any</em> method with "oopsie! this one is nil". Even the methods that Person does not implement will have that response.</p>
<p>When we use a Null Object to stand in for another object, we want it to behave as closely as possible to the real thing without breaking our code. But this code has a method interface that allows literally any method to be called on it. And that could be confusing if we need to take a look at it later and debug some problem.</p>
<p>Let's make our own library like Mimic and call it Imitate. We want it to create Null Object classes that will act like the class we give to it.</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">module Imitate
  def self.new(parent_class, &amp;block)
    klass = Class.new(parent_class, &amp;block)
    parent_class.instance_methods(false).each do |name|
      klass.define_method name do
        "oopsie! this one is nil"
      end
    end
    klass
  end
end</code></pre>

<p>This code creates an anonymous class and defines every method from the provided <code>parent_class</code> to return the string we want. And here's how we'd use it:</p>
<pre language="ruby" data-preserve-html-node="true"><code data-preserve-html-node="true">NotAPerson = Imitate.new(Person)

def PossiblyAPerson(object)
  if object.is_a?(Person)
    object
  else
    NotAPerson.new
  end
end</code></pre>

<p>Now we'll have objects that act like a person, but provide our warning message for every method.</p>
<p>Mimic does a lot more than Imitate. And now that we've walked through the structure and simple implementation we can start learning more about how Mimic works.</p>
<p>Look back and compare what Imitate <em>doesn't</em> do that Mimic does. Then dive in deeper to Mimic and learn more.</p>
<p>Understanding metaprogramming and both how <em>and</em> when to use it is critical to being able to build useful tools and solve difficult problems in Ruby. I often encorage everyone to build their own tools or know how to contribute to the ones they already use. That's why I'm building the <a href="https://master-class.saturnflyer.com">Ruby Metaprogramming MasterClass</a> to help developers develop knowledge and experience.</p>]]></content:encoded></item><item><title>Reading Ruby Metaprogramming inside Devise</title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 24 Jul 2019 13:31:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/reading-ruby-metaprogramming-inside-devise</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:5d376e92191f610001b1aa30</guid><description><![CDATA[Learn how to understand metaprogramming starting with what you already 
know.]]></description><content:encoded><![CDATA[<p>It's hard to avoid using Devise in a Rails project. That's mostly because the ease of using it is hard to beat.</p>
<p>Devise is incredibly configurable and that often means having code that can be hard to follow. Providing places in a library for configuration options and hooks for adding features is a difficult job.</p>
<p>But metaprogramming in Ruby can be a flexible way to make a library easy to configure.</p>
<p>Knowing metaprogramming helps you understand tools better, and if you don't know metaprogramming, you  just might feel lost. Iterating over arrays and building up strings with <code>define_method</code> and other things going on requires a lot of mental effort to follow.</p>
<p>The good news is that it's not as difficult to understand as you might expect when first reading it.</p>
<p>So let's dip our toes into the water to get a better understanding of metaprogramming and Devise and start with one of the first things you'll add to your rails project: <code>devise_for :users</code>. We'll see how it builds the helpers that become available to your controllers and views.</p>
<p>We're going to walk through the file in <a href="https://github.com/plataformatec/devise/blob/9aa17eec07719a97385dd40fa05c4029983a1cd5/lib/devise/controllers/url_helpers.rb">lib/devise/controllers/url_helpers.rb</a> as of commit 9aa17eec07719a97385dd40fa05c4029983a1cd5 but later commits are probably similar.</p>
<p>When you add that line to your routes.rb file to generate the routes for your <code>:users</code>, Devise begins generating the code for your controllers.</p>
<p>When I want to understand how something works in a library I'll start searching for the definition of a particular method. In this case I searched the source code for <code>"def devise_for"</code> which brought me to 
<code>lib/devise/rails/routes.rb</code>.</p>
<p>I find the method I want in there and start reading through for anything that refers to "helpers". Unfortunately nothing stands out. But I do see several references to "mapping" and it seems important to this method so maybe I'll find what I need if I follow that.</p>
<p>The first reference to <code>mapping</code> looks like this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">resources.each do |resource|
  mapping = Devise.add_mapping(resource, options)</code></pre>

<p>So we should probably find out what <code>add_mapping</code> does.</p>
<p>My first search fo <code>"def add_mapping"</code> returned nothing. So I looked for just <code>"add_mapping"</code> instead and saw a result listing <code>def self.add_mapping</code>.</p>
<p>Of course, a class method. That's one of the challenges with searching through a Ruby code base. That same method could have been defined as:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class &lt;&lt; self
  def add_mapping</code></pre>

<p>Or even as</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def Devise.add_mapping</code></pre>

<p>And other possibilities as well. But we found it and the <code>"add_mapping"</code> search would have been good enough to find those other options too.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def self.add_mapping(resource, options)
  mapping = Devise::Mapping.new(resource, options)
  @@mappings[mapping.name] = mapping
  @@default_scope ||= mapping.name
  @@helpers.each { |h| h.define_helpers(mapping) }
  mapping
end</code></pre>

<p>There's a <code>Mapping</code> constant referenced in there which looks interesting, but this line is what I'm after:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">@@helpers.each { |h| h.define_helpers(mapping) }</code></pre>

<p>At this point, I'm going to assume that Mapping has some details on it for when we setup routes for <code>:users</code> or whatever else we choose. That's good enough for now and I can search for more detail later if I need it.</p>
<p>So what is <code>@@helpers</code>?</p>
<p>It's defined earlier in the file like this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">mattr_reader :helpers
@@helpers = Set.new
@@helpers &lt;&lt; Devise::Controllers::Helpers</code></pre>

<p>That means that <code>h.define_helpers(mapping)</code> is calling <code>define_helpers</code> on <code>Devise::Controllers::Helpers</code>. So let's go look at that method...</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def self.define_helpers(mapping) #:nodoc:
  mapping = mapping.name

  class_eval &lt;&lt;-METHODS, __FILE__, __LINE__ + 1
    def authenticate_#\{mapping\}!(opts=\{\})
      opts[:scope] = :#\{mapping\}
      warden.authenticate!(opts) if !devise_controller? || opts.delete(:force)
    end
    def #\{mapping\}_signed_in?
      !!current_\{mapping\}#
    end
    def current_\{mapping\}#
      @current_\{mapping\}# ||= warden.authenticate(scope: :#\{mapping\})
    end
    def #_session
      current_#\{mapping\} &amp;&amp; warden.session(:#\{mapping\})
    end
  METHODS

  ActiveSupport.on_load(:action_controller) do
    if respond_to?(:helper_method)
      helper_method "current_#\{mapping\}", "#\{mapping\}_signed_in?", "#\{mapping\}_session"
    end
  end
end</code></pre>

<p>The first part of this is simple. <code>define_helpers</code> receives a <code>mapping</code> object and the local variable <code>mapping</code> is assigned to the <code>mapping.name</code>. A bit confusing, but simple: <code>mapping = mapping.name</code></p>
<p>Then it gets into the metaprogramming.</p>
<p>If you're new to metaprogramming, the next line looks weird:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class_eval &lt;&lt;-METHODS, __FILE__, __LINE__ + 1</code></pre>

<p>All of that can be easily explained but when I am trying to figure out what's going on, I look for things I recognize and go from that. I prefer to skip over what I <strong>don't</strong> understand in favor of starting with something more comfortable.</p>
<p>The bits I recognize are the lines defining methods:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def authenticate_#\{mapping\}!(opts=\{\})

def #\{mapping\}_signed_in?

def current_#\{mapping\}

def #\{mapping\}_session</code></pre>

<p>I'm familiar with string interpolation and this looks exactly like it. Every instance of <code>#\{mapping\}</code> will be replaced with the string representation of <code>:users</code> which we specified in our <code>routes_for</code>.</p>
<p>When the rails app boots up, the methods I need will be created for me. I put <code>routes_for :users</code> in my routes.rb file and I'll get:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def authenticate_user!(opts={})

def user_signed_in?

def current_user

def user_session</code></pre>

<p>Stepping back up we'll see the <code>class_eval</code> call which evaluates a block or string in the context of the current class.</p>
<p>The content between <code>&lt;&lt;-METHODS</code> and <code>METHODS</code> is seen as as a string by Ruby. We call this a "heredoc". So the heredoc builds up what the methods should look like if you typed them out yourself, and then is given to <code>class_eval</code> which will evaluate the string and turn it in to real live Ruby methods.</p>
<p>A heredoc marks the start and end of a string. But as you see in this example, the code immediately after the start of the heredoc isn't really a part of it. <code>class_eval</code> receives the heredoc start, and then a reference to the file being evaluated, and the line number where the evaluation starts.</p>
<p>So <code>__FILE__</code> provides the file name, and <code>__LINE__</code> provides the <strong>current</strong> line. So what's with that <code>+1</code> in there? Well if there's ever an error in your code this helps it report the correct line.</p>
<p>If, for example, an error is raised it the <code>warden.authenticate!(opts)</code> code within the <code>def authenticate_#\{mapping\})</code> definition, you'll want to see the correct line.
That code (as of the commit referenced above) is on line 118. The <code>class_eval</code> line is on line 115 but the code in the heredoc doesn't really begin until the next line, line 116.</p>
<p>So <code>__LINE__</code> will return 115 and the <code>+1</code> just bumps it to 116. An error in the <code>warden.authenticate!</code> line will properly report line 118. If we didn't add 1 to the starting line given to <code>class_eval</code>, we'd get an error reporting on line 117. That would be confusing.</p>
<p>To clarify this, try playing with it yourself. Create a file called <code>class_eval_error.rb</code> and paste this into it:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Tester
  class_eval &lt;&lt;-METHODS, __FILE__, __LINE__+1
    def problem
      raise "oopsie!"
    end
  METHODS
end
Tester.new.problem</code></pre>

<p>Then run <code>ruby class_eval_error.rb</code> in your terminal from the directory where you created the file. If your like me you'll see something like:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true">class_eval_error.rb:4:in `problem': oopsie! (RuntimeError)`</code></pre>

<p>If you remove that <code>+1</code> you'll see the error reported on line 3 instead of 4.</p>
<p>Let's jump back to Devise.</p>
<p>After these methods are creating using <code>class_eval</code> there's a block of code that tells your rails application controller to make some of the generated methods available to your views:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">ActiveSupport.on_load(:action_controller) do
  if respond_to?(:helper_method)
    helper_method "current_#\{mapping\}", "#\{mapping\}_signed_in?", "#\{mapping\}_session"
  end
end</code></pre>

<p>The <code>helper_method</code> method will receive (after string interpolation) three arguments of <code>"current_user"</code>,<code>"user_signed_in?"</code>, and <code>"user_session"</code>.</p>
<p>So that's how the methods are created for your controllers and become available in your views.</p>
<p>If you've read the <a href="http://clean-ruby.com/dsl">Ruby DSL Handbook</a> you may be familiar with some of this. But I'm working on building out a deep dive with the Ruby Metaprogramming MasterClass at <a href="https://master-class.saturnflyer.com/">master-class.saturnflyer.com</a>.</p>
<p>To get more Ruby tips and find out when the MasterClass will be complete, hop on my mailing list at <a href="https://www.saturnflyer.com/subscribe">www.saturnflyer.com/subscribe</a></p>
<p>Stay tuned for more on that in the future. Until then, don't be afraid to dive into the source code to get familiar with how your dependencies work.</p>]]></content:encoded></item><item><title>Fix it now </title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 09 Aug 2017 12:00:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/fix-it-now</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:598af47da803bb87a90611bc</guid><description><![CDATA[<p>By leaving problems in place, we are guaranteeing that we will run into them again.</p>
<p>Many times on many projects I've changed direction. We discover a new technique, new tool, or somehow figure out a better way to do something. The next step is to start using it. But if using that new technique requires that you change a lot of code, when should you do it?</p>
<h2 id="_when_-should-i-fix-this-"><em>When</em> should I fix this?</h2>
<p>I'll tell you a decision we made on one project recently: </p>
<blockquote>
<p>"Let's switch to this new tool as we make other changes. We'll eventually touch every area where the old tool is being used."</p>
</blockquote>
<p>We merrily coded along expecting to improve our project over time. </p>
<p>But that anticipated eventuality never came. Yes, as we moved some code to use a new tool, other areas remained with the old approach.</p>
<p>We later had to take time away from other work to bite the bullet and make all the changes we should have made. We spent more time removing the old way for the new.</p>
<h2 id="so-when-_should_-we-fix-it-">So when <em>should</em> we fix it?</h2>
<p>Postponing changes and improvements can add unexpected costs later.</p>
<p>Right NOW we understand the problem. We have time to understand it AND its solution. In the future we'll have to figure that out again. New problems, new ideas, and new priorities will call for our attention.</p>
<p>Worse, if the team is different in the future, we may lose knowledge of the problem and its solution.</p>
<p>When we only move to a better solution as we touch different areas of code, we leave in the old one, of course. This will lead future developers to wonder why we use one dependency over another.</p>
<p>I've played the <code>git blame</code> game more often than I'd like.</p>
<blockquote>
<p>Why is this here and that there? When did this change happen? Who committed this and what does the message say?</p>
</blockquote>
<p>Researching and removing this confusion is development time wasted.</p>
<p>Although git commit spelunking can reveal good information, it requires purposeful commit messages. If you run into surprises, you'll need to spend time investigating commits. Sometimes laziness wins and commit messages are terse and uninformative.</p>
<p>Sometimes git commits don't have the answers.</p>
<h2 id="can-t-we-_document_-it-">Can't we <em>document</em> it?</h2>
<p>If you can take time to document why code removal <em>should</em> occur, your time might be better spent removing it. If we add documentation for why a change has <em>not</em> been made, will it take as much time as making the desired change?</p>
<h2 id="let-s-add-a-deprecation-warning">Let's add a deprecation warning</h2>
<p>If you're building a library, a piece of an app shared by many, then deprecation might be appropriate. Upgrading to a newer version of a library brings complications. So a kind warning about future changes will help others prepare their own code for the change. Deprecations are great for users of libraries. </p>
<p>When we are writing our own app, we shouldn't deprecate code, we should remove it. We are the users of our own application code.</p>
<p>As James Shore put it on twitter <a href="https://twitter.com/jamesshore/status/888548473196302336">"Do; or do not. There is no //TODO"</a></p>
<h2 id="we-don-t-have-time-let-s-skip-the-tests-">We don't have time. Let's skip the tests.</h2>
<p>Sometimes adjusting our code means changing our tests. Depending on how you wrote your tests, that might be a painful process.</p>
<p>Most test runners provide you a way to <a href="https://github.com/seattlerb/minitest/blob/25f54a0ad675d3d1c239e3bd73d40952a371eada/lib/minitest/assertions.rb#L680">skip</a> or mark tests as <a href="https://github.com/rspec/rspec-core/blob/fc767bef47807008899c24a8fd919236567c9023/lib/rspec/core/pending.rb#L70">pending</a>. The messages you provide yourself and others here can be helpful for the future. Often that future doesn't come as quickly as we intend. </p>
<p>Yes, you can skip tests but that's not very different from deprecations and documentation. Your code still needs rework, and now your tests do too. Skipped tests leave noisy reminders in your test output. Inevitably you learn to ignore the noise.</p>
<p>How long will you ignore the pending test noise until you decide to finally address them. Skipped test are short term good with a long term loss. </p>
<h2 id="now-what-">Now what?</h2>
<p>With problems in many locations, developers will wonder: "how are we going to dig ourselves out of this?" </p>
<p>We want to ship code and create features. Cleaning up often feels boring. There's no excitement in rearranging or fixing up our implementation.</p>
<p>There's no glory in this work.</p>
<p>Clean up feels unproductive because we're not adding a new feature. I have spent many project cycles feeling unproductive. </p>
<p>But I was actually helping my whole team move forward faster. </p>
<p>Without it we get stuck. Spending time finally moving to that library, or finally switching to that new method gives us freedom to focus. </p>
<p>And it's not <em>just</em> freedom to focus for me. Or... for <em>you</em>. It's everyone on your team. Cleanup work removes distractions. Finalizing decisions about what to do with our code <strong>removes unknowns</strong>.</p>
<p>Without cleanup work, the team loses time because these changes need to happen. Without cleanup work, the confusion becomes solidified. Your team multiplies the loss of time and focus created by indecisive implementations. </p>
<p>My "unproductive" project cycles spread improvements for the whole team. There's no glory in this work but, it <em>is</em> a part of shipping. </p>
<h2 id="my-project-is-different-">My project is different...</h2>
<p>Maybe things are different for you. It's not likely but everyone likes to think that their project is <em>really</em> the unique one.</p>
<p>If you're <em>not</em> going to make changes that you should, ask yourself  these questions:</p>
<ul>
<li>can this lead to system going down? </li>
<li>what will developers do when they need to debug and fix it?</li>
<li>how will other developers know which implementation/feature/library to use going forward?</li>
<li>have I left informative commit messages?</li>
</ul>
<h2 id="get-advice-from-others">Get advice from others</h2>
<p>On two separate projects, my teams managed significant changes in two similar ways.</p>
<p>On one team we insisted that at least 3 developers discuss changes. That meant that if you discovered a new way to work, you got opinions and weighed the options looking for different perspectives. This helped us to spread knowledge about decision making. We were able to find alternative scenarios and ensure that  developers played a part in decision making.</p>
<p>On another team with constant pair programming we chose fast meetings. We called a team meeting for everyone to discuss changes with significant impact. Our goal was to have the original pair determine options and explain to the rest of the team. When discussion we went beyond 5 minutes we put a stop to the meeting. We decided to reevaluate our work with new stories or deferred decsisons to the origin pair or team lead.</p>
<p>As a team we agreed to give one person or pair the authority of benevolent dictator. We would all support the decision and move forward. If we needed more discussion, we made plans for it and set the changes aside so we could finish up our work. The next step was to discuss the changes we wanted to make.</p>
<p>These interruptions allowed our teams to communicate about the needs of the project. But the interruptions were designed to be short.</p>
<h2 id="get-advice-from-your-code">Get advice from your code</h2>
<p>You can look to your code and git commits to give you an idea of what areas of your code need your attention.</p>
<p>Use <a href="https://rubygems.org/gems/turbulence">turbulence</a> to check if you're likely to run into this code again.</p>
<p>If your code has a high amount of churn, you're likely to be editing it again. If it's got a high amount of complexity, you might find some bad habits in there that you could fix up.</p>
<h2 id="fix-your-code-now">Fix your code now</h2>
<p>It's easy to find reasons to postpone making changes. It's even easier to skip it and leave a note in the code for later. In my experience, that time to read notes and make changes rarely comes.</p>
<p>Avoiding manual changes is often overvalued. Sometimes the best thing to do is dig in, find all the places that need updating, and make the changes.</p>]]></description></item><item><title>7 ways to evaluate gems, and 1 crazy idea</title><dc:creator>Jim Gay</dc:creator><pubDate>Tue, 13 Jun 2017 14:35:46 +0000</pubDate><link>https://www.saturnflyer.com/blog/7-ways-to-evaluate-gems-and-1-crazy-idea</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:593ff7dde4fcb5c45867a95c</guid><description><![CDATA[<p data-preserve-html-node="true">I remember late nights browsing support forums ready for any answer to help. Writing a post, pleading for help, hitting refresh, and waiting for someone to reply was not efficient. But when that's all you know to do, it <em data-preserve-html-node="true">had</em> to work.</p>

<p data-preserve-html-node="true">Sleepless nights like those are much easier to avoid if you more carefully choose dependencies.</p>

<p data-preserve-html-node="true">When I've got a problem to solve, I often look around to see if someone else has already solved it. I never want to waste my time reinventing the wheel.</p>

<p data-preserve-html-node="true">Ruby has a healthy community. There are so many available gems it's not surprising to find your problem already solved. <a data-preserve-html-node="true" href="https://www.saturnflyer.com/blog/why-write-code-when-more-dependencies-will-do">Dropping a gem into your project is easy.</a> But if you don't understand the impact, you too could be up late begging the internet for help!</p>

<p data-preserve-html-node="true">Over time I developed a few steps of figuring out what to choose.</p>

<p data-preserve-html-node="true">If we're going to depend on one of these gems, we'd better make a good decision. Here are some questions to ask when I find a possible solution for my projects.</p>

<h2 data-preserve-html-node="true">1. How many stars/watchers does it have?</h2>

<p data-preserve-html-node="true">I've often seen this used as a major deciding factor of choosing a new dependency. A large and active community can keep a project healthy. Yes, if many people use it, that means finding help might be easier. But it's foolish to stop there. A collective mind is great guide, but it's no replacement for taking responsibility.</p>

<h2 data-preserve-html-node="true">2. How many active issues or pull requests are there?</h2>

<p data-preserve-html-node="true">Are the project's issues loaded with bug reports or confused developers? Do the maintainers categorize the issues according to how they will be addressed? For any old issues, is there active discussion?</p>

<h2 data-preserve-html-node="true">3. When was the most recent release?</h2>

<p data-preserve-html-node="true">Is the project active? When was the last time the gem was released? Or is the code so simple that regular updates aren't necessary? </p>

<h2 data-preserve-html-node="true">4. How many of its own dependencies does it have?</h2>

<p data-preserve-html-node="true">Are you prepared to pull all these dependencies into your project? What will happen if your project needs a newer version of one of these but this gem prevents it? Or if you need an older version but this requires something newer?</p>

<p data-preserve-html-node="true">The more dependencies a gem has, the more impact these questions will have.</p>

<h2 data-preserve-html-node="true">5. Are the maintainers friendly?</h2>

<p data-preserve-html-node="true">Whether in a bug ticket, a forum post, or anywhere else: do the maintainers act helpful? Can you count on them to help you when you need it?</p>

<p data-preserve-html-node="true">There is the corollary to that: are you helpful? When it comes time to ask for help can you provide steps to reproduce an error?</p>

<h2 data-preserve-html-node="true">6. How many forks with un-merged changes exist?</h2>

<p data-preserve-html-node="true">The GitHub network graph is a great place to find out if a project has a disconnected community. Are there many forks with good updates that the main project has ignored? Will you need to gather commits from those forks to get a feature working?</p>

<h2 data-preserve-html-node="true">7. Does it have documentation?</h2>

<p data-preserve-html-node="true">Is there a clear place to go that gives you example uses? Can you understand what the gem does and how it works from the provided documentation?</p>

<h2 data-preserve-html-node="true">8. The crazy one: Can you understand the code?</h2>

<p data-preserve-html-node="true">When things go wrong, as they inevitably will, have you chosen something you can figure out? Or is this dependency something that will stop in your tracks?</p>

<p data-preserve-html-node="true">I don't actually go through those other steps above until I've first looked at the code.</p>

<p data-preserve-html-node="true">Most often, the <strong data-preserve-html-node="true">first</strong> thing I do is read code.</p>

<p data-preserve-html-node="true">I recall a past project where my pair and I were researching a dependency. I immediately dove into the "lib" directory and he (who preferred other languages to Ruby) said: </p>

<blockquote data-preserve-html-node="true">
  <p data-preserve-html-node="true">Is this what Ruby developers do? Don't you look for documentation?</p>
</blockquote>

<p data-preserve-html-node="true">I don't know about other Ruby developers, but it's absolutely what I do first. If I think a project might be a fit for my problem, I want to see what kind of code will become a part of my application. My pair was a fantastic developer and his question was in good fun. But it made me realize that this code-first approach might be unusual.</p>

<p data-preserve-html-node="true">If it works now but the code is a hot mess, what will my life be like when things don't work?</p>

<p data-preserve-html-node="true">Here's my checklist in the order I do it:</p>

<ol data-preserve-html-node="true">
<li data-preserve-html-node="true">Can you understand the code?</li>
<li data-preserve-html-node="true">Does it have documentation?</li>
<li data-preserve-html-node="true">Are the maintainers friendly?</li>
<li data-preserve-html-node="true">How many of its own dependencies does it have?</li>
<li data-preserve-html-node="true">When was the most recent release?</li>
<li data-preserve-html-node="true">How many forks with un-merged changes exist?</li>
<li data-preserve-html-node="true">How many active issues or pull requests are there?</li>
</ol>

<p data-preserve-html-node="true">That's it. I always start with reading the code. The order of the rest of them may change here and there but that's typical. I may have to make concessions with one because the answer to another is compelling.</p>

<p data-preserve-html-node="true">You may notice that I left one out...</p>

<p data-preserve-html-node="true">I don't care how many stars or watchers a project has. If I can't answer the above questions with satisfaction, watchers means nothing. And if I am satisfied with the answers, watchers means nothing.</p>

<p data-preserve-html-node="true">When you bring in a dependency, you own it; you must be able to figure it out. </p>

<p data-preserve-html-node="true">If you're an experienced developer you may think differently about answering these questions. But one reason I look to the code first is that junior developers will need to be able to do it too.</p>

<p data-preserve-html-node="true">You may find that no existing tool does exactly what you want and you might then build your own. But if you cannot evaluate the code well, how would you know if you should build your own? </p>

<p data-preserve-html-node="true">What do <em data-preserve-html-node="true">you</em> do? Write a blog post about it and share your experience.</p>

<p data-preserve-html-node="true">Get in touch with me <a data-preserve-html-node="true" href="https://www.saturnflyer.com/work-with-me/">to help you evaluate your projects</a>.</p>]]></description></item><item><title>Why write code when more dependencies will do?</title><dc:creator>Jim Gay</dc:creator><pubDate>Tue, 30 May 2017 13:29:57 +0000</pubDate><link>https://www.saturnflyer.com/blog/why-write-code-when-more-dependencies-will-do</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:592d72dce4fcb57df0c2a684</guid><description><![CDATA[<p>What do you do when you need your code to work in different environments?</p>
<p>New versions of Ruby or important gems are released and we begin to consider how to switch between them. If your code needs to work in old as well as current versions of Ruby, how do you approach it? Or how do you handle changes in Rails for that matter?</p>
<p>Surely, there's a gem out there that would solve your problem for you...</p>
<h2 id="balancing-the-need-for-new-features">Balancing the need for new features</h2>
<p>A few years ago I was working on a project and was looking for a way to make <a href="https://github.com/saturnflyer/casting">Casting</a> work in versions of Ruby 1.9 and 2.0. I had to write code that would determine what <em>could</em> be done and ensure it would behave.</p>
<p>When Ruby 2.0 was released, it allowed methods defined on a Module to be bound to any object and called:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module Greeter
  def hello
    "Hello, I'm #{@name}"
  end
end

class Person
  def initialize(name)
    @name = name
  end
end

jim = Person.new('Jim')
Greeter.instance_method(:hello).bind(jim).call # =&gt; "Hello, I'm Jim"</code></pre>

<p>This was an exciting new feature. I had been working through new ways to structure behavior in my applications. My book, <a href="http://clean-ruby.com">Clean Ruby</a>, was in development. A version of Ruby came with a new feature but I couldn't yet use it in my current application environments with Ruby 1.9. This change gave me ideas about <a href="https://www.saturnflyer.com/blog/2017/5/17/what-if-we-organized-code-by-features">organizing code by application feature</a>.</p>
<p>The desire to use new features is strong. The problem is that upgrading your projects to new versions isn't always easy. Your infrastructure might require updates, your tests should be run and adjusted, dependencies should be checked for compatibility, and you might need to update or remove code.</p>
<p>Running Ruby 1.9 meant binding module methods wouldn't work. It was a challenge to get Casting to work in my current environment.</p>
<h2 id="bridging-the-platform-gap">Bridging the platform gap</h2>
<p>Giving objects new behavior often means you must include the module in the object's class. Or you may include it in the object's <code>singleton_class</code> using <code>extend</code>.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Person
  include Greeter
end

# or extend the instance:

jim = Person.new('Jim')
jim.extend(Greeter)

jim.hello # =&gt; "Hello, I'm Jim"</code></pre>

<p>There was a trick to get module method binding to work. You can clone an object, <code>extend</code> clone, and grab the unbound method for your original object.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">object.clone.extend(Greeter).method(:hello).bind(:object).call</code></pre>

<p>It was definitely a hack and certainly an unintended behavior of Ruby 1.9. But I wanted to use Casting in any Ruby version so I needed to be strategic about how to handle the differences.</p>
<p>One way to check your Ruby version is to look at the <code>RUBY_VERSION</code> constant and compare numbers. I quickly ruled that out. Checking that version value in JRuby, Rubinius, or some other implementation, might not be good enough. Alternative rubies have their own quirks. Since method binding isn't intended behavior in MRI, it's likely that things wouldn't work the way the code expected. Not every Ruby implementation is the same. <code>RUBY_VERSION</code> wouldn't be a reliable predictor of behavior.</p>
<p>I came across <a href="https://github.com/brixen/redcard">Redcard</a> which says in its README:</p>
<blockquote>
<p>RedCard provides a standard way to ensure that the running Ruby implementation matches the desired language version, implementation, and implementation version.</p>
</blockquote>
<p><em>That</em> seemed to be exactly what I wanted. Relying on an open source project can help you unload work required. Other users of the same project will want to fix bugs and add features. A collaborative and active community can be a great asset.</p>
<p>So I dove in and began placing <code>if RedCard.check '2.0'</code> and similar code wherever necessary</p>
<h2 id="build-around-behavior-not-versions">Build around behavior, not versions</h2>
<p>Once it was in, I still didn't feel quite right about adding this dependency.</p>
<p>Third-party code brings along it's own dependencies. Third party-code can add rigidity to your own by reducing your ability to adjust to changes. You're not in charge of the release schedule of third-party code, unlike your own.</p>
<p>I soon realized that I didn't actually care about versions at all. What I cared about was behavior.</p>
<p>I had added a third-party dependency for a single feature. Although RedCard can do more, I didn't need any of those other features. Adding this dependency for one behavior was easy but it exposed the project to more third-party code than I wanted.</p>
<p>It was much easier to check for the behavior I wanted, and store the result. Here's how I tackled that in early versions of Casting (before I dropped Ruby 1.9 support).</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby"># Some features are only available in versions of Ruby
# where this method is true
def module_method_rebinding?
  return @__module_method_rebinding__ if defined?(@__module_method_rebinding__)
  sample_method = Enumerable.instance_method(:to_a)
  @__module_method_rebinding__ = begin
    !!sample_method.bind(Object.new)
  rescue TypeError
    false
  end
end</code></pre>

<p>My solution was binding a method to an arbitrary object, catching any failure, and memoizing the result. If it worked my <code>module_method_rebinding?</code> method would return true without running the test again. If the result was false, then this method would always return false.</p>
<p>The beauty of this solution was that it removed a dependency. It relied on the natural behavior of Ruby: to raise an exception.</p>
<p>Removing the gem makes all the problems of having third-party code go away.</p>
<h2 id="preparing-for-the-future">Preparing for the future</h2>
<p>Adding dependecies to your code can make you more productive. Adding dependencies can also reduce flexibility in responding to the needs of your code. A new dependency might prevent you from upgrading aspects of your system due to compatibility problems.</p>
<p><a href="https://github.com/AaronLasseigne/polyfill">Polyfill</a>, a project I recently came across, reminded me of this. The polyfill project says:</p>
<blockquote>
<p>Polyfill implements newer Ruby features into older versions.</p>
</blockquote>
<p>It might make sense to implement new features in your current environment rather than upgrading. Polyfill is important because it helps us avoid checking for behavior completely and instead implements it. When you're unable to upgrade your Ruby environment, you might pull in a project like polyfill.</p>
<p>Polyfill uses refinements so you can isolate new features without affecting other areas of your code.</p>
<p>Polyfill attempts to get your environment working like a newer version of Ruby. ActiveSupport adds its own features to Ruby core classes, but polyfill adds features which exist by default. This allows you to write your code in a manner consistent with upcoming upgrades to Ruby. Writing code with new versions of Ruby in mind will prepare you to drop the polyfill dependency.</p>
<h2 id="prepare-for-the-future-by-implementing-your-own">Prepare for the future by implementing your own</h2>
<p>My current project had a need to truncate a Float. In Ruby 2.4 the <code>floor</code> method accepts an argument to limit the number of digits beyond the decimal. In our current environment with Ruby 2.3.x, the <code>floor</code> method doesn't accept any arguments.</p>
<p>Instead of pulling in polyfill for a new feature, our solution was to do the math required to truncate it. Although using <code>(3.14159265359).floor(2)</code> would be convenient, we can't yet justify a new dependency on polyfill, and we can implement this method on our own.</p>
<p>Handling versions and behavior limitations takes balance. Whether you are building gems or building applications, it's important to consider the larger impact of upgrading systems or installing new dependencies.</p>
<p>I'll be keeping my eyes on new features in Ruby and polyfill. If I'm unable to use either immediately, I'll at least be able to steal some good ideas.</p>]]></description></item><item><title>What if we organized code by features?</title><dc:creator>Jim Gay</dc:creator><pubDate>Thu, 18 May 2017 13:00:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/what-if-we-organized-code-by-features</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:591c6e6fb8a79b2d5ede0259</guid><description><![CDATA[<p>I began asking myself this question when I was working on a large Rails project. Requirements changed fairly often and we needed to react quickly.</p>
<p>When trying to figure out how something could change, I had to backtrack through how it already works. This often meant tracing method calls through several different files and classes. A collection of methods and collaborators can be difficult to keep in your head.</p>
<p>Too many times, it was easier to search for the person on the team who implemented the original code to figure out how best to change it. Figuring out how it was all put together can be a distraction. I went from "let's make changes" to "how does this work?"</p>
<p>If we organized our implementation by what we look for when we change features rather than by the related class, could eliminate distraction? What if someone wanted to make a change to a feature, and I was able to pull up the code that represented that feature? Then I'd be able to feel confident that I could look in as few places as possible to get what I need.</p>
<p>I began experimenting with how Ruby could help me stay focused quite a lot. One of the results is <a href="https://github.com/saturnflyer/casting">Casting</a>. Casting is a gem that allows you to apply behavior to an initialized object and to organize behavior around your features.</p>
<p>With Casting I could take the implementation details of an algorithm (the work to be done) out of individual classes of collaborating objects and move it into a centralized location. Rather than having 4 or 5 classes of things each contain a different part of the puzzle, I could put the puzzle together and have it ready for future changes.</p>
<p>Rather than each class knowing a lot about how a feature is put together, the classes could be small and focused on representing their data. A feature could grow or shrink within the context of every object it needed.</p>
<p>It's a bit different from other approaches where you wrap an object in another one to provide additional behavior, however.</p>
<p>Here's a simple example of what this means.</p>
<h2 id="applying-new-behavior">Applying new behavior</h2>
<p>Rather than putting code in multiple different places, or putting code in a class merely because that type of object needed it <em>at some point</em>, we could put it into a a fetaure class.</p>
<p>Let's take a collection of objects and start up a game:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Game
  def initialize(*players)
    @players = players
    # randomly select a leader
    @leader = players.sample
  end
end</code></pre>

<p>This <code>Game</code> class expects to receive a collection of objects, one is selected as a leader and then what?</p>
<p>Well, if I put together the features for what the players and leader can do, or if I want to read and understand what they can do later so that I can make changes, I'll look first to the Game itself to understand.</p>
<p>I can put all the behavior I need inside this class. It makes a lot of sense to me to keep it there because it will be behavior specific to this feature. The Game won't exist without the behavior and the behavior won't exist without the Game.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Game
  def initialize(*players)
    @players = players
    # randomly select a leader
    @leader = players.sample
  end

  module Player
    def build_fortress; end
    def plant_crops; end
  end

  module Leader
    def assemble_team; end
    def negotiate_trade; end
  end
end</code></pre>

<p>When the game is initialized with the <code>players</code>, we can make those players become what we need.</p>
<p>Using Casting, we can allow the objects to have access to new behaviors by including <code>Casting::Client</code> and telling them to look for missing methods in their collection of behaviors.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Account
  include Casting::Client
  delegate_missing_methods
end</code></pre>

<p>With that change, any <code>Account</code> object (or whatever class you use) will keep a collection of delegates. In other words, these objects will keep track of the roles they play in a given context and have access to the behaviors for those roles. The object will receive a message and first run through its own methods before looking at its behaviors for a matching method.</p>
<p>The next step is to assign the roles:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Game
  def initialize(*players)
    @players = players.map{|player| player.cast_as(Player) }
    # randomly select a leader
    @leader = players.sample.cast_as(Leader)
  end
end</code></pre>

<p>Now each of these objects will have access to the behavior of the assigned modules.</p>
<p>The <code>@leader</code> has both <code>Player</code> behavior as well as <code>Leader</code>.</p>
<p>Later, if we decide to add a <code>Guard</code> role to our game or some other job for a player, any player may gain that behavior at any point we determine.</p>
<p>Adding Casting to my projects allows me to work with objects and apply their behaviors where I plan for them to be used. Then I am able to look for my implementation where the feature is defined and I'm not distracted searching through multiple files and classes to piece together my understand of how it all works.</p>
<h2 id="why-not-just-use-">Why not just use...</h2>
<p>You might argue that you could simply create a wrapper using something like SimpleDelegator.</p>
<p>When using wrappers, we create new objects that maintain a reference to the original. We take those 2 objects and treat them as one.</p>
<p>Doing so might change our Game initializer like this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Game
  def initialize(*players)
    @players = players.map{|player| Player.new(player) }
    # randomly select a leader
    @leader = Leader.new(players.sample)
  end
end</code></pre>

<p>One of the downsides of this is that we are working with a new set of objects. The <code>self</code> inside that <code>Leader.new</code> isn't the same object as <code>players.sample</code>. Any process which would need to search for an object in the collection of players might attempt to compare them for equality and get an unexpected result.</p>
<p>To reduce our mental stress as best we can, we want only the information which is <em>neccessary</em> to understand our system. With an additional layer wrapping our objects we could be making it more difficult to understand.</p>
<p>Here's a small example of how wrapper objects like this can lie to us:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Account; end
require 'delegate'
class Player &lt; SimpleDelegator; end

account = Account.new
player = Player.new(account)

account == player # =&gt; false
player == account # =&gt; true

account.object_id # =&gt; 70340130700420
player.object_id  # =&gt; 70340122853880</code></pre>

<p>The result of these 2 comparisons are not the same even though we would expect them to be. The <code>player</code> object just forwards the <code>==</code> message to the wrapped object; whereas the <code>account</code> object will do a direct comparison with the provided object in the <code>==</code> method.</p>
<p>This complicates how we may interact with the objects and we must be careful to perform things in the right order.</p>
<p>If the object merely gains new behavior and remains itself, the outcome will give us relief:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">require 'casting'
class Account
  include Casting::Client
  delegate_missing_methods
end
module Player; end

account = Account.new
player = account.cast_as(Player)

account == player # =&gt; true
player == account # =&gt; true

account.object_id # =&gt; 70099874674300
player.object_id  # =&gt; 70099874674300</code></pre>

<p>Here we can see that the <code>account</code> and the <code>player</code> are definitely the same object. No surprises.</p>
<p>Wrapping up my objects is easy but I've spent my fair share of time tracking down bugs from the wrappers behaving differently than I expected. Time spent tracking down bugs is a distraction from building what I need.</p>
<p>Wrapping my objects in additional layers can affect my program in unexpected ways, interrupting my work. Although the code with wrappers is easy to read, it subtly hides the fact that the objects I care about are buried beneath the surface of the objects I interact with. By keeping my objects what they are and applying behavior with modules, I ensure that I can stay focused on the feature.</p>
<p>Our code is a communication tool about our expectations of how a program should execute. The better we focus on the actual objects of concern and avoid layers, the easier it will be to avoid unintentional behavior.</p>
<p>This is why I'm glad to have a tool like Casting to help me build systems that limit unnecessary layers.</p>
<h2 id="creating-the-shortest-path-to-understanding">Creating the shortest path to understanding</h2>
<p>When I began building and working with Casting, it allowed me to flatten the mental model I had of my programs.</p>
<p>It's easy for a programmer to see <a href="http://www.justinweiss.com/articles/a-decorator-vs-a-subclass/">a wrapper style implementation or subclass and understand the consequences</a>. Unfortunately that extra layer can and does lead to surprises that cost us time and stress.</p>
<p>I do still use tools <a href="https://www.saturnflyer.com/blog/ruby-delegate-rb-secrets">like SimpleDelegator</a>, but I often look to ways to make my programs better reflect the mental model of the end user. Sometimes SimpleDelegator-like tools work well, other times they don't.</p>
<p>If the ideas in my mind are closer to those in the user's mind, I'm much more likely to a program that communicates what it is and what it does more accurately.</p>
<p>Developers who work together need to communicate effectively to build the right thing. Our code can help or hinder our communication. Sometimes, when we want an object to gain new behavior, we introduce tools like SimpleDelegator and in doing so, we add layers to the program and more to understand.</p>
<p>Casting, although it too needs to be understood, provides us the ability to add behavior to an object without additional layers which might introduce distraction.</p>
<p>Attempting to meet requirements and build a product well, means we need to consider how our code reflects the shared understanding of what it should do.</p>
<p>When requirements change, and they often do, we'll look to our code to understand the features. The faster we can find and understand our features, the faster and more confidently we will be able to react to changing requirements.</p>
<p>When I needed to react to changing requirements and couldn't easily find all the pieces of the feature, it wasn't a confidence inspiring result for my other team members. Everyone should be able to find and understand how a feature works.</p>
<h2 id="where-to-look-and-where-to-understand">Where to look and where to understand</h2>
<p>By placing code in every class related to a feature, I gave myself many different places to look to build up my understanding of how it worked. I treated individual data classes as the only place to look for behavior, rather than creating the world I need with a feature class.</p>
<p>Organizing by class vs. feature makes me think about my product differently.</p>
<p>When I think about features, I remain focused on the goals of the end user. Each user of the system is only using it to achieve a specific purpose. Often we can become distracted by our code and forget the goals of the end user. Building up features is a continual reminder of the reason that code needs to be written and updated.</p>
<p>Thinking about the end user will help us implement only what is necessary for her or him to complete their work. We may better avoid getting tripped up my technical concerns.</p>
<p>When we add behavior in our data classes, it often ends up including behavior from many unrelated features.</p>
<p>Think about what you have in your classes and what they should or could be.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Account
  def build_fortress; end
  def plant_crops; end

  def assemble_team; end
  def negotiate_trade; end

  def renew; end
  def cancel; end
  def update_payment_info; end

  def send_friend_request; end
  def upload_photo; end

  # etcetera...
end</code></pre>

<p>With the above <code>Account</code> class there are many behaviors for vastly different concerns. If we were to move those behaviors into an object that represented the feature where the behaviors were required the class would be freed to better describe the data it represents.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Account
end</code></pre>

<h2 id="defending-my-focus">Defending my focus</h2>
<p>Being able to focus on my immediate problem drives me to think about how I want to structure my code. When I write code, I know that the next person to read it and change it may not be me. Maintaining my own mental model isn't good enough when solving a problem; programmers need to create code that helps someone else pick up the same mental model.</p>
<p>Sometimes adding layers to your code can help separate parts that <em>should</em> be separate. Sometimes adding layers means introducing distraction and distraction leads to bugs and lost time.</p>
<p>These ideas lead me to build <a href="https://github.com/saturnflyer/casting">Casting</a> and write about Object-oriented design in <a href="http://clean-ruby.com">Clean Ruby</a>.</p>
<p>Take a look at your application's features and ask yourself if you could organize differently. Can you remove distractions? Could Casting help you build cohesive features?</p>]]></description></item><item><title>Four tips to prepare yourself to build software</title><dc:creator>Jim Gay</dc:creator><pubDate>Tue, 11 Apr 2017 16:33:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/four-tips-to-prepare-yourself-to-build-software</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:58f4c620bebafbe00b6f9f7b</guid><description><![CDATA[<p> A few of my articles have caught some attention or challenged ideas and I thought you might like to read them.</p>
<p>Take a read through these articles and let me know what you think about object modeling and understanding and building your tools.</p>
<p><a href="https://www.saturnflyer.com/blog/ruby-forwardable-deep-dive">Ruby Forwardable Deep Dive</a></p>
<p>  Developers and teams that understand their tools will be better able to choose the right ones. They'll make better decisions about when to avoid existing tools and when to build their own.</p>
<p>  Take a deep dive into Ruby's standard library Forwardable. Use this article to get to know how it's built and how it works. Take lessons from the code and use them to decide when and where to use it or write your own. Alternatively, another good library to know is 'delegate' and <a href="https://www.saturnflyer.com/blog/ruby-delegate-rb-secrets">I dove deep</a> into that one too.</p>
<p><a href="https://www.saturnflyer.com/blog/enforcing-encapsulation-with-east-oriented-code">Enforcing Encapsulation with East-Oriented Code</a></p>
<p>  Responsibilities can explode in our programs without us ever realizing exactly how it happens. Before we know it, we've got a mess of interconnected objects that know too much about each other. With an approach called East-oriented Code (coined by James Ladd), we can create objects which enforce their responsibilities and make sure that you tell, don't ask. If you're interested in seeing more about it, check out <a href="https://www.youtube.com/watch?v=kXcrClJcfm8">my presentation from RubyConf</a> and of course I wrote something for functional programming and immutable data afficionados: <a href="https://www.saturnflyer.com/blog/commanding-objects-toward-immutability">Commanding Objects Toward Immutability</a></p>
<p><a href="https://www.saturnflyer.com/blog/working-later-bridging-your-code-with-the-background">How I fixed my biggest mistake with implementing background jobs</a></p>
<p>Distractions are an enormous problem for every software developer. This article doesn't solve all of them but it (and the others in the series that follow) shows one way to keep me focused on the problem at hand.</p>
<p>Walk through building a tool to remove distractions from your code. I pull from my own projects to show how I try to make a short a step as possible from deciding when to run code in the background.</p>
<p><a href="https://www.saturnflyer.com/blog/the-gang-of-four-is-wrong-and-you-dont-understand-delegation">The Gang of Four is wrong and you don't understand delegation</a></p>
<p>When I began researching earnestly for <a href="http://clean-ruby.com">Clean Ruby</a> I regularly came across references to Object-oriented programming about "delegation." What I found is that we tend to use this term to mean something entirely different than what it is.</p>
<p>Misunderstandings lead to frustration and bugs.</p>
<p>To make sure I understood it correctly, I spoke with Henry Lieberman creator of Self, a language which created the delegation concept. I followed it up with more research and contacted object modeling pioneer Lynn Andrea Stein who wrote that "Delegation is Inheritance" when I then wrote <a href="https://www.saturnflyer.com/blog/delegation-is-everything-and-inheritance-does-not-exist">Delegation is Everything and Inheritance Does Not Exist</a></p>]]></description></item><item><title>Building tools and building teams</title><dc:creator>Jim Gay</dc:creator><pubDate>Tue, 21 Mar 2017 13:56:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/building-tools-and-building-teams</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:58f4c93b29687fd0db80bd09</guid><description><![CDATA[<p>My series of articles has been an exploration of how we grow small solutions into larger tools. Sometimes we discover new information or rethink our approach and need to change direction.</p>
<p>Each article had it's own problem to solve and built upon the ideas and solutions of the last:</p>
<ul>
<li><a href="https://www.saturnflyer.com/blog/working-later-bridging-your-code-with-the-background">How I fixed my biggest mistake implementing background jobs</a></li>
<li><a href="https://www.saturnflyer.com/blog/turning-a-specific-solution-into-a-general-tool">Turning a specific solution into general a tool</a></li>
<li><a href="https://www.saturnflyer.com/blog/building-a-tool-thats-easy-for-your-team-to-use">Building a tool that's easy for your team to use</a></li>
<li><a href="https://www.saturnflyer.com/blog/from-implicit-magic-to-explicit-code">From implicit magic to explicit code</a></li>
</ul>
<p>I was talking to my friend <a href="https://betonyourself.com">Suzan</a> about this series and she asked me <em>"What is this about? What's the common thread?"</em></p>
<p>I had to think about it for a minute. This isn't <em>really</em> about background jobs.</p>
<p>It's about removing distractions.</p>
<h2 id="maintaining-focus-means-removing-distractions">Maintaining focus means removing distractions</h2>
<p>When developers need to make decisions when building software, we need to decide what matters and what doesn't.</p>
<p>My main goal in the code we've been writing has been to create the ability to make decisions quickly.</p>
<p>We turned this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">process.call</code></pre>

<p>into this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">process.later(:call)</code></pre>

<p>and we were able to focus on the code we care about.</p>
<p>What matters here is what we <em>don't</em> need to do.</p>
<p>We don't need to rethink our code structure.
We don't need to move code into a new background class.</p>
<p>As I wrote in the first article about building my background library:</p>
<blockquote>
<p>If my main purpose in the code is to initialize <code>SomeProcess</code> and use the <code>call</code> method. The only decision I need to make is to either run it immediately, or run it later.</p>
</blockquote>
<p>If my first instinct were to change a line of code to another type of implementation, another class for the background, another layer to fiddle with, I would pull every future reader of that code away from the purpose and toward that new thing.</p>
<p>When I or any future developer look at the code, I want them to read it and understand quickly. Adding in a <code>later</code> method is a device to let the reader know when something will occur without pulling them away to understand its implementation.</p>
<p>This decision to implement a <code>later</code> function is a compression of the idea of the background job. The words we choose should be good indicators of what to expect.</p>
<h2 id="when-we-share-our-understanding-we-are-free-to-be-expressive">When we share our understanding, we are free to be expressive</h2>
<p>Our software can help or hinder communication.</p>
<p>Knowing which it does will help us build better software.</p>
<p>When a team member reads what we've written, will they understand the words we've chosen as a compression of our ideas into more managable forms?</p>
<p>Do we express our solutions like poetry and provide greater meaning with each word? Or do we attempt to express in strict terms the absolute definition and possible interpretations?</p>
<p>I find that my approach changes often.</p>
<p>Sometimes I want things to be absolutely explicit. I want bondaries and clear expression of all requirements leaving no uncertain terms about what needs to be done.</p>
<p>Other times I want a single word to be placed to give new meaning. I want others to read once and understand larger implications without great effort of digging into documentation and implementation details.</p>
<p>To make truly successful code, I need to share my goals and express my intent with others who will interact with it in the future.</p>
<h2 id="learn-and-do-by-focusing-on-what-matters">Learn and do by focusing on what matters</h2>
<p>When I began writing this series, I was focused on what really mattered to me: decisions and implementations getting in the way.</p>
<p>When I discover that some bit of code is taking too long to run, I want to get that code running well. That may mean rewriting it. Or that may mean diving into optimization techninques.</p>
<p>One simple technique to optimize it is to just run it in a separate process. As long as that's a valid solution, I want it to be as easy as possible. I just want to say <code>later</code> and be done.</p>
<p>Here's what I've learned:</p>
<p>Although I've written a library like ProcessLater three times now on several projects, I'm less interested in exactly how it was implemented previously and more interested in getting distractions out of the way.</p>
<p>That's it's whole purpose.</p>
<p>As I wrote each article explaining what I would do and why, I found I'd run into scenarios where the code just didn't quite work right.</p>
<p>I had to fiddle to get some of my argument setup to work properly. I'd forget to add a splat (<code>*</code>) to my argument name and be confused and a little bit worried that my entire article about why this is a good idea was just derailed and wasn't working at all.</p>
<p>Developing a library isn't a straight path. I inevitably need to stop and reconsider new information. But each stopping point is an opportunity to refocus on my goals and make sure I'm not getting caught up in technical trouble.</p>
<p>I ask myself if I'm achieving my goal and if there's a better way. Am I able to remove distractions or am I creating more?</p>
<p>With each team where I've approached solving this problem, my focus has been to talk about the code and what I <em>want</em> to do:</p>
<p>"If all I need to do is run it in the background, then I just want to type this..."</p>
<p>By having a conversation with others, I can express my desire to make my and their lives simpler. We all had a shared understanding of putting a process into the background, and we all had a desire to remove distractions.</p>
<p>In the end, the conversations we have tend to be focused on:</p>
<ol>
<li>Whether or not we've chosen the right words to express the idea</li>
<li>"What if it worked this way..."</li>
</ol>
<p>These conversations always lead to either better code, or a better shared understanding. We all learn new things.</p>
<p><strong>Here's what I hope you've learned...</strong></p>
<p>I hope that you take lessons from what you've built and turn around to provide a better experience for the others on your team.</p>
<p>I hope that you've looked at what code you've written and how you've done it, and have thought about how expressive the words are. How will others understand it? How will they want to use it to something the same or similar?</p>
<p>Lastly, I want to point you to this <a href="http://www5.tdwi.org/TDWI/TDWI-Upside/Articles/2017/03/07/Technological-Breakthroughs-and-Trusting-Your-Team.aspx">interview with Russ Olsen</a></p>
<p>Olsen reminds us to consider our emotions and ambitions:</p>
<blockquote>
<p>"Technical people want to focus on technical issues: is this a good programming language, how fast will this workload run on that platform, [etc.] Fundamentally, a lot of what stands between us and what we want to do are human problems: issues of motivation, working together, how people cooperate," Olsen argues. When it comes to working together effectively, particularly in complex endeavors, human emotions and ambitions can complicate things -- even among geeks.</p>
</blockquote>
<p>Building software is complicated. Building software with a team can be even more complicated, but with good communication and forethought, we can build even better tools together than we can alone.</p>
<p>Stay focused on your goals and reach out for new ideas and different perspectives from your team members. Start a new conversation with your team, hit reply, or reach out about <a href="https://www.saturnflyer.com/work-with-me/">working together with me</a>.</p>]]></description></item><item><title>From implicit magic to explicit code</title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 08 Mar 2017 14:57:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/from-implicit-magic-to-explicit-code</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:58c01bed86e6c0b34100bf50</guid><description><![CDATA[<p>In this series we've built a tool to help us <a href="https://www.saturnflyer.com/blog/working-later-bridging-your-code-with-the-background">move processing into the background</a> and <a href="https://www.saturnflyer.com/blog/turning-a-specific-solution-into-a-general-tool">made it flexible enough to easily use in more that one situation</a> and <a href="https://www.saturnflyer.com/blog/building-a-tool-thats-easy-for-your-team-to-use">made sure it was easy to use without forgetting something important</a>.</p>
<p>If you haven't read through the series yet, start with <a href="https://www.saturnflyer.com/blog/working-later-bridging-your-code-with-the-background">"How I fixed my biggest mistake with implementing background jobs"</a></p>
<p>In the last article, we made sure than when initializing an object to use our ProcessLater module, we would store the appropriate data in <code>initializer_arguments</code> when it is initialized. This allows us to send that data to the background so it can do the job of initialization when it needs.</p>
<p>Our final code included parts which provided a hijack of the <code>new</code> method on the class using ProcessLater:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def self.included(klass)
    # ...omitted code...
    klass.extend(Initializer)
  end

  module Initializer
    def new(*args)
      instance = allocate
      instance.instance_variable_set(:@initializer_arguments, args)
      instance.send(:initialize, *args.flatten)
      instance
    end
  end
end</code></pre>

<p>This allowed us to keep our object initialization simple:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  include ProcessLater

  def initialize(some_id)
    @some_id = some_id
  end
end

SomeProcess.new(1).later(:call)</code></pre>

<p>Hijacking the <code>new</code> method might feel strange. It's certainly unusual and it's done implicitly. When you use this ProcessLater module, you may not be aware that this magically happens for you.</p>
<h2 id="building-clear-and-explicit-methods">Building clear and explicit methods</h2>
<p>We can make our code more explicit as well as provide an easy interface for other developers to use this library.</p>
<p>I wrote about solving problems like this and knowing how to build your own tools in the <a href="https://www.saturnflyer.com/ruby-dsl-handbook">Ruby DSL Handbook</a>.</p>
<p>The following is a chapter from the Ruby DSL Handbook called <em>Creating a Custom Initializer</em>. </p>
<p>This has some ideas about how we can build a method which would provide a clear and explicit initializer. Take a deep dive in to understanding solving this problem with some metaprogramming techniques. Afterward, I'll wrap it up and show how it ties into the ProcessLater module that we've been building for background jobs.</p>
<hr>
<h2 id="creating-a-custom-initializer">Creating a custom initializer</h2>
<p>Common and repetitive tasks are ripe for moving into a DSL and often Ruby developers find themselves wanting to take care of initialization and setting of accessor methods.</p>
<p>The following example is a modified version of a custom initializer from the <a href="https://github.com/saturnflyer/surrounded">Surrounded</a> project.</p>
<p>The goal of the custom initializer is to allow developers to simplify or shorten code like this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Employment
  attr_reader :employee, :boss
  private :employee, :boss
  def initialize(employee, boss)
    @employee = employee
    @boss = boss
  end
end</code></pre>

<p>The above sample creates <code>attr_reader</code> methods for <code>employee</code> and <code>boss</code>. Then it makes those methods private, and next defines an initializer method which takes the same named arguments and assigns them to instance variables of the same name.</p>
<p>This code is verbose and the repetition of the same words makes it harder to understand what's going on at a glance. If we understand the idea that we want to define an initializer which also defines private accessor methods, we can boil that down to a simple DSL.</p>
<p>This is far easier to type and easier to remember all the required parts:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Employment
  initialize :employee, :boss
end</code></pre>

<p>There is one restriction. We can't provide arguments like a typical method. If we tried this, it would fail:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">initialize employee, boss
  # or
  initialize(employee, boss)</code></pre>

<p>Ruby will process that code and expect to find <code>employee</code> and <code>boss</code> methods which, of course, don't exist. We need to provide names for what <em>will</em> be used to define arguments and methods. So we need to stick with symbols or strings.</p>
<p>Let's look at how to make that work.</p>
<p>Our first step is to define the class-level <code>initialize</code> method.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Employment
  def self.initialize()

  end
end</code></pre>

<p>Because we're creating a pattern that we can follow in multiple places, we'll want to move this to a module.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module CustomInitializer
  def initialize()
  end
end

class Employment
  extend CustomInitializer
end</code></pre>

<p>Now we're setup to use the custom initializer and we can use it in multiple classes.</p>
<p>Because we intend to use this pattern in multiple places, we want the class-level <code>initialize</code> method to accept any number of arguments. To do that we can easily use the splat operator: <code>*</code>. Placing the splat operator at the beginning of a named parameter will treat it as handling zero or more arguments. The parameter <code>*setup_args</code> will allow however many arguments we provide.</p>
<p>The next step is to take those same arguments and set them as <code>attr_reader</code>s and make them private.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module CustomInitializer
  def initialize(*setup_args)
    attr_reader(*setup_args)
    private(*setup_args)

  end
end</code></pre>

<p>With that change, we have the minor details out of the way and can move on to the heavy lifting.</p>
<p>As we saw in Chapter 2: Structure With Modules we want to define any generated methods on a module to preserve some flexability for later alterations. We only initialize Ruby objects once; since we're defining the initialize method in a special module, it doesn't make sense for us to check to see if the module already exists. All we need to do is create it and include it:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module CustomInitializer
  def initialize(*setup_args)
    attr_reader(*setup_args)
    private(*setup_args)

    initializer_module = Module.new
    line = __LINE__; method_module.class_eval %{

    }, __FILE__, line
    const_set('Initializer', initializer_module)
    include initializer_module
  end
end</code></pre>

<p>After we set the private attribute readers, we created a module with <code>Module.new</code>. We prepared the lines to evaluate the code we want to generate, and then we gave the module a name with <code>const_set</code>. Finally we included the module.</p>
<p>The last step is to define our initialize instance method, but this is tricky. At first glance it might seem that all we want to do is create a simple method definition in the evaluated string:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">line = __LINE__; method_module.class_eval %{
    def initialize(*args)

    end
  }, __FILE__, line</code></pre>

<p>This won't work the way we want it to. Remember that we are specifying particular names to be used for the arguments to this generated method in our class-level <code>initialize</code> using <code>employee</code> and <code>boss</code> as provided by our <code>*setup_args</code>.</p>
<p>The change in scope for these values can get confusing. So let's step back and look at what we want to generate.</p>
<p>In our end result, this is what we want:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def initialize(employee, boss)
    @employee = employee
    @boss = boss
  end</code></pre>

<p>Our <code>CustomInitializer</code> is merely generating a string to be evaluated as Ruby. So we need only to look at our desired code as a generated string. With the surrounding code stripped away, here's what we can do:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">%{
    def initialize(#{setup_args.join(',')})
      #{setup_args.map do |arg|
        ['@',arg,' = ',arg].join
      end.join("\n")}
    end
  }</code></pre>

<p>The <code>setup_args.join(',')</code> will create the string "employee, boss" so the first line will appear as we expect:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def initialize(employee,boss)</code></pre>

<p>Next, we use <code>map</code> to loop through the provided arguments and for each one we complile a string which consists of "@", the name of the argument, " = ", and the name of the argument.</p>
<p>So this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">['@',arg,' = ',arg].join</code></pre>

<p>Becomes this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">@employee = employee</code></pre>

<p>Because we are creating individual strings in our <code>map</code> block, we join the result with a newline character to put each one on it's own line.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">%{

    #{setup_args.map do |arg|

    end.join("\n")}

  }</code></pre>

<p>Here's our final custom initializer all the pieces assembled:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module CustomInitializer
  def initialize(*setup_args)
    attr_reader(*setup_args)
    private(*setup_args)

    mod = Module.new
    line = __LINE__; method_module.class_eval %{
      def initialize(#{setup_args.join(',')})
        #{setup_args.map do |arg|
          ['@',arg,' = ',arg].join
        end.join("\n")}
      end
    }, __FILE__, line
    const_set('Initializer', mod)
    include mod
  end
end</code></pre>

<hr>
<h2 id="custom-initializer-with-our-custom-tool">Custom initializer with our custom tool</h2>
<p>With the techniques from this Ruby DSL Handbook chapter, we can have our ProcessLater module provide an <code>initialize</code> method which can handle the dependencies we need for the background work, as well as be a warning sign to developers that something different is going on.</p>
<p>Here's an alternative to our original solution which hijacked the <code>new</code> method.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  # ...omitted code...

  def self.included(klass)
    # ...omitted code...

    # add the initializer
    klass.extend(CustomInitializer)
  end

  class Later &lt; Que::Job
    # ... omitted code...
    def run(*args)
      options = args.pop

      # Arguments changed from just "args" to "*args"
      self.class_to_run.new(*args).send(options['trigger_method'])
    end
  end

  module CustomInitializer
    def initialize(*setup_args)
      attr_reader(*setup_args)

      mod = Module.new
      line = __LINE__; mod.class_eval %{
        def initialize(#{setup_args.join(',')})
          #{setup_args.map do |arg|
            ['@',arg,' = ',arg].join
          end.join("\n")}

          @initializer_arguments = [#{setup_args.join(',')}]
        end
      }, __FILE__, line
      const_set('Initializer', mod)
      include mod
    end
  end
end</code></pre>

<p>This highlights changes since the <code>new</code> hijack approach and with these changes we'll be able to use our new <code>initialize</code> method:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  include ProcessLater

  initialize :some_id

  def call
    puts "#{self.class} ran #{__method__} with #{some_id}"
  end
end</code></pre>

<p>Now we can see explicit use of <code>initialize</code>.</p>
<p>This gives us an alternative approach that may do a better job of communicating with other developers about what this object needs to initialize.</p>
<h2 id="building-better-solutions-with-your-team-in-mind">Building better solutions with your team in mind</h2>
<p>Ruby gives us a lot of power to make decisions not only about how the code works, but how we want to understand it when we use it.</p>
<p>The code we've created supports our desire to stay focused on an individual task. We can decide to run code now or run it later without the need to build an intermediary background class in a way that keeps our code cohesive with closely related features tied together.</p>
<p>We've altered the code be flexible enough to run in multiple places. Once we've made it work with one class, we were able to use it on any other class without the burden of having to rethink the solution of using a background job.</p>
<p>Finally, we made the code so that it would ensure that developers would not forget an important dependency. Our solution first had an interception of <code>new</code> with no extra work for the developer and we later balanced that decision and rethought it to provide some explicit indicators to future developers about how this code works.</p>
<p>As we work together to build software, we communicate in unspoken way through the structure of our code. We can push each other to make good or bad decisions and we can even make the next developer to come along feel powerful when using our code.</p>
<p>This is the reason I wrote the <a href="https://www.saturnflyer.com/ruby-dsl-handbook">Ruby DSL Handbook</a>.</p>
<p>There are many ways to approach the challenges we face in our code. Knowing how to build and use our own tools and how to help others repeat our good work with ease can make a team work more efficiently. With Ruby, we can build a language around what we think and say and do that helps to guide our software development.</p>
<p>As you go forward solving problems with your team, consider the many ideas that each team member can bring to the code. When you decide to build your tool in a certain way, what does that do to the alternatives?</p>
<p>I'd love to know how you build your tools and what sorts of decisions you have made. Drop me a note especially if you've picked up the <a href="https://www.saturnflyer.com/ruby-dsl-handbook">Ruby DSL Handbook</a> and read through it, watched the videos, and experimented or applied any ideas or techniques.</p>
<p>If you haven't yet, grab a copy of the Ruby DSL Handbook and <a href="https://www.saturnflyer.com/ruby-dsl-handbook">bend Ruby to your will</a>... or maybe just build tools that make you and your team happy to have a solid understanding of your code.</p>]]></description></item><item><title>Building a tool that's easy for your team to use</title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 22 Feb 2017 14:00:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/building-a-tool-thats-easy-for-your-team-to-use</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:58ad6426197aea3437bfe37d</guid><description><![CDATA[<p>In previous articles I shared how I moved <a href="https://www.saturnflyer.com/blog/working-later-bridging-your-code-with-the-background">a solution to a problem</a> into <a href="https://www.saturnflyer.com/blog/turning-a-specific-solution-into-a-general-tool">a general tool</a>.</p>
<p>Building your own tools helps you avoid solving the same problem over and over again. Not only does it give you more power over the challenges in your system, but it gives you a point of communication about how a problem is solved.</p>
<p>By building tools around your patterns you'll be able to assign a common language to how you understand it's solution. Team members are better able to pass along understanding by using and manipulating the tools of their trade rather than reexplaining a solution and repeating the same workarounds.</p>
<p>We can compress our ideas and solutions into a simpler language by building up the Ruby code that supports it.</p>
<p>Here's the code:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def later(which_method)
    later_class.enqueue(initializer_arguments, 'trigger_method' =&gt; which_method)
  end

  private

  def later_class
    self.class.const_get(:Later)
  end

  class Later &lt; Que::Job
    # create the class lever accessor get the related class
    class &lt;&lt; self
      attr_accessor :class_to_run
    end

    # create the instance method to access it
    def class_to_run
      self.class.class_to_run
    end

    def run(*args)
      options = args.pop # get the hash passed to enqueue
      self.class_to_run.new(args).send(options['trigger_method'])
    end
  end

  def self.included(klass)
    # create the unnamed class which inherits what we need
    later_class = Class.new(::ProcessLater::Later)

    # name the class we just created
    klass.const_set(:Later, later_class)

    # assign the class_to_run variable to hold a reference
    later_class.class_to_run = klass
  end
end</code></pre>

<p>I showed how I'd use this code with this sample:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  include ProcessLater

  def initialize(some_id)
    @initializer_arguments = [some_id]
    @object = User.find(some_id)
  end
  attr_reader :initializer_arguments

  def call
    # perform some long-running action
  end
end</code></pre>

<p>Unfortunately EVERY class that uses ProcessLater will need to implement <code>initializer_arguments</code>. What will happen if you forget to implement it? Errors? Failing background jobs?</p>
<p>Ruby's Comparable library is an example of one that requires a method to be defined in order to be used properly, so it's not an unprecedented idea.</p>
<h2 id="dangerous-combination-implicit-dependencies-and-confusing-failures">Dangerous combination: implicit dependencies and confusing failures</h2>
<p>The Comparable library is a fantastic tool in Ruby's standard library. By defining one method, you gain many other useful methods for comparing and otherwise organizing your objects.</p>
<p>But here's an example of what happens when you <em>don't</em> define that required method:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby"># in a file called compare.rb
class CompareData
  include Comparable

  def initialize(data)
    @data = data
  end
end

first = CompareData.new('A')
second = CompareData.new('B')

first &lt; second # =&gt; compare.rb:12:in `&lt;': comparison of CompareData with CompareData failed (ArgumentError)</code></pre>

<p><code>comparison of CompareData with CompareData failed (ArgumentError)</code> isn't a helpful error message. It even tells me the problem is in the <code>&lt;</code> data-preserve-html-node="true" method and it's an <code>ArgumentError</code>, but it's actually not <em>really</em> there.</p>
<p>If you're new to using Comparable, this is a surprising result and the message tells you nothing about what to do to fix it.</p>
<p>If you know how to use Comparable, you'd immedately spot the problem in our small class: there's no <code>&lt;=&gt;</code> method (often called the "spaceship operator").</p>
<p>The Comparable library has an implicit dependency on <code>&lt;=&gt;</code> in classes where it is used.</p>
<p>We can fix our code by defining it:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby"># in a file called compare.rb
class CompareData
  include Comparable

  def initialize(data)
    @data = data
  end
  attr_reader :data

  def &lt;=&gt;(other)
    data &lt;=&gt; other.data
  end
end

first = CompareData.new('A')
second = CompareData.new('B')

first &lt; second # =&gt; true</code></pre>

<p>After what could have been a lot of head scratching, we've got our comparable data working. Thanks to our knowledge of that implicit dependency, we got past it quickly.</p>
<h2 id="built-in-dependency-warning-system">Built-in dependency warning system</h2>
<p>Although it's true that the documentation for Comparable says <code>The class must define the &lt;=&gt; operator</code>, it's always nice to know that the code itself will complain in useful ways when you're using it the wrong way.</p>
<p>Sometimes we like to dive into working with the code to get a feel for how things work. Comparable and libraries like it that have implicit dependencies don't lend themselves to playful interaction to discover it's uses.</p>
<p>I mentioned this implicit dependency in the previous article:</p>
<blockquote>
<p>The downside with this is that we have this implicit dependency on the <code>initializer_arguments</code> method. There are ways around that and techniques to use to ensure we do that without failure but for the sake of this article and the goal of creating this generalized library: that'll do.</p>
</blockquote>
<p>But really, that won't do. Requiring developers to implement a method to use this ProcessLater library isn't bad, but there should be a very clear error to occur if they do forget.</p>
<p>Documentation can be provided (and it should!) but I want the concrete feedback I get from direct interaction with it. I'd hate to have developers spend time toying with a problem only to remember hours later that they forgot the most important part.</p>
<p>Better yet, I'd like to provide them with a way to ensure that they <em>don't</em> forget.</p>
<p>We could check for the method we need when the module is included:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def self.included(klass)
    unless klass.method_defined?(:initializer_arguments)
      raise "Oops! You need to define `initializer_arguments' to initialize this class in the background."
    end
  end
end

class SomeProcess
  include ProcessLater
end # =&gt; RuntimeError: Oops! You need to define `initializer_arguments' to initialize this class in the background.</code></pre>

<p>That's helpful noise. And it should be easy to fix:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  include ProcessLater

  def initializer_arguments
    # ...
  end
end # =&gt; RuntimeError: Oops! You need to define `initializer_arguments' to initialize this class in the background.</code></pre>

<p><em>Wait a minute! What happened!?</em></p>
<p>When the Ruby virtual machine processes this code, it executes from the top to the bottom.</p>
<p>The <code>included</code> hook is fired <em>before</em> the required method is defined.</p>
<p>We could include the library <em>after</em> the method definition:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  def initializer_arguments
    # ...
  end
  include ProcessLater
end # =&gt; SomeProcess</code></pre>

<p>Although that works, other developers will find this to be a weird way of putting things together. Ruby developers tend to expect modules at the top of the source file. Although this example is small, it is, afterall, just an example so we should expect that a real world file would be much larger than just these few lines. Finding dependecies included at the bottom of the file would be a surprise, or perhaps we might not find them at all when first reading.</p>
<h2 id="everything-in-it-s-right-place">Everything in it's right place</h2>
<p>Let's keep the included module at the top of the file to prevent confusion and make our dependencies clear.</p>
<p>We can automatically define the <code>initializer_arguments</code> method and return an empty array:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def initializer_arguments; []; end
end</code></pre>

<p>But that would do away with the helpful noise when we forget to set it.</p>
<p>One way to ensure that the values are set is to intercept the object initialization. I've written about <a href="https://www.saturnflyer.com/blog/how-to-preserve-idioms-in-ruby-subclassing">managing the initialize method</a> before but here's how it can be done:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def new(*args)
    instance = allocate
    instance.instance_variable_set(:@initializer_arguments, args)
    instance.send(:initialize, *args.flatten)
    instance
  end
end</code></pre>

<p>The <code>new</code> method on a class is a factory which allocates a space in memory for the object,  runs <code>initialize</code> on it, then returns the instance. We can change this method to <em>also</em> set the <code>@initializer_arguments</code> variable.</p>
<p>But this also requires that we change the structure of our module.</p>
<p>Because we want to use a class method (<code>new</code>) we need to extend our class with a module instead of including it.</p>
<p>Our ProcessLater module already makes use of the <code>included</code> hook, so we can do what we need there. But first, let's make a module to use under the namespace of <code>ProcessLater</code>.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  module Initializer
    def new(*args)
      instance = allocate
      instance.instance_variable_set(:@initializer_arguments, args)
      instance.send(:initialize, *args.flatten)
      instance
    end
  end
end</code></pre>

<p>Next, we can add a line to the <code>included</code> hook to wire up this new feature:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def self.included(klass)
    later_class = Class.new(::ProcessLater::Later)
    klass.const_set(:Later, later_class)

    # extend the klass with our Initializer
    klass.extend(Initializer)

    later_class.class_to_run = klass
  end
end</code></pre>

<p>The final change, is to make sure that all objects which implement this module, have the <code>initializer_arguments</code> <em>method</em> to access the variable that our Initializer sets.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  attr_reader :initializer_arguments
end</code></pre>

<h2 id="no-longer-possible-to-forget">No longer possible to forget</h2>
<p>Our library will now intercept calls to <code>new</code> and store the arguments on the instance allowing them to be passed into our background job.</p>
<p>Developers won't find themselves in a situation where they <em>could</em> forget to store the arguments for the background job.</p>
<p>Here's what it's like to use it:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  include ProcessLater

  def initialize(some_id)
    @some_id = some_id
  end
  attr_reader :some_id

  def call
    # ...
  end
end</code></pre>

<p>That's a lot simpler than adding a line in every <code>initialize</code> method to store an implicitly required <code>@initializer_arguments</code> variable.</p>
<p>Although developers on your team will no longer find themselves in a situation to forget something crucial, you may still not like overriding the <code>new</code> method like this. That's might be a valid concern for your team, and I have an alternative approach to create a custom and <em>explicit</em> initialize method next time.</p>
<p>For now, however, we can see that Ruby gives us the power to make our code easy to run in the background, but Ruby gives us what we need to automatically manage our dependencies as well.</p>
<h2 id="what-this-means-for-other-developers">What this means for other developers</h2>
<p>When we write software, we are not only solving a technical or business problem, but we're introducing potential for our fellow developers to succeed or fail.</p>
<p>This can be an important factor in how your team communicates about your work and the code required to do it.</p>
<p>It may be acceptable to have a library like Comparable which implicitly requires a method to be defined. Or perhaps something like that might fall through the cracks and cause bugs too easily.</p>
<p>If we build tools that implicitly require things, it's useful to automatically provide them.</p>
<h2 id="ready-to-go">Ready to go</h2>
<p>We finally have a tool that can be passed along to others without much fear that they'll run into surprising errors.</p>
<p>Our ProcessLater library is ready to include in our classes. We can take our long-running processes and isolate them in the background by including our module and using our <code>later</code> method on the instance:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class ComplexCalculation
  include ProcessLater

  # ...existing code for this class omitted...
end

ComplexCalculation.new(with, whatever, arguments).later(method_to_run)</code></pre>

<p>This gives us a way to reevaluate the code which might be slow or otherwise time consuming and make a decision to run it later. As developers come together to discuss application performance issues, we'll have a new tool in our vocabulary of potential techniques to overcome the challenges.</p>
<p>Finally, here's the complete library:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def later(which_method)
    later_class.enqueue(initializer_arguments, 'trigger_method' =&gt; which_method)
  end

  attr_reader :initializer_arguments

  private

  def later_class
    self.class.const_get(:Later)
  end

  class Later &lt; Que::Job
    # create the class lever accessor get the related class
    class &lt;&lt; self
      attr_accessor :class_to_run
    end

    # create the instance method to access it
    def class_to_run
      self.class.class_to_run
    end

    def run(*args)
      options = args.pop # get the hash passed to enqueue
      self.class_to_run.new(args).send(options['trigger_method'])
    end
  end

  def self.included(klass)
    # create the unnamed class which inherits what we need
    later_class = Class.new(::ProcessLater::Later)

    # name the class we just created
    klass.const_set(:Later, later_class)

    # add the initializer
    klass.extend(Initializer)

    # assign the class_to_run variable to hold a reference
    later_class.class_to_run = klass
  end

  module Initializer
    def new(*args)
      instance = allocate
      instance.instance_variable_set(:@initializer_arguments, args)
      instance.send(:initialize, *args.flatten)
      instance
    end
  end
end</code></pre>

<p>When you solve your application's challenges, how to you build new tools? In what ways are the tools you build aiding future developers in there ability to overcome challenges without confusing errors or unknown dependencies?</p>]]></description></item><item><title>Turning a specific solution into a general tool</title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 25 Jan 2017 15:01:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/turning-a-specific-solution-into-a-general-tool</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:58877a59b3db2b858aa39f26</guid><description><![CDATA[<p>In a previous article I explored how I <a href="https://www.saturnflyer.com/blog/working-later-bridging-your-code-with-the-background">make putting work into the background easier</a>. 
The goal is to be able to decide when to run some procedure immediately or to run it asynchronously via a background job. Here it is:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  class Later &lt; Que::Job
    def run(*args)
      options = args.pop # get the hash passed to enqueue
      ::SomeProcess.new(args).send(options['trigger_method'])
    end
  end

  def initialize(some_id)
    @some_id = some_id
    @object = User.find(some_id)
  end
  attr_reader :some_id

  def later(which_method)
    Later.enqueue(some_id, 'trigger_method' =&gt; which_method)
  end

  def call
    # perform some long-running action
  end
end</code></pre>

<p>This works well for <em>this</em> class, but eventually we'll want to use this same idea elsewhere. You can always copy and paste, but we know that's a short term solution.</p>
<h2 id="generalizing-your-solution">Generalizing your solution</h2>
<p>Here's how we can take a solution like this and turn it into a more general tool.</p>
<p>First, I like to come up with the code that I <em>want</em> to write in order to use it. Deciding what code you want to write often means deciding how explicit you want to be. </p>
<p>Do we want to extend or include a module?
How should we specify that methods can be performed later?
Do we need to provide any default values?</p>
<p>I often begin answering these questions for myself but end up changing my answers as I think through them or even coming up with additional questions.</p>
<p>Here's where I might start...</p>
<p>Often, I want my code to clearly opt in to using a library like the one we're building. It is possible, however, to automatically make it available.</p>
<p>We can monkey-patch <code>Class</code> for example so that all classes might have this ability. But implicitly providing features to a vast collection of types lacks the clarity that developers of the future will want to find when reading through or changing our code.</p>
<p>Although I want to be able to make any class have the ability to run in the background, I'll want to explicitly declare that it can do that. </p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  include ProcessLater
end</code></pre>

<p>And here's what we would need inside that module:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def later(which_method)
    Later.enqueue(some_id, 'trigger_method' =&gt; which_method)
  end

  class Later &lt; Que::Job
    def run(*args)
      options = args.pop # get the hash passed to enqueue
      ::SomeProcess.new(args).send(options['trigger_method'])
    end
  end
end</code></pre>

<p>We've just moved some code around but have mostly left it the way it was before. This means we'll have a few problems.</p>
<h2 id="overcoming-specific-requirements-in-generalizations">Overcoming specific requirements in generalizations</h2>
<p>Our <code>ProcessLater</code> module has a direct reference to <code>SomeProcess</code> so the next class where we attempt to use this module will have trouble.</p>
<p>We need to tell our background job what class to initialize when it's pulled from the queue.</p>
<p>That means our <code>Later</code> class needs to look something like this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Later &lt; Que::Job
    def run(*args)
      options = args.pop # get the hash passed to enqueue
      class_to_run.new(args).send(options['trigger_method'])
    end
  end</code></pre>

<p>Every class that uses <code>ProcessLater</code> would need to provide that <code>class_to_run</code> object. We could initialize our <code>Later</code> class with an argument, but often with background libraries we don't have control over the initialization. Typically, all we get is a method like <code>run</code> or <code>perform</code> which accepts our arguments.</p>
<p>We'll get to solving that in a minute but another problem we'll see is that every queued job would be for the <code>ProcessLater::Later</code> class. Even though we're creating a generalized solution, I'd rather see something more specific in my queue.</p>
<p>I like to keep related code as close together as is reasonably possible and that leads me to nesting my background classes within the class of concern.</p>
<p>Here's an example of what jobs I'd like to see in my queue: <code>SomeProcess::Later</code>, <code>ComplexCalculation::Later</code>, <code>SolveHaltingProblem::Later</code>. </p>
<p>Seeing that data stored for processing (along with any relevant arguments) would give me an idea of what work would need to be done.</p>
<h2 id="creating-a-custom-general-class">Creating a custom general class</h2>
<p>We can create those classes when we include our module.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def later(which_method)
    Later.enqueue(some_id, 'trigger_method' =&gt; which_method)
  end

  class Later &lt; Que::Job
    # create the class lever accessor get the related class
    class &lt;&lt; self
      attr_reader :class_to_run
    end

    # create the instance method to access it
    def class_to_run
      self.class.class_to_run
    end

    def run(*args)
      options = args.pop # get the hash passed to enqueue
      class_to_run.new(args).send(options['trigger_method'])
    end
  end

  def self.included(klass)
    # create the unnamed class which inherits what we need
    later_class = Class.new(::ProcessLater::Later)

    # assign the @class_to_run variable to hold a reference
    later_class.instance_variable_set(:@class_to_run, self)

    # name the class we just created
    klass.const_set(:Later, later_class)
  end
end</code></pre>

<p>There's a lot going on there but the end result is that when you <code>include ProcessLater</code> you'll get a background class of <code>WhateverYourClassIs::Later</code>.</p>
<p>But there's still a problem. The <code>ProcessLater</code> module has our <code>later</code> method enqueue the background job with <code>Later</code> which will actually look for <code>ProcessLater::Later</code> but we need it to be specifically the class we just created.</p>
<p>We want the instance we create to know how to enqueue itself to the background. All we need to do is provide a method which will look for that constant.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def later(which_method)
    later_class.enqueue(some_id, 'trigger_method' =&gt; which_method)
  end

  private

  # Find the constant in the class that includes this module
  def later_class
    self.class.const_get(:Later)
  end</code></pre>

<h2 id="knowing-how-to-initialize">Knowing how to initialize</h2>
<p>There's still one problem: initializing your object.</p>
<p>The <code>later</code> method knows about that <code>some_id</code> argument. But not all classes are the same and arguments for initialization are likely to be different.</p>
<p>We're going to go with a "let's just make it work" kind of solution. Since we need to know how to initialize, we can just put those arguments into an <code>@initalizer_arguments</code> variable.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  include ProcessLater

  def initialize(some_id)
    @initializer_arguments = [some_id]
    @object = User.find(some_id)
  end
  attr_reader :initializer_arguments
end</code></pre>

<p>Now, instead of keeping track of an individual value, we track an array of arguments. We can alter our enqueueing method to use that array instead:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def later(which_method)
    later_class.enqueue(*initializer_arguments, 'trigger_method' =&gt; which_method)
  end</code></pre>

<p>Our general solution will now properly handle specific class requirements. </p>
<p>The downside with this is that we have this implicit dependency on the <code>initializer_arguments</code> method. There are ways around that and techniques to use to ensure we do that without failure but for the sake of this article and the goal of creating this generalized library: that'll do.</p>
<p>I'll cover handling those requirements like providing <code>initializer_arguments</code> in the future, but for now: how would you handle this? What impact would code like this have on your team?</p>
<h2 id="a-thin-slice-between-you-and-the-background-">A thin, slice between you and the background.</h2>
<p>With that change, we're enqueueing our background jobs with the right classes.</p>
<p>Here's the final flow:</p>
<ol>
<li>Initialize your class: <code>SomeProcess.new(123)</code></li>
<li>Run <code>later(:call)</code> on it</li>
<li>That enqueues the details storing the background class as <code>SomeProcess::Later</code></li>
<li>The job is picked up and the <code>SomeProcess::Later</code> class is initalized</li>
<li>The job object in turn initializes <code>SomeProcess.new(123)</code> and runs your specified method: <code>call</code></li>
</ol>
<p>That gives us a very small generalized layer for moving work into the background. What you'll see in your main class files is this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  include ProcessLater

  def initialize(some_id)
    @initializer_arguments = [some_id]
    @object = User.find(some_id)
  end
  attr_reader :initializer_arguments

  def call
    # perform some long-running action
  end
end</code></pre>

<p>And here's the final library:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">module ProcessLater
  def later(which_method)
    later_class.enqueue(initializer_arguments, 'trigger_method' =&gt; which_method)
  end

  private

  def later_class
    self.class.const_get(:Later)
  end

  class Later &lt; Que::Job
    # create the class lever accessor get the related class
    class &lt;&lt; self
      attr_accessor :class_to_run
    end

    # create the instance method to access it
    def class_to_run
      self.class.class_to_run
    end

    def run(*args)
      options = args.pop # get the hash passed to enqueue
      self.class_to_run.new(args).send(options['trigger_method'])
    end
  end

  def self.included(klass)
    # create the unnamed class which inherits what we need
    later_class = Class.new(::ProcessLater::Later)

    # name the class we just created
    klass.const_set(:Later, later_class)

    # assign the class_to_run variable to hold a reference
    later_class.class_to_run = klass
  end
end</code></pre>

<p>We'll explore more about building your own tools in the future and I put a lot of effort into explaining what you can do with Ruby in the <a href="https://www.saturnflyer.com/ruby-dsl-handbook">Ruby DSL Handbook</a>, so check it out and if you have any questions (or feedback), just hit reply!</p>
<p>Certainly some will say "Why aren't you using ActiveJob?" or "Why aren't you using Sidekiq?" or "Why aren't you ...."</p>
<p>All of those questions are good ones. </p>
<p>The way your team works, interacts, and builds their own tools has a lot more to do with answering those questions than my reasons. Many different decisions can be made but it's important for your whole team to understand which questions are the most important to answer.</p>
<p>Follow-up this article with the next in the series: <a href="https://www.saturnflyer.com/blog/building-a-tool-thats-easy-for-your-team-to-use">Building a tool that's easy for your team to use</a></p>]]></description></item><item><title>How I fixed my biggest mistake with implementing background jobs</title><dc:creator>Jim Gay</dc:creator><pubDate>Thu, 12 Jan 2017 15:13:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/working-later-bridging-your-code-with-the-background</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:584eafaac534a598658c3c34</guid><description><![CDATA[<p>When I first began implementing background jobs I found myself  moving my code into an appropriate background class whether it was in <code>app</code> or <code>lib</code> somewhere. I found it frustrating that I needed to shift code around based only on the decision to run it in the background. It seemed to be the conventional wisdom to do this, or at least that's what I thought.</p>
<p>It's not uncommon to find a reason to move some of your application into the background.</p>
<p>We build up systems that do a lot of work and at a certain point find that the work to be done takes too long. This often means that we reach for a new background job class, move our code to it, stick it in a place like <code>app/jobs</code> and then we're done with it.</p>
<p>Our code now lives in the background jobs and we move along to the next feature. So we separate <code>app/models</code> and <code>app/jobs</code>.</p>
<p>But this ends up feeling like I have two applications. I have my user facing application where most of my work happens and the one where things must happen in the background. But this is mostly a false dichotomy. That's not really how it works nor how any of us think about the system.</p>
<p>While it is important that background processing happen when necessary, I'd rather make those decisions as I determine them. I'd rather those descisions not require I rearrange my code like that.</p>
<h2 id="make-decisions-about-background-processing-without-rearranging-your-code">Make decisions about background processing without rearranging your code</h2>
<p>Here's an example of being able to make those decisions as you determine them. Developers using Rails may be familiar with this easy to change aspect of ActionMailer:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">Notifier.welcome(some_user).deliver_now
# or with a minor change to the code...
Notifier.welcome(some_user).deliver_later</code></pre>

<p>This feature is built-in and ready to use. Few things are easier to change than altering now <code>now</code> into <code>later</code>. </p>
<p>We can do the same in our code too.</p>
<p>To be able to handle this same approach, we'd need to create objects which can be initialized with data from your background data store. </p>
<p>A specialized class to write our object data to the background data store can do the job well, and it's pretty easy to do.</p>
<p>Here's a quick example.</p>
<p>Let's say you need to run some process.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  def initialize(some_id)
    @object = User.find(some_id)
  end

  def call
    # perform some long-running action (use your imagination)
  end
end
process = SomeProcess.new('ee6f1d66-b4e5-11e6-80f5-76304dec7eb7')
process.call</code></pre>

<p>But you've implemented a long running process that runs as soon as some user requests it.
If you follow the example from ActionMailer, maybe could just change <code>process.call</code> to <code>process.call_later</code>.</p>
<p>I want to have the ability to make decisions as easy as this when I need to run the <code>Process</code> code. When you keep all related code together, it’s easier to understand and make changes.</p>
<p>To make this work, we'll need that class to have a <code>call_later</code> method. We might have other methods we want to be able to run later too. Implementing <code>method_missing</code> can make this work...</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  def method_missing(method_name, *args, &amp;block)
    if method_name.to_s =~ /_later\z/
      # run it in the background
    else
      super # do the normal thing ruby does
    end
  end
end</code></pre>

<p>The above implementation of <code>method_missing</code> will catch any methods ending in <code>_later</code>, but I'd rather not do that.</p>
<p>Using <code>method_missing</code> hides the implementation of our hook into the world of background jobs. It's hard to know that it is there and will probably difficult to find later when you want to understand how it works.</p>
<p>Instead, I'm going to write some code so that I can run my code in the backgound by using <code>later(:call)</code> instead of <code>call</code>. It might not be as elegant as appending <code>_later</code> to a method name, but the implementation easier is to get going and will put the code in a place where you can more easily find it.</p>
<h2 id="saving-for-later">Saving for later</h2>
<p>So here's where we'll start:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  def later(trigger_method)
    # ...now what?
  end
end</code></pre>

<p>We've made a <code>later</code> method that will accept a single argument of some method that we want to run.</p>
<p>That's easy enough but now we need to actually save this to the background. Usually this involves referring to some background job class and saving it.</p>
<p>We need to create a class that will save our object information to the background data store, and then later initialize the object and run our <code>trigger_method</code>. </p>
<p>Writing the data to your background store will be handled by whatever library you use for managing background jobs. This example will use <a href="https://github.com/chanks/que">Que</a> but the differences with yours won't matter much.</p>
<p>Our backgroud class needs to initialize the <code>SomeProcess</code> object and tell it to run the <code>trigger_method</code>.</p>
<p>There's a trick to doing this. Our backgroud class needs to know what attributes are required to initialize the object, and which one to use as the method we're calling. </p>
<p>First, let's make a minor change to our initializer to store the argument we're given:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  def initialize(some_id)
    @some_id = some_id # &lt;-- keeping track of the argument
    @object = User.find(some_id)
  end
  attr_reader :some_id
end</code></pre>

<p>This change allows us to reference the argument we're given so that we can use it when we enqueue our background job. Rails allows us to pass an object into an ActiveJob instance (which we're not using here) and make it's best guess about how to serialize and deserialize the data to initialize our objects. Given our simple example here, we don't really need that feature (but we could implement the same if we like).</p>
<p>We really only need the class loaded by the background process to be a thin mediator between the data in the job store and the class which defines our business process. So I just make the class as small and isolated as possible.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  class Later &lt; Que::Job
    def run(*args)
      options = args.pop # get the hash passed to enqueue
      ::SomeProcess.new(args).send(options['trigger_method'])
    end
  end

  def later(which_method)
    Later.enqueue(some_id, 'trigger_method' =&gt; which_method)
  end
end</code></pre>

<p>There's no need to make a new thing inside of <code>app/jobs</code> (or anywhere else) since we never directly access this <code>Later</code> class.</p>
<p>If my main purpose in the code is to initialize <code>Process</code> and use the <code>call</code> method. The only decision I need to make is to either run it immediately, or run it later.</p>
<p>Once I began organizing my code with small and focused background classes, I was able to push aside the concern of when it would run until I needed to make that decision. Reading my code left my head clearer when I kept it all together.</p>
<p>With this code, I can make that decision as I determine the need for it.</p>
<p>Here's the final code for the class:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class SomeProcess
  class Later &lt; Que::Job
    def run(*args)
      options = args.pop # get the hash passed to enqueue
      ::SomeProcess.new(args).send(options['trigger_method'])
    end
  end

  def initialize(some_id)
    @some_id = some_id
    @object = User.find(some_id)
  end
  attr_reader :some_id

  def later(which_method)
    Later.enqueue(some_id, 'trigger_method' =&gt; which_method)
  end

  def call
    # perform some long-running action
  end
end</code></pre>

<p>There are some other features we could add to this, but this small class and <code>later</code> method get us where we want to be.</p>
<p>Now our decision to run this immediately or at a later time is as simple as changing this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">process.call</code></pre>

<p>to this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">process.later(:call)</code></pre>

<p>Are the objects in your system able to change like this? How do you handle decisions to move actions into the background?</p>
<p>Check the next article in the series: <a href="https://www.saturnflyer.com/blog/turning-a-specific-solution-into-a-general-tool">Turning a specific solution into a general tool</a></p>]]></description></item><item><title>Commanding objects toward immutability</title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 19 Aug 2015 16:15:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/commanding-objects-toward-immutability</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:5705367c2fe1311c917ec661</guid><description><![CDATA[<p>Following the rules for East-oriented Code helps me organize behavior in my code but it can lead to other benefits as well. As a result of following <a href="http://confreaks.tv/videos/rubyconf2014-eastward-ho-a-clear-path-through-ruby-with-oo">the rules</a>, I find that my code is better prepared for restrictions like that which immutable objects introduce.</p>
<p>I recently went looking for samples of how people are using <code>instance_eval</code> and <code>instance_exec</code> and ended up with a great <a href="http://www.saturnflyer.com/blog/the-difference-between-instanceeval-and-instanceexec/">example from FactoryGirl</a> thanks to Joshua Clayton. As I was searching, I came upon some code which happened to use <code>instance_eval</code>. Although it was a simple use case for that method it lent itself as a much better example of commands, immutability, and East-oriented code.</p>
<p>Here's the details...</p>
<p>If we want to use nested blocks to create a tree structure, we might create some pseudo-code like this to illustrate our desired code:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">Node.new('root') do
  node('branch') do
    node('leaf')
    node('leaf2')
    node('leaf3')
  end
end</code></pre>

<p>The representation of this set of objects should look something like this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">"['root', ['branch', ['leaf', 'leaf2', 'leaf3']]]"</code></pre>


<p>This shows that the created tree is a pair of a named node and an array of named children (who can also have children).</p>
<h2 id="imperative-approach">Imperative approach</h2>
<p>A simple solution is to initialize a <code>Node</code> and, using an imperative approach, to change its state; that is to say that we alter its collection of children.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Node
      def initialize(name, &amp;block)
        @name = name
        @children = []

        instance_eval(&amp;block) if block
      end    

      attr_reader :children, :name

      def node(name, &amp;block)
        children &lt;&lt; Node.new(name, &amp;block)
      end
    end</code></pre>

<p>When each node is created, its collection of <code>children</code> is set to an empty array. With each call to the <code>node</code> method, a new <code>Node</code> object is created and shoveled into the collection of children.</p>
<p>If we refactor our sample to inline the methods and show us exactly what's going on, it would look something like this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">Node.new('root') do
  self.children &lt;&lt; Node.new('branch') do
    self.children &lt;&lt; Node.new('leaf')
    self.children &lt;&lt; Node.new('leaf2')
    self.children &lt;&lt; Node.new('leaf3')
  end
end</code></pre>

<p>We can more clearly see what's happening inside of the <code>node</code> method with this change to our code.</p>
<h2 id="eastward-flow">Eastward flow</h2>
<p>As I worked with this problem I wondered: what would happen if I started following the 4 rules of East-oriented code?</p>
<p>If our <code>node</code> method returns <code>self</code>, how does that affect our code?</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Node
      # initialize omitted...

      def node(name, &amp;block)
        children &lt;&lt; Node.new(name, &amp;block)
        self
      end
    end</code></pre>

<p>Fortunately, because our code relies on an imperative approach by changing the state of the <code>children</code>, the code still works.</p>
<p>If we want, we can shrink the space we use by chaining commands together:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">t = Node.new("root") do
      node("branch") do
        node("subbranch") do
          node("leaf").node("leaf2").node("leaf3")
        end
      end
    end</code></pre>

<p>I think that's actually a little more difficult to read, so we can go back to the regular style:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">node("leaf")
    node("leaf2")
    node("leaf3")</code></pre>

<p>When seeing techniques like returning <code>self</code> to encourage an East-oriented approach, it's easy to fixate on the chaining. But it's commands that we want to introduce, not chaining. The chaining is incidental here.</p>
<p>If you <em>do</em> chain your method calls together, it at least appears more clearly that each subsequent method is operating on the return value of the last one.</p>
<p>If we want to be clear that we're operating on the last return value, we can maintain the readability of the multiline option by writing it like this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">node("leaf").
    node("leaf2").
    node("leaf3")</code></pre>

<p>Each line chains the next by adding the dot character. We don't have a specific need to do this, but it's good to know how it works.</p>
<p>Not much has changed after introducing our East-oriented approach. We're still updating that collection of <code>children</code>.</p>
<h2 id="introducing-immutability">Introducing immutability</h2>
<p>What will we see if we introduce immutable objects to our solution?</p>
<p>Immutable objects might just help us make our code more predictable. An object which never changes, of course, stays the same. This allows you to better handle the behavior of the system and, without changing any objects, makes a multithreaded approach much less likely to introduce headaches.</p>
<p>The simplest way to add immutability is to freeze objects as they are initialized:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Node
      def initialize(name, &amp;block)
        @name = name.freeze
        @children = [].freeze

        instance_eval(&amp;block) if block
      end

      attr_reader :children, :name

      def node(name, &amp;block)
        children &lt;&lt; Node.new(name, &amp;block).freeze
        self
      end
    end</code></pre>

<p>This, of course, breaks everything. Our code relies upon the fact that the <code>children</code> array may be mutated. Instead of doing the mutation, we'll see this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">RuntimeError: can't modify frozen Array</code></pre>

<p>Now what?</p>
<p>If we can't alter the collection, we're left at creating an entirely new one.</p>
<p>One thing we could do is change the constructor to accept a collection of children when the <code>Node</code> is initialized. Instead of altering the children, we'd use a constructor like this <code>Node.new(name, chlidren)</code>. Here's what that looks like:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Node
      def initialize(name, children=[], &amp;block)
        @name = name.freeze
        @children = children.freeze

        instance_eval(&amp;block) if block
      end
      # ... omitted code

    end</code></pre>


<p>That still doesn't allow us to change anything until we also change the way our <code>node</code> method works (since it is responsible for handling changes to the children).</p>
<p>If the <code>node</code> method created a new <code>Node</code> instead of altering the children, that would get us what we want. Let's break it down.</p>
<p>First, when the <code>node</code> method is called, it needs to create the node to be added to the collection of children:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def node(name, &amp;block)
      new_child = Node.new(name, &amp;block)
      # ... ?
      self
    end</code></pre>

<p>Since we're trying to avoid mutating the state of this object, we don't want to just shove the new node into the collection of children (and we can't because we used <code>freeze</code> on it).</p>
<p>So let's create an entirely new node, with an entirely new collection of children. In order to do that, we need to ensure that for every existing child object, we creat a corresponding new node.</p>
<p>For each command to the object with <code>node</code>, we'll get the representation of what the children should be. So let's build a method to do that:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def next_children
      children.map{|child| Node.new(child.name, child.next_children) }.freeze
    end</code></pre>

<p>When we changed our initializer, that allowed us to set the list of children. Our new <code>next_children</code> method relies on that feature and a recursive call to itself to build the collection of children for that new node with <code>Node.new(child.name, child.next_children)</code>.</p>
<p>Looking back at our <code>node</code> method we'll need to break the rules of East-oriented Code. Since we have immutable objects, we'll return a new node instead of <code>self</code>.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def node(name, &amp;block)
      new_child = Node.new(name, &amp;block)
      Node.new(self.name, next_children + [new_child])
    end</code></pre>

<p>But there's still a problem left. Because we need our initialized object to execute a block and the contstructor <code>new</code> might actually need to return a different object than the one originally created. The call to <code>node</code> inside the block changes the return value from the instance that <code>new</code> creates, to the instance that <code>node</code> creates.</p>
<h2 id="controlling-the-constructor">Controlling the constructor</h2>
<p>To better handle our immutable objects and the return values from the methods we created, we can alter the way the <code>new</code> method works on our Node class.</p>
<p>Instead of handling a block in the <code>initialize</code> method, we can move it to <code>new</code>.</p>
<p>Here's the new <code>new</code> method:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def self.new(*args, &amp;block)
      instance = super.freeze
      if block
        instance.instance_eval(&amp;block)
      else
        instance
      end
    end</code></pre>

<p>The first step is to call <code>super</code> to get an instance the way Ruby normally creates them (as defined in the super class of Node). Then we <code>freeze</code> it.</p>
<p>If we haven't provided a block to the <code>new</code> method, we'll want to return the instance we just created. If we have provided a block, we'll need to evaluate that block in the context of the instance we just created and return it's result.</p>
<p>This means that the block can use the <code>node</code> method and whatever is returned by it.</p>
<p>We need to alter the <code>new</code> method this way because we're not always just returning the instance it creates. Since our objects are frozen, we can't allow the block to alter their states.</p>
<p>The way <code>new</code> <em>usually</em> works is like this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="“language-ruby”">def self.new(*args, &amp;block)
      instance = allocate
      instance.send(:initialize, *args, &amp;block)
      return instance
    end</code></pre>

<p>You can see the reason that Ruby has you call <code>new</code> on a class but in practice you write your <code>initialize</code> method. This structure ensures that no matter the result of your <code>initialize</code> method, <code>new</code> will always return an instance of the class you've used.</p>
<p>We're bending the rules to allow us to evaluate the given block and return <em>its</em> result, instead of the instance typically created by <code>new</code>.</p>
<p>After that, we can remove the block evaluation from <code>initialize</code>:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="“language-ruby”">def initialize(name, children=[])
      @name = name.freeze
      @children = children.freeze
    end</code></pre>

<p>While the method signature (the list of accepted arguments) has changed for <code>initialize</code>, it's still the same for <code>new</code>: a list of arugments and a block.</p>
<p>Believe it or not, there's still one more problem to solve.</p>
<h2 id="operating-on-values">Operating on values</h2>
<p>We looked at how returning <code>self</code> allows you to chain your method calls. Although we've broken that rule and are instead returning a new Node object, it's important to consider that chaining.</p>
<p>Our initial code still doesn't work quite right and it's all because we need to think about operating on the return values of our commands and <em>not</em> relying on an imperitive approach to building and <em>changing</em> objects.</p>
<p>First, here's what our Node class looks like:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="“language-ruby”">class Node
      def self.new(*args, &amp;block)
        instance = super.freeze
        if block
          instance.instance_eval(&amp;block)
        else
          instance
        end
      end

      def initialize(name, children=[])
        @name = name.freeze
        @children = children.freeze
      end

      attr_reader :children, :name

      def node(name, &amp;block)
        new_child = self.class.new(name, &amp;block)
        self.class.new(self.name, next_children + [new_child])
      end

      def next_children
        children.map{|child| self.class.new(child.name, child.next_children) }.freeze
      end

      def inspect
        return %{"#{name}"} if children.empty?
        %{"#{name}", #{children}}
      end
    end</code></pre>

<p>We didn't discuss it, but there's an <code>inspect</code> method to return either the name of the node if it has no children, or the name and a list of children if it has some.</p>
<p>Here's what the code to create the tree looks like:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="“language-ruby”">Node.new('root') do
      node('branch') do
        node('leaf')
        node('leaf2')
        node('leaf3')
      end
    end</code></pre>

<p>If we assign the result of that to a variable and inspect it we'll get a surprising result.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="“language-ruby”">t = Node.new('root') do
          node('branch') do
            node('leaf')
            node('leaf2')
            node('leaf3')
          end
        end
    puts [t].inspect</code></pre>

<p>The output will only be </p><pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="“language-ruby”"><code>["root", ["branch", ["leaf3"]]]</code></code></pre><p></p>
<p>So what happened to the other <code>leaf</code> and <code>leaf2</code> objects? Why aren't they there?</p>
<p>Remember that each <code>node</code> call returns a new node. With every <code>node</code> a new result is returned. The <code>node('leaf')</code> returns an object, but <code>node('leaf2')</code> is not a message sent to the object returned by the first. It is a message sent to the <code>node('branch')</code> result.</p>
<p>Each of those calls is returned and forgotten. Here it is annotated:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="“language-ruby”">t = Node.new('root') do
          node('branch') do
            node('leaf') # returned and forgotten
            node('leaf2') # returned and forgotten
            node('leaf3') # returned and used as the final result
          end
        end
    puts [t].inspect
    #=&gt; ["root", ["branch", ["leaf3"]]]</code></pre>

<p>The answer to this problem is to command each object to do the next thing. We can achieve this by chaining the methods. The result of one method is the object which will receive the next command.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="“language-ruby”">t = Node.new('root') do
          node('branch') do
            node('leaf'). # dot (.) charater added to chain
            node('leaf2'). # executed on the result of the last node
            node('leaf3') # executed on the result of the last node
          end
        end
    puts [t].inspect
    #=&gt; ["root", ["branch", ["leaf", "leaf2", "leaf3"]]]</code></pre>

<p>An alternative way to look at this is to store the result of each command:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="“language-ruby”">t = Node.new('root') do
          node('branch') do
            branch = node('leaf')
            next_branch = branch.node('leaf2')
            final_branch = next_branch.node('leaf3')
          end
        end
    puts [t].inspect
    #=&gt; ["root", ["branch", ["leaf", "leaf2", "leaf3"]]]</code></pre>

<h2 id="following-the-rules-so-you-know-when-to-break-them">Following the rules so you know when to break them</h2>
<p>What was interesting about this to me was that my code was prepared for the immutable objects when I prepared it to operate on the same one. By structuring my code to return <code>self</code> and send the next message to the result of the last, I was able to change the implementation from an imperative style to a functional style.</p>]]></description></item><item><title>Cohesive behaviors with data clumps</title><dc:creator>Jim Gay</dc:creator><pubDate>Thu, 30 Apr 2015 16:59:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/cohesive-behaviors-with-data-clumps</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:570539204d088e2b35b5b764</guid><description><![CDATA[<p>A good example of how we use context and locality to understand and manage concepts in our code is using a data clump.</p>
<p>A data clump is a collection of two or more bits of information that are consistently used together. You’ll find that your data loses its meaning when you remove items from the clump. </p>
<p>Date ranges are simple examples of how a data clump puts necessary information into context.<br>An example of this is to find out if a question was asked between today and one month ago. If our Question class implements a query method for this:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Question
      def asked_within?(start_date, end_date)
        (start_date..end_date).cover?(self.asked_date)
      end
    end</code></pre>

<p>Then we can pass in our desired dates to get the answer:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby"># using ActiveSupport
    start_date = 1.month.ago
    end_date = Time.now
    question.asked_within?(start_date, end_date)</code></pre>

<p>Discovering whether a question is within this time frame always requires both a start and end date. This is an indication that we can only understand the feature and indeed only implement it when we have this data clump. To better encapsulate the behavior of these values, we can create a class to manage initializing objects that represent them.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">DateRange = Struct.new(:start_date, :end_date)
    last_month = DateRange.new(1.month.ago, Time.now)
    question.asked_within?(last_month)</code></pre>


<p>We can then change our Question class to instead take a date range object for the asked_within? method, but the question’s responsibilities have grown a bit here. A question doesn’t have anything to do with comparing dates, so we can move the control of that information into the data clump that represents them.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">DateRange = Struct.new(:start_date, :end_date) do
      def contains?(date)
        (start_date..end_date).cover?(date)
      end
    end</code></pre>
Now, instead of the question managing its date comparison, the date range can do the work.

<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">last_month.contains?(question.date_asked)</code></pre>

<p>By analyzing the individual parts of this date comparison we have to juggle a bit more in our heads. Considering a range as an complete object rather than a collection of parts is simpler and we tend not to think of every individual day within a month when doing a mental comparison. A date range is a small system of interacting parts that we better understand as a broader context.</p>
<p>This example shows us the value not only of separating responsibilities, but of bringing objects together. We get more value by putting details into context than we would have if they remained separate.</p>
<h2 id="things-to-note">Things to note</h2>
<p><code>Struct.new</code> returns a class instance. Inheriting from the result of a new Struct creates an anonymous class in the ancestors of your created class: </p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">[DateRange, #<class:0x007f885d0be518>, Struct, ...]
</class:0x007f885d0be518></code></pre>

<p>Instead of <code>class DateRange &lt; Struct.new; end</code> use <code>DateRange = Struct.new</code> and avoid an anonymous class in the ancestors:&gt;</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">[DateRange, Struct, ...]</code></pre>

<p>Additionaly, be careful with large ranges. If our code used <code>include?</code> instead of <code>cover?</code>, Ruby would initialize a <code>Time</code> object for every time between the beginning and end. As your range grows, the memory needed to calculate the answer will grow too.</p>
<p>Avoid excessive memory and use <code>cover?</code> instead. It will check that your beginning date is less than or equal to the given date, and that the given date is less than or equal to the end date.</p>
<p>This article is an excerpt from my book <a data-preserve-html-node="true" href="http://clean-ruby.com/" target="_blank">Clean Ruby</a></p>]]></description></item><item><title>Locality and Cohesion</title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 22 Apr 2015 00:56:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/locality-and-cohesion</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:5705b0899f7266e11af89bc2</guid><description><![CDATA[<p>"The primary feature for easy maintenance is locality: Locality is that characteristic of source code that enables a programmer to understand that source by looking at only a small portion of it." -- Richard Gabriel</p>
<p>This advice is from <a href="https://www.dreamsongs.com/Files/PatternsOfSoftware.pdf">Patterns of Software</a> by Richard Gabriel.</p>
<p>Keeping cohesive parts of our system together can help us understand it. By managing locality we can keep cohesive parts together.</p>
<p>It’s easy to see coupling in our code. When one object can't do it's job without another, we experience frustration in the face of change. We often think about dependencies in our code, but cohesion is the relatedness of the behaviors and plays an import part in how we organize the ideas to support our domain.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def process_payment(amount)
      gateway.authorize_and_charge(amount) do
        deliver_cart
      end
      logger.info "handling payment: #{amount}"
      logger.info "cart delivered: #{id}"
    end</code></pre>

<p>The exact purpose of this completely-made-up code isn't that important. But we can look at parts of this procedure and extract them into a related method:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def process_payment(amount)
      gateway.authorize_and_charge(amount) do
        deliver_cart
      end
      log_purchase(amount)
    end

    def log_purchase(amount)
      logger.info "handling payment: #{amount}"
      logger.info "cart delivered: #{id}"
    end</code></pre>

<p>As Gabriel points out in his book, we can compress a procedure into a simple phrase like <code>log_purchase</code> but this compression carries a cost. In order to understand the behavior of this <code>log_purchase</code> phrase, we need to understand the context around it.</p>
<p>Indeed, we might look at this and realize that there's a problem with the way we managed the locality of the procedure. Instead of easily understanding a single method, we might look at <code>process_payment</code> and realize there's a bit more to it than we first expect. </p>
<p>We're forced to understand the <code>log_purchase</code> <strong>and</strong> the context which previously surrounded it's procedure. A second look at this extraction might lead us to reconsider and to go back to inline the method. Let's keep this code with a tighter locality:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def process_payment(amount)
      gateway.authorize_and_charge(amount) do
        deliver_cart
      end
      logger.info "handling payment: #{amount}"
      logger.info "cart delivered: #{id}"
    end</code></pre>

<p>While extracting the <code>log_purchase</code> method was easy, given the original code, it added a bit too much for us to understand and it doesn't feel quite right. Handling the locality of this code helps us to better understand it and to make better decisions about how to improve the main <code>process_payment</code> method.</p>
<p>Consider this: How much must you pack into your head before you can begin evaluating a part of your code?</p>
<p>While breaking procedures up into small methods can be a useful way to make easy to understand (and easy to test) parts, we may do so to the detriment of understanding.</p>
<p>This is something to consider if you are <a href="http://clean-ruby.com/dsl">building a DSL</a> to compress ideas in your code or if you're trying to <a href="http://clean-ruby.com">create objects to manage your business logic</a>. I'll be writing more about the value of controlling the locality of behavior in your system, but I'd love to hear how you manage locality. What do you do to ensure that related bits stay together?</p>]]></description></item><item><title>The difference between instance_eval and instance_exec</title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 15 Apr 2015 15:14:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/the-difference-between-instanceeval-and-instanceexec</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:5705addf3c44d81ea7425048</guid><description><![CDATA[<p>There's an important difference between <code>instance_eval</code> and <code>instance_exec</code>. And there's a great lesson about how to use them well in <a href="https://github.com/thoughtbot/factory_girl">FactoryGirl</a></p>
<p>But first, before you go <a href="http://clean-ruby.com/dsl">rushing off to build your fantastic DSL</a>, let's look at what <code>instance_eval</code> is and does.</p>
<p>The simplest of examples can be taken straight from the Ruby docs:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class KlassWithSecret
      def initialize
        @secret = 99
      end
    end
    k = KlassWithSecret.new
    k.instance_eval { @secret } #=&gt; 99</code></pre>

<p>The current value for <code>self</code> inside the provided block will be the object on which you call <code>instance_eval</code>. So in this case the <code>k</code> object is the current context for the block; <code>@secret</code> is a variable stored inside <code>k</code> and <code>instance_eval</code> opens up access to that object and all of it's internal variables.</p>
<p>The interface that FactoryGirl provides is simple and straightforward. Here's an example from it's "Getting Started" documentation:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">FactoryGirl.define do
      factory :user do
        first_name "Kristoff"
        last_name  "Bjorgman"
        admin false
      end
    end</code></pre>

<p>Here, FactoryGirl uses <code>instance_eval</code> to execute the blocks of code passed to <code>factory</code>.</p>
<p>Let's take a look at some representative code from how FactoryGirl makes this work:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def factory(name, &amp;block)
      factory = Factory.new(name)
      factory.instance_eval(&amp;block) if block_given?
      # ... more code
    end</code></pre>

<p>That's not actually the code from FactoryGirl, but it represents roughly what happens. When the method <code>factory</code> is called a new <code>Factory</code> is created and then the block is executed in the context of that object. In other words where you see <code>first_name</code> it's as if you had that factory instance before it and instead had <code>factory.first_name</code>. By using <code>instance_eval</code>, the users of FactoryGirl don't need to specify the factory object, it's implicitly applied to it.</p>
<p>_Ok, that's all well and good, but what about <code>instance_exec</code>?_</p>
<p>I'm glad you asked. </p>
<p>The <code>instance_eval</code> method can only evaluate a block (or a string) but that's it. Need to pass arguments into the block? You'll be frozen in your tracks.</p>
<p>But <code>instance_exec</code> on the other hand, will evaluate a provide block <strong>and</strong> allow you to pass arguments to it. Let's take a look...</p>
<p>FactoryGirl allows you to handle callbacks to perform some action, for example, after the object is created.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">FactoryGirl.define do
      factory :user do
        first_name "Kristoff"
        last_name "Bjorgman"
        admin false

        after(:create) do |user, evaluator|
          create_list(:post, evaluator.posts_count, user: user)
        end
      end
    end</code></pre>

<p>In this sample, the <code>after(:create)</code> is run after the object is created, but the block accepts two arguments: <code>user</code> and <code>evaluator</code>. The <code>user</code> argument is the user that was created. The <code>evaluator</code> is an object which stores all the values created by the factory.</p>
<p>Let's take a look at how this is implemented:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def run(instance, evaluator)
      case block.arity
      when 1, -1 then syntax_runner.instance_exec(instance, &amp;block)
      when 2 then syntax_runner.instance_exec(instance, evaluator, &amp;block)
      else        syntax_runner.instance_exec(&amp;block)
      end
    end</code></pre>

<p>FactoryGirl will create a callback object named by the argument given to the <code>after</code> method. The callback is created with a name, <code>:create</code> in this case, and with a block of code.</p>
<p>The block that we used in our example had two arguments.</p>
<p>The <code>run</code> method decides how to execute the code from the block.</p>
<p>The callback object stores the provided block and Ruby allows us to check the arity of the block, or in other words, it allows us to check the number of arguments.</p>
<p>When looking at a <code>case</code> statement, it's a good idea to check the <code>else</code> clause first. This gives you an idea of what will happen if there's no match for whatever code exists in the <code>when</code> parts.</p>
<p>There we see <code>syntax_runner.instance_exec(&amp;block)</code> and this could easily be changed to use <code>instance_eval</code> instead. Ruby will evaluate, or execute, the block in the context of the <code>syntax_runner</code> object.</p>
<p>If the block's arity is greater than zero, FactoryGirl needs to provide the objects to the block so that our code works the way we expect.</p>
<p>The second part of the case checks if the block arity is equal to <code>2</code>.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">when 2 then syntax_runner.instance_exec(instance, evaluator, &amp;block)</code></pre>

<p>If it is, the <code>syntax_runner</code> receives the <code>instance</code> (or in our case <code>user</code>) and the <code>evaluator</code>.</p>
<p>If, however, the arity is <code>1</code> or <code>-1</code> then the block will only receive the <code>instance</code> object.</p>
<p>So what is that <code>-1</code> value? Let's look at the ways we <em>could</em> create a callback:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby"># Two arguments and arity of 2
    after(:create) do |user, evaluator|
      create_list(:post, evaluator.posts_count, user: user)
    end
    # One argument and arity of 1
    after(:create) do |user|
      create_group(:people, user: user)
    end
    # Zero arguments and arity of 0
    after(:create) do
      puts "Yay!"
    end
    # Any arguments and arity of -1
    after(:create) do |*args|
      puts "The user is #{args.first}"
    end</code></pre>

<p>Ruby doesn't know how many <code>args</code> you'll give it with <code>*args</code> so it throws up it's hands and tells you that it's some strange number: <code>-1</code>.</p>
<p>This is the power of understanding how and when to use <code>instance_exec</code>; users of the DSL will expect it to make sense, and it will.</p>
<p>But wait! There's more!</p>
<p>What if you want to specify the same value for multiple attributes?</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">FactoryGirl.define do
      factory :user do
        first_name "Kristoff"
        last_name  "Bjorgman"

        password "12345"
        password_confirmation "12345"
      end
    end</code></pre>

<p>In the above example, both the <code>password</code> and <code>password_confirmation</code> are set to the same value. This could be bad.
What if you change the password for one, but forget to change the other? If they are inherently tied in their implementation, then that could lead to some unexpected behavior when they are not the same.</p>
<p>I would, and probably you would too, prefer to tell FactoryGirl to just use the value I'd already configured.</p>
<p>Fortunately FactoryGirl allows us to use a great trick in Ruby using the <code>to_proc</code> method. Here's what it looks like in use:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">FactoryGirl.define do
      factory :user do
        first_name "Kristoff"
        last_name  "Bjorgman"

        password "12345"
        password_confirmation &amp;:password
      end
    end</code></pre>

<p>The important part is the <code>&amp;:password</code> value provided to <code>password_confirmation</code>. Ruby will see the <code>&amp;</code> character and treat the following as a block by calling <code>to_proc</code> on it. To implement this feature, FactoryGirl defines <code>to_proc</code> on attributes and there will use <code>instance_exec</code> to provide the symbol <code>password</code> to the block:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def to_proc
      block = @block

      -&gt; {
        value = case block.arity
                when 1, -1 then instance_exec(self, &amp;block)
                else instance_exec(&amp;block)
                end
        raise SequenceAbuseError if FactoryGirl::Sequence === value
        value
      }
    end</code></pre>

<h3 id="what-about-lambdas-and-procs-">What about lambdas and procs?</h3>
<p>Some commenters in Reddit raised an important question about how these methods behave when given lambdas and procs.</p>
<p>If you provide a lambda which accepts no arguments as the block, <code>instance_eval</code> will raise an error:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">object = Object.new
    argless = -&gt;{ puts "foo" }
    object.instance_eval(&amp;argless) #=&gt; ArgumentError: wrong number of arguments (1 for 0)</code></pre>

<p>This error occurs because Ruby will yield the current object to the provided block as <code>self</code>. So you can fix it by providing a lambda which accepts an argument:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">args = -&gt;(obj){ puts "foo" }
    object.instance_eval(&amp;args) #=&gt; "foo"</code></pre>

<p>This changes a bit if you use <code>instance_exec</code>:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">object.instance_exec(&amp;argless) #=&gt; "foo"
    object.instance_exec(&amp;args) #=&gt; ArgumentError: wrong number of arguments (0 for 1)
    object.instance_exec("some argument", &amp;args) #=&gt; "foo"</code></pre>

<p>Because a <code>proc</code> is less restrictive with argument requirements, it will allow either approach to work without error:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">p_argless = proc{ puts "foo" }
    object.instance_eval(&amp;p_argless) #=&gt; "foo"

    p_args = proc{|obj| puts "foo" }
    object.instance_eval(&amp;p_args) #=&gt; "foo"

    object.instance_exec(&amp;p_args) #=&gt; "foo"
    object.instance_exec(&amp;p_argless) #=&gt; "foo"</code></pre>

<p>Now you know, <code>instance_exec</code> and <code>instance_eval</code> are similar in the way they behave, but you'll reach for <code>instance_exec</code> if you need to pass variables around.</p>
<p>##Announcing Ruby Metaprogramming Masterclass</p>
<p>I'm offering a new online class where I'll be teaching you how to master metaprogramming in Ruby on April 30th (the day after my birthday!)</p>
<p>I'm keeping the spaces limited to 25 so attendees will be able to talk and ask questions but already over a quarter of the seats are gone. <a data-preserve-html-node="true" href="http://clean-ruby.com/metaprogramming"> So grab a seat now</a>, before they're all gone.</p>]]></description></item><item><title>The 4 Rules of East-oriented Code: Rule 4</title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 08 Apr 2015 01:30:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/the-4-rules-of-east-oriented-code-rule-4</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:5705b83620c64764a01c855a</guid><description><![CDATA[<p>Often the rules we create are defined by their exceptions.</p>
<p>It is difficult to create a program which continually passes objects and never returns data. Often the first rule of "Always return self" is met with immediate rejection because it's easy to see the difficulty you'd encounter if that rule is continually followed for every object.</p>
<p>In <a href="http://confreaks.com/videos/4825-RubyConf2014-eastward-ho-a-clear-path-through-ruby-with-oo">my presentation for RubyConf</a>, I showed how we break the rules to allow value objects to handle data for a template. I <a href="http://www.saturnflyer.com/blog/preferring-value-objects-or-setters-and-arguments/">previously wrote</a> about the approach I used in the presentation to push data into a value object.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Address
      def display(template)
        if protect_privacy?
          template.display_address(private_version)
        else
          template.display_address(public_version)
        end
        self
      end
    end</code></pre>

<p>In the sample above, an Address instance commands a template to <code>display_address</code> with different versions of data: <code>private_version</code> or <code>public_version</code>. This makes a flexible interface that allows <code>Address</code> to create any number of different versions if necessary. Perhaps the requirements will demand a <code>semi_public_version</code> in the future; our design of the template need not change.</p>
<p>This is a great way to break the rules. Value objects allow us to parameterize a collection of data in a single object. The alternative to this approach would be to use setter methods on the template object:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Address
      def display(template)
        unless protect_privacy?
          template.street = street
          template.apartment = apartment
          template.postal_code = postal_code
        end
        template.city = city
        template.province = province
        template.display_address
        self
      end
    end</code></pre>

<p>We can plainly see that although the code follows the rules by commanding the template object, there's also quite a lot happening in this <code>display</code> method on <code>Address</code>. If the requirements change we might feel encouraged to complicate the <code>unless</code> block or "refactor" it into a <code>case</code> statement. While that might solve our problem, the resulting code could lead to some difficult to read and understand implementation details.</p>
<p>By breaking the rules with a value object we can better encapsulate the ideas in a private address object or public or any other type we desire.</p>
<p>But we're not just breaking the rules inside the <code>Address</code> methods; the template breaks the rules too. Rule 2 says that <code>objects may query themselves</code> and subsequently means they should not query other objects. But by choosing to break the rules we make a design decision at a specific location to make things better.</p>
<p>No matter what rules you follow, you decide not only to follow them, but decide to break them as well. To make your program easy to understand and to create reasonable expectations, you can lean on creating barriers. Preventing yourself from doing one thing frees you to do another.</p>
<p>Embrace constraints.</p>
<p>How do you add constraints to your programs? What are you better able to do by adding restrictions?</p>]]></description></item><item><title>The 4 Rules of East-oriented Code: Rule 3</title><dc:creator>Jim Gay</dc:creator><pubDate>Tue, 17 Mar 2015 15:32:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/the-4-rules-of-east-oriented-code-rule-3</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:5705b81420c64764a01c845a</guid><description><![CDATA[<p>When I set out to create <a href="http://confreaks.com/videos/4825-RubyConf2014-eastward-ho-a-clear-path-through-ruby-with-oo">my presentation for RubyConf</a>, I wanted to provide the audience with something they could easily try. By doing that, one could walk away and put themselves in a position to think about their code differently. While, James Ladd, the creator of East-oriented Code made some basic rules, I decide to take them and frame it in the specific context of Ruby:</p>
<ol>
<li>Always return self</li>
<li>Objects may query themselves</li>
<li>Factories are exempt</li>
<li>Break the rules sparingly</li>
</ol>
<p>After writing about <a href="http://www.saturnflyer.com/blog/the-4-rules-of-east-oriented-code-rule-1/">Rule 1</a> and <a href="http://www.saturnflyer.com/blog/the-4-rules-of-east-oriented-code-rule-2/">Rule 2</a> I'm very eager to get to Rule 3. It's an easy way to break the intent of this style without breaking the rules.</p>
<h2 id="factories-are-exempt">Factories are Exempt</h2>
<p>They must be. If you returned <code>self</code> from <code>Object.new</code> you'd just get <code>Object</code> back, not an instance of an object. So factories are exempt from returning <code>self</code>.</p>
<p>The best way to get around any of these rules is to just make something into a factory. But here lies the danger.
It's important to first think about what these objects are doing. For what are they responsible?</p>
<p>We could create a class to sweep our messy code under the rug.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">user = User.new
    signup = UserSignupProcess.new
    signup.create_with(user)</code></pre>

<p>The code above, we could say, is East-oriented. The factories create instances, and the <code>signup</code> object is told to <code>create_with</code> and given the <code>user</code> object.</p>
<p>Beyond this (inside <code>create_with</code>), it could easily be an enormous mess. While we can and probably should use different programming techniques for different situations, taking a load of <code>if</code> statements and sweeping it into a class could still be problematic.</p>
<p>Now, the sample code above is completely made up to show how you can take part of your program and say "this part is East-oriented, but over here I used this other technique. I call it If-oriented."</p>
<p>Examining your domain and creating a program to support it requires that you carefully evaluate what objects should exist, what their responsibilities are, and what you will name them.</p>
<p>East-orientation is all about designating responsibilities.</p>
<p>This leads us to breaking the rules...</p>
<p>We'll be getting to that later. There's likely very good reasons to break any particular programming rule, but it probably depends on the context.</p>
<p>I wrote <a href="http://clean-ruby.com">Clean Ruby</a> and the chapter on East-oriented Code before I set up the 4 rules for my presentation, but the same lessons are there. I'll be adding more to it, particularly as discussion and ideas around DCI evolve, but I'm putting effort toward wrapping up the <a href="http://clean-ruby.com/dsl">Ruby DSL Handbook</a>. It will soon be complete and the $12 price will go up to $24, so pick it up now if you're interested.</p>
<p>Ruby DSL Handbook is about how to create a DSL without headaches from metaprogramming and I just released an update with a chapter about creating a DSL without metaprogramming at all. Much like this discussion today, it's all about managing responsibilities. </p>]]></description></item><item><title>The 4 Rules of East-oriented Code: Rule 2</title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 11 Mar 2015 01:29:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/the-4-rules-of-east-oriented-code-rule-2</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:5705b7f720c64764a01c838a</guid><description><![CDATA[<p>In a previous article I wrote about <a href="http://www.saturnflyer.com/blog/the-4-rules-of-east-oriented-code-rule-1/">the first rule of East-oriented Code</a>.</p>
<p>Here again are the rules I set forth in my presentation at <a href="http://confreaks.com/videos/4825-RubyConf2014-eastward-ho-a-clear-path-through-ruby-with-oo">RubyConf</a>:</p>
<ol>
<li>Always return self</li>
<li>Objects may query themselves</li>
<li>Factories are exempt</li>
<li>Break the rules sparingly</li>
</ol>
<p>The second rule, that "Objects may query themselves", allows the design of objects to work with their own attributes.</p>
<p>When we design our systems of interacting objects we can use the <a href="https://pragprog.com/articles/tell-dont-ask">Tell, Don't Ask</a> approach to limit the decisions in the code to objects which are responsible for the data used to make them.</p>
<p>The Tell, Don't Ask article begins by quoting Alec Sharp:</p>
<blockquote>
<p>Procedural code gets information then makes decisions. Object-oriented code tells objects to do things.</p>
</blockquote>
<p>In order for objects to do things, they may need to ask questions about their own data. Though the first rule of East-oriented Code says that you should return <code>self</code>, internal private methods don't need to follow this rule. We can and might need to create query methods to allow the object to make decisions.</p>
<p>It's easy to begin designing an object by specifying what it's attributes are:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Person
      attr_reader :name, :nickname, :gender
    end</code></pre>

<p>When we do that, we also implicitly allow other objects to use these attributes and make decisions:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">if person.nickname =~ /^DJ/
      person.setup_playlist_preferences('house')
    else
      person.setup_playlist_preferences('classical')
    end</code></pre>

<p>In the sample code above we're using a method <code>setup_playlist_preferences</code> which accepts a single argument. The decision about what value to set is made outside of the <code>person</code> object. As additional options are added to the system, this <code>if</code> may have <code>elsif</code> clauses added to it or it may turn into a <code>case</code> statement. With public attributes, those changes can appear in multiple places in your system, which can lead to headaches when the structures of your objects change.</p>
<p>Alternatively, we could command the object to do what we want:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">person.setup_playlist_preferences</code></pre>

<p>Any decision about what to do to setup preferences can be made inside the <code>setup_playlist_preferences</code> method.</p>
<p>Here's a summary from the <a href="http://c2.com/cgi/wiki?TellDontAsk">C2 wiki</a></p>
<blockquote>
<p>Very very short summary: It is okay to use accessors to get the state of an object, as long as you don't use the result to make decisions outside the object. Any decisions based entirely upon the state of one object should be made 'inside' the object itself.</p>
</blockquote>
<p>One way to prevent decisions about an object from being made outside that object is to limit the public information:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Person
      private
      attr_reader :name, :nickname, :gender
    end</code></pre>

<p>If you like this, check out the new book I'm writing: <a href="http://clean-ruby.com/dsl">Ruby DSL Handbook</a> which is currently half-off the final price. It's designed to be a guide to help you make decisions about how to build your own DSL and compressions of concepts.</p>]]></description></item><item><title>The 4 Rules of East-oriented Code: Rule 1</title><dc:creator>Jim Gay</dc:creator><pubDate>Wed, 11 Feb 2015 02:28:00 +0000</pubDate><link>https://www.saturnflyer.com/blog/the-4-rules-of-east-oriented-code-rule-1</link><guid isPermaLink="false">56fd5a4d01dbae3f584a0a4e:56fd5bdd62cd94b482c63099:5705b7cbc6fc08aa18827fc5</guid><description><![CDATA[<p>4 simple rules are pretty easy to remember, but a bit harder to understand and apply.</p>
<p>A key concept of East-oriented Code is to enforce the use of commands by returning the object receiving a message.</p>
<p>Here's a simple example of what that looks like:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def do_something
      # logic for doing something omitted...
      self
    end</code></pre>

<p>It's incredibly simple to follow.</p>
<p>Here are the rules I set forth in my presentation at <a href="http://confreaks.com/videos/4825-RubyConf2014-eastward-ho-a-clear-path-through-ruby-with-oo">RubyConf</a>:</p>
<ol>
<li>Always return self</li>
<li>Objects may query themselves</li>
<li>Factories are exempt</li>
<li>Break the rules sparingly</li>
</ol>
<p>The first three are hard rules. The fourth, obviously, is more lenient.
We'll get to some guidance on breaking the rules in the future but for now let's look at applying this to your code.</p>
<h2 id="rule-1-always-return-self">Rule 1: Always return self</h2>
<p>Although this rule is simple at first, it inevitably leads to the queston of getter methods.</p>
<p>What if your objects had no getters? What if an object's <code>name</code> attribute simply was inaccessible to an external object?</p>
<p>You can make your data private by either marking your <code>attr_accessor</code>s as private:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">attr_accessor :name
    private :name</code></pre>

<p>Or you can use the <code>private</code> method to mark all of the following defined methods to be private:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">private
    attr_accessor :name</code></pre>

<p>How you choose to do it will depend upon your code, but this would help you remove any getter methods.</p>
<p>Now this leaves you with a conundrum. How do you use the information?</p>
<p>If you have a need for that <code>name</code>, what can you do?</p>
<p>The only answer is to create a command which will apply the data to the thing you need.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">def apply_name_to(form)
      form.name = name
      self
    end</code></pre>

<p>The restricitions we put in our code are often self-imposed. </p>
<p>We can make whatever we want, so what's to stop us from putting Rails model data manipulation in it's view template?
Nothing concrete stops us from doing so.</p>
<p>The same goes for getter methods like <code>name</code>. If it is publicly accessible by external objects, then we can create whatever <code>if</code> and <code>case</code> statements we want. We can put logic wherever we want.</p>
<p>If we create our own restrictions, we can guide ourselves and other programmers to the direction we intend for our application's structure.</p>
<h2 id="creating-restrictions">Creating restrictions</h2>
<p>I've written about the Forwardable library in the past not only because of it's usefulness, but because we can copy the same pattern to create our own DSL.</p>
<p>Forwardable provides methods which create getter methods for related objects. But what if we created our own DSL for commands to related objects? What if we could pass the messages on, but allow the related object to handle the values?</p>
<p>Here's what that could look like:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Person
      command :send_email =&gt; :emailer
    end
    person = Person.find(1) # get some record
    person.emailer = Emailer.get # get some object to handle the emailing
    person.send_email</code></pre>

<p>That's a lot of pseudo-code but the parts we care about are sending the command to a related object. Commands return the receiving object, queries will return a value.</p>
<p>Here's what that code would look like without our (yet unimplemented) <code>command</code> DSL.</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Person
      def send_email
        emailer.send_email
        self
      end
    end</code></pre>

<p>Any code which uses a <code>Person</code> will have to rely on the command to do its own thing. This prevents a programmer from leaking logic out of the person.</p>
<p>What should happen when the email is sent? With the structure above, this code, can't make decisions:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">if person.send_email
      # do one thing
    else
      # this will never work now
    end</code></pre>

<p>If you find that you often write code like the <code>if</code> statement above, you might wonder "where does that logic go now?" Now, you'll be forced to write this code:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">person.send_email</code></pre>

<p>And this means that your <code>send_email</code> now has the job of handling what to do:</p>
<pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Person
      def send_email
        emailer.send_email
        # do some other things...
        self
      end
    end</code></pre>

<p>That might provide you with better cohesion; the related behaviors remain together.</p>
<p>Getting back to that <code>command</code> DSL we used above...</p>
<p>This was the final point of my presentation at RubyConf: you can build guidlines like this for yourself.</p>
<p>I created a gem called <code>direction</code> to handle enforcing this East-oriented approach. I'll write more about that later, but it shows that I can create signals to other developers on my team. I can take a simple concept like a command and simplify my code to show other developers what's happening:</p>
 <pre data-preserve-html-node="true"><code data-preserve-html-node="true" class="language-ruby">class Person
      command :send_email =&gt; :emailer
    end</code></pre>

<p> Building a DSL can aid in communication. The language and terminology we use can compress ideas into easily digestible parts.</p>
<p> If you like this, check out my new book: <a href="http://clean-ruby.com/dsl">Ruby DSL Handbook</a> designed to be a guide to help you build your own compressions of concepts.</p>]]></description></item></channel></rss>