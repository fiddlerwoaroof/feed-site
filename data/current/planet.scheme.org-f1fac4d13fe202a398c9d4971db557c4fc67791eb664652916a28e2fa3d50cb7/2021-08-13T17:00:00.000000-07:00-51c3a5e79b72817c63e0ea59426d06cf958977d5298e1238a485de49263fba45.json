{
  "title":"A Record Type Representation Trick",
  "date":"2021-08-13T17:00:00.000000-07:00",
  "author":"weinholt",
  "id":"https://weinholt.se/articles/record-type-representation-trick/",
  "link":"https://weinholt.se/articles/record-type-representation-trick/",
  "content":"I’ve been working on optimizations in Loko Scheme recently and\nhave implemented large parts\nof A Sufficiently Smart Compiler for Procedural Records (Keep\n&amp; Dybvig, 2012). At the same time I have improved the representation\nof record type descriptors and wanted to share a simple trick\nI used to improve record type checks for non-sealed records. But first\nI should explain what a record is in Scheme.\n\nBackground: Records in Scheme\nScheme supports record types, which are user-defined data\ntypes. R⁷RS Scheme has a syntax-based variant of this feature,\nbased on SRFI-9. Here’s an example:\n(import (scheme base))\n\n(define-record-type point\n  (make-point x y)\n  point?\n  (x point-x point-x-set!)\n  (y point-y point-y-set))\n\nThis will let you write (make-point 0.0 0.0) to get a point at (0.0,\n0.0), and (point-x p) to access the x field of p. That’s it for\nrecords in R⁷RS and SRFI-9.\nThe record type system in R⁶RS Scheme improves on SRFI-9 in\nseveral ways. In R⁶RS you would instead write this:\n(import (rnrs))\n\n(define-record-type point\n  (fields (mutable x)\n          (mutable y)))\n\nThere is no longer any need to explicitly write out the names of the\nconstructor, predicate, accessors and mutators (unless you want to).\nAdditionally, you can extend a record type, you can customize the\nconstructor, and you can control what happens if define-record-type\nruns multiple times, i.e. if it makes a new type each time or not.\nA syntactical record layer can be abstraction on top of a procedural\nlayer. What you can do with syntax, you can also do with procedure\ncalls at runtime. R⁶RS standardizes this layer as well. It also\nstandardizes a record inspection layer that lets you get the record\ntype descriptor (RTD) from a record at runtime (unless it’s marked\nas opaque) and also to inspect all aspects of RTDs. In fact, RTDs\nare objects in their own right, just like pairs and symbols.\nThe above record type definition might expand to this code that uses\nthe procedural layer (a real expansion would use fresh identifiers for\nthe RTD and RCD):\n(define point-rtd\n  (make-record-type-descriptor\n    'point #f #f #f #f\n    '#((mutable x) (mutable y))))\n(define point-rcd\n  (make-record-constructor-descriptor\n    point-rtd #f #f))\n\n(define point? (record-predicate point-rtd))\n(define make-point (record-constructor point-rcd))\n(define point-x (record-accessor point-rtd 0))\n(define point-y (record-accessor point-rtd 1))\n(define point-x-set! (record-mutator point-rtd 0))\n(define point-y-set! (record-mutator point-rtd 1))\n\nThis code uses the helpers record-predicate, record-constructor,\nrecord-accessor and record-mutator to create procedures. An\nintermediate record constructor descriptor contains the information\nneeded to make the constructor.\nNext we will have a look at records in memory, how the code above\nis optimized, and finally a trick to speed up record type checks.\nRecord Type Representation\nLoko Scheme has a straightforward representation of records. Using the\nabove point type as an example, here are the records returned by\n(make-point 1.0 2.0) and (make-point 1.5 -2.0) as they are\nstructured in memory. The rows are 64-bit words and the arrows are\ntagged pointers. Memory allocations are aligned to 16 bytes, and the\nempty space created by alignment is also shown.\n\nThe information stored in the record is a pointer to the record type\ndescriptor, which is reused for each record of the same type, followed\nby a slot for each field in the record.\nThe information in the record type descriptor is used by the record\ninspection procedures and the garbage collector. The slots contain: a\ntype tag for the rtd itself, the size of the records, an optional\nparent type, an optional record unique identifier, the field names,\nfield mutability (a bit-field), and an optional record writer\nprocedure.\nLoko uses the first slot in the RTD to store the length of the RTD and\nthese flags: opaque?, sealed?, generative?.\nOther R⁶RS implementations will have similar representations of RTDs\nbecause all this information is needed at runtime.\nSingle Inheritance\nR⁶RS supports single inheritance for record types. Instead of\ndemonstrating this with some contrived geometric shapes or balloon\nanimals, let’s use an example from working code. The following record\ntypes are simplified variants of records used in Loko’s PCI library.\n(define-record-type pcibar\n  (fields reg base size))\n\n(define-record-type pcibar-i/o\n  (parent pcibar))\n\n(define-record-type pcibar-mem\n  (parent pcibar)\n  (fields type prefetchable?))\n\nPCI base address registers (BARs) all have these fields: reg,\nbase, and size. If they are in I/O space then that’s all, but BARs\nin memory space have two additional fields: type and\nprefetchable?.\n\nNotice that both pcibar-i/o and pcibar-mem point to pcibar as\ntheir parent. The size field is larger in pcibar-mem to account for\nthe extra fields. The extra fields in the pcibar-mem record are\nplaced immediately after the fields that belong to pcibar, so\naccessors for pcibar don’t need to recompute the slot numbers when\npassed a pcibar-mem.\nPredicates for Non-Sealed Types\nR⁶RS lets you say that a record type is sealed. This prevents a\nrecord type from being extended. As a consequence, type checks are\nmore efficient. Why is that?\nThe record predicate pcibar? is given an object and returns true if\nthe object has that record type, and false otherwise. If the\nimplementation uses tagged pointers then the predicate first checks\nthe tag. Next, it reads the type field of the object and compares it\nto the pcibar type.\nBut if types are not sealed then they can be extended, and it’s\npossible that the type that the predicate is checking for was used as\na parent. The pcibar? predicate should return true even for a\npcibar-mem record.\nThe Trick\nPreviously Loko Scheme’s record-predicate procedure worked as\nfollows. It checked the RTD to see if it’s sealed. For sealed RTDs it\nreturned a procedure that implemented the fast check described above.\nFor non-sealed RTDs another procedure was returned that did that\ncheck, and additionally looped over all parent RTDs to see if any of\nthem was the desired RTD:\n(define (record-predicate rtd)\n  (if (record-type-sealed? rtd)\n      (lambda (obj)     ;fast path\n        (and\n          ($box? obj)\n          (eq? ($box-type obj) rtd)))\n      (lambda (obj)     ;slow path\n        (and\n          ($box? obj)\n          (let ((t ($box-type obj)))\n            (or\n              (eq? t rtd)\n              (and\n                (record-type-descriptor? t)\n                (let lp ((t (record-type-parent t)))\n                  (cond\n                    ((eq? t rtd) #t)\n                    ((not t) #f)\n                    (else\n                     (lp (record-type-parent t))))))))))))\n\nI haven’t checked around, but I suspect that most R⁶RS implementations\ndo something similar. Even when I checked Chez Scheme’s assembly\noutput I saw a loop that’s morally equivalent to this one. This loop\nalso shows up in accessors and mutators, because they need to know\nthat the object they’ve been passed has the right type.\nThe trick: this loop can be avoided by extending the RTD\nrepresentation so that each RTD directly contains pointers to all\nparent RTDs. The pointers are laid out so that the base type is placed\nfirst, followed by the sub-types in order. An RTD will then appear at\na fixed location in any RTD that extends it.\nI’m sure that there are other language implementations where this\nproblem of sub-typing shows up and someone else has come up with just\nthis optimization, because it’s kind of obvious.\nSuppose that we have a base record type and some record types that\nextend each other. For simplicity, I will not give them any fields.\n(define-record-type A)\n\n(define-record-type B (parent A))\n(define-record-type C (parent B))\n\n(define-record-type S (parent A))\n(define-record-type T (parent S))\n\nThe expression (A? (make-A)) evaluates to true, which also A? does\nfor all types shown. But (B? (make-T)) evaluates to false because\nT does not have B anywhere in its chain of parents. That’s what\nthe loop would be checking.\nThis picture shows the memory layout when the trick is used on these\nRTDs.\n\nThe pointer to the A RTD is always in the 0: slot for any RTD that\nextends it. Similarly, the predicate for B knows to always check in\nthe 1: slot. A bounds check on the RTD is also needed in this\nlayout.\nTaking it further\nFurther improvements on this layout are possible. Loko Scheme always\nallocates memory for four parent RTDs. If an RTD will appear at slots\n0 to 3, then the predicate does not need to do bounds checking on the\nRTD. The parent: slot is not strictly needed and can be removed.\nSpecially just for Loko Scheme, the predicates hidden inside accessors\nand mutators use slightly less code than the predicate procedures.\nThese hidden predicates do not explicitly verify the tags on the\npointers, instead leaving it up to the processor’s\nbuilt-in alignment checking to trap\ninvalid references.\nThe type checks are even faster if specialized predicates, accessors,\nand mutators can be generated at compile time. If the RTD is known at\ncompile time then the slot that contains the RTD is also known and can\nbe inlined.\nSufficiently Smart\nA sufficiently smart compiler is a legendary compiler that does your\nfavorite optimizations so that your favorite language feature becomes\nvery efficient.\nIn A Sufficiently Smart Compiler for Procedural Records, Andy\nKeep and Kent Dybvig present their work on optimizing the R⁶RS\nprocedural record system in Chez Scheme. It builds on top of the\nsource-level optimizer cp0. Loko Scheme has its own implementation of\ncp0, so adapting their work has been pretty simple.\nThe basic idea is to have cp0 generate static or partially static\nRTDs, which are then propagated throughout the program using cp0’s\nexisting mechanisms. If cp0 succeeds in propagating the RTDs to where\nrecord-accessor (etc) are called, then it can also generate code\nspecialized to each record type.\nI’ve implemented large parts of the ideas in the paper in Loko Scheme,\ntogether with the improved record type representation.\nPost-script\nCompiling Loko Scheme with Loko Scheme is now almost as fast as\ncompiling it with Chez Scheme, if garbage collection time is not\ncounted (run the compilation with something like LOKO_HEAP=28000 if\nyou have enough RAM). I’m not sure it’s an apples-to-apples comparison\nthough, because when Chez is used, it also has to load and compile\nLoko’s compiler, whereas Loko cheats by already having it loaded. But\nstill, Loko’s performance is improving. I’m interested in seeing how\nwell the next release will fare in the Scheme Benchmarks.\n    "
}