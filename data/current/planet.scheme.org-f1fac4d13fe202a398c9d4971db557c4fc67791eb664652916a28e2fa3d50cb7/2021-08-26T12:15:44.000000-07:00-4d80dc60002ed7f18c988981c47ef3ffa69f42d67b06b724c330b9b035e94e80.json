{
  "title":"Negative zero",
  "date":"2021-08-26T12:15:44.000000-07:00",
  "author":null,
  "id":"https://blog.practical-scheme.net/gauche/20210826-negative-zero",
  "link":"https://blog.practical-scheme.net/gauche/20210826-negative-zero",
  "content":"Negative zero\nGauche supports IEEE754 negative zero -0.0.  It simply wraps\nan IEEE754 double as a scheme object, so mostly it just works as specified\nin IEEE754 (and as supported by the underlying math library).\nOr, so we thought.\nLet's recap the behavior of -0.0.\nIt's numerically indistinguishable from 0.0 (so, it is not\n&quot;an infinitely small value less than zero&quot;):\n(= -0.0 0.0) ⇒ #t\n\n(&lt; -0.0 0.0) ⇒ #f\n\n(zero? -0.0) ⇒ #t\nBut it can make a difference when there's a functon f(x) such that it is\ndiscontinuous at x = 0, and\nf(x) goes to different values when x approaches to zero from positive\nside or negative side.\n(/ 0.0)  ⇒ +inf.0\n(/ -0.0) ⇒ -inf.0\nFor arithmetic primitive procedures, we simply pass unboxed double to\nthe underlying math functions, so we didn't think we need to\nhandle -0.0 specially.\nThe first wakeup call was this article via HackerNews:\nOne does not simply calculate the absolute value\nIt talks about writing abs in Java, but every time I saw articles like\nthis I just try it out on Gauche, and alas!\n;; Gauche 0.9.10\n(abs -0.0) ⇒ -0.0    ; Ouch!\nYeah, the culprit was the C implementation of abs, the gist of which was:\n   if (x &lt; 0.0) return -x;\n   else return x;\n-0.0 doesn't satisfy x &lt; 0.0 so it was returned without negation.\nThe easy fix is to use signbit.\n   if (signbit(x)) return -x;\nI reported the fix on Twitter, then somebody raised an issue: What about\n(eqv? -0.0 0.0)?\nMy initial reaction was that it should be #t, since (= -0.0 0.0)\nis #t.  In fact, R5RS states this:\nThe eqv? procedure returns #t if:\n... obj1 and obj2 are both numbers, are numerically equal\n(see = ...), and are either both exact or both inexact.\nHowever, I realized that R7RS has more subtle definition.\nThe eqv? procedure returns #f if:\n... obj1 and obj2 are both inexact numbers such that\neither they are numerically unequal (in the sense of =),\nor they do not yield the same results (...) when passed as arguments\nto any other procedure that can be defined as a finite composition\nof Scheme's standard arithmetic procedures, ...\nClearly, -0.0 and 0.0 don't yield the same results when passed to /,\nso it should return #f.  (It is also mentioned in 6.2.4\nthat -0.0 is distinct from 0.0 in a sense of eqv?.)\nFix for this is a bit involved.  When I fixed eqv?, a bunch of\ntests started failing.   It looks like some\ninexact integer division routines in the tests yield -0.0, and\nare compared to 0.0 with equal?, which should follow eqv?\nif arguments are numbers.\nIt turned out that the root cause was rounding primitives returning -0.0:\n;; Gauche 0.9.10\n(ceiling -0.5) ⇒ -0.0\nAlthough this itself is plausible, in most of the cases when\nyou're thinking of integers (exact or inexact), you want to treat\nzero as zero.  Certainly you don't want to deal with two\ndistint zeros in quotients or remainders.\nThe choices would be either leave the rounding primitives as are\nand fix the integer divisions, or change the rounding primitives\naltogether.  I choose the latter.\nThe fixes are in the HEAD now.\n;; Gauche 0.9.11\n(eqv? -0.0 0.0) ⇒ #f\n(ceiling -0.5) ⇒ 0.0\nTags: 0.9.11, Flonums\n\n\n    "
}