{
  "title":"Loko Scheme 2022 Q4 Update",
  "date":"2022-11-06T00:00:00.000000Z",
  "author":"weinholt",
  "id":"https://weinholt.se/articles/loko-scheme-2022-q4/",
  "link":"https://weinholt.se/articles/loko-scheme-2022-q4/",
  "content":"I released Loko Scheme 0.12.0 last month and forgot to blog\nabout it. I’ve been busy starting my own consulting company so it just\nslipped my mind. There are two cool milestones with this release.\n\nSelf-compilation on bare metal\nA cool milestone in 0.12.0 is one of those things that is pretty\nsignificant but that you can’t really demonstrate visually.\nI have implemented enough of the Linux syscall layer that I was able\nto run Loko’s compiler on bare metal. I used an old Acer laptop to\ncompile Loko itself while running only Loko on the laptop. Many\ncompilers can compile themselves but this is a new extreme.\nValand, a windowing system\nLoko now has a windowing system called Valand. Its design is somewhat\ninspired by Wayland, except it’s integrated in the kernel and is meant\nto be used on bare metal. So Loko on bare metal now has support for\nrunning multiple graphical programs with preemptive multitasking. You\ncan even run Doom through a port\nof doomgeneric:\n\nThe way this works is through an extension to the Linux syscall ABI\nemulation. When you cross-compile doomgeneric on Linux you get an ELF\nbinary that you can copy to the hard drive and then load with\n@/doomgeneric in the REPL window. That starts a doomgeneric process\nthat opens /dev/valand, which gives it a file descriptor for Valand.\nThe Valand file descriptor supports an ioctl for creating a\ngraphical surface which is then mapped into the process memory with\nmmap. Doomgeneric writes pixel data to this memory and calls another\nioctl to mark the surface as damaged. Valand regularly fixes the\ndamages by copying the damaged pixels to the framebuffer, which means\nthat the screen is updated with a new frame from the game.\nKeyboard events are returned by doing a non-blocking read on the\nValand file descriptor. If there is an event then it’s returned as a\nstruct that specifies a USB HID page and usage. Using USB HID means\nthat there is no need to invent yet another scancode table just for\nLoko.\nValand keeps track of surfaces and composes an image from them. The\ncomposing magic is done with a bunch of rectangle math and a z-buffer.\nIt is all done in Scheme code compiled to native machine code by Loko.\nI haven’t benchmarked it, but it’s fast enough to not be laggy.\nIt’s not much but it’s enough to get Doom running. You might notice\nthat there are no title bars and controls on the windows. There’s very\nlittle that the window system gives you in the current version. You\ncan move windows and keyboard focus will follow the mouse. Valand is\nstarting out small and simple.\nDreaming up what’s next\nThe next milestone could be to port an editor. With an editor running\non Loko and Valand it would in principle be possible to keep\ndeveloping Loko without using another OS. I’m thinking that the fork\nof uEmacs/PK that Torvalds maintains should be pretty simple to port.\nLoko doesn’t have a terminal emulator, not even a tty layer, but you\ncould build the terminal renderer into the uEmacs binary and have it\nuse Valand for the UI.\nAnd I intend for Valand to be an integral part of the operating system\nthat I’m building with Loko. This will make it possible to do some\nthings that you can’t do in an OS like GNU/Linux where these\ncomponents are much more loosely coupled. The Linux kernel has no idea\nabout the desktop environment you’re using, which is the right thing\nfor its design, but which also limits what can be done.\nThe tighter coupling means that Valand can provide a trusted path.\nThe user should have a way into the system which they know with\ncertainty can’t be faked. The system menu on top of the screen will be\none such trusted path. It’s a placeholder in the screenshot shown\nabove, but you can imagine something like the macOS menu. Window\ndecorations will be another trusted path; it should not be possible to\nfake them.\nA mini-rant\nLinux systems sometimes freeze because the kernel overcommits memory\nand under heavy memory pressure begins discarding the pages of\ndemand-paged executables. The kernel can basically decide to discard\nall of user space in favor of a rogue memory hog, so user space grinds\nto a halt.\nLoko should guarantee that the computer always remains responsive,\neven if a program goes rogue and uses up all resources. I’m pretty\nweary of my Linux desktop occasionally freezing, so I’m not going to\nallow that in Loko.\nAnd I don’t want to support anything that steals keyboard focus. Not\neven dialogue windows. Imagine typing and knowing with utter certainty\nwhere your keystrokes will be sent. I haven’t experienced that since\nDOS.\nSo when 1.0?\nObviously a version number like 0.12.0\nis getting ridiculous and it’s time for 1.0.0\nsoon. The big milestone that I’ve been wanting to reach before 1.0.0\nis to make eval use the compiler. I’ve been putting it off, even\nthough it’s not really all that difficult. Perhaps I’ll get to it once\nmy company is off the ground.\n # Possibly a hiatus \n I will take a break away from working on Loko for a couple months \n while my business starts up. \n    "
}