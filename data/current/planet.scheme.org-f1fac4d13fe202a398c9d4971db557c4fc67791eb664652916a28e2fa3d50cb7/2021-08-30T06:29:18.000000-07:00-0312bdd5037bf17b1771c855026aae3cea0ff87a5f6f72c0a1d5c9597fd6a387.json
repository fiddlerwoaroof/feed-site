{
  "title":"Tail recursion and fold-left",
  "date":"2021-08-30T06:29:18.000000-07:00",
  "author":"Joe Marshall",
  "id":"tag:blogger.com,1999:blog-8288194986820249216.post-3272867687298467093",
  "link":"https://funcall.blogspot.com/2021/08/tail-recursion-and-fold-left.html",
  "content":"fold-left has this basic recursion:(fold-left f init ())      = init\n(fold-left f init (a . d)) = (fold-left f (f init a) d)\nA straightforward implementation of this is(defun fold-left (f init list)\n  (if (null list)\n      init\n      (fold-left f (funcall f init (car list)) (cdr list))))\nThe straightforward implementation uses a slightly more space than\nnecessary.  The call to f occurs in a subproblem\nposition, so there the stack frame for fold-left is\npreserved on each call and the result of the call is returned to that\nstack frame.\nBut the result of fold-left is the result of the last\ncall to f, so we don't need to retain the stack frame\nfor fold-left on the last call.  We can end the iteration on a tail call\nto f on the final element by unrolling the loop\nonce:(defun fold-left (f init list)\n  (if (null list)\n      init\n      (fold-left-1 f init (car list) (cdr list))))\n\n(defun fold-left-1 (f init head tail)\n  (if (null tail)\n      (funcall f init head)\n      (fold-left-1 f (funcall f init head) (car tail) (cdr tail))))\nThere aren't many problems where this would make a difference (a\n  challenge to readers is to come up with a program that runs fine\n  with the unrolled loop but causes a stack overflow with the\n  straightforward implementation), but depending on how extreme your\n  position on tail recursion is, this might be worthwhile.\n    "
}