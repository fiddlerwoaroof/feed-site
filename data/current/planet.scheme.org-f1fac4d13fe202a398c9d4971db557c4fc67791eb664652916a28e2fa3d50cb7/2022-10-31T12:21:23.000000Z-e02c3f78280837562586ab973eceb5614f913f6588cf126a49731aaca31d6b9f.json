{
  "title":"ephemerons and finalizers",
  "date":"2022-10-31T12:21:23.000000Z",
  "author":"Andy Wingo",
  "id":"https://wingolog.org/2022/10/31/ephemerons-and-finalizers",
  "link":"https://wingolog.org/archives/2022/10/31/ephemerons-and-finalizers",
  "content":"Good day, hackfolk.  Today we continue the series on garbage collection\nwith some notes on ephemerons and finalizers.conjunctions and disjunctionsFirst described in a 1997 paper by Barry\nHayes, which\nattributes the invention to George Bosworth, ephemerons are a kind of\nweak key-value association.Thinking about the problem abstractly, consider that the garbage\ncollector's job is to keep live objects and recycle memory for dead\nobjects, making that memory available for future allocations.  Formally\nspeaking, we can say:An object is live if it is in the root setAn object is live it is referenced by any live object.This circular definition uses the word any, indicating a disjunction:\na single incoming reference from a live object is sufficient to mark a\nreferent object as live.Ephemerons augment this definition with a conjunction: An object V is live if, for an ephemeron E containing an\nassociation betweeen objects K and V, both E and K are live.This is a more annoying property for a garbage collector to track.  If\nyou happen to mark K as live and then you mark E as live, then you\ncan just continue to trace V.  But if you see E first and then you\nmark K, you don't really have a direct edge to V.  (Indeed this is\none of the main purposes for ephemerons: associating data with an\nobject, here K, without actually modifying that object.)During a trace of the object graph, you can know if an object is\ndefinitely alive by checking if it was visited already, but if it wasn't\nvisited yet that doesn't mean it's not live: we might just have not\ngotten to it yet.  Therefore one common implementation strategy is to\nwait until tracing the object graph is done before tracing ephemerons.\nBut then we have another annoying problem, which is that tracing\nephemerons can result in finding more live ephemerons, requiring another\ntracing cycle, and so on.  Mozilla's Steve Fink wrote a nice article on\nthis\nissue\nearlier this year, with some mitigations.finalizers aren't quite ephemeronsAll that is by way of introduction.  If you just have an object graph\nwith strong references and ephemerons, our definitions are clear and\nconsistent.  However, if we add some more features, we muddy the waters.Consider finalizers.  The basic idea is that you can attach one or a\nnumber of finalizers to an object, and that when the object becomes\nunreachable (not live), the system will invoke a function.  One way to\nimagine this is a global association from finalizable object O to\nfinalizer F.As it is, this definition is underspecified in a few ways.  One, what\nhappens if F references O?  It could be a GC-managed closure, after\nall.  Would that prevent O from being collected?Ephemerons solve this problem, in a way; we could trace the table of\nfinalizers like a table of ephemerons.  In that way F would only be\ntraced if O is live already, so that by itself it wouldn't keep O\nalive.  But then if O becomes dead, you'd want to invoke F, so you'd\nneed it to be live, so reachability of finalizers is not quite the same\nas ephemeron-reachability: indeed logically all F values in the\nfinalizer table are live, because they all will be invoked at some\npoint.In the end, if F references O, then F actually keeps O alive.\nWhether this prevents O from being finalized depends on our definition\nfor finalizability.  We could say that an object is finalizable if it is\nfound to be unreachable after a full trace, and the finalizers F are\nin the root set.  Or we could say that an object is finalizable if it is\nunreachable after a partial trace, in which finalizers are not\nthemselves in the initial root set, and instead we trace them after\ndetermining the finalizable set.Having finalizers in the initial root set is unfortunate: there's no\nquick check you can make when adding a finalizer to signal this problem\nto the user, and it's very hard to convey to a user exactly how it is\nthat an object is referenced.  You'd have to add lots of gnarly\ndocumentation on top of the already\nunavoidable\ngnarliness\nthat you already had to write.  But, perhaps it is a local maximum.Incidentally, you might think that you can get around these issues by\nsaying &quot;don't reference objects from their finalizers&quot;, and that's true\nin a way.  However it's not uncommon for finalizers to receive the\nobject being finalized as an argument; after all, it's that object which\nprobably encapsulates the information necessary for its finalization.\nOf course this can lead to the finalizer prolonging the longevity of an\nobject, perhaps by storing it to a shared data structure.  This is a\nrisk for correct program construction (the finalized object might\nreference live-but-already-finalized\nobjects),\nbut not really a burden for the garbage collector, except in that it's a\nserialization point in the collection algorithm: you trace, you compute\nthe finalizable set, then you have to trace the finalizables again.ephemerons vs finalizersThe gnarliness continues!  Imagine that O is associated with a\nfinalizer F, and also, via ephemeron E, some auxiliary data V.\nImagine that at the end of the trace, O is unreachable and so will be\ndead.  Imagine that F receives O as an argument, and that F looks\nup the association for O in E.  Is the association to V still\nthere?Guile's\ndocumentation\non guardians, a\nfinalization-like facility, specifies that weak associations\n(i.e. ephemerons) remain in place when an object becomes collectable,\nthough I think in practice this has been broken since Guile switched to\nthe BDW-GC collector some 20 years ago or so and I would like to fix it.One nice solution falls out if you prohibit resuscitation by not\nincluding finalizer closures in the root set and not passing the\nfinalizable object to the finalizer function.  In that way you will\nnever be able to look up E×O⇒V, because you don't have O.  This\nis the path that JavaScript has taken, for example, with\nWeakMap\nand\nFinalizationRegistry.However if you allow for resuscitation, for example by passing\nfinalizable objects as an argument to finalizers, I am not sure that\nthere is an optimal answer.  Recall that with resuscitation, the trace\nproceeds in three phases: first trace the graph, then compute and\nenqueue the finalizables, then trace the finalizables.  When do you\nperform the conjunction for the ephemeron trace?  You could do so after\nthe initial trace, which might augment the live set, protecting some\nobjects from finalization, but possibly missing ephemeron associations\nadded in the later trace of finalizable objects.  Or you could trace\nephemerons at the very end, preserving all associations for finalizable\nobjects (and their referents), which would allow more objects to be\nfinalized at the same time.Probably if you trace ephemerons early you will also want to trace them\nlater, as you would do so because you think ephemeron associations are\nimportant, as you want them to prevent objects from being finalized, and\nit would be weird if they were not present for finalizable objects.\nThis adds more serialization to the trace algorithm, though:(Add finalizers to the root set?)Trace from the rootsTrace ephemerons?Compute finalizablesTrace finalizables (and finalizer closures if not done in 1)Trace ephemerons again?These last few paragraphs are the reason for today's post.  It's not\nclear to me that there is an optimal way to compose ephemerons and\nfinalizers in the presence of resuscitation.  If you add finalizers to\nthe root set, you might prevent objects from being collected.  If you\ndefer them until later, you lose the optimization that you can skip\nsteps 5 and 6 if there are no finalizables.  If you trace\n(not-yet-visited) ephemerons twice, that's overhead; if you trace them\nonly once, the user could get what they perceive as premature\nfinalization of otherwise reachable objects.In Guile I think I am going to try to add finalizers to the root set,\npass the finalizable to the finalizer as an argument, and trace\nephemerons twice if there are finalizable objects.  I think this wil\nminimize incoming bug reports.  I am bummed though that I can't\neliminate them by construction.Until next time, happy hacking!\n    "
}