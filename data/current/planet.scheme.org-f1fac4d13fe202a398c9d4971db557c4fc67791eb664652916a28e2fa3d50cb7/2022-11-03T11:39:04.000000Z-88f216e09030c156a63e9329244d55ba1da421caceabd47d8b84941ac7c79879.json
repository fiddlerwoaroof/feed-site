{
  "title":"YAML vs StrictYAML\n    ",
  "date":"2022-11-03T11:39:04.000000Z",
  "author":"Idiomdrottning",
  "id":"https://idiomdrottning.org/yaml-vs-strictyaml",
  "link":"https://idiomdrottning.org/yaml-vs-strictyaml",
  "content":"StrictYAML is a project that tries to fix some issues with YAML.\n            They set out to make tools, not standards, and that’s great.\n            They wanted to make a subset of YAML and a parser for it. Super\n              good approach. But then they don’t follow through on that idea. For\n              example, No is a boolean false in YAML but when StrictYAML reads it,\n              it’s a two-character string (if I understand their documentation\n              correctly). So you’ll end up with misleading bugs later. Maybe a\n              linter would’ve been better?\n            They disallow duplicate keys but so does the YAML standard as\n              far as I understand it. It’s good that it does, in order to be\n              compatible with JSON, but that’s a problem with both JSON and YAML\n              compared to HTML where a <body> can have many <p>. When I made\n              xj, which turns XML to JSON, I had to implement elements as objects\n              with one key, the element name, and the value is an array with the\n              children of the element because of this limitation in JSON. Attributes\n              in XML has the same limitation which is why attributes in the JSON\n              that xj emits has easier semantics.\n            They also forbid inline JSON which I think might be a mistake.\n              The fact that YAML is a superset of JSON solves a lot of other\n              problems people have with JSON (such as no comments).\n            YAML does have problems\n            YAML is a very finicky and stressful language to write. It’s difficult\n              to remember the exact incantations of indentation and hyphenation to\n              get what you want.\n            Coming from Lisp, I more often just use sexp for serialization. It’s\n              the “it’s just already there so why not” solution for lispers.\n            I kind of have a love-hate relationship with YAML.\n            When I read YAML trying to think “What data structures, exactly, will\n              this parse as?” then I’m gonna be miserable.\n            When I read YAML as a human as opposed to as “a human compiler”,\n              that’s where it shines. That’s where I’m like “OK so this is the\n              author and this is the date and this is the categories and this is the\n              comment and this is that list of addresses and phone numbers”, like,\n              if I can trick my mind out of “programmer brain” for a moment and just\n              look at the data qua data, it’s great.\n            Of course, if I’m looking at the data because I’m trying to debug\n              something, then that’s again where we’ve got problems that YAML (or\n              StrictYAML) is not good at solving.\n            It’s sometimes tricky figuring out what’s a list and what isn’t a list\n              and where the object boundaries lie when you are nesting maps in maps.\n              It’s not a problem in “human reading mode”, it’s just an issue when I\n              “try to program in YAML”. I mostly use YAML with Jekyll, which\n              sometimes does additional string-splitting magic on top of YAML. All\n              for the sake of DWIMminess and\n              human-ness at the expense of clear and strict semantics.\n            StrictYAML has almost all of the drawbacks of YAML and as far as I can\n              tell makes incompatible changes rather than being a true subset.\n    </p></body>"
}