{
  "title":"Polynomial Multiplication Using the FFT",
  "date":"2022-11-16T16:00:00.000000Z",
  "author":"j2kun",
  "id":"https://jeremykun.com/?p=118895",
  "link":"https://jeremykun.com/2022/11/16/polynomial-multiplication-using-the-fft/",
  "content":"Problem: Compute the product of two polynomials efficiently.\n\n\n\nSolution:\n\n\nimport numpy\nfrom numpy.fft import fft, ifft\n\n\ndef poly_mul(p1, p2):\n    &quot;&quot;&quot;Multiply two polynomials.\n\n    p1 and p2 are arrays of coefficients in degree-increasing order.\n    &quot;&quot;&quot;\n    deg1 = p1.shape[0] - 1\n    deg2 = p1.shape[0] - 1\n    # Would be 2*(deg1 + deg2) + 1, but the next-power-of-2 handles the +1\n    total_num_pts = 2 * (deg1 + deg2)\n    next_power_of_2 = 1 &lt;&lt; (total_num_pts - 1).bit_length()\n\n    ff_p1 = fft(numpy.pad(p1, (0, next_power_of_2 - p1.shape[0])))\n    ff_p2 = fft(numpy.pad(p2, (0, next_power_of_2 - p2.shape[0])))\n    product = ff_p1 * ff_p2\n    inverted = ifft(product)\n    rounded = numpy.round(numpy.real(inverted)).astype(numpy.int32)\n    return numpy.trim_zeros(rounded, trim='b')\n\n\n\nDiscussion: The Fourier Transform has a lot of applications to science, and I’ve covered it on this blog before, see the Signal Processing section of Main Content. But it also has applications to fast computational mathematics.\n\n\n\nThe naive algorithm for multiplying two polynomials is the “grade-school” algorithm most readers will already be familiar with (see e.g., this page), but for large polynomials that algorithm is slow. It requires $O(n^2)$ arithmetic operations to multiply two polynomials of degree $n$.\n\n\n\nThis short tip shows a different approach, which is based on the idea of polynomial interpolation. As a side note, I show the basic theory of polynomial interpolation in chapter 2 of my book, A Programmer’s Introduction to Mathematics, along with an application to cryptography called “Secret Sharing.”\n\n\n\nThe core idea is that given $n+1$ distinct evaluations of a polynomial $p(x)$ (i.e., points $(x, p(x))$ with different $x$ inputs), you can reconstruct the coefficients of $p(x)$ exactly. And if you have two such point sets for two different polynomials $p(x), q(x)$, a valid point set of the product $(pq)(x)$ is the product of the points that have the same $x$ inputs.\n\n\n\n\\[ \\begin{aligned} p(x) &amp;= \\{ (x_0, p(x_0)), (x_1, p(x_1)), \\dots, (x_n, p(x_n))  \\} \\\\ q(x) &amp;= \\{ (x_0, q(x_0)), (x_1, q(x_1)), \\dots, (x_n, q(x_n))  \\} \\\\ (pq)(x) &amp;= \\{ (x_0, p(x_0)q(x_0)), (x_1, p(x_1)q(x_1)), \\dots, (x_n, p(x_n)q(x_n))  \\} \\end{aligned} \\]\n\n\n\nThe above uses $=$ loosely to represent that the polynomial $p$ can be represented by the point set on the right hand side.\n\n\n\nSo given two polynomials $p(x), q(x)$ in their coefficient forms, one can first convert them to their point forms, multiply the points, and then reconstruct the resulting product.\n\n\n\nThe problem is that the two conversions, both to and from the coefficient form, are inefficient for arbitrary choices of points $x_0, \\dots, x_n$. The trick comes from choosing special points, in such a way that the intermediate values computed in the conversion steps can be reused. This is where the Fourier Transform comes in: choose $x_0 = \\omega_{N}$, the complex-N-th root of unity, and $x_k = \\omega_N^k$ as its exponents. $N$ is required to be large enough so that $\\omega_N$’s exponents have at least $2n+1$ distinct values required for interpolating a degree-at-most-$2n$ polynomial, and because we’re doing the Fourier Transform, it will naturally be “the next largest power of 2” bigger than the degree of the product polynomial.\n\n\n\nThen one has to observe that, by its very formula, the Fourier Transform is exactly the evaluation of a polynomial at the powers of the $N$-th root of unity! In formulas: if $a = (a_0, \\dots, a_{n-1})$ is a list of real numbers define $p_a(x) = a_0 + a_1x + \\dots + a_{n-1}x^{n-1}$. Then $\\mathscr{F}(a)(k)$, the Fourier Transform of $a$ at index $k$, is equal to $p_a(\\omega_n^k)$. These notes by Denis Pankratov have more details showing that the Fourier Transform formula is a polynomial evaluation (see Section 3), and this YouTube video by Reducible also has a nice exposition. This interpretation of the FT as polynomial evaluation seems to inspire quite a few additional techniques for computing the Fourier Transform that I plan to write about in the future.\n\n\n\nThe last step is to reconstruct the product polynomial from the product of the two point sets, but because the Fourier Transform is an invertible function (and linear, too), the inverse Fourier Transform does exactly that: given a list of the $n$ evaluations of a polynomial at $\\omega_n^k, k=0, \\dots, n-1$, return the coefficients of the polynomial.\n\n\n\nThis all fits together into the code above:\n\n\n\n\nPad the input coefficient lists with zeros, so that the lists are a power of 2 and at least 1 more than the degree of the output product polynomial.\n\n\n\nCompute the FFT of the two padded polynomials.\n\n\n\nMultiply the result pointwise.\n\n\n\nCompute the IFFT of the product.\n\n\n\nRound the resulting (complex) values back to integers.\n\n\n\n\nHey, wait a minute! What about precision issues?\n\n\n\nThey are a problem when you have large numbers or large polynomials, because the intermediate values in steps 2-4 can lose precision due to the floating point math involved. This short note of Richard Fateman discusses some of those issues, and two paths forward include: deal with it somehow, or use an integer-exact analogue called the Number Theoretic Transform (which itself has issues I’ll discuss in a future, longer article).\n\n\n\nPostscript: I’m not sure how widely this technique is used. It appears the NTL library uses the polynomial version of Karatsuba multiplication instead (though it implements FFT elsewhere). However, I know for sure that much software involved in doing fully homomorphic encryption rely on the FFT for performance reasons, and the ones that don’t instead use the NTT.\n    "
}