{
  "title":"Get Started with Rust: Enums",
  "date":"2022-10-25T00:00:00.000000Z",
  "author":"Gints Dreimanis",
  "id":"https://serokell.io/blog/enums-and-pattern-matching",
  "link":"https://serokell.io/blog/enums-and-pattern-matching",
  "content":"<h1 id=\"get-started-with-rust%3A-enums\" tabindex=\"-1\">Get Started with Rust: Enums</h1>\n<p>There are two ways to create custom data types in Rust: structs and enums.</p>\n<p>In contrast to <a href=\"https://serokell.io/blog/structs-in-rust\">structs</a>, enums construct a type that has multiple variants and not multiple fields.</p>\n<p>While structs are a part of pretty much any programming language, enums are not so mainstream and are mostly seen in statically typed functional languages like Haskell or OCaml. But, as we’ll see, they are quite nice for domain modeling with types.</p>\n<p>This article will show you how to use enums in Rust. By the end of the article, you’ll know the answers to these questions:</p>\n<ul>\n<li>How to define and instantiate an enum?</li>\n<li>When to use enums instead of structs?</li>\n<li>What is pattern matching, and why is it so useful?</li>\n<li>What are the <code>Option</code> and <code>Result</code> enums, and how to use them?</li>\n</ul>\n<h2 id=\"what-is-an-enum-in-rust%3F\" tabindex=\"-1\">What is an enum in Rust?</h2>\n<p>Enums (short for enumerations) are a way to create compound data types in Rust. They let us <em>enumerate</em> multiple possible variants of a type.</p>\n<p>For example, we can use enums to recreate a <code>Bool</code> data type with two variants: <code>True</code> and <code>False</code>.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">//   [1]  </span>\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Bool</span> {\n<span class=\"hljs-comment\">//  [2]</span>\n    True,\n    False,\n}\n\n<span class=\"hljs-comment\">// [1]: The name of the data type.</span>\n<span class=\"hljs-comment\">// [2]: The variants of the data type. </span>\n</code></pre>\n<p>We can get a value of this type by constructing it with one of the two variants.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">is_true</span> = Bool::True;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">is_false</span> = Bool::False;\n</code></pre>\n<p>Enum variants are like structs: they can contain fields, which can be unnamed or named. In the example below, the <code>Alive</code> variant contains an unnamed signed 8-bit integer.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">HealthBar</span> {\n    <span class=\"hljs-title function_ invoke__\">Alive</span>(<span class=\"hljs-type\">i8</span>),\n    Dead,\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">is_alive</span> = HealthBar::<span class=\"hljs-title function_ invoke__\">Alive</span>(<span class=\"hljs-number\">100</span>);\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">is_dead</span> = HealthBar::Dead;\n</code></pre>\n<p>If we would like to signify that the field represents life points, we can use a named “life” field instead:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">HealthBar</span> {\n    Alive{life: <span class=\"hljs-type\">i8</span>},\n    Dead,\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">is_alive</span> = HealthBar::Alive{life: <span class=\"hljs-number\">100</span>};\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">is_dead</span> = HealthBar::Dead;\n</code></pre>\n<p>Rust enums might be familiar to you from other languages in the guise of <a href=\"https://serokell.io/blog/algebraic-data-types-in-haskell#sum-types\">sum types</a> (Haskell and other FP languages) or <a href=\"https://blog.logrocket.com/understanding-discriminated-union-intersection-types-typescript/\">discriminated unions</a>. Together with structs, they create a simple yet highly usable mechanism for encoding a lot of information in your types.</p>\n<h3 id=\"enums-vs.-structs\" tabindex=\"-1\">Enums vs. structs</h3>\n<p>A struct has multiple fields. In contrast, an enum has multiple variants.</p>\n<p>But, while the concrete value of a struct type has multiple fields, a concrete value of an enum type is exactly one variant.</p>\n<p>Enums enable you to build clearer types and decrease the number of illegal states that your data can take.</p>\n<p>Let’s look at an example. We want to model a character in a game.</p>\n<p>It can have three states:</p>\n<ul>\n<li>Alive. In this case, it has life points.</li>\n<li>Knocked out. In this case, it has life points and a counter of turns it needs to wait to regain consciousness.</li>\n<li>Dead. In this case, it doesn’t need any additional fields.</li>\n</ul>\n<p>Modeling it with only a struct is quite awkward. But we can try the following:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Player</span> {\n    state: <span class=\"hljs-type\">String</span>,\n    life: <span class=\"hljs-type\">i8</span>,\n    turns_to_wait: <span class=\"hljs-type\">i8</span>,\n}\n</code></pre>\n<p>Here, we store the name of the state in a string. If the character is “dead”, their life should be 0. And if they are “knocked out”, they should have some turns to wait until they can act.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">dead_player</span> = Player {\n    state: <span class=\"hljs-string\">&quot;dead&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(),\n    life: <span class=\"hljs-number\">0</span>,\n    turns_to_wait: <span class=\"hljs-number\">0</span>,\n};\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">knocked_out_player</span> = Player {\n    state: <span class=\"hljs-string\">&quot;knocked out&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(),\n    life: <span class=\"hljs-number\">50</span>,\n    turns_to_wait: <span class=\"hljs-number\">3</span>,\n};\n</code></pre>\n<p>This works, but it’s very wonky and obscures the states in type. You need to read the code or docs to know the available states, which diminishes the value of types as documentation. You can also use any kind of string in your code, such as “daed” or “knacked out”, without a compiler error.</p>\n<p>Using an enum, we can list all the possible states in a readable manner.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Player</span> {\n    Alive{life: <span class=\"hljs-type\">i8</span>},\n    KnockedOut{life: <span class=\"hljs-type\">i8</span>, turns_to_wait: <span class=\"hljs-type\">i8</span>},\n    Dead,\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">dead_player</span> = Player::Dead;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">knocked_out_player</span> = Player::KnockedOut { \n    life: <span class=\"hljs-number\">50</span>, \n    turns_to_wait: <span class=\"hljs-number\">3</span>, \n};\n</code></pre>\n<h2 id=\"pattern-matching\" tabindex=\"-1\">Pattern Matching</h2>\n<p>Enum types can have one of multiple variants. So if a function takes an enum, we need a way to adapt the function’s behavior depending on the variant of data it will encounter.</p>\n<p>This is done with pattern matching. If variants <em>construct</em> values of a type, pattern matching <em>deconstructs</em> them.</p>\n<p>Recall our <code>Bool</code> data type:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Bool</span> {\n    True,\n    False,\n}\n</code></pre>\n<p>Suppose we want to create a function called <code>neg</code> that returns the opposite of the boolean that we provide.</p>\n<p>This is how we can do it in Rust using pattern matching.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">neg</span>(value: Bool) <span class=\"hljs-punctuation\">-&gt;</span> Bool {\n<span class=\"hljs-comment\">//        [1]</span>\n    <span class=\"hljs-keyword\">match</span> value {\n<span class=\"hljs-comment\">//      [2]           [3]</span>\n        Bool::True =&gt; Bool::False,\n        Bool::False =&gt; Bool::True,\n    }\n}\n\n<span class=\"hljs-comment\">// [1]: The value we’re pattern matching on.</span>\n<span class=\"hljs-comment\">// [2]: Pattern we want to match. </span>\n<span class=\"hljs-comment\">// [3]: Result.</span>\n</code></pre>\n<p>The result of a match statement can be either an expression or a statement.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">print_value</span>(value: Bool) {\n    <span class=\"hljs-keyword\">match</span> value {\n        Bool::True =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;Clearly true!&quot;</span>),\n        Bool::False =&gt; <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;Unfortunately false!&quot;</span>),\n    }\n}\n</code></pre>\n<p>If you want the result to be more than a single statement or expression, you can use curly braces.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">print_and_return_value</span>(value: Bool) <span class=\"hljs-punctuation\">-&gt;</span> Bool {\n    <span class=\"hljs-keyword\">match</span> value {\n        Bool::True =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;Clearly true!&quot;</span>);\n            Bool::True\n        }\n        Bool::False =&gt; {\n            <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;Unfortunately false!&quot;</span>);\n            Bool::False\n        }\n    }\n}\n</code></pre>\n<p>While this basic case highly resembles a case/switch statement, pattern matching can do much more. We can use pattern matching to assign values <em>while</em> choosing the code path to execute. This enables us to easily work with nested values.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">take_five</span>(player: Player) <span class=\"hljs-punctuation\">-&gt;</span> Player {\n    <span class=\"hljs-keyword\">match</span> player {\n        Player::Alive { life: life } =&gt; Player::Alive { life: life - <span class=\"hljs-number\">5</span> },\n        Player::KnockedOut {\n            life: life,\n            turns_to_wait: turns_to_wait,\n        } =&gt; Player::KnockedOut {\n            life: life - <span class=\"hljs-number\">5</span>,\n            turns_to_wait: turns_to_wait,\n        },\n        Player::Dead =&gt; Player::Dead,\n    }\n}\n</code></pre>\n<p>To make the code example above even simpler, we can use the <a href=\"https://serokell.io/blog/structs-in-rust#field-init-shorthand\">field init shorthand</a>. It lets us substitute <code>life:life</code> with <code>life</code> in pattern matching and construction of structs.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">take_five</span>(player: Player) <span class=\"hljs-punctuation\">-&gt;</span> Player {\n    <span class=\"hljs-keyword\">match</span> player {\n        Player::Alive { life } =&gt; Player::Alive { life: (life - <span class=\"hljs-number\">5</span>) },\n        Player::KnockedOut {\n            life,\n            turns_to_wait,\n        } =&gt; Player::KnockedOut {\n            life: (life - <span class=\"hljs-number\">5</span>),\n            turns_to_wait,\n        },\n        Player::Dead =&gt; Player::Dead,\n    }\n}\n</code></pre>\n<p>The code above has one problem: it doesn’t take into account the fact that a player will die if their health reduces to 0. We can fix that with the help of <a href=\"https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards\">match guards</a>. and <a href=\"https://doc.rust-lang.org/book/ch18-03-pattern-syntax.html#ignoring-an-entire-value-with-_\">wildcards</a>.</p>\n<ul>\n<li>\n<p><strong>Match guards</strong> enable you to add <code>if</code> conditions to the pattern. So we can make the pattern match if the life of <code>Player::Alive</code> is larger than 5, for example.</p>\n</li>\n<li>\n<p>If you put a <strong>wildcard</strong> (marked by underscore) in a pattern, it will match anything. It can be used at the end of a match statement to handle all the remaining cases.</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">take_five_advanced</span>(player: Player) <span class=\"hljs-punctuation\">-&gt;</span> Player {\n    <span class=\"hljs-keyword\">match</span> player {\n        Player::Alive { life } <span class=\"hljs-keyword\">if</span> life &gt; <span class=\"hljs-number\">5</span> =&gt; Player::Alive { life: (life - <span class=\"hljs-number\">5</span>) },\n        Player::KnockedOut {\n            life,\n            turns_to_wait,\n        } <span class=\"hljs-keyword\">if</span> life &gt; <span class=\"hljs-number\">5</span> =&gt; Player::KnockedOut {\n            life: (life - <span class=\"hljs-number\">5</span>),\n            turns_to_wait,\n        },\n        _ =&gt; Player::Dead,\n    }\n}\n</code></pre>\n<p>The match statement must be exhaustive – it needs to cover all the possible values. If you fail to cover some of the options, the program won’t compile.</p>\n<p>For example, if we didn’t use the underscore at the end of the statement, we would have two states that are not covered: <code>Alive</code> and <code>KnockedOut</code> with less than 5 life points. The compiler can detect this and reject the code.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">//error[E0004]: non-exhaustive patterns: `Alive { .. }` and `KnockedOut { .. }` not covered</span>\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">take_five_advanced</span>(player: Player) <span class=\"hljs-punctuation\">-&gt;</span> Player {\n    <span class=\"hljs-keyword\">match</span> player {\n        Player::Alive { life } <span class=\"hljs-keyword\">if</span> life &gt; <span class=\"hljs-number\">5</span> =&gt; Player::Alive { life: (life - <span class=\"hljs-number\">5</span>) },\n        Player::KnockedOut {\n            life,\n            turns_to_wait,\n        } <span class=\"hljs-keyword\">if</span> life &gt; <span class=\"hljs-number\">5</span> =&gt; Player::KnockedOut {\n            life: (life - <span class=\"hljs-number\">5</span>),\n            turns_to_wait,\n        },\n        Player::Dead =&gt; Player::Dead,\n    }\n}\n</code></pre>\n<h2 id=\"enum-methods-and-traits\" tabindex=\"-1\">Enum methods and traits</h2>\n<p>Like structs, enums allow for the creation of associated methods and the implementation of traits. They are a powerful tool for clearing up your code and reducing boilerplate.</p>\n<h3 id=\"defining-methods-for-enums\" tabindex=\"-1\">Defining methods for enums</h3>\n<p>Take a look at the negation function that we implemented earlier.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">neg</span>(value: Bool) <span class=\"hljs-punctuation\">-&gt;</span> Bool {\n  <span class=\"hljs-keyword\">match</span> value {\n    Bool::True =&gt; Bool::False,\n    Bool::False =&gt; Bool::True,\n  }\n}\n</code></pre>\n<p>It would be better to have it be a method so that we can access it via dot-notation.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">is_true</span> = Bool::True;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">not_true</span> = is_true.<span class=\"hljs-title function_ invoke__\">neg</span>();\n</code></pre>\n<p>To do that, we need to create an implementation block for Bool. In it, we use the <code>self</code> keyword to refer to the <code>Bool</code> value at hand. <code>Self</code> stands for the type we’re writing the implementation for.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Bool</span> {\n  <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">neg</span>(<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n    <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n      <span class=\"hljs-keyword\">Self</span>::True =&gt; <span class=\"hljs-keyword\">Self</span>::False,\n      <span class=\"hljs-keyword\">Self</span>::False =&gt; <span class=\"hljs-keyword\">Self</span>::True,\n    }\n  }\n}\n</code></pre>\n<h3 id=\"defining-traits-for-enums\" tabindex=\"-1\">Defining traits for enums</h3>\n<p>Like structs, enums can also have <a href=\"https://doc.rust-lang.org/book/ch10-02-traits.html\">traits</a> – Rust’s version of interfaces that enable common functionality among types.</p>\n<p>You can derive common traits such as <a href=\"https://doc.rust-lang.org/std/fmt/trait.Debug.html\"><code>Debug</code></a>, <a href=\"https://doc.rust-lang.org/std/clone/trait.Clone.html\"><code>Clone</code></a>, and <a href=\"https://doc.rust-lang.org/std/cmp/trait.Eq.html\"><code>Eq</code></a> using the <a href=\"https://doc.rust-lang.org/reference/attributes/derive.html\"><code>derive</code></a> attribute.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[derive(Debug, Eq, PartialEq)]</span>\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Bool</span> {\n  True,\n  False,\n}\n</code></pre>\n<p>For example, after deriving <code>Debug</code> and <code>PartialEq</code>, we can now print and compare values of <code>Bool</code>.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">is_true</span> = Bool::True;\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">is_false</span> = Bool::False;\n<span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;{:?}&quot;</span>, is_true); <span class=\"hljs-comment\">// Prints “True”. </span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">are_same</span> = is_true == is_false; <span class=\"hljs-comment\">// false </span>\n</code></pre>\n<p>It’s also possible to create your own custom traits and implementations. For more info on this, you can read our <a href=\"https://serokell.io/blog/rust-traits\">article on traits</a>.</p>\n<h2 id=\"option-and-result-enums\" tabindex=\"-1\"><code>Option</code> and <code>Result</code> enums</h2>\n<p>Two enums you will frequently encounter in Rust are <a href=\"https://doc.rust-lang.org/std/option/enum.Option.html\"><code>Option</code></a>, Rust’s safe alternative to <code>null</code>, and <a href=\"https://doc.rust-lang.org/std/result/\"><code>Result</code></a>, Rust’s safe alternative to exceptions.</p>\n<p>Where can they be used? Well, sometimes a function is not able to return a result for a given input. As a simple example, you cannot divide a number by 0.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">impossible</span> = <span class=\"hljs-number\">4</span> / <span class=\"hljs-number\">0</span>;\n</code></pre>\n<p>In fact, Rust doesn’t let you compile a line of code that divides by zero. But you can still do it in multiple other ways.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">main</span>() {\n  <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;Choose what to divide 4 with!&quot;</span>);\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">input</span> = <span class=\"hljs-type\">String</span>::<span class=\"hljs-title function_ invoke__\">new</span>();\n  std::io::<span class=\"hljs-title function_ invoke__\">stdin</span>().<span class=\"hljs-title function_ invoke__\">read_line</span>(&amp;<span class=\"hljs-keyword\">mut</span> input).<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">divisor</span>: <span class=\"hljs-type\">i32</span> = input.<span class=\"hljs-title function_ invoke__\">trim</span>().<span class=\"hljs-title function_ invoke__\">parse</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n\n  <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">result</span> = <span class=\"hljs-number\">4</span> / divisor;\n}\n</code></pre>\n<p>But what if we don’t want the program to crash whenever we encounter a division by zero? We can instead make the function return the <code>Option</code> type and handle the problem further down the code.</p>\n<p><code>Option</code> has two variants: <code>None</code> or <code>Some</code>. The first represents a lack of output – something you would commonly use <code>null</code> or <code>nil</code> for. <code>Some</code> can wrap any type and signifies that the function has successfully returned a value.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Option</span>&lt;T&gt; {\n    <span class=\"hljs-literal\">None</span>,\n    <span class=\"hljs-title function_ invoke__\">Some</span>(T),\n}\n</code></pre>\n<p>For example, we can wrap division in <code>Option</code> so it doesn’t panic when we divide by 0.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">safe_division</span>(a: <span class=\"hljs-type\">i32</span>, b: <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> (<span class=\"hljs-type\">Option</span>&lt;<span class=\"hljs-type\">i32</span>&gt;) {\n    <span class=\"hljs-keyword\">match</span> b {\n        <span class=\"hljs-number\">0</span> =&gt; <span class=\"hljs-literal\">None</span>,\n        _ =&gt; <span class=\"hljs-title function_ invoke__\">Some</span>(a / b),\n    }\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">possible</span> = <span class=\"hljs-title function_ invoke__\">safe_division</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// None</span>\n</code></pre>\n<p><code>Result</code> is similar, but it returns the error encountered instead of returning <code>None</code>.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Result</span>&lt;T, E&gt; {\n   <span class=\"hljs-title function_ invoke__\">Ok</span>(T),\n   <span class=\"hljs-title function_ invoke__\">Err</span>(E),\n}\n</code></pre>\n<p>Here’s how <code>safe_division</code> looks with <code>Result</code>:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[derive (Debug, Clone)]</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DivideByZero</span>; <span class=\"hljs-comment\">// custom error type</span>\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">safe_division_result</span>(a: <span class=\"hljs-type\">i32</span>, b: <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> (<span class=\"hljs-type\">Result</span>&lt;<span class=\"hljs-type\">i32</span>, DivideByZero&gt;) {\n    <span class=\"hljs-keyword\">match</span> b {\n        <span class=\"hljs-number\">0</span> =&gt; <span class=\"hljs-title function_ invoke__\">Err</span>(DivideByZero),\n        _ =&gt; <span class=\"hljs-title function_ invoke__\">Ok</span>(a / b),\n    }\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">also_possible</span> = <span class=\"hljs-title function_ invoke__\">safe_division_result</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// Err(DivideByZero)</span>\n</code></pre>\n<p>As you can see, we created a custom error type for the error. It’s possible to use strings to denote errors, but it’s not recommended.</p>\n<h3 id=\"option-and-result-methods\" tabindex=\"-1\"><code>Option</code> and <code>Result</code> methods</h3>\n<p>Both of these enums are useful, but they tend to complicate the code.</p>\n<p>Here are some commonly used methods that will make working with them easier. They work on both <code>Option</code> and <code>Result</code> types.</p>\n<h4 id=\"unwrap\" tabindex=\"-1\"><code>unwrap</code></h4>\n<p>The straightforward way to get the value inside an <code>Option</code> or a <code>Result</code> is to call <code>unwrap</code> on it.</p>\n<p>This method has a big downside, though. Calling it on a <code>None</code> or <code>Error</code> will panic the program, defeating the purpose of error handling.</p>\n<p>let some = safe_division(6, 3); // Some(2)\nlet none = safe_division(4, 0); // None</p>\n<p>let two = some.unwrap(); // 2\nlet oops = none.unwrap(); // thread ‘main’ panicked at ‘called <code>Option::unwrap()</code> on a <code>None</code> value’</p>\n<p>Therefore, its use is generally discouraged. It can come in handy when you’re writing prototypes, using Rust for simple scripts, or trying out libraries.</p>\n<h4 id=\"unwrap_or_else\" tabindex=\"-1\"><code>unwrap_or_else</code></h4>\n<p>A safe way to unwrap values is to use the <code>unwrap_or_else</code> method.</p>\n<p>It takes a closure (anonymous function) as an argument. If it runs into <code>None</code> or <code>Err</code>, it uses this closure to compute a value to use instead of panicking.</p>\n<p>For example:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">two</span> = <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-number\">2</span>).<span class=\"hljs-title function_ invoke__\">unwrap_or_else</span>(|| {<span class=\"hljs-number\">0</span>}); <span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">safe</span> = <span class=\"hljs-literal\">None</span>.<span class=\"hljs-title function_ invoke__\">unwrap_or_else</span>(|| {<span class=\"hljs-number\">0</span>}); <span class=\"hljs-comment\">// 0</span>\n</code></pre>\n<p>There are two more unwrap variants that you can use:</p>\n<ul>\n<li><code>unwrap_or</code>, which lets you provide a value directly. The difference between it and <code>unwrap_or_else</code> is that it calculates the default value anytime you run the function, while <code>unwrap_or_else</code> calculates it only when necessary.</li>\n<li><code>unwrap_or_default</code>, which provides a default value instead of panicking if the type has a <code>Default</code> trait implemented.</li>\n</ul>\n<h4 id=\"%3F\" tabindex=\"-1\"><code>?</code></h4>\n<p>The <a href=\"https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html\">question mark (try)</a> operator is a way to get values out of <code>Option</code> and <code>Result</code> without handling the <code>None</code> case.</p>\n<p>You can write it at the end of any function call that returns <code>Option</code> or <code>Result</code> that <em>is inside</em> a function block that returns <code>Option</code> or <code>Result</code>.</p>\n<p>If it encounters a success state, it will extract the value and proceed with the function. If it encounters a fail state (<code>None</code> or <code>Err</code> of some sort), it will short-circuit the function and return the result.</p>\n<p>For <code>Option</code>, it is approximately equivalent to:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">match</span> expr {\n    <span class=\"hljs-title function_ invoke__\">Some</span>(x) =&gt; x,\n    <span class=\"hljs-literal\">None</span> =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>,\n}\n</code></pre>\n<p>Let’s look at an example: a function that performs safe division twice.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">safe_division_twice</span>(a: <span class=\"hljs-type\">i32</span>, b: <span class=\"hljs-type\">i32</span>, c: <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Option</span>&lt;<span class=\"hljs-type\">i32</span>&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">result</span> = <span class=\"hljs-title function_ invoke__\">safe_division</span>(a, b)?;\n    <span class=\"hljs-title function_ invoke__\">safe_division</span>(result, c)\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">one</span> = <span class=\"hljs-title function_ invoke__\">safe_division_twice</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// Some(1)</span>\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">oops</span> = <span class=\"hljs-title function_ invoke__\">safe_division_twice</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// None</span>\n</code></pre>\n<p>It can be very useful when chaining multiple functions that use one of these enums. The alternative of <code>safe_division_twice</code> with <code>match</code> is quite wordy.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">safe_division_twice</span>(a: <span class=\"hljs-type\">i32</span>, b: <span class=\"hljs-type\">i32</span>, c: <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Option</span>&lt;<span class=\"hljs-type\">i32</span>&gt; {\n    <span class=\"hljs-keyword\">match</span> <span class=\"hljs-title function_ invoke__\">safe_division</span>(a, b) {\n        <span class=\"hljs-title function_ invoke__\">Some</span>(x) =&gt; <span class=\"hljs-title function_ invoke__\">safe_division</span>(x, c),\n        <span class=\"hljs-literal\">None</span> =&gt; <span class=\"hljs-literal\">None</span>,\n    }\n}\n</code></pre>\n<p>But it would become even worse when we need to chain more than two of these functions: each operation requires its own nested match statement.</p>\n<details>\n<summary> How a <code>safe_division_thrice</code> function looks with <code>match</code> vs. <code>?</code></summary>\n<p><em>With pattern matching</em></p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">safe_division_thrice</span>(a: <span class=\"hljs-type\">i32</span>, b: <span class=\"hljs-type\">i32</span>, c: <span class=\"hljs-type\">i32</span>, d: <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Option</span>&lt;<span class=\"hljs-type\">i32</span>&gt; {\n    <span class=\"hljs-keyword\">match</span> <span class=\"hljs-title function_ invoke__\">safe_division</span>(a, b) {\n        <span class=\"hljs-title function_ invoke__\">Some</span>(x) =&gt; <span class=\"hljs-keyword\">match</span> <span class=\"hljs-title function_ invoke__\">safe_division</span>(x, c) {\n            <span class=\"hljs-title function_ invoke__\">Some</span>(y) =&gt; <span class=\"hljs-title function_ invoke__\">safe_division</span>(y, d),\n            <span class=\"hljs-literal\">None</span> =&gt; <span class=\"hljs-literal\">None</span>,\n        },\n        <span class=\"hljs-literal\">None</span> =&gt; <span class=\"hljs-literal\">None</span>,\n    }\n}\n</code></pre>\n<p><em>With the question mark operator</em></p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">safe_division_thrice</span>(a: <span class=\"hljs-type\">i32</span>, b: <span class=\"hljs-type\">i32</span>, c: <span class=\"hljs-type\">i32</span>, d: <span class=\"hljs-type\">i32</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Option</span>&lt;<span class=\"hljs-type\">i32</span>&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">first</span> = <span class=\"hljs-title function_ invoke__\">safe_division</span>(a, b)?;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">second</span> = <span class=\"hljs-title function_ invoke__\">safe_division</span>(first, c)?;\n    <span class=\"hljs-title function_ invoke__\">safe_division</span>(second, d)\n}\n</code></pre>\n</details>\n<br>\n<h4 id=\"and_then\" tabindex=\"-1\"><code>and_then</code></h4>\n<p>Another way to chain these enums without writing deep pattern matching statements is the <a href=\"https://doc.rust-lang.org/rust-by-example/error/option_unwrap/and_then.html\"><code>and_then</code></a> combinator.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">one</span> = <span class=\"hljs-title function_ invoke__\">safe_division</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>)\n    .<span class=\"hljs-title function_ invoke__\">and_then</span>(|x| <span class=\"hljs-title function_ invoke__\">safe_division</span>(x, <span class=\"hljs-number\">2</span>));\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">oops</span> = <span class=\"hljs-title function_ invoke__\">safe_division</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>)\n    .<span class=\"hljs-title function_ invoke__\">and_then</span>(|x| <span class=\"hljs-title function_ invoke__\">safe_division</span>(x, <span class=\"hljs-number\">2</span>));\n</code></pre>\n<p>It extracts the wrapped value and then applies the function provided as its argument to it. In case the value is <code>None</code> or <code>Error</code>, it will short circuit the function and return that value.</p>\n<p>In our case, it will extract the result of the first function. Then, it will take that result and pass it to the anonymous function we provided, which is the same as safe_division, but with the second argument already provided.</p>\n<h2 id=\"conclusion\" tabindex=\"-1\">Conclusion</h2>\n<p>In this article, we covered the basics of enums in Rust. We looked at what they are and how they can be useful. We also looked at pattern matching, a powerful tool that can be used with enums. We also briefly covered two common enums – <code>Option</code> and <code>Result</code> – and the methods that you can use to handle them.</p>\n<p>If you would like to read more beginner-friendly articles about Rust, be sure to follow us on <a href=\"https://twitter.com/serokell\">Twitter</a> or subscribe to our newsletter via the form below.</p>\n"
}