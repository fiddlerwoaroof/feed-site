{
  "title":"DataKinds Are Not What You Think",
  "date":"2022-11-15T00:00:00.000000Z",
  "author":"Vladislav Zavialov",
  "id":"https://serokell.io/blog/datakinds-are-not-what-you-think",
  "link":"https://serokell.io/blog/datakinds-are-not-what-you-think",
  "content":"<p>The <code>DataKinds</code> language extension doesn’t work the way you think it does… probably. Of course I can’t possibly know what mental model you have for <code>DataKinds</code>. Perhaps you are one of the few who understand its true nature. But I’ve seen experts – yes, type-level Haskell wizards – fall into the trap that I’m about to expose.</p>\n<h2 id=\"how-datakinds-are-commonly-explained\" tabindex=\"-1\">How DataKinds are commonly explained</h2>\n<p>To set the stage, let’s take a look at how <code>DataKinds</code> are commonly explained.</p>\n<p>Matt Parsons in his article “Basic Type Level Programming in Haskell” (2017) writes:</p>\n<blockquote>\n<p><code>data Nat = Zero | Succ Nat</code></p>\n<p>In plain Haskell, this definition introduces a new type <code>Nat</code> with two value constructors, <code>Zero</code> and <code>Succ</code> (which takes a value of type <code>Nat</code>). With the <code>DataKinds</code> extension, this also defines some extra new tidbits. We get a new kind <code>Nat</code>, which exists in a separate namespace. And we get two new types: a type constant <code>'Zero</code>, which has the kind <code>Nat</code>, and a type constructor <code>'Succ</code>, which accepts a type of kind <code>Nat</code>.</p>\n</blockquote>\n<p>Sandy Maguire in his book “Thinking with Types” (2018) writes:</p>\n<blockquote>\n<p><code>data Bool = False | True</code></p>\n<p>… the <code>data Bool</code> definition above introduces the following things into scope (as usual):</p>\n<ul>\n<li>A type constructor <code>Bool</code> of kind <strong>Type</strong></li>\n<li>A data constructor <code>True</code> of type <code>Bool</code></li>\n<li>A data constructor <code>False</code> of type <code>Bool</code></li>\n</ul>\n<p>However, when <code>-XDataKinds</code> is enabled, our definition of <code>Bool</code> also\nintroduces the following into scope:</p>\n<ul>\n<li>A new kind: <strong>Bool</strong></li>\n<li>A promoted data constructor <code>'True</code> of kind <strong>Bool</strong></li>\n<li>A promoted data constructor <code>'False</code> of kind <strong>Bool</strong></li>\n</ul>\n</blockquote>\n<p>Rebecca Skinner in her article “An Introduction to Type Level Programming” (2021) writes:</p>\n<blockquote>\n<p><code>data ExampleColor = Red | Green | Blue</code></p>\n<p>Here we’re creating a sum type with constructors <code>Red</code>, <code>Green</code> and <code>Blue</code>, but thanks to <code>DataKinds</code> we’re also creating a new Kind with types <code>Red</code>, <code>Green</code> and <code>Blue</code>.</p>\n</blockquote>\n<p>The common theme in those explanations is that kinds are <em>created</em> from types, as if there was some duplication happening behind the scenes:</p>\n<p><img src=\"https://serokell.io/files/ha/halalaw6.DataKinds_Are_Not_What_You_ThinK_pic4_(3)_(1).png\" alt=\"duplication of types from kinds\"></p>\n<h2 id=\"what%E2%80%99s-wrong-with-this-explanation%3F\" tabindex=\"-1\">What’s wrong with this explanation?</h2>\n<p>Prior to GHC 8.0 (2016), this model used to work just fine because types and kinds were indeed entirely separate. But with the introduction of the type-in-type axiom, this picture became outdated and misleading. Here are a few lines of code that do not quite fit within this framework:</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> <span class=\"hljs-keyword\">family</span> <span class=\"hljs-type\">Sing</span> :: k -&gt; <span class=\"hljs-type\">Type</span></span>\n<span class=\"hljs-class\">\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-type\">FromSing</span> k <span class=\"hljs-keyword\">where</span></span>\n  fromSing :: <span class=\"hljs-type\">Sing</span> (a :: k) -&gt; k\n</code></pre>\n<p>At first glance, this does not even seem related to the picture above. And yet it reveals a fatal flaw in it. In the type signature for <code>fromSing</code>, is <code>k</code> a type or a kind?</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-title\">fromSing</span> :: <span class=\"hljs-type\">Sing</span> (a :: k) -&gt; k\n                   <span class=\"hljs-comment\">--  ↑     ↑</span>\n                   <span class=\"hljs-comment\">-- kind  type</span>\n</code></pre>\n<p>Well, the first occurrence is a kind, and the second occurrence is a type! How can one variable be a type and a kind simultaneously? This paradox is resolved by the following mental shift: there are no kinds. You heard that right.</p>\n<ul>\n<li><strong>Pre-8.0:</strong> terms have types, types have kinds.</li>\n<li><strong>Post-8.0:</strong> terms have types, types have types.</li>\n</ul>\n<p>We used to have terms, types, and kinds. Now we’re down to terms and types. Occasionally, however, the old terminology is still convenient. Saying “type of a type” every time is a bit awkward, so we may say “kind” instead. The important thing to keep in mind is that a kind isn’t a thing in itself; a type can be used as a kind.</p>\n<p>So in the example above, <code>k</code> is a <em>type</em> variable. It’s used as a kind in <code>Sing (a :: k)</code>, so we might also call it a <em>kind</em> variable. However, this is a statement about how it’s used, not about what it is.</p>\n<p>This suggests the following modification to our understanding of <code>DataKinds</code>:</p>\n<p><img src=\"https://serokell.io/files/ct/ctahu89d.DataKinds_Are_Not_What_You_ThinK_pic3_(3)_(1).png\" alt=\"how modified understanding of datakinds looks\"></p>\n<p>Compared to the previous model, we now have the type level and the term level, whereas kinds don’t get their own level and are merged into types. This is definitely an improvement, but it’s still incorrect in a subtle way. Since this interpretation of <code>DataKinds</code> is based on duplication, we end up with two separate <code>Bool</code>s. But are they really distinct?</p>\n<p>Building upon our definitions of <code>Sing</code> and <code>FromSing</code>, here are some instances for them:</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">SBool</span> (<span class=\"hljs-title\">a</span> :: <span class=\"hljs-type\">Bool</span>) where</span>\n  <span class=\"hljs-type\">STrue</span> :: <span class=\"hljs-type\">SBool</span> <span class=\"hljs-type\">True</span>\n  <span class=\"hljs-type\">SFalse</span> :: <span class=\"hljs-type\">SBool</span> <span class=\"hljs-type\">False</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> instance <span class=\"hljs-type\">Sing</span> @<span class=\"hljs-type\">Bool</span> = <span class=\"hljs-type\">SBool</span></span>\n<span class=\"hljs-class\">\n<span class=\"hljs-keyword\">instance</span> <span class=\"hljs-type\">FromSing</span> <span class=\"hljs-type\">Bool</span> <span class=\"hljs-keyword\">where</span></span>\n  fromSing :: <span class=\"hljs-type\">Sing</span> (a :: <span class=\"hljs-type\">Bool</span>) -&gt; <span class=\"hljs-type\">Bool</span>\n  fromSing <span class=\"hljs-type\">STrue</span>  = <span class=\"hljs-type\">True</span>\n  fromSing <span class=\"hljs-type\">SFalse</span> = <span class=\"hljs-type\">False</span>\n</code></pre>\n<p>Haskell is no stranger to puns. I could declare <code>data Proxy a = Proxy</code> and have two proxies in scope: one is a data constructor and the other is a type constructor. So it wouldn’t be unreasonable to assume that the same thing is happening with <code>Bool</code>: perhaps one is a type and the other one is a kind, yet they are internally distinct. Let me mark type and kind occurrences with different numbers:</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">SBool</span> (<span class=\"hljs-title\">a</span> :: <span class=\"hljs-type\">Bool1</span>) where</span>\n  <span class=\"hljs-type\">STrue</span> :: <span class=\"hljs-type\">SBool</span> <span class=\"hljs-type\">True</span>\n  <span class=\"hljs-type\">SFalse</span> :: <span class=\"hljs-type\">SBool</span> <span class=\"hljs-type\">False</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">type</span> instance <span class=\"hljs-type\">Sing</span> @<span class=\"hljs-type\">Bool1</span> = <span class=\"hljs-type\">SBool</span></span>\n<span class=\"hljs-class\">\n<span class=\"hljs-keyword\">instance</span> <span class=\"hljs-type\">FromSing</span> <span class=\"hljs-type\">Bool2</span> <span class=\"hljs-keyword\">where</span></span>\n  fromSing :: <span class=\"hljs-type\">Sing</span> (a :: <span class=\"hljs-type\">Bool1</span>) -&gt; <span class=\"hljs-type\">Bool2</span>\n  fromSing <span class=\"hljs-type\">STrue</span>  = <span class=\"hljs-type\">True</span>\n  fromSing <span class=\"hljs-type\">SFalse</span> = <span class=\"hljs-type\">False</span>\n</code></pre>\n<p>The hypothesis we need to test now is whether GHC thinks that <code>Bool1</code> and <code>Bool2</code> are actually distinct entities. The answer shall reveal itself if we compare the type signature of <code>fromSing</code> in the class declaration and in the instance:</p>\n<pre><code class=\"hljs language-haskell\"><span class=\"hljs-title\">fromSing</span> :: <span class=\"hljs-type\">Sing</span> (a :: k) -&gt; k\n<span class=\"hljs-title\">fromSing</span> :: <span class=\"hljs-type\">Sing</span> (a :: <span class=\"hljs-type\">Bool1</span>) -&gt; <span class=\"hljs-type\">Bool2</span>\n</code></pre>\n<p>We seem to instantiate <code>k</code> to <code>Bool1</code> in one position and to <code>Bool2</code> in another. So if we had <code>Bool</code> the type and <code>Bool</code> the kind, we would expect a type error of the following form:</p>\n<pre><code class=\"hljs language-none\">• Couldn't match type 'Bool' with kind 'Bool'\n</code></pre>\n<p>… because GHC couldn’t decide what <code>k</code> stands for. And yet the code above compiles just fine, which leads us to the only possible conclusion: there’s just one <code>Bool</code>.</p>\n<p><img src=\"https://serokell.io/files/uh/uh3seuc8.DataKinds_Are_Not_What_You_ThinK_pic2_(3)_(1).png\" alt=\"types and kinds are one!\"></p>\n<p>One might wonder: are <code>True</code> and <code>False</code> actually duplicated if <code>Bool</code> isn’t? As long as terms and types are separated, we can’t really tell. A term-level variable can’t occur in a type-level context or vice versa, so we can’t ask the compiler if the term-level <code>True</code> and the type-level <code>True</code> are equal. There is currently no way to test this hypothesis. One could indeed argue that promoted data constructors are a mirror image of their term-level counterparts.</p>\n<p>Dependent types, however, lead us to a more elegant model:</p>\n<p><img src=\"https://serokell.io/files/n9/n9lx0s5r.DataKinds_Are_Not_What_You_ThinK_pic1_(2)_(1).png\" alt=\"with dependent types, everything is an expression\"></p>\n<p>For now this simplification is out of reach, but, personally, I find it to be a very attractive direction.</p>\n<h2 id=\"conclusion\" tabindex=\"-1\">Conclusion</h2>\n<p>Enabling the <code>DataKinds</code> extension does not create new kinds. Instead, it allows existing types to be used as kinds. This objection isn’t based on vague philosophical grounds but has practical implications, as illustrated by a fairly basic use of singleton types that we covered.</p>\n"
}