{
  "title":"Get Started with Rust: Traits",
  "date":"2022-11-07T00:00:00.000000Z",
  "author":"Serokell staff",
  "id":"https://serokell.io/blog/rust-traits",
  "link":"https://serokell.io/blog/rust-traits",
  "content":"<h1 id=\"get-started-with-rust%3A-traits\" tabindex=\"-1\">Get Started with Rust: Traits</h1>\n<p>A trait is a basic language concept for defining shared behavior on types. Traits describe an interface that types can implement.</p>\n<p>Rust traits are a sibling of <a href=\"https://docs.scala-lang.org/tour/traits.html\">Scala traits</a> and <a href=\"https://serokell.io/blog/haskell-typeclasses\">Haskell type classes</a>, as well as a cousin of C++ and Java interfaces.</p>\n<p>This article will show you how to use traits in Rust. After reading it, you’ll be able to answer these questions:</p>\n<ul>\n<li>What is a trait?</li>\n<li>Why do we use traits in Rust?</li>\n<li>How to implement and define traits in Rust?</li>\n<li>What does it mean to derive a trait, and when can we do it?</li>\n</ul>\n<p>We expect that you are somewhat familiar with <a href=\"https://serokell.io/blog/structs-in-rust\">structs</a> and <a href=\"https://serokell.io/blog/enums-and-pattern-matching\">enums</a> in Rust.</p>\n<h2 id=\"what-is-a-trait%3F\" tabindex=\"-1\">What is a trait?</h2>\n<p>Traits allow us to define interfaces or shared behaviors on types. To implement a trait for a type, we need to implement methods of that trait.</p>\n<p>For example, let’s look at the simplified version of the <a href=\"https://doc.rust-lang.org/std/cmp/trait.PartialEq.html\"><code>PartialEq</code></a> trait, which allows us to define equality for user-defined types:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">PartialEq</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">eq</span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;<span class=\"hljs-keyword\">Self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span>;\n}\n</code></pre>\n<p>For a type to implement <code>PartialEq</code>, it needs to implement its method: <code>eq</code>. Implementing it allows us to write <code>x == y</code> and <code>x != y</code> for this type.</p>\n<h2 id=\"traits-are-everywhere\" tabindex=\"-1\">Traits are everywhere</h2>\n<p>You don’t need to dig too deep to find traits in Rust. Let’s look at a couple of examples.</p>\n<p>You might be familiar with <code>for</code> loops:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;{i}&quot;</span>);\n}\n<span class=\"hljs-comment\">// Prints: </span>\n<span class=\"hljs-comment\">// 1</span>\n<span class=\"hljs-comment\">// 2</span>\n<span class=\"hljs-comment\">// 3</span>\n</code></pre>\n<p>Rust’s <code>for</code> loop syntax is actually syntactic sugar for <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\">iterators</a>, which are responsible for the logic of iterating over some items.</p>\n<p>There’s a trait in the standard library for converting something to an iterator called <a href=\"https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\"><code>IntoIterator</code></a>. This is usually implemented for types that describe a collection. This includes Vectors, HashMaps, and Options.</p>\n<p>Let’s look at another example.</p>\n<p>Imagine that we’ve defined a simple <code>Book</code> struct and created an instance:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Book</span> {\n    title: <span class=\"hljs-type\">String</span>,\n    author: <span class=\"hljs-type\">String</span>\n}\n\n<span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">my_book</span> = Book {\n    title: <span class=\"hljs-type\">String</span>::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">&quot;Case of the Stuffed Goose&quot;</span>),\n    author: <span class=\"hljs-type\">String</span>::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">&quot;Theo Witty&quot;</span>),\n};\n</code></pre>\n<p>What can we do with it? Can we print a book?</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;My book: {my_book}&quot;</span>);\n</code></pre>\n<p>No. The code doesn’t compile:</p>\n<pre><code class=\"hljs language-none\">error: `Book` doesn't implement `std::fmt::Display`\nhelp: the trait `std::fmt::Display` is not implemented for `Book`\n</code></pre>\n<p>And the compiler gives us a hint. <code>std::fmt::Display</code> is a trait that we must implement for our <code>Book</code> struct if we want to print it out.</p>\n<p>What else can we try? Can we compare two books?</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">your_book</span> = Book {\n    title: <span class=\"hljs-type\">String</span>::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">&quot;Case of the Shrieking Bacon&quot;</span>),\n    author: <span class=\"hljs-type\">String</span>::<span class=\"hljs-title function_ invoke__\">from</span>(<span class=\"hljs-string\">&quot;Casey Fennimore&quot;</span>),\n};\n\n<span class=\"hljs-keyword\">if</span> my_book == your_book {\n\t...\n}\n</code></pre>\n<p>Also no. We get a slightly different, but similar compilation error:</p>\n<pre><code class=\"hljs language-none\">error: binary operation `==` cannot be applied to type `Book`\n   |\n   |     my_book == your_book\n   |     ------- ^^ --------- Book\n   |     |\n   |     Book\n   |\nnote: an implementation of `PartialEq&lt;_&gt;` might be missing for `Book`\nhelp: consider annotating `Book` with `#[derive(PartialEq)]`\n   |\n   | #[derive(PartialEq)]\n   |\n</code></pre>\n<p>We must implement <code>PartialEq</code> for our <code>Book</code> struct if we want to check for equality using the <code>==</code> operator.</p>\n<p>We’ve got a hint that we should provide an implementation for these traits. Let’s do that next.</p>\n<h2 id=\"how-to-implement-a-trait%3F\" tabindex=\"-1\">How to implement a trait?</h2>\n<h3 id=\"how-to-implement-a-trait-manually%3F\" tabindex=\"-1\">How to implement a trait manually?</h3>\n<p>We should keep in mind that a trait defines an interface. In order for a type to implement a trait, it must provide definitions of all the required methods.</p>\n<p>Let’s implement the <code>PartialEq</code> trait for <code>Book</code>. The only method we have to define is <code>eq</code>.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">PartialEq</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Book</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">eq</span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;<span class=\"hljs-keyword\">Self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n        <span class=\"hljs-keyword\">self</span>.title == other.title &amp;&amp; <span class=\"hljs-keyword\">self</span>.author == other.author\n    }\n}\n</code></pre>\n<p>These are a lot of new words at once, so let’s take a closer look. The first line defines the trait implementation:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">//[1][2]       [3] [4]</span>\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">PartialEq</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Book</span> {\n\n<span class=\"hljs-comment\">// [1]: `impl` keyword.</span>\n<span class=\"hljs-comment\">// [2]: The trait name (in this case, PartialEq).</span>\n<span class=\"hljs-comment\">// [3]: `for` keyword.</span>\n<span class=\"hljs-comment\">// [4]: The type name (in this case, Book).</span>\n</code></pre>\n<p>Then we have to define the method:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">//     [1][2]    [3]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">eq</span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;<span class=\"hljs-keyword\">Self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n<span class=\"hljs-comment\">//      [4]</span>\n        <span class=\"hljs-keyword\">self</span>.title == other.title &amp;&amp; <span class=\"hljs-keyword\">self</span>.author == other.author\n    }\n}\n\n<span class=\"hljs-comment\">// [1]: Trait instance method has</span>\n<span class=\"hljs-comment\">// [2]: the **&amp;self** parameter as the first parameter;</span>\n<span class=\"hljs-comment\">// [3]: any extra parameters must come after.</span>\n<span class=\"hljs-comment\">// [4]: Implementation details.</span>\n</code></pre>\n<p><strong>Note:</strong> <code>eq</code> is an instance method – a trait method that requires an instance of the implementing type via the <code>&amp;self</code> argument. Traits can also define static methods that don’t require an instance and do not have <code>&amp;self</code> as their first parameter, but we aren’t going to cover them here.</p>\n<p>The <code>self</code> is an instance of the implementing type that gives us access to its internals. For example, we can get our struct fields with <code>self.title</code> and <code>self.author</code>.</p>\n<p>The actual implementation of <code>eq</code> is quite primitive. We compare each field between the structs and make sure that all of them are equal:</p>\n<pre><code class=\"hljs language-rust\">    <span class=\"hljs-keyword\">self</span>.title == other.title &amp;&amp; <span class=\"hljs-keyword\">self</span>.author == other.author\n</code></pre>\n<hr>\n<p>\uD83D\uDCA1 <strong><code>&amp;self</code> is syntactic sugar for <code>self: &amp;Self</code>.</strong></p>\n<p>The <code>Self</code> keyword is only available within type definitions, trait definitions, and <code>impl</code> blocks. In trait definitions, <code>Self</code> stands for the implementing type. For more information, see <a href=\"https://doc.rust-lang.org/reference/paths.html#self-1\">The Rust Reference</a>.</p>\n<hr>\n<p>We can compare our books now:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">if</span> my_book == your_book {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;We have the same book!&quot;</span>);\n} <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;We have different books.&quot;</span>);\n}\n<span class=\"hljs-comment\">// Prints: </span>\n<span class=\"hljs-comment\">// We have different books.</span>\n</code></pre>\n<hr>\n<p>\uD83D\uDCA1 <strong>Which common traits should my types implement?</strong></p>\n<p>There is no list of required traits. If you are writing an application, implement traits that you need as the need arises. If you are writing a library that will be used by others, it’s trickier. On the one hand, not adding a trait can limit your library users. On the other hand, removing a “wrong” trait is not backward-compatible. You can find more information on interoperability in the <a href=\"https://rust-lang-nursery.github.io/api-guidelines/interoperability.html\">Rust API Guidelines</a>.</p>\n<hr>\n<p>Defining traits can be tedious and error-prone. That’s why it’s common to ask the compiler for help. The Rust compiler can provide an implementation for some of the traits via the derive mechanism.</p>\n<h3 id=\"deriving-a-trait\" tabindex=\"-1\">Deriving a trait</h3>\n<p>Let’s drop the <code>PartialEq</code> implementation for the <code>Book</code> and rewind back to the compiler error:</p>\n<pre><code class=\"hljs language-none\">error: binary operation `==` cannot be applied to type `Book`\n   |\n   |     my_book == your_book\n   |     ------- ^^ --------- Book\n   |     |\n   |     Book\n   |\nnote: an implementation of `PartialEq&lt;_&gt;` might be missing for `Book`\nhelp: consider annotating `Book` with `#[derive(PartialEq)]`\n   |\n   | #[derive(PartialEq)]\n   |\n</code></pre>\n<p>The compiler not only tells us what the issue is but also suggests a solution for it. Let’s follow the instructions and annotate the <code>Book</code> struct with <code>#[derive(PartialEq)]</code>:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[derive(PartialEq)]</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Book</span> {\n    title: <span class=\"hljs-type\">String</span>,\n    author: <span class=\"hljs-type\">String</span>\n}\n</code></pre>\n<p>We can compare the books again and it should behave the same:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">if</span> my_book == your_book {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;We have the same book!&quot;</span>);\n} <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;We have different books.&quot;</span>);\n}\n<span class=\"hljs-comment\">// Prints: </span>\n<span class=\"hljs-comment\">// We have different books.</span>\n</code></pre>\n<p><code>derive</code> generates the implementation of a trait for us. We don’t have to do the work ourselves. It provides a generally useful behavior that we don’t have to worry about. For example, in the case of derived <code>PartialEq</code> on structs, two instances are equal if all the fields are equal, and not equal if any fields aren’t equal.</p>\n<p>We can derive multiple traits at the same time – <code>derive</code> accepts a list of all the required traits inside the parentheses. Let’s try to derive <code>Display</code> so we can print our books:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-meta\">#[derive(PartialEq, Display)]</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Book</span> {\n    title: <span class=\"hljs-type\">String</span>,\n    author: <span class=\"hljs-type\">String</span>\n}\n</code></pre>\n<p>Unfortunately, it doesn’t compile:</p>\n<pre><code class=\"hljs language-rust\">error: cannot find derive <span class=\"hljs-keyword\">macro</span> `Display` <span class=\"hljs-keyword\">in</span> this scope\n</code></pre>\n<p>It says that it can’t find the way to derive it in this scope. But the compiler won’t be able to find it in any scope! Because <code>Display</code> can’t be derived. The <code>Display</code> trait is used for user-facing output, and Rust cannot decide for you how to pretty print your type. Should it print the name of the struct? Should it print all the fields? You have to answer these and other questions yourself.</p>\n<p>Deriving is limited to a certain number of traits. In case you want to implement a trait that can’t be derived or you want to implement a specific behavior for a derivable trait, you can write the functionality yourself.</p>\n<hr>\n<p>\uD83D\uDCA1 <strong>Which standard library traits can be derived?</strong></p>\n<p>Rust book’s <a href=\"https://doc.rust-lang.org/book/appendix-03-derivable-traits.html#appendix-c-derivable-traits\">Appendix C: Derivable Traits</a> provides a reference of all the derivable traits in the standard library.</p>\n<p>\uD83D\uDCA1 <strong>Can the non-standard-library traits be derived?</strong></p>\n<p>Yes. Developers can implement <code>derive</code> for their own traits through <a href=\"https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros\">procedural macros</a>.</p>\n<p>\uD83D\uDCA1 <strong>When should I implement and when should I derive traits?</strong></p>\n<p>When deriving is available, it provides a general implementation of the trait, which is what you want most of the time. If it’s not the case, you can manually define the desired behavior.</p>\n<hr>\n<h2 id=\"how-to-define-a-trait%3F\" tabindex=\"-1\">How to define a trait?</h2>\n<p>Until now, we have only been talking about other people’s traits. But we can also define our own traits.</p>\n<p>Imagine that we want to estimate reading time. It shouldn’t matter what type of content we are reading (an article, a novel, or even a poem). We could use the following trait:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">//    [1]</span>\n<span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">Estimatable</span> {\n<span class=\"hljs-comment\">//  [2]         [3]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">estimate</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">f64</span>;\n}\n\n<span class=\"hljs-comment\">// [1]: The trait name (in this case, Estimatable).</span>\n<span class=\"hljs-comment\">// [2]: Trait methods (in this case, only one).</span>\n<span class=\"hljs-comment\">// [3]: The **&amp;self** parameter, followed by other parameters (in this case, none)</span>\n</code></pre>\n<p><strong>Note:</strong> We are using a simple type for minutes for the sake of simplicity. Try not to do this at home! And try not to do this in production!</p>\n<p>Any type implementing the <code>Estimatable</code> trait should define an <code>estimate</code> method that calculates how long it might take to read something in minutes.</p>\n<p>Let’s try doing that.</p>\n<h3 id=\"implementing-a-trait-for-an-enum\" tabindex=\"-1\">Implementing a trait for an enum</h3>\n<p>In the previous section, we implemented a trait for a struct. Let’s try working with an enum this time. Imagine that we have a personal blog with different kinds of content:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Content</span> {\n    Infographic,\n    PersonalEssay { text: <span class=\"hljs-type\">String</span> },\n    TechArticle { text: <span class=\"hljs-type\">String</span>, topic: <span class=\"hljs-type\">String</span> },\n}\n</code></pre>\n<p>We can define the <code>Estimatable</code> trait for it. It’s not that different from implementing a trait for a struct, but note that we have to define behavior for all the enum variants:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Estimatable</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Content</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">estimate</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">f64</span> {\n        <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span> {\n            Content::Infographic =&gt; <span class=\"hljs-number\">1.0</span>,\n\n            Content::PersonalEssay { text } =&gt; \n                <span class=\"hljs-title function_ invoke__\">word_count</span>(text) / AVG_WORDS_PER_MINUTE,\n\n            <span class=\"hljs-comment\">// You have to pay attention, especially when learning Rust</span>\n            Content::TechArticle { text, topic } =&gt; {\n                <span class=\"hljs-keyword\">if</span> topic == <span class=\"hljs-string\">&quot;Rust&quot;</span> {\n                    <span class=\"hljs-title function_ invoke__\">word_count</span>(text) / (<span class=\"hljs-number\">0.5</span> * AVG_WORDS_PER_MINUTE)\n                } <span class=\"hljs-keyword\">else</span> {\n                    <span class=\"hljs-title function_ invoke__\">word_count</span>(text) / (<span class=\"hljs-number\">0.7</span> * AVG_WORDS_PER_MINUTE)\n                }\n            }\n        }\n    }\n}\n</code></pre>\n<p><strong>Note:</strong> For this example, imagine that <code>word_count</code> is a function that returns the number of words in a string and <code>AVG_WORDS_PER_MINUTE</code> is a constant for <code>250.0</code>.</p>\n<h3 id=\"default-implementations\" tabindex=\"-1\">Default implementations</h3>\n<p>Let’s revisit the <code>PartialEq</code> trait. We saw a simplified version before, here is the actual definition:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">PartialEq</span>&lt;Rhs = <span class=\"hljs-keyword\">Self</span>&gt;\n<span class=\"hljs-keyword\">where</span>\n    Rhs: ?<span class=\"hljs-built_in\">Sized</span>,\n{\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">eq</span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;Rhs) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span>;\n\n    <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">ne</span>(&amp;<span class=\"hljs-keyword\">self</span>, other: &amp;Rhs) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> { ... }\n}\n</code></pre>\n<p>When we defined the <code>PartialEq</code> implementation for the <code>Book</code>, we only had to implement one method, <code>eq</code>. But the definition clearly has two methods. How can this be?</p>\n<p>Trait definitions can provide default method definitions. <code>ne</code> is a method with a default implementation.</p>\n<p>As an example, we can extend the <code>Estimatable</code> trait with a <code>display_estimate</code> method:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">Estimatable</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">estimate</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">f64</span>;\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">display_estimate</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">String</span> {\n        <span class=\"hljs-built_in\">format!</span>(<span class=\"hljs-string\">&quot;{} minute(s)&quot;</span>, <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">estimate</span>())\n    }\n}\n</code></pre>\n<p>We don’t have to update the implementation for the <code>Content</code> type. It works as expected based on <code>estimate</code>:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;Estimated read: {}&quot;</span>, Content::Infographic.<span class=\"hljs-title function_ invoke__\">display_estimate</span>())\n<span class=\"hljs-comment\">// Prints:</span>\n<span class=\"hljs-comment\">// Estimated read: 1 minute(s)</span>\n</code></pre>\n<p>Sometimes it’s useful to have default behaviors for the trait methods. When someone implements the trait for their type, they can decide whether to keep or override the default implementations.</p>\n<hr>\n<p>Remember how we talked about iterators? The standard library provides a lot of useful methods for <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\"><code>Iterator</code></a> such as <code>map</code>, <code>filter</code>, and <code>fold</code>. As long as the collection implements either <a href=\"https://doc.rust-lang.org/std/iter/trait.Iterator.html\"><code>Iterator</code></a> or <a href=\"https://doc.rust-lang.org/std/iter/trait.IntoIterator.html\"><code>IntoIterator</code></a>, you get these for free.</p>\n<pre><code class=\"hljs language-rust\">(<span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">10</span>)                     <span class=\"hljs-comment\">// A range of integers</span>\n  .<span class=\"hljs-title function_ invoke__\">filter</span>(|x| x % <span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span>)   <span class=\"hljs-comment\">// Keep only odd numbers</span>\n  .<span class=\"hljs-title function_ invoke__\">map</span>(|x| x * x)           <span class=\"hljs-comment\">// Square each number</span>\n  .collect::&lt;<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt;&gt;(); <span class=\"hljs-comment\">// Return a new Vector</span>\n<span class=\"hljs-comment\">// [1, 9, 25, 49, 81]</span>\n</code></pre>\n<h2 id=\"how-to-use-traits-in-function-parameters%3F\" tabindex=\"-1\">How to use traits in function parameters?</h2>\n<p>Now that we know how to define our own traits, we can explore how to make use of them.</p>\n<p>A trait is an interface that defines behaviors with a contract that other code can rely on. We can implement functions that depend on this interface.</p>\n<p>In other words, we can implement functions that accept any type implementing our trait. The functions don’t need to know anything else about these types.</p>\n<p>Let’s see how we could implement a function similar to <code>println!</code> that can print any <code>Estimatable</code> type:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">//          [1] [2]              [3]  </span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">summarize</span>&lt;T: Estimatable&gt;(obj: T) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;Estimated read: {}&quot;</span>, obj.<span class=\"hljs-title function_ invoke__\">display_estimate</span>());\n}\n\n<span class=\"hljs-comment\">// [1]: The function takes any type T</span>\n<span class=\"hljs-comment\">// [2]: that is Estimatable.</span>\n<span class=\"hljs-comment\">// [3]: `obj` has a type T.</span>\n</code></pre>\n<p><code>&lt;T: Estimatable&gt;</code> declares a generic type parameter with a <a href=\"https://doc.rust-lang.org/book/ch10-02-traits.html#trait-bound-syntax\">trait bound</a>. We can use trait bounds to restrict generics. In this case, it says that we accept any type <code>T</code> that implements the <code>Estimatable</code> trait. (If you would like to learn more about generic type parameters, see the <a href=\"https://doc.rust-lang.org/book/ch10-01-syntax.html#generic-data-types\">Generic Data Types</a> chapter of The Rust Book.)</p>\n<p>In simple cases like this, we can use a more concise <code>impl Trait</code> syntax, which is syntactic sugar for trait bounds. We can rewrite it as follows:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">//          [1]   [2]  [3]</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">summarize</span>(obj: <span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Estimatable</span>) {\n    <span class=\"hljs-built_in\">println!</span>(<span class=\"hljs-string\">&quot;Estimated read: {}&quot;</span>, obj.<span class=\"hljs-title function_ invoke__\">display_estimate</span>());\n}\n\n<span class=\"hljs-comment\">// [1]: The `obj` parameter should be a type</span>\n<span class=\"hljs-comment\">// [2]: that **impl**ements </span>\n<span class=\"hljs-comment\">// [3]: the `Estimatable` trait.</span>\n</code></pre>\n<p>The syntax <code>impl Trait</code> is convenient in simple cases, while the trait bound syntax can express more complex use cases.</p>\n<p>Either way, we can now call <code>summarize</code>:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-title function_ invoke__\">summarize</span>(Content::Infographic)\n<span class=\"hljs-comment\">// Prints:</span>\n<span class=\"hljs-comment\">// Estimated read: 1 minute(s)</span>\n</code></pre>\n<p>If we try calling the <code>summarize</code> function with a type that doesn’t implement the <code>Estimatable</code> trait, the code won’t compile:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-title function_ invoke__\">summarize</span>(my_book)\n<span class=\"hljs-comment\">// error: the trait bound `Book: Estimatable` is not satisfied</span>\n</code></pre>\n<p>With traits, we can build functions that accept any type as long as it implements a certain behavior.</p>\n<hr>\n<p>\uD83D\uDCA1 <strong>We can also use traits as return types from functions.</strong></p>\n<p>For example, you can return an iterator from a function. Using traits in return types is less common than in parameters. If you are interested, make sure to explore <a href=\"https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\">it in The Rust Book</a>.</p>\n<hr>\n<h2 id=\"how-to-extend-traits%3F\" tabindex=\"-1\">How to extend traits?</h2>\n<p>Rust doesn’t have a concept of inheritance. However, you can define supertraits to specify that a trait is an extension of another trait.\nFor example, we can add another trait that adds a paywall to long reads on the website. For this, we need the ability to estimate from <code>Estimatable</code>, so we’ll extend it.</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-comment\">//    [1]        [2][3]</span>\n<span class=\"hljs-keyword\">trait</span> <span class=\"hljs-title class_\">PayWallable</span> : Estimatable {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">use_pay_wall</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span>;\n}\n\n<span class=\"hljs-comment\">// To define </span>\n<span class=\"hljs-comment\">// [1]: a subtrait,</span>\n<span class=\"hljs-comment\">// [2]: that extends </span>\n<span class=\"hljs-comment\">// [3]: the supertrait.</span>\n</code></pre>\n<p>If you want to implement a subtrait (<code>PayWallable</code>), you must implement all the required methods of the trait itself (<code>PayWallable</code>) as well as all the required methods of the supertrait (<code>Estimatable</code>).\nWhen you implement a method on a subtrait, you can use the functionality of the supertrait:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">PayWallable</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Book</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">use_pay_wall</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n        <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">estimate</span>() &gt; <span class=\"hljs-number\">10.0</span>\n    }\n}\n</code></pre>\n<p>But if you don’t implement the supertrait, you will get a compiler error:</p>\n<pre><code class=\"hljs language-none\">error[]: the trait bound `Book: Estimatable` is not satisfied\n    |\n    | impl PayWallable for Book {\n    |      ^^^^^^^^^^^ the trait `Estimatable` is not implemented for `Book`\n    |\n</code></pre>\n<p>We can fix the error by implementing the supertrait as well:</p>\n<pre><code class=\"hljs language-rust\"><span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Estimatable</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Book</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">estimate</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">f64</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">book_content</span> = <span class=\"hljs-title function_ invoke__\">get_book_content_todo</span>();\n        <span class=\"hljs-title function_ invoke__\">word_count</span>(&amp;book_content) / AVG_WORDS_PER_MINUTE\n    }\n}\n</code></pre>\n<h2 id=\"traits-have-many-uses\" tabindex=\"-1\">Traits have many uses</h2>\n<p>In this blog post, we’ve covered one major use case for traits. Traits can be used as <strong>interfaces</strong>. Traits can serve as a contract that defines an interaction between components that use the interface. All types implementing a given trait must support the functionality defined by this trait, but it can be implemented differently for each type.</p>\n<p>For example, a <code>sort</code> algorithm can be applied to a collection of items of any type, as long as they support comparison (implement the <code>Ord</code> trait).</p>\n<p>But traits are more flexible than that. Look at what different things we can do with traits:</p>\n<ul>\n<li>\n<p>Traits can be used to <strong>extend the functionality</strong> of types. We can use traits to add methods to types that are defined in other libraries. For example, the <code>itertools</code> library adds a lot of convenience methods to all iterators (outside of their definition).</p>\n</li>\n<li>\n<p>Traits can be used for <strong>dynamic dispatch</strong> (deciding which method to call at runtime). When used like this, they are very similar to Java interfaces.</p>\n</li>\n</ul>\n<p>There are many other uses: traits as abstract classes, as mix-ins, as <a href=\"https://doc.rust-lang.org/std/marker/index.html\">behavioral markers</a>, and for <a href=\"https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#default-generic-type-parameters-and-operator-overloading\">operator overloading</a>.</p>\n<h2 id=\"conclusion\" tabindex=\"-1\">Conclusion</h2>\n<p>Understanding traits and how the standard library traits work is an important part of learning Rust.</p>\n<p>We have learned that traits in Rust are a way to add functionality to structs or enums and define shared behavior between different types. We’ve also explored how to use traits as interfaces and peeked at the various uses of traits.</p>\n<p>If you would like to learn more about traits and the problems they solve, check out the Rust book chapters <a href=\"https://doc.rust-lang.org/book/ch10-02-traits.html\">on traits</a> and <a href=\"https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#advanced-traits\">advanced traits</a>, and the Rust Blog <a href=\"https://blog.rust-lang.org/2015/05/11/traits.html\">post about traits</a>.</p>\n<p>And if you would like to read more beginner-friendly articles about Rust, be sure to follow us on <a href=\"https://twitter.com/serokell\">Twitter</a> or subscribe to our newsletter via the form below.</p>\n"
}