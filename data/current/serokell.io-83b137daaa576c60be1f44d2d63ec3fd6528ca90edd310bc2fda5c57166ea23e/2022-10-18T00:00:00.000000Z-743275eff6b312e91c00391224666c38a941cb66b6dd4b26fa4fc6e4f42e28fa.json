{
  "title":"Support Vector Machine Algorithm",
  "date":"2022-10-18T00:00:00.000000Z",
  "author":"Inna Logunova",
  "id":"https://serokell.io/blog/support-vector-machine-algorithm",
  "link":"https://serokell.io/blog/support-vector-machine-algorithm",
  "content":"<p>The support vector machine (SVM) algorithm is a machine learning algorithm widely used because of its high performance, flexibility, and efficiency. In most cases, you can use it on terabytes of data, and it will still be much faster and cheaper than working with deep neural networks.</p>\n<p>The algorithm is used for a wide range of tasks such as text classification, handwriting and face recognition, and identification of genes, among others.</p>\n<p>In some cases, support vector machines enables simplified application of other ML methods. For example you can combine CNN and SVM, as described <a href=\"https://www.sciencedirect.com/science/article/pii/S1877050920307754\">here</a>.</p>\n<h2 id=\"what-is-a-support-vector-machine%3F\" tabindex=\"-1\">What is a support vector machine?</h2>\n<p>A support vector machine (SVM) is a supervised ML algorithm that performs classification or regression tasks by constructing a divider that separates data in two categories. The optimal divider is the one which is in equal distance from the boundaries of each group.</p>\n<p>The algorithm is more commonly used for classification than regression. In some articles, the SVM for regression is also called support vector regression (SVR). Check out <a href=\"https://towardsdatascience.com/unlocking-the-true-power-of-support-vector-regression-847fd123a4a0\">this post</a> to learn more about SVR.</p>\n<h2 id=\"how-does-the-support-vector-machine-classifier-work%3F\" tabindex=\"-1\">How does the support vector machine classifier work?</h2>\n<p>As a starting point, let’s consider a simple example with a two-dimensional dataset.</p>\n<p>Suppose we have a dataset with two features – x and y – where each entry is tagged with one of two classes (represented with yellow and green colors). Our goal is to build a classifier that can classify unknown points into one of these classes according to their features.</p>\n<p><img src=\"https://serokell.io/files/9b/9bz0z228.Support_Vector_Machine_pic1.png\" alt=\"Support vector machine classifier\"></p>\n<p>The obvious way of dividing these classes would be to draw a line that separates the entries with “yellow” and “green” classes. But there is an infinite number of possible lines to draw. How can we know which one is correct?</p>\n<p><img src=\"https://serokell.io/files/ec/ecdid3f7.Support_Vector_Machine_pic2.png\" alt=\"SVM classifier\"></p>\n<p>The best possible line that we can draw from the data in the training set is the one that has the greatest distance to the boundary points of each class. In our example, it’s H<sub>2</sub>.</p>\n<p>Then, when we can use this line to classify points to each of these classes. The points that fall on the “yellow side” of the line will be classified as yellow, the points that fall on the “green side” will be classified as green. For this reason, we call it a <a href=\"https://en.wikipedia.org/wiki/Decision_boundary\">decision boundary</a>.</p>\n<p><img src=\"https://serokell.io/files/8t/8t4hbvmu.Support_Vector_Machine_pic3.png\" alt=\"Decision boundary in SVM\"></p>\n<p>Let’s look at the two pictures above to understand how we chose the decision boundary.</p>\n<p>First, we only pay attention to the points on the boundary between two classes and can safely forget about many others.</p>\n<p>Now we perform a calculation. We linearly connect each pair of points on opposite sides, and the center of this line is equidistant from the classes on the boundary lines. These support points on the boundary lines are actually the sequence containers representing arrays. From now on, we will call them support vectors.</p>\n<p>Finally, the line formed based on these middle points is our boundary line. In our example, it is a straight line, but it also can be a curve. We’ll see how that is possible later.</p>\n<p><img src=\"https://serokell.io/files/su/suedi6sr.Support_Vector_Machine_pic4.png\" alt=\"Linear decision boundary in support vector machine\"></p>\n<p>As with any supervised ML case, after training the model, we need to measure the quality of the model’s performance with a test set. After successful verification, the model can work with raw data.</p>\n<p>If you want to go deeper into the mathematical foundation of the topic, this <a href=\"https://see.stanford.edu/materials/aimlcs229/cs229-notes3.pdf\">detailed explanation</a> will be helpful.</p>\n<h2 id=\"hard-margin-vs.-soft-margin-in-support-vector-machines\" tabindex=\"-1\">Hard margin vs. soft margin in support vector machines</h2>\n<p>In the example above, we discussed a case where the points from the two classes are clearly separated. There, we worked with what’s called a hard margin.</p>\n<p>In cases where it’s complicated to build a decision boundary without misclassifying some of the boundary points, we have to loosen the rules by introducing a soft margin.</p>\n<h3 id=\"what-does-a-hard-margin-mean%3F\" tabindex=\"-1\">What does a hard margin mean?</h3>\n<p>The hard margin means that the SVM is very rigid in classification and tries to perform extremely well in the training set, covering all available data points. This works well when the deviation is insignificant, but can lead to overfitting, in which case we would need to switch to a soft margin.</p>\n<h3 id=\"what-does-a-soft-margin-mean%3F\" tabindex=\"-1\">What does a soft margin mean?</h3>\n<p>The idea behind the soft margin is based on a simple assumption: allow the support vector classifier to make some mistakes while still keeping the margin as large as possible.</p>\n<p>If we want a soft margin, we have to decide how to ignore some of the outliers while still getting good classification results. The solution is to introduce penalties for outfitting that are regulated by the C parameter (as it’s called in many frameworks).</p>\n<h3 id=\"which-margin-to-choose%3F\" tabindex=\"-1\">Which margin to choose?</h3>\n<p>We use an SVM with hard margin when data is evidently separable. However, we may choose the soft margin when we have to disregard some of the outliers to improve the model’s overall performance.</p>\n<h3 id=\"c-hyperparameter-for-svm-turning\" tabindex=\"-1\">C hyperparameter for SVM turning</h3>\n<p>The C hyperparameter is relevant in the case of soft margin. For each misclassified data point, it applies a penalty. When C is low, choosing a decision boundary with a large margin can lead to more misclassifications because the penalty for misclassified points is low. When C is large, the support vector machine model tries to reduce the number of misclassified examples due to the high penalty, and this results in a decision boundary with a narrower margin. Not all misclassified points receive the same penalty. The further a misclassified point is from the boundary, the larger penalty it gets.</p>\n<p><img src=\"https://serokell.io/files/nq/nqj1it01.Support_Vector_Machine_pic5_1.png\" alt=\"SVM with large value of C\"></p>\n<p>Thanks to soft margins, the model can violate the support vector machine’s boundaries to choose a better classification line. The lower the deviation of the outliers from the actual borders in the soft margin (the distance of the misclassified point from its actual plane), the more accurate the SVM road becomes. Choosing the correct soft margin value ensures that the support vector machine has the right balance between clean boundaries and generalizability.</p>\n<p><img src=\"https://serokell.io/files/ez/ezoj21mb.Support_Vector_Machine_pic5_2.png\" alt=\"SVM with small value of C\"></p>\n<h2 id=\"applying-svm-to-nonlinear-data\" tabindex=\"-1\">Applying SVM to nonlinear data</h2>\n<p>Now, let’s look at more complicated cases where data cannot be separated with a line. What should we do if the dataset’s yellow tags are mixed with the green ones as in the picture below?</p>\n<p><img src=\"https://serokell.io/files/ng/ngfg59q5.Support_Vector_Machine_pic6.png\" alt=\"Nonlinear data in support vector machine \"></p>\n<p>The solution is to add a third dimension to data.</p>\n<p><img src=\"https://serokell.io/files/gi/giaf65gn.Support_Vector_Machine_pic7_1.png\" alt=\"Constructing a hyperplane\"></p>\n<p><img src=\"https://serokell.io/files/fz/fzjim8dl.Support_Vector_Machine_pic7_2.png\" alt=\"Hyperplane in support vector machine\"></p>\n<p>If we embed data in a higher-dimensional feature space, it’s possible to find a classifier to separate the two classes. This is done by what’s called a kernel function.</p>\n<p><img src=\"https://serokell.io/files/5b/5b3zqoeh.Support_Vector_Machine_pic8_3.png\" alt=\"Kernel function\"></p>\n<h3 id=\"kernel-functions\" tabindex=\"-1\">Kernel functions</h3>\n<p>To add more dimensions to the dataset, we use a <a href=\"https://programmathically.com/what-is-a-kernel-in-machine-learning/\">kernel function</a>.</p>\n<p>A simple example of a kernel function is a <a href=\"https://en.wikipedia.org/wiki/Polynomial_kernel\">polynomial kernel</a>, which builds a new dimension for the dataset based on polynomials of original variables.</p>\n<p>Let’s look at an example. On the picture on the left, the dataset’s classes lie in a straight line. The picture on the right shows the same dataset after we added an extra dimension to it (by setting the other axis value to be the square of the values of points), which makes the data points linearly separable.</p>\n<p><img src=\"https://serokell.io/files/tb/tbnwrv5w.Support_Vector_Machine_pic9.png\" alt=\"Linear separation of data points using kernel function\"></p>\n<p>Another popular kernel is <a href=\"https://en.wikipedia.org/wiki/Radial_basis_function_kernel\">Gaussian RBF</a>. To make classes linearly separable, it uses the radial basis function, the value of which solely depends on the distance between a fixed point and the input. For two points x1 and x2, the RBF kernel function calculates their similarity, or how close they are to each other.</p>\n<p>To improve the performance of a kernel function, we can introduce a tuning parameter called gamma.</p>\n<p>The gamma parameter of the RBF controls the radius of influence of a single training point. A large similarity radius, indicated by low gamma values, results in more points being grouped. At high gamma values, points must be quite close to each other to be grouped (or assigned to a class). As a result, overfitting is more common in models with very high gamma values. The concept is better explained by the following visualizations.</p>\n<p><img src=\"https://serokell.io/files/03/03dwyame.Support_Vector_Machine_pic10.png\" alt=\"Low gamma\"></p>\n<p><img src=\"https://serokell.io/files/g8/g8fk3hvk.Support_Vector_Machine_pic11.png\" alt=\"Large gamma\"></p>\n<p>Watch this video to learn more about the application of kernels in support vector machines.</p>\n\n<h2 id=\"advantages-of-support-vector-machines\" tabindex=\"-1\">Advantages of support vector machines</h2>\n<h3 id=\"resilient-to-overfitting\" tabindex=\"-1\">Resilient to overfitting</h3>\n<p>Except for the points closest to the plane (support vectors), most of the remaining data becomes redundant. When working with the boundary points, we can intentionally allow some outliers to be misclassified to see the big picture and determine the optimal hyperplane.</p>\n<h3 id=\"simplified-calculation\" tabindex=\"-1\">Simplified calculation</h3>\n<p>Once the hyperplane is built, we can assign a class to the data points located in the classified area without the need to calculate the distances between each point.</p>\n<p>The SVM algorithm doesn’t work well in the following situations:</p>\n<ul>\n<li>The dataset contains a lot of classes.</li>\n<li>The dataset contains a lot of noise.</li>\n<li>The target classes overlap.</li>\n</ul>\n<h2 id=\"support-vector-machine-use-cases\" tabindex=\"-1\">Support vector machine use cases</h2>\n<p><img src=\"https://serokell.io/files/j6/j69hf6d3.Support_Vector_Machine_pic12.png\" alt=\"Support vector machine use cases\"></p>\n<p>The support vector machine algorithm is widely used despite the development of more sophisticated machine learning techniques, such as deep neural networks. The reason is that the model trains quickly, has minimal processing requirements, and enables you to teach the algorithm based on a limited amount of data points rather than computing the whole training data set.</p>\n<p>Some of the common applications of support vector machines are described below.</p>\n<h3 id=\"computational-biology\" tabindex=\"-1\">Computational biology</h3>\n<p>The detection of protein remote homology is a common issue in computational biology. In recent years, SVM algorithms have been extensively applied for solving this problem. These algorithms are widely used for biological sequence identification, classifying genes, predicting patients’ diseases based on their genes, etc.</p>\n<h3 id=\"steganography-detection\" tabindex=\"-1\">Steganography detection</h3>\n<p>With the help of SVMs, you can tell whether a digital image has been altered or contaminated. The algorithm can detect unauthorized data and watermarks illegally embedded into official documents. The support vector machine separates the individual pixels and stores the data in different datasets, making it easy to analyze.</p>\n<h3 id=\"face-recognition\" tabindex=\"-1\">Face recognition</h3>\n<p>The SVM classifier divides the elements of the image into face and non-face categories. First it is inputted training information for n × n pixels with face (+1) and non-face (-1) classes. Then it separates the features of each pixel into the face or non-face categories. Based on the pixel brightness, it draws a square frame around the faces and classifies each image.</p>\n<h3 id=\"text-categorization\" tabindex=\"-1\">Text categorization</h3>\n<p>Using training data, the support vector machine classifies documents into many categories, including news stories, emails, and web pages. For example, you can group news into “business” and “movies” or classify web pages into personal home pages and others. For that, a score is calculated for each document and compared to a given threshold. Documents are then assigned to particular categories if their score exceeds a specific value. If the value is below the threshold, the document is defined as a general one.</p>\n<h3 id=\"image-classification\" tabindex=\"-1\">Image classification</h3>\n<p>SVMs can classify images more accurately compared to traditional query-based refinement systems.</p>\n<h3 id=\"surface-categorization\" tabindex=\"-1\">Surface categorization</h3>\n<p>SVMs are used to determine textures. The algorithm performs well in categorizing surfaces in photographs as smooth or rough.</p>\n<h3 id=\"handwriting-recognition\" tabindex=\"-1\">Handwriting recognition</h3>\n<p>SVMs are used to read handwritten characters for data entry and signature verification.</p>\n<h3 id=\"geoscience\" tabindex=\"-1\">Geoscience</h3>\n<p>The SVM is successfully employed in the analysis and modeling of geospatial and spatiotemporal environmental data.</p>\n<p>Watch the video below as a recap on how the support vector machine works and what applications it has.</p>\n\n<h2 id=\"conclusion\" tabindex=\"-1\">Conclusion</h2>\n<p>SVMs are easy to implement and interpret. They provide high accuracy with less effort and computation. In addition to working on its own, the algorithm is a powerful machine learning tool to lay the basis for further investigation by neural networks. The support vector machine classifier is essential for developing applications that use predictive models and can be used in any domain.</p>\n"
}