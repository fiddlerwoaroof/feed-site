{
  "title":"The inherent unreliability of after_commit callbacks and most service objects’ implementation",
  "date":"2022-11-12T08:00:00.000000Z",
  "author":"Karol Galanciak",
  "id":"https://karolgalanciak.com/blog/2022/11/12/the-inherent-unreliability-of-after_commit-callback-and-most-service-objects-implementation",
  "link":"https://karolgalanciak.com/blog/2022/11/12/the-inherent-unreliability-of-after_commit-callback-and-most-service-objects-implementation/",
  "content":"<p>Service objects and/or <code class=\"language-plaintext highlighter-rouge\">after_commit</code> callbacks are ubiquitous in most real-world Rails applications. Whether it’s a good idea or not (ActiveRecord callbacks - I’m looking at you) is a different story, but one thing that is notoriously overlooked in the <strong>application design</strong> is <strong>reliability</strong>. And yes, the service objects are equally bad as <code class=\"language-plaintext highlighter-rouge\">after_commit</code> callbacks in that regard.</p>\n\n<p>Let’s explore the concept of reliability and also some solutions that can help solve the problem.</p>\n\n\n\n<h2 id=\"using-transactions-and-reliability\">Using transactions and reliability</h2>\n\n<p>Typically, <code class=\"language-plaintext highlighter-rouge\">after_commit</code> callbacks are used for executing side effects after the transaction. And for a good reason! This is usually where some background jobs are scheduled, and it would be pointless to do that from, for example, the <code class=\"language-plaintext highlighter-rouge\">after_save</code> callback as the transaction can fail. In such a scenario, the background job will never be processed and will keep failing with the <code class=\"language-plaintext highlighter-rouge\">ActiveRecord::RecordNotFound</code>error. So using <code class=\"language-plaintext highlighter-rouge\">after_commit</code> sounds like a great design decision, right? Right..?</p>\n\n<p>Unfortunately - <strong>no</strong>. Let’s make this problem even more apparent with a simple service object:</p>\n\n<div class=\"language-rb highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">UserCreator</span>\n  <span class=\"k\">def</span> <span class=\"nf\">call</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n    <span class=\"n\">user</span> <span class=\"o\">=</span> <span class=\"no\">User</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">user</span><span class=\"p\">.</span><span class=\"nf\">valid?</span>\n      <span class=\"no\">ActiveRecord</span><span class=\"o\">::</span><span class=\"no\">Base</span><span class=\"p\">.</span><span class=\"nf\">transaction</span> <span class=\"k\">do</span>\n        <span class=\"n\">user</span><span class=\"p\">.</span><span class=\"nf\">save!</span>\n        <span class=\"no\">UserProfile</span><span class=\"p\">.</span><span class=\"nf\">create!</span><span class=\"p\">(</span><span class=\"ss\">user: </span><span class=\"n\">user</span><span class=\"p\">)</span>\n      <span class=\"k\">end</span>\n      <span class=\"no\">UserCreatedNotifierJob</span><span class=\"p\">.</span><span class=\"nf\">perform_async</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">.</span><span class=\"nf\">id</span><span class=\"p\">)</span>\n      <span class=\"no\">MySuperCriticalJobThatAbsolutelyNeedsToBeExecuted</span><span class=\"p\">.</span><span class=\"nf\">perform_async</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">.</span><span class=\"nf\">id</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span>\n      <span class=\"k\">raise</span> <span class=\"no\">ActiveRecord</span><span class=\"o\">::</span><span class=\"no\">RecordInvalid</span><span class=\"p\">.</span><span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>There is nothing special here, and at first glance, it might actually look quite solid - there is a transaction block for two separate writes, so either both will succeed, or both will fail so that the state will be consistent. And also, the side effects are outside the transaction block, and they happen after the commit, just like <code class=\"language-plaintext highlighter-rouge\">after_commit</code>.</p>\n\n<p>So what’s the problem here?</p>\n\n<p>There is no guarantee that anything after the transaction block will be executed. As far as the transaction goes, this is entirely clear - it will just work as you expect. However, once the transaction ends, there is a chance that the rest of the logic might just not be executed. And exactly the same thing applies to <code class=\"language-plaintext highlighter-rouge\">after_commit</code> callbacks.</p>\n\n<p>The process might experience Out Of Memory error and will be killed right after the transaction block. It might also be restarted, or maybe the node where the actual process is running might be taken down. There are multiple ways how it can happen. It doesn’t mean that it happens often, it’s more of a relatively rare edge case, but on a huge scale, even the low-chance events can happen multiple times per day. And it would be pretty bad if <code class=\"language-plaintext highlighter-rouge\">MySuperCriticalJobThatAbsolutelyNeedsToBeExecuted</code> was not executed 100% of the time.</p>\n\n<p>The key question to ask at this point would be: what’s the solution to that problem? For sure, moving the execution of the side effects to the transaction block is not the solution. Having some errors in the background jobs is definitely the least problematic scenario you could experience.</p>\n\n<p>Imagine performing some HTTP requests that modify the state in some external service. If the transaction failed, an automatic rollback handled by ActiveRecord wouldn’t be enough - you would also need to execute some compensatory logic on the third-party service, which not only brings massive complexity, but it might also be not easily doable - for example, if that service delivers some notifications, e.g., SMS message or even just sends an email.</p>\n\n<p>Fortunately, there is a well-established pattern precisely to this problem. It’s a transactional outbox.</p>\n\n<h2 id=\"transactional-outbox-pattern\">Transactional Outbox Pattern</h2>\n\n<p>The transactional outbox pattern is based on the atomicity of the transactions (and no, we don’t need a distributed transaction here) - either everything fails or everything succeeds.</p>\n\n<p>To apply this pattern, we need to create something extra in the transaction - a dedicated Outbox Entry record that will stand for the execution of some side effects. Then, some external process will fetch it, execute the side effects, and mark the entry as processed (or destroy the record to not re-execute it again in the future).</p>\n\n<p>Essentially, it would be using an ACID database as a temporary message queue.</p>\n\n<p>Here is how we could visualize the entire flow:</p>\n\n<p><img src=\"/assets/images/transactional_outbox/transactional_outbox.jpg\" alt=\"Graph\"></p>\n\n<p class=\"center\">\n  <a href=\"/assets/images/transactional_outbox/transactional_outbox.jpg\">See in better quality</a>\n</p>\n\n<p>As the graph shows, the<code class=\"language-plaintext highlighter-rouge\">UserCreator</code> service creates all the records within the same transaction, including the <code class=\"language-plaintext highlighter-rouge\">OutboxEntry</code>. Later, some Outbox worker (a separate process) picks unprocessed records (probably in the infinite loop), executes the logic (ideally, scheduling Sidekiq jobs where the actual side effects will be executed), and marks the entries as processed so that the records will not be processed again in the next iteration. It’s important to keep in mind that it will likely imply the at-least-once delivery semantics as the process might get killed after scheduling jobs (but right before marking entries as processed), so the jobs need to be idempotent. Funny enough, that’s another potential reliability issue inside the solution that is supposed to bring more reliability.</p>\n\n<p>The unclear part is how exactly the Outbox worker will know what logic to execute once it fetches the entries. The essential thing is that the entry itself should contain some indicators. It could be, for example, the event name with the  ID and name of the created model (so here: “user_created” <code class=\"language-plaintext highlighter-rouge\">event</code> with “User” as <code class=\"language-plaintext highlighter-rouge\">model_class</code> and its ID as <code class=\"language-plaintext highlighter-rouge\">model_id</code>) and based on that, you could implement some pub-sub mechanism using model class and its ID as arguments. Or you could store the name of the service instead of the event name and implement some dedicated method/hook, like <code class=\"language-plaintext highlighter-rouge\">on_success</code> that would be executed by the worker:</p>\n\n<div class=\"language-rb highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">UserCreator</span>\n  <span class=\"k\">def</span> <span class=\"nc\">self</span><span class=\"o\">.</span><span class=\"nf\">on_success</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">)</span>\n    <span class=\"no\">UserCreatedNotifierJob</span><span class=\"p\">.</span><span class=\"nf\">perform_async</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">.</span><span class=\"nf\">id</span><span class=\"p\">)</span>\n    <span class=\"no\">MySuperCriticalJobThatAbsolutelyNeedsToBeExecuted</span><span class=\"p\">.</span><span class=\"nf\">perform_async</span><span class=\"p\">(</span><span class=\"n\">user</span><span class=\"p\">.</span><span class=\"nf\">id</span><span class=\"p\">)</span>\n  <span class=\"k\">end</span>\n\n  <span class=\"k\">def</span> <span class=\"nf\">call</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">)</span>\n    <span class=\"c1\"># original method goes here</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n</code></pre></div></div>\n\n<p>Using events might be a bit more complex, but it can sometimes be worth it. One of the significant benefits is that such a solution will make it easier to use event sourcing in the future or at least have an event-driven architecture.</p>\n\n<p>We’ve managed to cover service objects, but what about <code class=\"language-plaintext highlighter-rouge\">after_commit</code> callbacks? Ideally, you would not use them at all. However, if there are already there in the app and the refactoring/rewrite is not feasible, there are some things that you could do that are not that complex.</p>\n\n<p>First, you would need to use some other dedicated callback that would work like <code class=\"language-plaintext highlighter-rouge\">after_commit</code> but would not be a part of <code class=\"language-plaintext highlighter-rouge\">ActiveRecord</code>, for example, a custom <code class=\"language-plaintext highlighter-rouge\">reliable_after_commit</code> that would have the same interface as <code class=\"language-plaintext highlighter-rouge\">after_commit</code>. The next step would be to keep these callbacks in some registry accessible from the outside (like <code class=\"language-plaintext highlighter-rouge\">Model.reliable_after_callbacks</code>) so that the worker can easily execute each of them. And since <code class=\"language-plaintext highlighter-rouge\">after_commit</code> callbacks often contain some logic taking advantage of dirty-tracking (<code class=\"language-plaintext highlighter-rouge\">previous_changes</code>), you would also need to store such changeset with the Outbox Entry and bring back that state in the Outbox worker when materializing the model record.</p>\n\n<p>Sounds complex? Fortunately, you don’t need to implement this logic or even the worker itself. You can use <a href=\"https://github.com/BookingSync/rails-transactional-outbox\">rails-transactional-outbox gem</a> that I extracted from one of the <a href=\"https://www.bookingsync.com\">BookingSync</a>  projects as an experimental way of addressing reliability concerns.</p>\n\n<h2 id=\"conclusions\">Conclusions</h2>\n\n<p><strong>Reliability</strong> is a factor that is arguably often overlooked when it comes to implementing business logic, at least if judging it by the popularity (or lack of it) of a <strong>transactional outbox pattern</strong> or other alternatives. Fortunately, the pattern itself is not very complex, and some solutions are available as <a href=\"https://github.com/BookingSync/rails-transactional-outbox\">gems</a> that make it easy to apply the pattern in your Rails applications.</p>"
}