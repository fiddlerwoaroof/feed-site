<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="https://kddnewton.com/feed.xml" rel="self" type="application/atom+xml"><link href="https://kddnewton.com/" rel="alternate" type="text/html"><updated>2022-10-21T03:52:31+00:00</updated><id>https://kddnewton.com/feed.xml</id><title type="html">Kevin Newton</title><subtitle>Personal website</subtitle><author><name>Kevin Newton</name></author><entry><title type="html">AArch64 Bitmask Immediates</title><link href="https://kddnewton.com/2022/08/11/aarch64-bitmask-immediates.html" rel="alternate" type="text/html" title="AArch64 Bitmask Immediates"><published>2022-08-11T00:00:00+00:00</published><updated>2022-08-11T00:00:00+00:00</updated><id>https://kddnewton.com/2022/08/11/aarch64-bitmask-immediates</id><content type="html" xml:base="https://kddnewton.com/2022/08/11/aarch64-bitmask-immediates.html">&lt;p&gt;This post illustrates a small but fascinating piece of the &lt;a href=&quot;https://en.wikipedia.org/wiki/AArch64&quot;&gt;AArch64&lt;/a&gt; architecture called bitmask immediates. We’ll briefly cover what AArch64 is, how it is different from other architectures, what a bitmask immediate is, and how all of this can be encoded in Rust.&lt;/p&gt;

&lt;p&gt;For context, I work at Shopify on &lt;a href=&quot;https://github.com/Shopify/yjit&quot;&gt;YJIT&lt;/a&gt;, a just-in-time compiler for CRuby. Lately I’ve been working on adding support for the AArch64 architecture; practically this means support for Apple M1s. Learning the ARM architecture and encoding it has been quite an adventure; you can check out our &lt;a href=&quot;https://github.com/Shopify/ruby/tree/yjit_backend_ir/yjit/src/asm/arm64&quot;&gt;working branch&lt;/a&gt; if you’d like to follow along.&lt;/p&gt;

&lt;h2 id=&quot;fixed-width-instruction-sets&quot;&gt;Fixed-width instruction sets&lt;/h2&gt;

&lt;p&gt;First, a bit of background. AArch64 is a fixed-width instruction set of 32-bits. That means every instruction, every time, is 32-bits. This is pretty different from, for example, &lt;a href=&quot;https://en.wikipedia.org/wiki/X86-64&quot;&gt;x86-64&lt;/a&gt;, which allows variable-width instructions making encoding large values quite a bit easier.&lt;/p&gt;

&lt;p&gt;For example, if you’re attempting to move a 64-bit value into a 64-bit register, it’s 1 instruction on x86-64, and (at worst) 4 instructions on AArch64. Let’s say the value is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xC3FFFFFFC3FFFFFF&lt;/code&gt;. On x86-64, you would run:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mov %RAX, 0xC3FFFFFFC3FFFFFF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(&lt;a href=&quot;https://godbolt.org/z/MabvKPbsf&quot;&gt;Compiler Explorer&lt;/a&gt;). This says to move the immediate 64-bit value into the RAX register, overwriting whatever was there previously. This encodes as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;48 B8 FF FF FF C3 FF FF FF C3
^^^^^
mov RAX
      ^^^^^^^^^^^^^^^^^^^^^^^
      0xC3FFFFFFC3FFFFFF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s 10 bytes in total. On AArch64, you would instead run:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;movz X0, #0xC3FF
movk X0, #0xFFFF, lsl 16
movk X0, #0xC3FF, lsl 32
movk X0, #0xFFFF, lsl 48
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(&lt;a href=&quot;https://godbolt.org/z/KdKTMP6zv&quot;&gt;Compiler Explorer&lt;/a&gt;). This says to first, move the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xC3FF&lt;/code&gt; 16-bit value into the X0 register and clear out the rest of the register by setting all other bits to 0. Then move the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xFFFF&lt;/code&gt; 16-bit value into the X0 register shifted left (lsl means logical shift left) by 16 bits, and keep the other bits in the register the same (i.e., leave &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xC3FF&lt;/code&gt; in place). Then do the same for the other two 16-bit values. This encodes as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;E0 7F 98 D2 E0 FF BF D2 E0 7F D8 D2 E0 FF FF D2
^^^^^^^^^^^
movz X0, 0xC3FF
            ^^^^^^^^^^^
            movk X0, 0xFFFF, lsl 16
                        ^^^^^^^^^^^
                        movk X0, 0xC3FF, lsl 32
                                    ^^^^^^^^^^^
                                    movk X0, 0xFFFF, lsl 48
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s 16 bytes (4 for each 4-byte instruction). Because the width of the value that we’re trying to move into the register is larger than the width of the instructions, AArch64 designers were forced to be a bit creative by splitting up the overall immediate.&lt;/p&gt;

&lt;h2 id=&quot;bitmask-immediates&quot;&gt;Bitmask immediates&lt;/h2&gt;

&lt;p&gt;There is another encoding for this same operation that can be accomplished in one instruction, however. A very common use-case when you’re writing assembly is to compare a value against a bitmask, as in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;value &amp;amp; 0b1111&lt;/code&gt; to pull out the lower 4 bits of a number. This was common enough that the designers of AArch64 came up with a way to encode the most common patterns of bitmasks all of the way up to 64-bits, while excluding the less common patterns: bitmask immediates.&lt;/p&gt;

&lt;p&gt;The official &lt;a href=&quot;https://developer.arm.com/documentation/dui0802/b/A64-General-Instructions/MOV--bitmask-immediate-#:~:text=Is%20the%20bitmask%20immediate%2e&quot;&gt;documentation&lt;/a&gt; for ARM explains bitmask immediates in the following way:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Such an immediate is a 32-bit or 64-bit pattern viewed as a vector of identical elements of size e = 2, 4, 8, 16, 32, or 64 bits. Each element contains the same sub-pattern: a single run of 1 to e-1 non-zero bits, rotated by 0 to e-1 bits. This mechanism can generate 5,334 unique 64-bit patterns (as 2,667 pairs of pattern and their bitwise inverse). Because the all-zeros and all-ones values cannot be described in this way, the assembler generates an error message.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Like our example above, usually you’ve got one or more sequential 1s that you want to use in a logical comparison (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;or&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;and&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xor&lt;/code&gt;, etc.). To encode this kind of pattern on AArch64, these instructions have allocated 13 bits within the 32-bit instruction. Those 13 bits are broken up into 3 parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; (1 bit) - whether or not the pattern we’re encoding is 64-bits wide&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imms&lt;/code&gt; (6 bits) - the size of the pattern, a 0, and then one less than the number of sequential 1s&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;immr&lt;/code&gt; (6 bits) - the number of right rotations to apply to the pattern&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;immr&lt;/code&gt; are relatively quick to understand because they correspond to other constructs in the instruction set. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imms&lt;/code&gt; however is quite a mind-bender. This table helps illuminate what we’re talking about here:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;imms&lt;/th&gt;
      &lt;th&gt;element size&lt;/th&gt;
      &lt;th&gt;number of 1s&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 1 1 1 0 x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;2 bits&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 1 1 0 x x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;4 bits&lt;/td&gt;
      &lt;td&gt;1-3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 1 0 x x x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;8 bits&lt;/td&gt;
      &lt;td&gt;1-7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 0 x x x x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;16 bits&lt;/td&gt;
      &lt;td&gt;1-15&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0 x x x x x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;32 bits&lt;/td&gt;
      &lt;td&gt;1-31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x x x x x x&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;64 bits&lt;/td&gt;
      &lt;td&gt;1-63&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Below I’ll show a couple of examples of these values being encoded.&lt;/p&gt;

&lt;h3 id=&quot;2-bit-patterns&quot;&gt;2-bit patterns&lt;/h3&gt;

&lt;p&gt;When &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imms&lt;/code&gt; starts with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;11110x&lt;/code&gt;, it means that the pattern is 2 bits in size, and the number of 1s is always 1. In this case &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;immr&lt;/code&gt; can only effectively indicate that it can be rotated 0 or 1 time. The only pattern this works for is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;01&lt;/code&gt;, which can optionally be right-rotated by 1 bit. The resulting 2 options for 2-bit patterns are:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;N&lt;/th&gt;
      &lt;th&gt;imms&lt;/th&gt;
      &lt;th&gt;immr&lt;/th&gt;
      &lt;th&gt;bits&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111100&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000000&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0101010101010101010101010101010101010101010101010101010101010101&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111100&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000001&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1010101010101010101010101010101010101010101010101010101010101010&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;4-bit-patterns&quot;&gt;4-bit patterns&lt;/h3&gt;

&lt;p&gt;When &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imms&lt;/code&gt; starts with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1110xx&lt;/code&gt;, it means that the pattern is 4 bits in size, and there can be 1, 2, or 3 sequential 1s. This works for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0001&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0011&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0111&lt;/code&gt;, and all of the allowable right-rotations of these numbers (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0001&lt;/code&gt; can actually have a 1 in any position). The resulting 12 options for 4-bit patterns are:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;N&lt;/th&gt;
      &lt;th&gt;imms&lt;/th&gt;
      &lt;th&gt;immr&lt;/th&gt;
      &lt;th&gt;bits&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111000&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000000&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0001000100010001000100010001000100010001000100010001000100010001&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111000&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000001&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1000100010001000100010001000100010001000100010001000100010001000&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111000&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000010&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0100010001000100010001000100010001000100010001000100010001000100&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111000&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000011&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0010001000100010001000100010001000100010001000100010001000100010&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111001&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000000&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0011001100110011001100110011001100110011001100110011001100110011&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111001&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000001&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1001100110011001100110011001100110011001100110011001100110011001&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111001&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000010&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1100110011001100110011001100110011001100110011001100110011001100&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111001&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000011&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0110011001100110011001100110011001100110011001100110011001100110&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111010&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000000&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0111011101110111011101110111011101110111011101110111011101110111&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111010&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000001&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1011101110111011101110111011101110111011101110111011101110111011&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111010&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000010&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1101110111011101110111011101110111011101110111011101110111011101&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;111010&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000011&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1110111011101110111011101110111011101110111011101110111011101110&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;other-patterns&quot;&gt;Other patterns&lt;/h3&gt;

&lt;p&gt;You can see that this idea can be replicated to the 8-bit, 16-bit, 32-bit, and 64-bit options. Notice that for 64-bit patterns, the values are not copied since it fills the entire width.&lt;/p&gt;

&lt;h2 id=&quot;encoding-values&quot;&gt;Encoding values&lt;/h2&gt;

&lt;p&gt;It’s important to note that not every value can be encoded. If the value does not correspond to a binary representation that consists of one set of sequential 1s that can be copied up to 64 bits, it can’t be encoded. The problem then becomes finding the correct values for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imms&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;immr&lt;/code&gt; for a given value if that triplet exists.&lt;/p&gt;

&lt;p&gt;The language I’m writing this in is Rust, but pretty much any language can do the kind of bit manipulation necessary to determine these values. Rust does have some niceties that I’ll take advantage of though. Since we are attempting to convert an unsigned integer into a bitmask immediate, I’ll first define a struct for the bitmask immediate:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitmaskImmediate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;imms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;immr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Next, I’ll implement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TryFrom&amp;lt;u64&amp;gt;&lt;/code&gt; for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;BitmaskImmediate&lt;/code&gt;. You could implement this for each unsigned integer size, but we pass around unsigned integers in our intermediate representation so this is the only one I need. The outline for implementing this trait looks like the following:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TryFrom&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitmaskImmediate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;try_from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(())&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Implementing this trait allows us to call:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;immediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitmaskImmediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.try_into&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We are then free to unwrap, map, or otherwise manipulate the result as we see fit.&lt;/p&gt;

&lt;p&gt;The first steps in implementing this trait are some edge cases. The documentation specifically mentions that all 0s and all 1s cannot be represented as a bitmask immediate. We’ll handle those first:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The next step is to determine the size of the pattern that we’re dealing with. To do this, we’ll start at 64-bits and work downward. If the binary representation of the value is equal to itself when shifted by 32 bits, then we know we can continue. Otherwise, it must be a 64-bit pattern. Similarly, if the binary representation of the value is equal to itself when shifted by 16 bits, we can continue on. We continue on in this manner until we find the size. That code looks like the following:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now that we have the size, we also inherently have the pattern — although it may be rotated. So the next step is to determine the number of left rotations to get it back to having all 1s on the right side and all 0s on the left side. To do that, we’ll first need to quick helper functions.&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;/// Is this number's binary representation all 1s?&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;/// Is this number's binary representation one or more 1s followed by&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;/// one or more 0s?&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_shifted_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;is_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These utility functions are necessary to help us figure out when the pattern has been rotated enough. Finally, we can find the number of rotations. If the number is already a shifted mask (i.e., it’s just a series of 1s and then a series of 0s) it’s relatively trivial to find the number of rotations: count the number of trailing 0s. If it’s split up (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1001&lt;/code&gt;), then we need to add together the number of trailing and leading 0s. (Because of number representations, we actually flip all of the bits first to make them 1s first.) The code to do that looks like the following:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trailing_ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left_rotations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;is_shifted_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_rotations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.trailing_zeros&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;trailing_ones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left_rotations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.trailing_ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;is_shifted_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Err&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(());&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leading_ones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.leading_ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_rotations&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leading_ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;trailing_ones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leading_ones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imm&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.trailing_ones&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;64&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now that we have the size of the pattern, the number of sequential 1s, and the number of rotations, we have all of the information that we need. We can encode the values of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imms&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;immr&lt;/code&gt; like so:&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;// immr is the number of right rotations it takes to get from the&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// matching unrotated pattern to the target value.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;immr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left_rotations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// imms is encoded as the size of the pattern, a 0, and then one less&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;// than the number of sequential 1s.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;trailing_ones&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;// n is 1 if the element size is 64-bits, and 0 otherwise.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitmaskImmediate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;imms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imms&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x3f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;immr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;immr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0x3f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;u8&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s it! We have successfully encoded a bitmask immediate for an unsigned integer.&lt;/p&gt;

&lt;h2 id=&quot;testing-our-encoding&quot;&gt;Testing our encoding&lt;/h2&gt;

&lt;p&gt;We can now write a couple of tests to verify the code is behaving as we expect. Writing a full test suite for this is outside the scope of this post, but below are a couple of the tests that made sense to write.&lt;/p&gt;

&lt;div class=&quot;language-rust highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;#[test]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_size_16_minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bitmask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;BitmaskImmediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;try_from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0x0001000100010001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;matches!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bitmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitmaskImmediate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;immr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0b000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0b100000&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[test]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_size_16_rotated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bitmask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;BitmaskImmediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;try_from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0xff8fff8fff8fff8f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;matches!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bitmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitmaskImmediate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;immr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0b001001&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0b101100&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nd&quot;&gt;#[test]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;test_size_16_maximum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bitmask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;BitmaskImmediate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;try_from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0xfffefffefffefffe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;matches!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bitmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Ok&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BitmaskImmediate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;immr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0b001111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imms&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0b101110&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;})));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These tests exercise the minimum and maximum values encodeable into a 16-bit pattern. Additionally it tests a random 16-bit pattern that has been rotated.&lt;/p&gt;

&lt;h2 id=&quot;putting-it-all-together&quot;&gt;Putting it all together&lt;/h2&gt;

&lt;p&gt;Now that we have this code available to us, we can actually use a more efficient version of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov&lt;/code&gt; instruction that supports encoding bitmask immediates. Since we were trying to move &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xC3FFFFFFC3FFFFFF&lt;/code&gt; into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;X0&lt;/code&gt;, we can actually directly do:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mov X0, 0xC3FFFFFFC3FFFFFF
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;(&lt;a href=&quot;https://godbolt.org/z/d1x3nsKqE&quot;&gt;Compiler Explorer&lt;/a&gt;). We can do this because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0xC3FFFFFFC3FFFFFF&lt;/code&gt; can be directly encoded into a bitmask immediate. Its binary representation is:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1100001111111111111111111111111111000011111111111111111111111111
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is actually the following 32-bit pattern rotated twice to the right:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00000011111111111111111111111111
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The components of our bitmask immediate will then be:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N&lt;/code&gt; = 0 since it’s not a 64-bit pattern&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;imms&lt;/code&gt; = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;011011&lt;/code&gt; to indicate a 32-bit pattern with 28 zeroes&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;immr&lt;/code&gt; = &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;000010&lt;/code&gt; to indicate 2 right rotations of the pattern&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Which means that the overall instruction is encoded as:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;B2 02 6F E0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Where before we had 16 bytes, we now only have 4! This is quite a reduction in size, and will result in a smaller binary size in the end.&lt;/p&gt;

&lt;p&gt;In YJIT we lower every one of our intermediate representation instructions that load a value into a series of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mov&lt;/code&gt; instructions. If &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;try_into()&lt;/code&gt; results in an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ok&lt;/code&gt;, we use that representation first, since it’s the most compact. Otherwise we fall back to the first approach we described with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;movz&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;movk&lt;/code&gt; instructions.&lt;/p&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;I hope someone finds this helpful. I don’t imagine it’s all that common place to write your own AArch64 encoder, let alone encode bitmask immediates. But for that one person that reads this and needs this information, I hope it’s helpful to you! If you’re looking for a reference, you can find the source code related to this post &lt;a href=&quot;https://github.com/Shopify/ruby/blob/73f567b0c1635a36c2f77da182108010dcd0d29d/yjit/src/asm/arm64/arg/bitmask_imm.rs&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;</content><author><name>Kevin Newton</name></author><summary type="html">This post illustrates a small but fascinating piece of the AArch64 architecture called bitmask immediates. We’ll briefly cover what AArch64 is, how it is different from other architectures, what a bitmask immediate is, and how all of this can be encoded in Rust.</summary></entry><entry><title type="html">Syntax Tree and lambda-local variables</title><link href="https://kddnewton.com/2022/05/16/syntax-tree-lambda-locals.html" rel="alternate" type="text/html" title="Syntax Tree and lambda-local variables"><published>2022-05-16T00:00:00+00:00</published><updated>2022-05-16T00:00:00+00:00</updated><id>https://kddnewton.com/2022/05/16/syntax-tree-lambda-locals</id><content type="html" xml:base="https://kddnewton.com/2022/05/16/syntax-tree-lambda-locals.html">&lt;p&gt;I just released version &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.6.0&lt;/code&gt; of Syntax Tree. Along with a couple of other changes, this includes support for lambda-local variable declarations. This was a bit of a journey, so I thought I’d write up how I discovered this syntax, how I added support for it to Syntax Tree, and go ahead and plug Syntax Tree one more time as something that should be merged into Ruby core.&lt;/p&gt;

&lt;p&gt;If you want to skip straight to the code, here’s the &lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree/pull/84/files&quot;&gt;pull request&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;lambda-local-variables&quot;&gt;lambda-local variables&lt;/h2&gt;

&lt;p&gt;What are lambda-local variables? (Side note: I have no idea if that’s the correct terminology. I might be making it up.) You &lt;em&gt;may&lt;/em&gt; be familiar with block-local variables. If you’re not don’t worry about it — you’re certainly not the only one. I’ll introduce both quickly. First, let’s look at the syntax for block-local variables:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;single&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;triple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;single&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; 10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What is going on here? It turns out that &lt;em&gt;after&lt;/em&gt; all of the regular parameter declarations on blocks, you can use a semicolon to indicate that you want to declare block-local variables. Those variables are exclusively scoped to the block, and will not effect variables declared outside the block (notice that printing the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;double&lt;/code&gt; variable after the block shows us it has its initial value).&lt;/p&gt;

&lt;p&gt;You can do the same thing with lambda literals. For example, if we were to do the same kind of thing as the above example:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;perform&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;single&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;triple&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;single&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;

  &lt;span class=&quot;nb&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;single&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;triple&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;perform&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;nb&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; 10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’ve never actually seen someone use this feature. You probably haven’t either. That’s okay, that’s not actually what this post is about.&lt;/p&gt;

&lt;h2 id=&quot;discovery&quot;&gt;Discovery&lt;/h2&gt;

&lt;p&gt;Lately, I’ve been working on translating Syntax Tree’s AST into other Ruby ASTs in my &lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree-translator&quot;&gt;ruby-syntax-tree/syntax_tree-translator&lt;/a&gt; project. This project has a lot of different uses, not all of which I’m ready to share just yet.&lt;/p&gt;

&lt;p&gt;In the translator project’s test suite, I pull in the tests for &lt;a href=&quot;https://github.com/whitequark/parser&quot;&gt;whitequark/parser&lt;/a&gt; and &lt;a href=&quot;https://github.com/seattlerb/ruby_parser&quot;&gt;seattlerb/ruby_parser&lt;/a&gt;. I do this so that I can assert that my translated tree when translated matches their expected tree when parsed. When doing this, I noticed a lot of interesting differences with the parsers. One of the things that stood out from this list was an entire class of failures involving lambda-local variables.&lt;/p&gt;

&lt;p&gt;Since Syntax Tree is based on ripper, I was surprised to find that there was syntax that it didn’t handle. Only issue was, this was irrefutable evidence that it didn’t. Both the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ruby_parser&lt;/code&gt; gems were showing me their ASTs, and they both had references to these locals (I also learned because of this that they’re sometimes called shadow variables).&lt;/p&gt;

&lt;h2 id=&quot;support&quot;&gt;Support&lt;/h2&gt;

&lt;p&gt;Because &lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree&quot;&gt;Syntax Tree&lt;/a&gt; is a syntax tree and formatter for the Ruby language, it necessarily has to support every kind of syntax in the language. This includes so many things that most folks will never use. But to be correct, it’s all or nothing. So, in that spirit, I went about adding support for lambda-local variables.&lt;/p&gt;

&lt;p&gt;I know from exhaustively looking at ripper classes that ripper didn’t support this out of the box, otherwise I would have seen it. This meant going into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse.y&lt;/code&gt; and finding the specific production rule to edit. Fortunately, the &lt;a href=&quot;https://github.com/ruby/ruby/pull/5801/files&quot;&gt;pull request&lt;/a&gt; wasn’t so bad. I’m not going to go into this pull request too much, but if you’re interested in learning more check out my post on &lt;a href=&quot;/2022/02/14/formatting-ruby-part-1.html&quot;&gt;how ripper works&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Now that I know Ruby will eventually support it, I needed to support it in Syntax Tree for all of the existing versions. The first step was going to be to add support for the new event once it gets into ripper. That itself is not so bad, and looks like most of the other ripper event handlers in Syntax Tree:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# :call-seq:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   on_lambda_var: (Params params, Array[ Ident ] locals) -&amp;gt; LambdaVar&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_lambda_var&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;location&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;locals&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;any?&lt;/span&gt;

  &lt;span class=&quot;no&quot;&gt;LambdaVar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;params: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;locals: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;locals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;location: &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This first determines its location by looking at its children, the instantiates a new node. Not so bad. This will work in versions going forward. However, to support previous versions, we’re going to need to parse the code ourselves without the help of the parser generator.&lt;/p&gt;

&lt;h2 id=&quot;parsing&quot;&gt;Parsing&lt;/h2&gt;

&lt;p&gt;In order to write our own parser, we’re going to need the tokens first. Fortunately, ripper ships with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper.lex&lt;/code&gt;, which will provide those tokens. If you lex the source for an example in the console, you’ll get the following output:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;lex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-&amp;gt;(; local) {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;[[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:on_tlambda&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-&amp;gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ENDFN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;                    
 &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:on_lparen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;(&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;BEG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;LABEL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;                  
 &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:on_semicolon&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;BEG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;                     
 &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:on_sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;BEG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;                            
 &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:on_ident&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;local&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;CMDARG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;                  
 &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:on_rparen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ENDFN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;                     
 &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:on_sp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot; &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;ENDFN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;                         
 &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:on_tlambeg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;{&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;BEG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;                      
 &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:on_rbrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;   
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first column is a tuple of line and column information. The second is the type of token. The third is the actual value. The fourth is the lexer state when it hit that token. Since we now have the tokens, we’ll need to write a little parser. Fortunately, this parser can be relatively simple and modeled as a state machine.&lt;/p&gt;

&lt;p&gt;First, we’re going to set an initial state. If we’ve found a semicolon, then we have to find an item first. (You can’t do &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;(;) {}&lt;/code&gt;.) So we’ll say our initial state is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:item&lt;/code&gt;. From there, if we hit an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:on_ident&lt;/code&gt; token, then we’ve received our item and we can transition to a new state. This new state should either look for an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:on_comma&lt;/code&gt; (to indicate another local is present) or an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:on_rparen&lt;/code&gt; to indicate we’ve hit the end of the list. Favor in a couple of whitespace events like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:on_sp&lt;/code&gt; and we’ve got ourselves a state machine. The machine itself is described in ASCII art below:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ┌────────┐               ┌────────┐                ┌─────────┐
    │        │               │        │                │┌───────┐│
──&amp;gt; │  item  │ ─── ident ──&amp;gt; │  next  │ ─── rparen ──&amp;gt; ││ final ││
    │        │ &amp;lt;── comma ─── │        │                │└───────┘│
    └────────┘               └────────┘                └─────────┘
       │  ^                     │  ^
       └──┘                     └──┘
   ignored_nl, sp              nl, sp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The reason we have to do this validation is that you can actually have a semicolon in a couple of places within those parentheses, and we need to make sure we’re parsing the correct pattern. For example:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;While this is a bit contrived, if we didn’t have our state machine we would choke on this input because it would see the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;;&lt;/code&gt; and attempt to parse lambda-locals immediately afterward.&lt;/p&gt;

&lt;p&gt;With that, we’re done! We can map all of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:on_ident&lt;/code&gt; tokens into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyntaxTree::Ident&lt;/code&gt; nodes and pretend like it came in through the future &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_lambda_var&lt;/code&gt; method. When we eventually drop support for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3.1&lt;/code&gt; in 2025, we can remove all of this extraneous code.&lt;/p&gt;

&lt;h2 id=&quot;syntax-tree&quot;&gt;Syntax Tree&lt;/h2&gt;

&lt;p&gt;I want to take just a second to talk about why an object layer above the AST is so valuable. Ruby core understandably doesn’t want to commit to an AST structure. The logic is that it’s too easy to get pinned into supporting a structure that you want to change. I understand this argument, and sympathize with its intention. I certainly wouldn’t want to lay more work on an already overburdened team of dedicated individuals.&lt;/p&gt;

&lt;p&gt;However, Syntax Tree can ease that burden by providing this abstraction. I can release this new version of Syntax Tree outside the release cycle of Ruby to fix this for consumers of the AST. If there are breaking changes, folks can continue to use old versions of the gem. The actual change that’s occurring within Syntax Tree that could potentially impact folks boils down to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyntaxTree::Lambda&lt;/code&gt;’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;params&lt;/code&gt; field is now a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;LambdaVar | Paren&lt;/code&gt; as opposed to a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Params | Paren&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_lambda_var&lt;/code&gt; should be added to any visitors attempting to visit every node.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That’s a pretty small surface area for such a big change. Even though a lot of stuff had to change in the parser, not much has to change in the object layer. Just food for thought.&lt;/p&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;I really enjoyed this deep-dive into Ruby syntax. It was nice to be able to put my skills to the test and work on fixing up ripper’s behavior. I hope you can see from this post how this is possible!&lt;/p&gt;</content><author><name>Kevin Newton</name></author><summary type="html">I just released version 2.6.0 of Syntax Tree. Along with a couple of other changes, this includes support for lambda-local variable declarations. This was a bit of a journey, so I thought I’d write up how I discovered this syntax, how I added support for it to Syntax Tree, and go ahead and plug Syntax Tree one more time as something that should be merged into Ruby core.</summary></entry><entry><title type="html">ruby-syntax-tree.github.io</title><link href="https://kddnewton.com/2022/04/25/ruby-syntax-tree-github-io.html" rel="alternate" type="text/html" title="ruby-syntax-tree.github.io"><published>2022-04-25T00:00:00+00:00</published><updated>2022-04-25T00:00:00+00:00</updated><id>https://kddnewton.com/2022/04/25/ruby-syntax-tree-github-io</id><content type="html" xml:base="https://kddnewton.com/2022/04/25/ruby-syntax-tree-github-io.html">&lt;p&gt;Over the weekend I cobbled together &lt;a href=&quot;https://ruby-syntax-tree.github.io&quot;&gt;ruby-syntax-tree.github.io&lt;/a&gt;, and I thought I’d share a quick post about what it is, how it works, and what I learned while I built it.&lt;/p&gt;

&lt;h2 id=&quot;what-is-it&quot;&gt;What is it?&lt;/h2&gt;

&lt;p&gt;A lot of good tools exist in the Ruby ecosystem that allow you to run some version of Ruby in the browser. I’m talking about tools like &lt;a href=&quot;https://try.ruby-lang.org/&quot;&gt;try.ruby-lang.org&lt;/a&gt;, &lt;a href=&quot;https://runrb.io/&quot;&gt;runruby.io&lt;/a&gt;, and &lt;a href=&quot;https://sorbet.run/&quot;&gt;sorbet.run&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Usually getting Ruby to run in the browser entails using &lt;a href=&quot;https://emscripten.org/&quot;&gt;emscripten&lt;/a&gt; to compile C to &lt;a href=&quot;https://webassembly.org/&quot;&gt;WebAssembly&lt;/a&gt; or using &lt;a href=&quot;https://opalrb.com/&quot;&gt;Opal&lt;/a&gt; to compile Ruby to JavaScript. Recently, however, the &lt;a href=&quot;https://www.ruby.or.jp/en/news/20211025&quot;&gt;Ruby Association&lt;/a&gt; funded a project to compile Ruby to WebAssembly using the &lt;a href=&quot;https://github.com/WebAssembly/WASI&quot;&gt;WASI ABI&lt;/a&gt;. Using this new functionality, you can compile Ruby itself or a Ruby application into a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.wasm&lt;/code&gt; file that you can execute natively in the browser or through a polyfill. (You can actually execute it on any WebAssembly runtime, but for my purposes the browser will do.) For more information on the WASI Ruby project, check out the &lt;a href=&quot;https://itnext.io/final-report-webassembly-wasi-support-in-ruby-4aface7d90c9&quot;&gt;final report&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;So, to get to the titular question of this section. &lt;a href=&quot;https://ruby-syntax-tree.github.io&quot;&gt;ruby-syntax-tree.github.io&lt;/a&gt; is a website that uses the new WASI ABI functionality of Ruby to compile a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.wasm&lt;/code&gt; file containing both the Ruby runtime and the source for the &lt;a href=&quot;https://ruby-syntax-tree.github.com/syntax_tree&quot;&gt;Syntax Tree&lt;/a&gt; gem. It then boots a virtual machine within the browser and uses it to transpile your Ruby into equivalent s-expressions.&lt;/p&gt;

&lt;h2 id=&quot;how-it-works&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;Let’s start from the ground up. The first part of building the site was to build the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.wasm&lt;/code&gt; file containing the Ruby runtime and the Ruby files necessary to run Syntax Tree. Following instructions from the &lt;a href=&quot;https://github.com/ruby/ruby.wasm&quot;&gt;ruby/ruby.wasm&lt;/a&gt; README, I ran a bunch of commands locally to get my own machine up and running. Once I verified that I had everything I needed, I replicated that process in a &lt;a href=&quot;https://github.com/ruby-syntax-tree/ruby-syntax-tree.github.io/blob/main/Rakefile&quot;&gt;Rakefile&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One of the trickier parts was including Syntax Tree itself. I briefly considering including it as a git submodule so that it could be mounted as part of the wasi-vfs build process. I ended up scrapping that solution since dependabot wouldn’t be able to automatically update it, and I realized that if I ever wanted any other gems loaded I wanted a reproducable solution.&lt;/p&gt;

&lt;p&gt;Instead, I ended up using bundler as normal to install the dependencies. Once they were installed, I knew they existed &lt;em&gt;somewhere&lt;/em&gt; on the system. I also knew that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;require &quot;bundler/setup&quot;&lt;/code&gt; sets up the load paths so that you can require gems my name. So I decided to piggy-back on this functionality to copy the gem contents into the mounted directory. I found the right directory based on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$:&lt;/code&gt; load path global variable.&lt;/p&gt;

&lt;p&gt;With everything in place, I used wasi-vfs to build the file. For packaging this file into the built web application, I used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;esbuild&lt;/code&gt;. They don’t have built-in support for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.wasm&lt;/code&gt; files, but adding support isn’t hard. You can write your own plugin by mostly copy-pasting from their docs. That resulted in the esbuild plugin &lt;a href=&quot;https://github.com/ruby-syntax-tree/ruby-syntax-tree.github.io/blob/main/bin/wasmPlugin.js&quot;&gt;here&lt;/a&gt;. That makes it so that you can import &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.wasm&lt;/code&gt; files as you would normally import modules. The default export is a function that accepts the imports for the module, and it asynchronously returns the module. You can then use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ruby-head-wasm-wasi&lt;/code&gt; npm package that Ruby now ships to wrap up the module and provide an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;eval&lt;/code&gt; function to evaluate RUby code.&lt;/p&gt;

&lt;p&gt;Once the module is imported, it’s a matter of requiring the correct files at the top of the file. That’s accomplished by requiring the native gems that we need, then adding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lib&lt;/code&gt; directory we put the Syntax Tree gem into early to the load path, then requiring it. All of that is encapsulated in the &lt;a href=&quot;https://github.com/ruby-syntax-tree/ruby-syntax-tree.github.io/blob/main/src/createRuby.ts&quot;&gt;createRuby.ts&lt;/a&gt; file. The actual web application is a relatively standard React/TypeScript application. Since it’s not the novelty of this post, I won’t cover it, but you can check out the source &lt;a href=&quot;https://github.com/ruby-syntax-tree/ruby-syntax-tree.github.io/blob/main/src/index.tsx&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;what-i-learned&quot;&gt;What I learned&lt;/h2&gt;

&lt;p&gt;I learned a bunch of stuff with this experiment! Here are a couple of things that I found useful that I feel are worth sharing:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Rake proxies all of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FileUtils&lt;/code&gt; class methods as instance methods, so you can call things like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rm_rf&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cp_r&lt;/code&gt; from within Rake tasks and it will just work.&lt;/li&gt;
  &lt;li&gt;You can reflect on load paths to find out where gems are housed by looking at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$:&lt;/code&gt; once &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bundler/setup&lt;/code&gt; is required.&lt;/li&gt;
  &lt;li&gt;There’s a new-ish &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Awaited&lt;/code&gt; TypeScript generic type that will return the type encapsulated by a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Promise&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;esbuild&lt;/code&gt; is really well documented and plugins are not too hard to write.&lt;/li&gt;
  &lt;li&gt;You can deploy directly to GitHub pages through GitHub actions even if you have to invoke something like rake. (&lt;a href=&quot;https://github.com/ruby-syntax-tree/ruby-syntax-tree.github.io/blob/main/.github/workflows/main.yml&quot;&gt;See here&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At some point I’d like to add the ability to format the source, add a better editor, and general improve the styling and UX. But for now, the current state is up at &lt;a href=&quot;https://ruby-syntax-tree.github.io&quot;&gt;ruby-syntax-tree.github.io&lt;/a&gt;.&lt;/p&gt;</content><author><name>Kevin Newton</name></author><summary type="html">Over the weekend I cobbled together ruby-syntax-tree.github.io, and I thought I’d share a quick post about what it is, how it works, and what I learned while I built it.</summary></entry><entry><title type="html">Ruby Association Final Report</title><link href="https://kddnewton.com/2022/03/17/ruby-association-final-report.html" rel="alternate" type="text/html" title="Ruby Association Final Report"><published>2022-03-17T00:00:00+00:00</published><updated>2022-03-17T00:00:00+00:00</updated><id>https://kddnewton.com/2022/03/17/ruby-association-final-report</id><content type="html" xml:base="https://kddnewton.com/2022/03/17/ruby-association-final-report.html">&lt;p&gt;In accordance with the Ruby Association’s timeline, this is the final report on the &lt;a href=&quot;https://www.ruby.or.jp/en/news/20211025&quot;&gt;Ruby formatter&lt;/a&gt; project.&lt;/p&gt;

&lt;h2 id=&quot;deliverables&quot;&gt;Deliverables&lt;/h2&gt;

&lt;p&gt;When the project was initially proposed to create a standard library formatter, a list of 5 delivers was created. Below I detail what the initial proposal for each one was, as well as the work that ended up being done.&lt;/p&gt;

&lt;h3 id=&quot;ripper-updates&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; updates&lt;/h3&gt;

&lt;p&gt;A definitive representation of the Ruby syntax tree based on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; was proposed. The existing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; subclasses ship without location information for inner nodes, discard comments in the final representation, and don’t have named fields. These issues and more are remedied in the new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper::Tree&lt;/code&gt; subclass. This subclass is now backing the formatter &lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree/blob/773315c1157c9279933f19da69ad9d102dae8d8c/lib/syntax_tree.rb&quot;&gt;here&lt;/a&gt; as the basis for the syntax tree. Its main benefits are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It uses class instances instead of arrays to represent nodes. This has the benefit of explicitness as well as documentation.&lt;/li&gt;
  &lt;li&gt;Comments are automatically attached to the various nodes when parsing is finished. This makes it much easier to detect which comments “belong” to which nodes.&lt;/li&gt;
  &lt;li&gt;A couple of additional nodes are added for clarity (i.e., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ArgStar&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Not&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PinnedBegin&lt;/code&gt;, etc.) as opposed to having to rely on contextual information.&lt;/li&gt;
  &lt;li&gt;Every node has location information attached to it (as opposed to just the scanner event nodes). This is vital for formatting.&lt;/li&gt;
  &lt;li&gt;There’s a standard interface for descending the tree (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;child_nodes&lt;/code&gt; method).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This work hasn’t been merged upstream, but the pull request has been opened &lt;a href=&quot;https://github.com/ruby/ruby/pull/5679&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;prettyprint-updates&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; updates&lt;/h3&gt;

&lt;p&gt;Updates and enhancements to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; library were proposed. In general, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; is well suited to printing out object descriptions but lacks enough necessary functionality to be able to accurately print a programming language like Ruby. Many (non-breaking) updates were made to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; library to enhance it enough to power the formatter. The following issues have been addressed:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; assumed that content in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Text&lt;/code&gt; would not change its representation if it was contained within a broken group versus contained within a flat group. This wasn’t a problem for the existing uses of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt;, but for the purposes of building a formatter, it definitely was. Consider something like trailing commas (where you want a comma if it is broken but nothing if it’s not) or block operators (where you would use a do and end for multi-line (broken group) or braces for single line (flat group)).&lt;/li&gt;
  &lt;li&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Breakable&lt;/code&gt; class assumed that you always wanted to indent the subsequent line up to the current indentation level. This was true in most cases, and certainly for all the existing use cases. But there are times when you don’t want that behavior (for example if you’re in the middle of a nested indentation structure but have to force content to start at the beginning of the next line as in a comment with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=begin&lt;/code&gt;..&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;=end&lt;/code&gt; bounds).&lt;/li&gt;
  &lt;li&gt;There was previously no way to force a group to break. You can access the current group in the printer with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;current_group&lt;/code&gt;, but that wouldn’t force the parent groups to break. Without hacking around a lot of stuff, it was difficult to get this behavior. This is necessary if you want to ensure a newline is added and respected, like after a keyword where it would be necessary.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These issues were addressed with a small algorithm change and the additional of many node types in the print tree. From the user of this class’s perspective, nothing is different. Internally however, there’s a bunch of additional functionality and a lot more control over the printing algorithm! Also the ability to debug has been greatly enhanced with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pretty_print&lt;/code&gt; methods on each of the nodes and the ability to walk the print tree nodes before they’re printed.&lt;/p&gt;

&lt;p&gt;This work hasn’t been merged upstream, but the pull request has been opened &lt;a href=&quot;https://github.com/ruby/prettyprint/pull/3&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;formatter&quot;&gt;Formatter&lt;/h3&gt;

&lt;p&gt;A formatter for Ruby source code was proposed. With the work done on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; subclass and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; updates, this amounted to combining those two efforts by defining formatting functions on each of the node types.&lt;/p&gt;

&lt;p&gt;That work was all bundled up into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; gem (now published). You can see how all of that formatting is performed &lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree/blob/773315c1157c9279933f19da69ad9d102dae8d8c/lib/syntax_tree.rb&quot;&gt;here&lt;/a&gt;. Particularly look at all of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;format&lt;/code&gt; methods, as well as the various classes and modules created to support those methods.&lt;/p&gt;

&lt;h3 id=&quot;cli&quot;&gt;CLI&lt;/h3&gt;

&lt;p&gt;A CLI for formatting files was proposed. When the formatter was finished, this was a matter of triggering its execution from the command line.&lt;/p&gt;

&lt;p&gt;This work has been bundled up into the &lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree/blob/773315c1157c9279933f19da69ad9d102dae8d8c/lib/syntax_tree/cli.rb&quot;&gt;cli.rb&lt;/a&gt; file in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; gem. It includes the proposed functionality of formatting Ruby code. It also supports various other helpful functionality, a subset of which is listed below.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stree ast FILE&lt;/code&gt; - prints out the AST corresponding to the given files.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stree check FILE&lt;/code&gt; - ensures that the given files are formatted as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; would format them.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stree format FILE&lt;/code&gt; - prints out the formatted version of the given files.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stree write FILE&lt;/code&gt; - reads, formats, and writes back the source of the given files.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;language-server&quot;&gt;Language server&lt;/h3&gt;

&lt;p&gt;A language server supporting the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formatOnSave&lt;/code&gt; option was proposed.&lt;/p&gt;

&lt;p&gt;A subset of the language server protocol has been implemented in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; gem and supports the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formatOnSave&lt;/code&gt; option &lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree/blob/773315c1157c9279933f19da69ad9d102dae8d8c/lib/syntax_tree/language_server.rb&quot;&gt;here&lt;/a&gt;. A couple other features were added as well (the ability to disassemble the YARV bytecode for a given method, various inlayed code hints, as well as the ability to see the syntax tree). These features and more were also built into a &lt;a href=&quot;https://github.com/ruby-syntax-tree/vscode-syntax-tree&quot;&gt;VSCode plugin&lt;/a&gt; to make it easier for developers to integrate into their workflows.&lt;/p&gt;

&lt;h2 id=&quot;future-work&quot;&gt;Future work&lt;/h2&gt;

&lt;p&gt;I still plan to build lots of additional functionality into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; and its related projects. Some of that functionality includes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A well-defined interface for programmatic code modification functionality. Currently you &lt;em&gt;can&lt;/em&gt; replace nodes and have them formatted correctly, meaning you can programmatically change Ruby code. However, doing this is definitely not easy and requires a lot of knowledge of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; internals. Ideally this would be a lot easier.&lt;/li&gt;
  &lt;li&gt;A backend for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt; gem. Ideally I’d like to create an interface layer that would convert &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; nodes into their &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt; gem counterparts. I’d like to do this because it would make it trivial for gems that are consumers of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt; gem to switch to using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; as the parser for some additional speed boosts. Note that this wouldn’t mean switching off the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt; gem, it would just mean that the parsing would be faster.&lt;/li&gt;
  &lt;li&gt;Decoupling the parsing functionality (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; subclass) from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; node definitions. In the far future, this could potentially mean being able to switch out the parser backing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; to some other tool but maintaining all of the functionality built into the various node types.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you’re interested in following this project, you can watch the &lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree&quot;&gt;ruby-syntax-tree/syntax_tree&lt;/a&gt; repository or check/subscribe to this blog. I’ve also started a blog series describing how this project was built, which you can start reading with the &lt;a href=&quot;/2022/02/03/formatting-ruby-part-0&quot;&gt;introductory post&lt;/a&gt;.&lt;/p&gt;</content><author><name>Kevin Newton</name></author><summary type="html">In accordance with the Ruby Association’s timeline, this is the final report on the Ruby formatter project.</summary></entry><entry><title type="html">Formatting Ruby</title><link href="https://kddnewton.com/2022/02/14/formatting-ruby-part-1.html" rel="alternate" type="text/html" title="Formatting Ruby"><published>2022-02-14T00:00:00+00:00</published><updated>2022-02-14T00:00:00+00:00</updated><id>https://kddnewton.com/2022/02/14/formatting-ruby-part-1</id><content type="html" xml:base="https://kddnewton.com/2022/02/14/formatting-ruby-part-1.html">&lt;p&gt;This post is part of a series about how &lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree&quot;&gt;ruby-syntax-tree/syntax_tree&lt;/a&gt; works under the hood. It’s part of an ongoing effort to spread the word about this project, document how it works, and explain some of the internals for anyone interested. This post specifically focuses on ripper, the Ruby standard library used to parse Ruby files. For an overview of this series, see the &lt;a href=&quot;/2022/02/03/formatting-ruby-part-0&quot;&gt;introduction post&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;history&quot;&gt;History&lt;/h2&gt;

&lt;p&gt;On October 20th, 2001, &lt;a href=&quot;https://i.loveruby.net/&quot;&gt;Minero Aoki&lt;/a&gt; released version 0.0.1 of ripper, a streaming Ruby parser. You can still go to his website and download the &lt;a href=&quot;https://i.loveruby.net/archive/ripper/ripper-0.0.1.tar.gz&quot;&gt;first version&lt;/a&gt; he released.&lt;/p&gt;

&lt;p&gt;At the time, Ruby 1.7 had just come out. Ruby was still a tree-walk interpreter (it didn’t use an internal bytecode). There was work going on to create Ruby’s first bytecode, but it hadn’t yet landed on the master branch. Because Ruby’s tree was so central to how it functioned, there was a lot of interest in accessing, debugging, and manipulating it. Other projects at the time focused on taking the already parsed tree and returning it to the user, as in &lt;a href=&quot;https://kddnewton.com/parsing-ruby/projects/ruth/readme.txt&quot;&gt;ruth&lt;/a&gt; and &lt;a href=&quot;https://kddnewton.com/parsing-ruby/projects/nodeDump/README.txt&quot;&gt;nodeDump&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Ripper took a different approach. Because Ruby’s parser was created through &lt;a href=&quot;http://dinosaur.compilertools.net/yacc/&quot;&gt;yacc&lt;/a&gt;, there was a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse.y&lt;/code&gt; grammar file in the Ruby repository that encapsulated both how the parser was to be created and how the file should be lexically parsed. Ripper took that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse.y&lt;/code&gt; grammar file, forked it, and manipulated it to stream nodes and tokens as they were parsed. This is still how the project works today.&lt;/p&gt;

&lt;p&gt;Eventually, it became difficult to maintain a separate grammar file outside of the Ruby codebase, since it required keeping up with any relevant change in the upstream file. In Ruby 1.9, when YARV landed and Ruby became a bytecode interpreter, ripper was merged in as a standard library. Now instead of checking in the changes to the grammar file, the changes were moved into comments and a separate build step was added to replace the body of the production rule with the content of the comments. We’ll come back to this momentarily.&lt;/p&gt;

&lt;p&gt;Over time, ripper has continued to be one of the most frequently changed libraries in core (because it changes whenever Ruby syntax changes), but also one of the least understood. It’s no surprise that from 2001 to today, it still says it’s in &lt;a href=&quot;https://github.com/ruby/ruby/blob/95aff214687a5e12c3eb57d056665741e734c188/ext/ripper/README#L9-L10&quot;&gt;early-alpha&lt;/a&gt;. Nevertheless, many projects have been built on top of the functionality that ripper provides, including some that you may have heard of like &lt;a href=&quot;https://github.com/prettier/plugin-ruby&quot;&gt;prettier&lt;/a&gt;, &lt;a href=&quot;https://github.com/penelopezone/rubyfmt&quot;&gt;rubyfmt&lt;/a&gt;, &lt;a href=&quot;https://github.com/ruby-formatter/rufo&quot;&gt;rufo&lt;/a&gt;, and &lt;a href=&quot;https://github.com/lsegal/yard&quot;&gt;yard&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A lot more can be written about the history of ripper and what it has meant for the community, but this post is meant to focus on its technical aspectss. If you’re interested in more history like this, see my previous talk on the history of &lt;a href=&quot;https://www.youtube.com/watch?v=lUIt2UWXW-I&quot;&gt;parsing Ruby&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-it-works&quot;&gt;How it works&lt;/h2&gt;

&lt;p&gt;At a high-level, ripper is a streaming bottom-up parser. It works by modifying the actions of each production of the Ruby grammar file to dispatch an event on the parser object. When it dispatches an event, it calls a method that can be overridden by the user. The result of the called method is then passed up the tree. Let’s break down what that actually means.&lt;/p&gt;

&lt;h3 id=&quot;step-1-building&quot;&gt;Step 1. Building&lt;/h3&gt;

&lt;p&gt;Ripper is shipped as a native extension to CRuby. This means it has its own &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;extconf.rb&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;depend&lt;/code&gt; file for configuring how it’s built. Digging into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;depend&lt;/code&gt; file, we can find the exact steps used to build ripper’s grammar file here: &lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/ext/ripper/depend#L20-L27&quot;&gt;ext/ripper/depend&lt;/a&gt;.  In these steps it is running a couple of file processing scripts written in Ruby to grab various data from around the Ruby codebase to create a new &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse.y&lt;/code&gt; file that ripper can use. Below is the list of scripts that it runs.&lt;/p&gt;

&lt;h4 id=&quot;toolsid2tokenrb&quot;&gt;tools/id2token.rb&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/tool/id2token.rb&quot;&gt;id2token.rb&lt;/a&gt; runs over the checked in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse.y&lt;/code&gt; file and replaces instances of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RUBY_TOKEN(...)&lt;/code&gt; pattern with their numeric equivalents. In this case a token represents a scanner token (e.g., the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;==&lt;/code&gt; operator, a symbol literal, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-&amp;gt;&lt;/code&gt; lambda begin, etc.). To get a better sense of what it’s actually doing, you can run the file and diff its result with the original file, as in: &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;diff parse.y &amp;lt;(tool/id2token.rb id.h parse.y)&lt;/code&gt;. That results in the diff below.&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;1216,1238c1216,1238
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;&amp;lt; %token tUPLUS		RUBY_TOKEN(UPLUS)  &quot;unary+&quot;
&amp;lt; %token tUMINUS		RUBY_TOKEN(UMINUS) &quot;unary-&quot;
&amp;lt; %token tPOW		RUBY_TOKEN(POW)    &quot;**&quot;
&amp;lt; %token tCMP		RUBY_TOKEN(CMP)    &quot;&amp;lt;=&amp;gt;&quot;
&amp;lt; %token tEQ		RUBY_TOKEN(EQ)     &quot;==&quot;
&amp;lt; %token tEQQ		RUBY_TOKEN(EQQ)    &quot;===&quot;
&amp;lt; %token tNEQ		RUBY_TOKEN(NEQ)    &quot;!=&quot;
&amp;lt; %token tGEQ		RUBY_TOKEN(GEQ)    &quot;&amp;gt;=&quot;
&amp;lt; %token tLEQ		RUBY_TOKEN(LEQ)    &quot;&amp;lt;=&quot;
&amp;lt; %token tANDOP		RUBY_TOKEN(ANDOP)  &quot;&amp;amp;&amp;amp;&quot;
&amp;lt; %token tOROP		RUBY_TOKEN(OROP)   &quot;||&quot;
&amp;lt; %token tMATCH		RUBY_TOKEN(MATCH)  &quot;=~&quot;
&amp;lt; %token tNMATCH		RUBY_TOKEN(NMATCH) &quot;!~&quot;
&amp;lt; %token tDOT2		RUBY_TOKEN(DOT2)   &quot;..&quot;
&amp;lt; %token tDOT3		RUBY_TOKEN(DOT3)   &quot;...&quot;
&amp;lt; %token tBDOT2		RUBY_TOKEN(BDOT2)   &quot;(..&quot;
&amp;lt; %token tBDOT3		RUBY_TOKEN(BDOT3)   &quot;(...&quot;
&amp;lt; %token tAREF		RUBY_TOKEN(AREF)   &quot;[]&quot;
&amp;lt; %token tASET		RUBY_TOKEN(ASET)   &quot;[]=&quot;
&amp;lt; %token tLSHFT		RUBY_TOKEN(LSHFT)  &quot;&amp;lt;&amp;lt;&quot;
&amp;lt; %token tRSHFT		RUBY_TOKEN(RSHFT)  &quot;&amp;gt;&amp;gt;&quot;
&amp;lt; %token &amp;lt;id&amp;gt; tANDDOT	RUBY_TOKEN(ANDDOT) &quot;&amp;amp;.&quot;
&amp;lt; %token &amp;lt;id&amp;gt; tCOLON2	RUBY_TOKEN(COLON2) &quot;::&quot;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;---
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;&amp;gt; %token tUPLUS		132 &quot;unary+&quot;
&amp;gt; %token tUMINUS		133 &quot;unary-&quot;
&amp;gt; %token tPOW		134 &quot;**&quot;
&amp;gt; %token tCMP		135 &quot;&amp;lt;=&amp;gt;&quot;
&amp;gt; %token tEQ		140 &quot;==&quot;
&amp;gt; %token tEQQ		141 &quot;===&quot;
&amp;gt; %token tNEQ		142 &quot;!=&quot;
&amp;gt; %token tGEQ		139 &quot;&amp;gt;=&quot;
&amp;gt; %token tLEQ		138 &quot;&amp;lt;=&quot;
&amp;gt; %token tANDOP		148 &quot;&amp;amp;&amp;amp;&quot;
&amp;gt; %token tOROP		149 &quot;||&quot;
&amp;gt; %token tMATCH		143 &quot;=~&quot;
&amp;gt; %token tNMATCH		144 &quot;!~&quot;
&amp;gt; %token tDOT2		128 &quot;..&quot;
&amp;gt; %token tDOT3		129 &quot;...&quot;
&amp;gt; %token tBDOT2		130 &quot;(..&quot;
&amp;gt; %token tBDOT3		131 &quot;(...&quot;
&amp;gt; %token tAREF		145 &quot;[]&quot;
&amp;gt; %token tASET		146 &quot;[]=&quot;
&amp;gt; %token tLSHFT		136 &quot;&amp;lt;&amp;lt;&quot;
&amp;gt; %token tRSHFT		137 &quot;&amp;gt;&amp;gt;&quot;
&amp;gt; %token &amp;lt;id&amp;gt; tANDDOT	150 &quot;&amp;amp;.&quot;
&amp;gt; %token &amp;lt;id&amp;gt; tCOLON2	147 &quot;::&quot;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;toolspure_parserrb&quot;&gt;tools/pure_parser.rb&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/tool/pure_parser.rb&quot;&gt;pure_parser.rb&lt;/a&gt; is a very simple script that replaces a couple of lines in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse.y&lt;/code&gt; file in order to support Bison 3. The generated diff from running this file over the parser is below.&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;1085,1086c1085,1086
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;&amp;lt; %define api.pure
&amp;lt; %define parse.error verbose
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;---
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;&amp;gt; %pure-parser
&amp;gt; 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These first two scripts are the same scripts that are run to generate the main &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse.y&lt;/code&gt; file that Ruby uses (as you can see in &lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/common.mk#L885-L886&quot;&gt;common.mk&lt;/a&gt;). So at this point, we have a temporary file that exactly matches the file that is going to be passed into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bison&lt;/code&gt; to generate the Ruby parser.&lt;/p&gt;

&lt;h4 id=&quot;extrippertoolspreprocrb&quot;&gt;ext/ripper/tools/preproc.rb&lt;/h4&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/ext/ripper/tools/preproc.rb&quot;&gt;preproc.rb&lt;/a&gt; is responsible for transforming the default &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse.y&lt;/code&gt; file that bison uses into a different &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse.y&lt;/code&gt; file that bison will use to generate the ripper parser. It does 3 things while it’s parsing the file.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;First, it copies over the entire prelude of the file before the grammar. The prelude contains all of the required includes, struct definitions, and helper function forward declarations necessary to make parsing work. While it’s copying, it also makes a list of each of the lexer states and their associated descriptions.&lt;/li&gt;
  &lt;li&gt;Next, it copies over the entire grammar section of the file. While it’s copying, it modifies the actions of each of the production rules. First, it finds the C comments within the action that match the pattern &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;%r&amp;lt;/\*% *ripper(?:\[(.*?)\])?: *(.*?) *%\*/&amp;gt;&lt;/code&gt;. Then, it grabs up the rest of the action and puts it behind an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#if 0 ... #endif&lt;/code&gt; macro call so that you can still see the original action. Then, it runs each of the comments through the &lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/ext/ripper/tools/dsl.rb&quot;&gt;ext/ripper/tools/dsl.rb&lt;/a&gt; file to get their C equivalent. We’ll come back to this in a second.&lt;/li&gt;
  &lt;li&gt;Finally, it copies over the user code section of the file. It runs &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ERB&lt;/code&gt; over that section in order to dump the lexer states into defined constants on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper&lt;/code&gt; class so that they can be accessed in user code. These constants look something like the following code.&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* newline significant, +/- is an operator. */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rb_define_const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ripper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;EXPR_END&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT2NUM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXPR_END&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;At this point, the file is ready to be fed into &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bison&lt;/code&gt; to generate the compiler.&lt;/p&gt;

&lt;h4 id=&quot;extrippertoolsdslrb&quot;&gt;&lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/ext/ripper/tools/dsl.rb&quot;&gt;ext/ripper/tools/dsl.rb&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;It’s worth discussing quickly how the DSL within the ripper comments work. Effectively, they’re a quick way of describing the events that should be dispatched, as well as the values that should be passed up the tree. You can run the script yourself locally (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ruby -r./ext/ripper/tools/dsl -e 'p DSL.new(&quot;...&quot;, []).generate' &lt;/code&gt;) to see how it works. Below are a couple of examples along with the code they generate (after macro expansion):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;$1&lt;/code&gt; - In a production rule with a single element, this passes the value directly up to the parent without dispatching a single event:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo!($1)&lt;/code&gt; - In a production rule with a single element, this calls out to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper_dispatch1&lt;/code&gt; function with the ID &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper_id_foo&lt;/code&gt; (coming from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo!&lt;/code&gt;), then passes the result of that value directly up to the parent:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;VALUE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ripper_dispatch1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ripper_id_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;$$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The implementation of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper_dispatch1&lt;/code&gt; is relatively simple in that it first validates and then makes a function call.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VALUE&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;ripper_dispatch1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parser_params&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VALUE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;validate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rb_funcall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That function call ends up calling out to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper#_dispatch_1&lt;/code&gt; on whatever parser object ripper is currently using. That will be important later.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo!($1, $2)&lt;/code&gt; - In a production rule with two elements, this calls the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper_dispatch2&lt;/code&gt; function, then passes the result of that value up to the parent:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;VALUE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ripper_dispatch2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ripper_id_foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;$$&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo!($1, bar($2))&lt;/code&gt; - In a production rule with two elements, this first calls the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bar&lt;/code&gt; function but does not dispatch an event to ripper (notice the lack of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;!&lt;/code&gt; on the function call). Then it calls the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper_dispatch2&lt;/code&gt; function like the previous example and passes it up the tree.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;step-2-parsing&quot;&gt;Step 2. Parsing&lt;/h3&gt;

&lt;p&gt;Now that the parser is built, it can be used to parse Ruby source for whatever purpose. Instantiating a parser is pretty simple:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1 + 2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we discussed in the previous section, each of the nodes in the tree as they’re being parsed are created through the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatchN&lt;/code&gt; family of functions, which make it up to user-space through a set of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_*&lt;/code&gt; methods. So if you wanted to parse integers, you would define the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_int&lt;/code&gt; method. (Note this is because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_int&lt;/code&gt; is aliased to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_dispatch_1&lt;/code&gt; &lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/ext/ripper/lib/ripper/core.rb#L49&quot;&gt;here&lt;/a&gt;.)&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Got an integer: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;no&quot;&gt;Parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1 + 2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; nil&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Got an integer: 1&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Got an integer: 2 &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Unfortunately, you still receive a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt; for the result of the parse method. This is because by default the base &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper&lt;/code&gt; class does not provide implementations of the various event handlers needed to produce a useful tree. Instead, it provides subclasses for that purpose. The actual abstract syntax tree that Ruby uses internally for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1 + 2&lt;/code&gt; is akin to the following:&lt;/p&gt;

&lt;div align=&quot;center&quot;&gt;
&lt;!--
digraph {
  left [label=&quot;int (1)&quot;, shape=&quot;box&quot;];
  oper [label=&quot;+&quot;];
  right [label=&quot;int (2)&quot;, shape=&quot;box&quot;];

  program -&gt; stmts_add;
  stmts_add -&gt; stmts_new;
  stmts_add -&gt; binary;

  binary -&gt; left;
  binary -&gt; oper;
  binary -&gt; right;
}
--&gt;
  &lt;img src=&quot;data:image/svg+xml;base64,PCEtLSBHZW5lcmF0ZWQgYnkgZ3JhcGh2aXogdmVyc2lvbiAyLjUwLjAgKDIwMjExMjA0LjIwMDcpCiAtLT4KPCEtLSBQYWdlczogMSAtLT4KPHN2ZyB3aWR0aD0iMjU2cHQiIGhlaWdodD0iMjYwcHQiCiB2aWV3Qm94PSIwLjAwIDAuMDAgMjU1Ljc1IDI2MC4wMCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+CjxnIGlkPSJncmFwaDAiIGNsYXNzPSJncmFwaCIgdHJhbnNmb3JtPSJzY2FsZSgxIDEpIHJvdGF0ZSgwKSB0cmFuc2xhdGUoNCAyNTYpIj4KPHBvbHlnb24gZmlsbD0id2hpdGUiIHN0cm9rZT0idHJhbnNwYXJlbnQiIHBvaW50cz0iLTQsNCAtNCwtMjU2IDI1MS43NSwtMjU2IDI1MS43NSw0IC00LDQiLz4KPCEtLSBsZWZ0IC0tPgo8ZyBpZD0ibm9kZTEiIGNsYXNzPSJub2RlIj4KPHRpdGxlPmxlZnQ8L3RpdGxlPgo8cG9seWdvbiBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBwb2ludHM9IjEwMy43NSwtMzYgNDkuNzUsLTM2IDQ5Ljc1LDAgMTAzLjc1LDAgMTAzLjc1LC0zNiIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSI3Ni43NSIgeT0iLTE0LjMiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCI+aW50ICgxKTwvdGV4dD4KPC9nPgo8IS0tIG9wZXIgLS0+CjxnIGlkPSJub2RlMiIgY2xhc3M9Im5vZGUiPgo8dGl0bGU+b3BlcjwvdGl0bGU+CjxlbGxpcHNlIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGN4PSIxNDguNzUiIGN5PSItMTgiIHJ4PSIyNyIgcnk9IjE4Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjE0OC43NSIgeT0iLTE0LjMiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCI+KzwvdGV4dD4KPC9nPgo8IS0tIHJpZ2h0IC0tPgo8ZyBpZD0ibm9kZTMiIGNsYXNzPSJub2RlIj4KPHRpdGxlPnJpZ2h0PC90aXRsZT4KPHBvbHlnb24gZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgcG9pbnRzPSIyNDcuNzUsLTM2IDE5My43NSwtMzYgMTkzLjc1LDAgMjQ3Ljc1LDAgMjQ3Ljc1LC0zNiIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSIyMjAuNzUiIHk9Ii0xNC4zIiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiPmludCAoMik8L3RleHQ+CjwvZz4KPCEtLSBwcm9ncmFtIC0tPgo8ZyBpZD0ibm9kZTQiIGNsYXNzPSJub2RlIj4KPHRpdGxlPnByb2dyYW08L3RpdGxlPgo8ZWxsaXBzZSBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBjeD0iOTguNzUiIGN5PSItMjM0IiByeD0iNDAuODkiIHJ5PSIxOCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSI5OC43NSIgeT0iLTIzMC4zIiBmb250LWZhbWlseT0iVGltZXMsc2VyaWYiIGZvbnQtc2l6ZT0iMTQuMDAiPnByb2dyYW08L3RleHQ+CjwvZz4KPCEtLSBzdG10c19hZGQgLS0+CjxnIGlkPSJub2RlNSIgY2xhc3M9Im5vZGUiPgo8dGl0bGU+c3RtdHNfYWRkPC90aXRsZT4KPGVsbGlwc2UgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgY3g9Ijk4Ljc1IiBjeT0iLTE2MiIgcng9IjQ2LjU5IiByeT0iMTgiLz4KPHRleHQgdGV4dC1hbmNob3I9Im1pZGRsZSIgeD0iOTguNzUiIHk9Ii0xNTguMyIgZm9udC1mYW1pbHk9IlRpbWVzLHNlcmlmIiBmb250LXNpemU9IjE0LjAwIj5zdG10c19hZGQ8L3RleHQ+CjwvZz4KPCEtLSBwcm9ncmFtJiM0NTsmZ3Q7c3RtdHNfYWRkIC0tPgo8ZyBpZD0iZWRnZTEiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPnByb2dyYW0mIzQ1OyZndDtzdG10c19hZGQ8L3RpdGxlPgo8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImJsYWNrIiBkPSJNOTguNzUsLTIxNS43Qzk4Ljc1LC0yMDcuOTggOTguNzUsLTE5OC43MSA5OC43NSwtMTkwLjExIi8+Cjxwb2x5Z29uIGZpbGw9ImJsYWNrIiBzdHJva2U9ImJsYWNrIiBwb2ludHM9IjEwMi4yNSwtMTkwLjEgOTguNzUsLTE4MC4xIDk1LjI1LC0xOTAuMSAxMDIuMjUsLTE5MC4xIi8+CjwvZz4KPCEtLSBzdG10c19uZXcgLS0+CjxnIGlkPSJub2RlNiIgY2xhc3M9Im5vZGUiPgo8dGl0bGU+c3RtdHNfbmV3PC90aXRsZT4KPGVsbGlwc2UgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgY3g9IjQ4Ljc1IiBjeT0iLTkwIiByeD0iNDguOTkiIHJ5PSIxOCIvPgo8dGV4dCB0ZXh0LWFuY2hvcj0ibWlkZGxlIiB4PSI0OC43NSIgeT0iLTg2LjMiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCI+c3RtdHNfbmV3PC90ZXh0Pgo8L2c+CjwhLS0gc3RtdHNfYWRkJiM0NTsmZ3Q7c3RtdHNfbmV3IC0tPgo8ZyBpZD0iZWRnZTIiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPnN0bXRzX2FkZCYjNDU7Jmd0O3N0bXRzX25ldzwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik04Ni45LC0xNDQuNDFDODAuNzksLTEzNS44NyA3My4yMywtMTI1LjI4IDY2LjQ1LC0xMTUuNzkiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iNjkuMTcsLTExMy41NyA2MC41MSwtMTA3LjQ3IDYzLjQ3LC0xMTcuNjQgNjkuMTcsLTExMy41NyIvPgo8L2c+CjwhLS0gYmluYXJ5IC0tPgo8ZyBpZD0ibm9kZTciIGNsYXNzPSJub2RlIj4KPHRpdGxlPmJpbmFyeTwvdGl0bGU+CjxlbGxpcHNlIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGN4PSIxNDguNzUiIGN5PSItOTAiIHJ4PSIzMy4yOSIgcnk9IjE4Ii8+Cjx0ZXh0IHRleHQtYW5jaG9yPSJtaWRkbGUiIHg9IjE0OC43NSIgeT0iLTg2LjMiIGZvbnQtZmFtaWx5PSJUaW1lcyxzZXJpZiIgZm9udC1zaXplPSIxNC4wMCI+YmluYXJ5PC90ZXh0Pgo8L2c+CjwhLS0gc3RtdHNfYWRkJiM0NTsmZ3Q7YmluYXJ5IC0tPgo8ZyBpZD0iZWRnZTMiIGNsYXNzPSJlZGdlIj4KPHRpdGxlPnN0bXRzX2FkZCYjNDU7Jmd0O2JpbmFyeTwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik0xMTAuNTksLTE0NC40MUMxMTYuNzksLTEzNS43NCAxMjQuNDgsLTEyNC45NyAxMzEuMzMsLTExNS4zOCIvPgo8cG9seWdvbiBmaWxsPSJibGFjayIgc3Ryb2tlPSJibGFjayIgcG9pbnRzPSIxMzQuMzYsLTExNy4xNiAxMzcuMzMsLTEwNi45OSAxMjguNjcsLTExMy4wOSAxMzQuMzYsLTExNy4xNiIvPgo8L2c+CjwhLS0gYmluYXJ5JiM0NTsmZ3Q7bGVmdCAtLT4KPGcgaWQ9ImVkZ2U0IiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT5iaW5hcnkmIzQ1OyZndDtsZWZ0PC90aXRsZT4KPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgZD0iTTEzMy4xMiwtNzMuODFDMTIzLjk0LC02NC44OCAxMTIuMTEsLTUzLjM4IDEwMS42NywtNDMuMjMiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iMTAzLjk3LC00MC41OSA5NC4zNiwtMzYuMTMgOTkuMDksLTQ1LjYxIDEwMy45NywtNDAuNTkiLz4KPC9nPgo8IS0tIGJpbmFyeSYjNDU7Jmd0O29wZXIgLS0+CjxnIGlkPSJlZGdlNSIgY2xhc3M9ImVkZ2UiPgo8dGl0bGU+YmluYXJ5JiM0NTsmZ3Q7b3BlcjwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik0xNDguNzUsLTcxLjdDMTQ4Ljc1LC02My45OCAxNDguNzUsLTU0LjcxIDE0OC43NSwtNDYuMTEiLz4KPHBvbHlnb24gZmlsbD0iYmxhY2siIHN0cm9rZT0iYmxhY2siIHBvaW50cz0iMTUyLjI1LC00Ni4xIDE0OC43NSwtMzYuMSAxNDUuMjUsLTQ2LjEgMTUyLjI1LC00Ni4xIi8+CjwvZz4KPCEtLSBiaW5hcnkmIzQ1OyZndDtyaWdodCAtLT4KPGcgaWQ9ImVkZ2U2IiBjbGFzcz0iZWRnZSI+Cjx0aXRsZT5iaW5hcnkmIzQ1OyZndDtyaWdodDwvdGl0bGU+CjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iYmxhY2siIGQ9Ik0xNjQuMzcsLTczLjgxQzE3My41NSwtNjQuODggMTg1LjM4LC01My4zOCAxOTUuODIsLTQzLjIzIi8+Cjxwb2x5Z29uIGZpbGw9ImJsYWNrIiBzdHJva2U9ImJsYWNrIiBwb2ludHM9IjE5OC40LC00NS42MSAyMDMuMTMsLTM2LjEzIDE5My41MiwtNDAuNTkgMTk4LjQsLTQ1LjYxIi8+CjwvZz4KPC9nPgo8L3N2Zz4K&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;So, in order to get a useful value out of your parser, you would need to implement &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_program&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_stmts_add&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_stmts_new&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_binary&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_int&lt;/code&gt;. If you do define those methods, you can get the parse tree out. Let’s do that quickly below as an example:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_binary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:binary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_i&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_program&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stmts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stmts&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_stmts_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stmts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stmts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stmt&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_stmts_new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;no&quot;&gt;Parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1 + 2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; [[:binary, 1, :+, 2]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If you look at the tree that I drew above, you see how we arrive at this final product. The order that the methods are called in is left to right, bottom to top. So if we trace the execution, we get the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_stmts_new&lt;/code&gt; is called and we return an empty array.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_int&lt;/code&gt; is called with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;1&quot;&lt;/code&gt;. We convert that to an integer with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#to_i&lt;/code&gt; and return it to move it up the tree.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_int&lt;/code&gt; is called with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;2&quot;&lt;/code&gt;. We do the same as the previous call.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_binary&lt;/code&gt; is called with the result of the two &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_int&lt;/code&gt; calls and a symbol literal representing the operator. For that, we return an array containing all of the information present as well as a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:binary&lt;/code&gt; symbol literal used to indicate the kind of node being represented.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_stmts_add&lt;/code&gt; is called with the result of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_stmts_new&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_binary&lt;/code&gt; calls. We push the result of the righthand operand (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_binary&lt;/code&gt;) onto the value of the lefthand operand (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_stmts_new&lt;/code&gt;). This results in an array of a single value containing the result of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_binary&lt;/code&gt; call.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_program&lt;/code&gt; is called with the result of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_stmts_add&lt;/code&gt; call. We immediately return that value.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;api&quot;&gt;API&lt;/h2&gt;

&lt;p&gt;There are a number of APIs within ripper that you can use when processing dispatched events. First, it’s important to discuss a couple of helper APIs within ripper that represent a lot of important functionality. Then we’ll discuss the bigger APIs represented by the two subclasses that ripper ships with.&lt;/p&gt;

&lt;h3 id=&quot;lineno-and-column&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#lineno&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#column&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;These two methods represent the internal state of the parser when you are within a specific event handler. For example, if you’re handling an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_int&lt;/code&gt;, then &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lineno&lt;/code&gt; is the line in the source that the int was found on, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;column&lt;/code&gt; is the offset (in &lt;em&gt;bytes&lt;/em&gt;, not characters) on that line at which the int was found. It’s important to know that these APIs were designed to reflect the internal state of the parser only, and are not meant as definitive location information. For example, if you’re processing an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_binary&lt;/code&gt; event and there happens to be a comment after your righthand operand, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;column&lt;/code&gt; method will return a value &lt;em&gt;after&lt;/em&gt; the comment has been read. So, if you want specific location information you need to get it on a case-by-case basis for each event handler.&lt;/p&gt;

&lt;h3 id=&quot;encoding&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#encoding&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;When Ruby first reads a source file, it assumes an encoding for that file. If it encounters an encoding magic comment, then it will change how its parsing the remainder of the file from that point on. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;encoding&lt;/code&gt; is an accessor method to retrieve the encoding it is currently using at any given time. This is very important if you’re parsing files that aren’t in an encoding you might expect like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UTF-8&lt;/code&gt; or &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ASCII&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;error&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#error?&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Error handling is a massive subject in parser literature. Within parser generators like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bison&lt;/code&gt;, you can use the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error&lt;/code&gt; production to catch errors and perform some action when they are found. In the case that an error &lt;em&gt;has been&lt;/em&gt; found, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;error?&lt;/code&gt; method will return true. This is very important to note because Ruby might be able to generate a parse tree for you that contains errored nodes internally.&lt;/p&gt;

&lt;h3 id=&quot;state&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;#state&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Because the lexical grammar of the Ruby language is not regular, CRuby maintains its own state machine within the lexer in order to accept different patterns at different locations. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;state&lt;/code&gt; is your access to that information. Previously, this information wasn’t available, but in Ruby 2.5 it got exposed as part of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;preproc.rb&lt;/code&gt; script’s work.&lt;/p&gt;

&lt;h3 id=&quot;sexp_raw&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::sexp_raw&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Finally, we get to the big APIs. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper::sexp_raw&lt;/code&gt; is the same thing is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::parse&lt;/code&gt; except that it uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper::SexpBuilder&lt;/code&gt; subclass of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper&lt;/code&gt; instead of the main class. The main’s classes implementation of every &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch*&lt;/code&gt; method is to simply &lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/ext/ripper/lib/ripper/core.rb#L34-L41&quot;&gt;return the first argument&lt;/a&gt;. That doesn’t work for most use cases, so instead &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SexpBuilder&lt;/code&gt; ships with a &lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/ext/ripper/lib/ripper/sexp.rb#L115-L131&quot;&gt;default implementation&lt;/a&gt; for every node that returns an array representing an &lt;a href=&quot;https://en.wikipedia.org/wiki/S-expression&quot;&gt;s-expression&lt;/a&gt; for each node. You can check this out yourself on the command line by running:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sexp_raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1 + 2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# =&amp;gt; [:program, [:stmts_add, [:stmts_new], [:binary, [:@int, &quot;1&quot;, [1, 0]], :+, [:@int, &quot;2&quot;, [1, 4]]]]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can see how this mirrors the AST structure we mentioned earlier. You can also see that scanner events (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@int&lt;/code&gt;, i.e. leaf nodes) contain their source location while parser events (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;binary&lt;/code&gt;, i.e., inner nodes) do not.&lt;/p&gt;

&lt;h3 id=&quot;sexp&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::sexp&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Lastly, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper::sexp&lt;/code&gt; is like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper::sexp_raw&lt;/code&gt; except that it uses the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper::SexpBuilderPP&lt;/code&gt; subclass of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper&lt;/code&gt;. It can a couple of small differences, but the main one is that it treats arrays of elements differently. First, let’s take a look at the s-expressions it generates:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sexp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;1 + 2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# =&amp;gt; [:program, [[:binary, [:@int, &quot;1&quot;, [1, 0]], :+, [:@int, &quot;2&quot;, [1, 4]]]]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You’ll notice there aren’t any &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stmts_*&lt;/code&gt; nodes contained in this output. That’s because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SexpBuilderPP&lt;/code&gt; treats all of the various &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;add/new&lt;/code&gt; pairs as just arrays that can be concatenated whenever a new element is added. You can see how that’s implemented &lt;a href=&quot;https://github.com/ruby/ruby/blob/v3_0_0/ext/ripper/lib/ripper/sexp.rb#L178-L183&quot;&gt;here&lt;/a&gt;. Depending on your use case, this tree could be easier to work with. However, if you need specific information about exactly which nodes were used in the source, this is not the method for you. For more information about dealing with lists in ripper, see &lt;a href=&quot;https://kddnewton.com/ripper-docs/lists&quot;&gt;this page&lt;/a&gt; in my &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;kddnewton/ripper-docs&lt;/code&gt; repository for more information.&lt;/p&gt;

&lt;h2 id=&quot;example-parser&quot;&gt;Example parser&lt;/h2&gt;

&lt;p&gt;As a final note, let’s build an example parser to put a more practical look on what we’ve been talking about. It’s going to be relatively contrived in order to fit into a blog post, but it should give you a sense of what we’re talking about here.&lt;/p&gt;

&lt;p&gt;We’re going to build a small parser that will return to us the documentation for any module declarations within our code. When I say documentation I mean comments immediately preceeding the module. If there’s a newline between them, then we don’t want them. First, let’s start by just trying to get a list of the modules declared within the file.&lt;/p&gt;

&lt;p&gt;It’ll be easiest to tell which kinds of event handlers we need to define by using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;::sexp_raw&lt;/code&gt; method. Let’s start by running that:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sexp_raw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;~&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RUBY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;
module Foo::Bar
end
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RUBY&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# =&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# [:program,                                  &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#  [:stmts_add,                               &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   [:stmts_new],                             &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   [:module,                                 &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#    [:const_path_ref,                        &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     [:var_ref, [:@const, &quot;Foo&quot;, [1, 7]]],   &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     [:@const, &quot;Bar&quot;, [1, 12]]],             &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#    [:bodystmt,                              &lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     [:stmts_add, [:stmts_new], [:void_stmt]],&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     nil,&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     nil,&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     nil]]]]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Remember that any event dispatched that only takes one argument (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch1&lt;/code&gt; family of nodes) we don’t &lt;em&gt;have&lt;/em&gt; to define an event handler because it just passes up the first argument. For the rest of the nodes, we’ll need an explicit handler if we want its information. For our purposes, we want the names of the modules, which from the comment above we know we need &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_const&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_var_ref&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_const_path_ref&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_module&lt;/code&gt;. Let’s define those explicitly, as well as an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_program&lt;/code&gt; to return the module names at the end.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;
    &lt;span class=&quot;vi&quot;&gt;@modules&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_const_path_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_var_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bodystmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@modules&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;const&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_program&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@modules&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can test this out by running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Parser::parse&lt;/code&gt; on a source string, as in:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;~&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RUBY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;
module Foo
end

module Foo::Bar
end
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RUBY&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# =&amp;gt; [&quot;Foo&quot;, &quot;Foo::Bar&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now that we have the module names, we can change &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@modules&lt;/code&gt; to be a hash keyed off the names where the values should be the documentation. We’ll need to hook into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_comment&lt;/code&gt; scanner event handler to get the value of the comments, and change our event handlers a bit to better handle line numbers. All told, this is what the new parser looks like:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;
    &lt;span class=&quot;vi&quot;&gt;@comments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;vi&quot;&gt;@modules&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_comment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@comments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;strip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lineno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_const_path_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_var_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bodystmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;comments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lineno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

    &lt;span class=&quot;vi&quot;&gt;@comments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reverse_each&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lineno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

      &lt;span class=&quot;n&quot;&gt;comments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;unshift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;lineno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;vi&quot;&gt;@modules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comments&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_program&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;vi&quot;&gt;@modules&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Again, we can test this out by running against our previous example, with some additional comments:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Parser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;~&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RUBY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;
# This is the first module.
module Foo
end

# This is an unassociated comment.

# This is the second module.
# This is definitely the second module.
module Foo::Bar
end
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;RUBY&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# =&amp;gt; {&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   &quot;Foo&quot;=&amp;gt;&quot;This is the first module.&quot;,&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#   &quot;Foo::Bar&quot;=&amp;gt;&quot;This is the second module.\nThis is definitely the second module.&quot;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we’ve got something that’s actually working. It still has some definite limitations (for example it doesn’t properly handle nested modules), but it’s good enough for a small example.&lt;/p&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;If you’re interested in learning more about ripper, here are a couple of other things you can read:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://kddnewton.com/parsing-ruby/#2001-10-20&quot;&gt;Parsing Ruby&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://kddnewton.com/ripper-docs&quot;&gt;Ripper docs&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ruby-hacking-guide.github.io/&quot;&gt;Ruby hacking guide&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ruby-formatter/rufo/blob/v0.13.0/lib/rufo/parser.rb&quot;&gt;Rufo’s parser&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree/tree/v1.2.0/lib/syntax_tree.rb&quot;&gt;Syntax Tree’s parser&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/lsegal/yard/blob/v0.9.27/lib/yard/parser/ruby/ruby_parser.rb&quot;&gt;YARD’s parser&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the next post in this series I’ll show how &lt;a href=&quot;https://github.com/ruby-syntax-tree/syntax_tree&quot;&gt;ruby-syntax-tree/syntax_tree&lt;/a&gt; uses ripper under the hood to build its own syntax tree representing Ruby source. So if you’re looking for a more practical application of the knowledge you got from this blog post, stay tuned.&lt;/p&gt;</content><author><name>Kevin Newton</name></author><summary type="html">This post is part of a series about how ruby-syntax-tree/syntax_tree works under the hood. It’s part of an ongoing effort to spread the word about this project, document how it works, and explain some of the internals for anyone interested. This post specifically focuses on ripper, the Ruby standard library used to parse Ruby files. For an overview of this series, see the introduction post.</summary></entry><entry><title type="html">Formatting Ruby</title><link href="https://kddnewton.com/2022/02/03/formatting-ruby-part-0.html" rel="alternate" type="text/html" title="Formatting Ruby"><published>2022-02-03T00:00:00+00:00</published><updated>2022-02-03T00:00:00+00:00</updated><id>https://kddnewton.com/2022/02/03/formatting-ruby-part-0</id><content type="html" xml:base="https://kddnewton.com/2022/02/03/formatting-ruby-part-0.html">&lt;p&gt;Last October, the Ruby Association selected its &lt;a href=&quot;https://www.ruby.or.jp/en/news/20211025&quot;&gt;2021 grant recipients&lt;/a&gt; for the various projects around the Ruby ecosystem that they would support. Among them was my proposal to create a standard library Ruby formatter. Below is the description of the project, as per the submission:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Ruby formatter is a reimplementation of the prettier plugin for Ruby written in pure Ruby. It will provide an executable that can be used to format Ruby files from the command line. It will also provide a language server that can be used to integrate with Its implementation will be based on both the ripper and prettyprint gems, with additional functionality being added to both.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Work on this project is well underway; you can check out the current state of affairs in the &lt;a href=&quot;https://github.com/kddnewton/syntax_tree&quot;&gt;kddnewton/syntax_tree&lt;/a&gt; repository on GitHub or read my previous post on this blog detailing the &lt;a href=&quot;/2022/01/17/ruby-association-intermediate-report&quot;&gt;intermediate report&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a part of this work, and an introduction to the Ruby community, I’ve planned out a series of blog posts on the formatter that will show how I made it, why I made it, and how you can use it. The planned posts are the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2022/02/14/formatting-ruby-part-1&quot;&gt;Formatting Ruby: Part 1&lt;/a&gt; - How ripper works&lt;/li&gt;
  &lt;li&gt;Formatting Ruby: Part 2 - Building the syntax tree&lt;/li&gt;
  &lt;li&gt;Formatting Ruby: Part 3 - How prettyprint works&lt;/li&gt;
  &lt;li&gt;Formatting Ruby: Part 4 - Formatting the syntax tree&lt;/li&gt;
  &lt;li&gt;Formatting Ruby: Part 5 - Building the CLI&lt;/li&gt;
  &lt;li&gt;Formatting Ruby: Part 6 - Building the language server&lt;/li&gt;
  &lt;li&gt;Formatting Ruby: Part 7 - Extending the language server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When the posts are done, this post will link back to all of them. I’m planning (hoping) to write one per week, which means this blog series would end just after the final report of the project is due on March 18th. (Maybe we’ll squeeze two into one week to get it done on time, but no promises.)&lt;/p&gt;

&lt;p&gt;If you’re interested in this work and how you can use it to improve your Ruby development experience, check back here, follow me on twitter, or subscribe to the RSS feed at the bottom of this page. See you next week.&lt;/p&gt;</content><author><name>Kevin Newton</name></author><summary type="html">Last October, the Ruby Association selected its 2021 grant recipients for the various projects around the Ruby ecosystem that they would support. Among them was my proposal to create a standard library Ruby formatter. Below is the description of the project, as per the submission:</summary></entry><entry><title type="html">Solving Wordle in Ruby</title><link href="https://kddnewton.com/2022/01/29/solving-wordle-in-ruby.html" rel="alternate" type="text/html" title="Solving Wordle in Ruby"><published>2022-01-29T00:00:00+00:00</published><updated>2022-01-29T00:00:00+00:00</updated><id>https://kddnewton.com/2022/01/29/solving-wordle-in-ruby</id><content type="html" xml:base="https://kddnewton.com/2022/01/29/solving-wordle-in-ruby.html">&lt;p&gt;You may have seen the word game &lt;a href=&quot;https://www.powerlanguage.co.uk/wordle/&quot;&gt;wordle&lt;/a&gt; going around the various social media. It’s a simple game that works like this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The game selects a 5-letter word that the player is trying to guess.&lt;/li&gt;
  &lt;li&gt;The player gets 6 guesses to find the word.&lt;/li&gt;
  &lt;li&gt;Every time the player guesses a word, they are told if the letter they selected was either not in the word (gray tile), in the word but in the wrong place (yellow tile), or in the word and in the right place (green tile).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Being a programmer, it’s hard to resist the urge to script a solution to this game. So that’s what I did. If you want to skip straight to the code, it’s here: &lt;a href=&quot;https://github.com/kddnewton/wordle&quot;&gt;kddnewton/wordle&lt;/a&gt;. Otherwise, read on for how this is done.&lt;/p&gt;

&lt;h2 id=&quot;getting-the-list-of-words&quot;&gt;Getting the list of words&lt;/h2&gt;

&lt;p&gt;Fortunately, wordle is a relatively simple game, and makes no attempt to hide the dictionary it’s using (by, for instance, putting it behind an API request). Instead, everything ships in one compact JavaScript bundle. So if you view the source of the file through your browser, you can pull out the exact words it’s going to be using. (You can also just pull out the solutions, but that’s not nearly as fun.)&lt;/p&gt;

&lt;p&gt;After you find the right variables, you can dump them into a file for reading later. In my repository, I called it (somewhat unimaginatively) &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;words.txt&lt;/code&gt;. We then need to read the file in and create the shell of our program, which is done like so:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# The `chomp` here means to strip off the newline characters from each line, so&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# we're just left with the words.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;readlines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;words.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;chomp: &lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# Do something in here to whittle down the list of words that are left until&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# we're left with just one.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# At this point, there should only be one word left in the dictionary, which&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# means we've found our final word.&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;The word is: &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;getting-user-input&quot;&gt;Getting user input&lt;/h2&gt;

&lt;p&gt;Now that we have the shell of our program, we need a way to get the user’s input so we can guess words and they can tell us how we did. We’ll come up with a simple little protocol that works like the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;We’ll output a guess to the command line.&lt;/li&gt;
  &lt;li&gt;The player will input that guess into wordle.&lt;/li&gt;
  &lt;li&gt;The player will then input the color of the tiles back to our program. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_&lt;/code&gt; will represent a gray tile, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; will represent a yellow tile, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;g&lt;/code&gt; will represent a green tile.&lt;/li&gt;
  &lt;li&gt;Repeat.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For now, we’ll just output a random word as a guess. We’ll come back and make it better shortly. Here’s how we’re going to accomplish what we’ve just described:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Get a random word from the remaining list of words.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sample&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guess&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; ? &quot;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Read the user's input from the command line.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;gets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;chomp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;downcase&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;guess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;zip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each_with_index&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;letter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;_&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# In this case, the letter is not in the final word, so delete any words&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# from the dictionary that contain that letter.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reject!&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;include?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;letter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;g&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# In this case, the letter is in the final word at this index, so delete&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# any words from the dictionary that do not also have this letter at&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# that index.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reject!&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;letter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;y&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# In this case, the letter is in the final word but at a different&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# index, so delete any words from the dictionary that either do not have&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# this letter or that have this letter at this same index.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;reject!&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;include?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;letter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;letter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That code will go in the middle of our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;while&lt;/code&gt; loop that we created earlier. This code actually works pretty well, though the guesses are very much not optimal. Let’s see if we can fix that.&lt;/p&gt;

&lt;h2 id=&quot;guessing-better-words&quot;&gt;Guessing better words&lt;/h2&gt;

&lt;p&gt;The strategy that we’re going to take for this is going to be to guess the word that gives us the most information. If almost every word remaining in our dictionary contains an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;, then for sure we want our guess to include an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;. The same can be said about any other letter. We also want to make sure we weight it according to the remaining possible words, not just the entire dictionary every time. So if we’ve already guessed &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;a&lt;/code&gt;, we don’t want it to factor into our guessing at all. We can accomplish this with the following code:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# First, set of a list of letters remaining to be guessed. This is important for&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# building up the list of weights for choosing optimal guesses.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;letters&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;a&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;z&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_a&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Now, within the while loop...&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# Build up a list of &quot;weights&quot;. This is a hash of letters that point to the&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# number of unique words that contain those letters. So for example, if you had&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# the words:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     apple&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     knoll&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# You would end up with a hash of weights that looked like:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#     { &quot;a&quot; =&amp;gt; 1, &quot;e&quot; =&amp;gt; 1, &quot;k&quot; =&amp;gt; 1, &quot;l&quot; =&amp;gt; 2, &quot;n&quot; =&amp;gt; 1, &quot;o&quot; =&amp;gt; 1, &quot;p&quot; =&amp;gt; 1 }&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;uniq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;tally&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:itself&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;select!&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;letter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;letters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;include?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;letter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Determine which word we're guessing based on which word in the remaining&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# list has the highest weight. We determine the weight by adding the weight of&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# each letter in the word together.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;words&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;max_by&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;uniq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;weights&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now our guess is properly weighted by the remaining words. The only other thing to add is something that deletes from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;letters&lt;/code&gt; list when an action is taken, so we can add to our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;each_with_index&lt;/code&gt; loop above:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;letters&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;letter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We’re done! We’re now guessing much better words.&lt;/p&gt;

&lt;h2 id=&quot;testing-our-guessing&quot;&gt;Testing our guessing&lt;/h2&gt;

&lt;p&gt;To test that our program won’t break on any input, we can run through every word in the dictionary and see how it performs. That will involve running our guessing program for each word and playing through it by writing the tile colors back as if we were playing on the actual game.&lt;/p&gt;

&lt;p&gt;We can do this by spawning a subprocess. Let’s assume we’re working with a fixed word like “apple”:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;require&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;open3&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;apple&quot;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Open a new ruby process executing the wordle.rb file. Within the&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# block, you can write to the STDIN and read from the STDOUT IO objects&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# to communicate with the child process.&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;Open3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;popen2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ruby wordle.rb&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waiter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# The protocol is a little loose, but basically if you get to the&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# final word it outputs &quot;The word is&quot;, so we can use that as our loop&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# condition.&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;The&quot;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# Read the rest of the guess, and then skip past the prompt on the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# STDOUT pipe.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;guess&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Create the input necessary to tell the child process which tiles&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# turned which colors. This is analogous to inputting the guessed&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# word into the text box.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;chars&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;guess&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;each_char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;with_index&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;
          &lt;span class=&quot;s2&quot;&gt;&quot;g&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elsif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;include?&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
          &lt;span class=&quot;s2&quot;&gt;&quot;y&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
          &lt;span class=&quot;s2&quot;&gt;&quot;_&quot;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;# Write the input to STDIN and flush it down the pipe so the child&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# process will unblock its read.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;chars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;flush&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# Once we get here, it has started to print &quot;The word is&quot; so read the&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# rest and then verify that it selected the correct word.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The code above allows us to communicate with the subprocess by writing to its STDIN (as if the user were typing in) and reading from its STDOUT (as if the user were reading the output).&lt;/p&gt;

&lt;p&gt;We can now change the code above to loop through every word in the dictionary:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Build up a thread-safe queue for every word in the dictionary.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;
&lt;span class=&quot;no&quot;&gt;File&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;foreach&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;words.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;chomp: &lt;/span&gt;&lt;span class=&quot;kp&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;empty?&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;shift&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;# The code above goes here.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can even parallelize it to get better performance using threads (since a lot of this work is IO-bound):&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;workers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
    &lt;span class=&quot;no&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;# our until loop goes here&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# Join each worker thread back into the main thread to make sure we wait for&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# everything to complete.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;workers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;rating-our-guessing&quot;&gt;Rating our guessing&lt;/h2&gt;

&lt;p&gt;If we want to rate our guessing (so we can improve the algorithm over time), we can add a little logging to our tests. First, we’ll create a hash where we’ll log the information about how many guesses each word took:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# Create a hash whose default value is 0 for any new keys. We'll use this to&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# track how many guesses it took to successfully get to the final word.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, inside the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;until&lt;/code&gt; loop, we’ll create a variable to track how many guesses each word took:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;guesses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Inside the inner &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;until&lt;/code&gt; loop we’ll increment this value so it tracks each guess.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;guesses&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, at the end of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;until&lt;/code&gt; loop, we’ll log our score for that word:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guesses&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;At the end of the test program, we now have a hash of number of guesses pointing to the number of words that required that many guesses. Somewhat arbitrarily, we can score this like the following:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;score&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;results&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;where you get 10 points for every word that you guessed within 3 guesses, and 5 points for every word that you got correctly at all.&lt;/p&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;In this post, I showed some code to solve the twitter-famed wordle game. We wrote some tests, and scored it as well. I hope you enjoyed! Here are a couple of APIs that I used if you’re interesting in learning more:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://ruby-doc.org/core-3.1.0/Enumerable.html#method-i-max_by&quot;&gt;Enumerable#max_by&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ruby-doc.org/core-3.1.0/Enumerable.html#method-i-tally&quot;&gt;Enumerable#tally&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ruby-doc.org/core-3.1.0/Enumerable.html#method-i-zip&quot;&gt;Enumerable#zip&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ruby-doc.org/core-3.1.0/IO.html#method-c-readlines&quot;&gt;IO#readlines&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://ruby-doc.org/stdlib-3.1.0/libdoc/open3/rdoc/Open3.html#method-c-popen2&quot;&gt;Open3::popen2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the algorithm I’ve detailed in the post, I get a score of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;81370&lt;/code&gt;. Feel like a challenge? I’d love to hear of a higher score and how you got it!&lt;/p&gt;</content><author><name>Kevin Newton</name></author><summary type="html">You may have seen the word game wordle going around the various social media. It’s a simple game that works like this:</summary></entry><entry><title type="html">Ruby Association Intermediate Report</title><link href="https://kddnewton.com/2022/01/17/ruby-association-intermediate-report.html" rel="alternate" type="text/html" title="Ruby Association Intermediate Report"><published>2022-01-17T00:00:00+00:00</published><updated>2022-01-17T00:00:00+00:00</updated><id>https://kddnewton.com/2022/01/17/ruby-association-intermediate-report</id><content type="html" xml:base="https://kddnewton.com/2022/01/17/ruby-association-intermediate-report.html">&lt;p&gt;In accordance with the Ruby Association’s timeline, this is an intermediate report on the &lt;a href=&quot;https://www.ruby.or.jp/en/news/20211025&quot;&gt;Ruby formatter&lt;/a&gt; project.&lt;/p&gt;

&lt;h2 id=&quot;proposed-work&quot;&gt;Proposed work&lt;/h2&gt;

&lt;p&gt;When I first proposed the project, here are the list of deliverables that I mentioned in the proposal:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A definitive representation of the Ruby AST based on &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt;. It would be an additional shipped &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; subclass (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper::SexpBuilder&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper::SexpBuilderPP&lt;/code&gt;) with Ruby. The difference is that every node has location information available on it. It will also involve documentation of every node type being shipped along with the parser.&lt;/li&gt;
  &lt;li&gt;Updates and enhancements to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; gem. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; does not currently support all of the various node types that will be neccessary, so another pull request will be merging in additional functionality to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; gem. This has the added benefit of allowing other developers to build formatters as well with the same infrastructure.&lt;/li&gt;
  &lt;li&gt;The formatter itself that will convert the nodes from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; parser into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; IR.&lt;/li&gt;
  &lt;li&gt;A CLI for formatting files (this could be baked into the Ruby CLI as well). This will trigger the formatter on each of the files given.&lt;/li&gt;
  &lt;li&gt;A language server that supports the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formatOnSave&lt;/code&gt; option. The idea here is to trigger the formatter whenever the developer hits save and watch everything snap into place.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;current-status&quot;&gt;Current status&lt;/h2&gt;

&lt;p&gt;Progress for each bullet is detailed below.&lt;/p&gt;

&lt;h3 id=&quot;ripper-subclass&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; subclass&lt;/h3&gt;

&lt;p&gt;I’ve created an additional &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; subclass here: &lt;a href=&quot;https://github.com/kddnewton/syntax_tree/blob/main/lib/syntax_tree.rb&quot;&gt;https://github.com/kddnewton/syntax_tree/blob/main/lib/syntax_tree.rb&lt;/a&gt;. This file lives within the published &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; gem. Each node contains an instance of a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SyntaxTree::Location&lt;/code&gt; object that can be used to get definitive information about where it existed in the source. Each node also provides &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;attr_reader&lt;/code&gt; methods for each of the child nodes, which are all documented.&lt;/p&gt;

&lt;p&gt;As a part of this work, I’ve also added documentation to all of the various node types that ship with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; here: &lt;a href=&quot;https://kddnewton.com/ripper-docs/&quot;&gt;https://kddnewton.com/ripper-docs/&lt;/a&gt;. Ideally, I’d like to upstream both the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; AST builder and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; documentation to make it easier for others to contribute and maintain it as a part of CRuby.&lt;/p&gt;

&lt;h3 id=&quot;prettyprint-updates&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; updates&lt;/h3&gt;

&lt;p&gt;In order to support all of the necessary formatting capabilities of a Ruby language formatter, I’ve opened a pull request (&lt;a href=&quot;https://github.com/ruby/ruby/pull/5163&quot;&gt;https://github.com/ruby/ruby/pull/5163&lt;/a&gt;) against Ruby that adds a bunch of new functionality to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; gem. That pull request itself has a lot of details on why the changes are necessary and details about how the gem is impacted.&lt;/p&gt;

&lt;h3 id=&quot;formatter&quot;&gt;Formatter&lt;/h3&gt;

&lt;p&gt;The formatter itself is baked into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; gem. Each node has its own corresponding &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;format&lt;/code&gt; node (that functions in the same spirit as the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pretty_print&lt;/code&gt; method convention of accepting a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PrettyPrint&lt;/code&gt; object). For example, &lt;a href=&quot;https://github.com/kddnewton/syntax_tree/blob/0d3e9b7bcc0b198ca92b617cc787b17744035dd8/lib/syntax_tree.rb#L866-L881&quot;&gt;here&lt;/a&gt; is the code that handles formatting an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ARef&lt;/code&gt; node (a node in the syntax tree that corresponds to accessing a collection at an index like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;collection[index]&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;As of the latest commit on the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main&lt;/code&gt; branch of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; repository, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; supports all of the Ruby 3.1 syntax. As an additional guarantee of stability, I’ve added to the test suite a &lt;a href=&quot;https://github.com/kddnewton/syntax_tree/blob/0d3e9b7bcc0b198ca92b617cc787b17744035dd8/test/idempotency_test.rb&quot;&gt;test&lt;/a&gt; that formats all of the files shipped with Ruby twice to test for idempotency.&lt;/p&gt;

&lt;h3 id=&quot;stree-cli&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stree&lt;/code&gt; CLI&lt;/h3&gt;

&lt;p&gt;The &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; gem now ships with an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stree&lt;/code&gt; executable that functions as a CLI for formatting files. It provides a lot of additional functionality is well (like displaying the syntax tree or the doc node print tree). One additional nicety that it provides is the ability to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stree check **/*&lt;/code&gt; which will exit &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; if any files are not formatted as expected (which allows running this in a continuous integration environment).&lt;/p&gt;

&lt;h3 id=&quot;language-server&quot;&gt;Language server&lt;/h3&gt;

&lt;p&gt;Recently, I added language server support to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; project to support integrating with editors that support the language server protocol. The code for that lives &lt;a href=&quot;https://github.com/kddnewton/syntax_tree/blob/0d3e9b7bcc0b198ca92b617cc787b17744035dd8/lib/syntax_tree/language_server.rb&quot;&gt;here&lt;/a&gt;. Currently it supports the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;textDocument/formatting&lt;/code&gt; request type, which allows &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;formatOnSave&lt;/code&gt; functionality (you can turn this on in your editor of choice today by manually bundling the language server).&lt;/p&gt;

&lt;p&gt;One additional piece of functionality that the language server provides is the custom &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntaxTree/visualizing&lt;/code&gt; request. This request returns the syntax tree of the file corresponding to the given URI, which allows the requesting editor to display a tree-like structure inline with the code being edited. In VSCode, if you execute &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntaxTree.visualize&lt;/code&gt;, it will now open a side-by-side tab with the displayed tree.&lt;/p&gt;

&lt;h2 id=&quot;future-work&quot;&gt;Future work&lt;/h2&gt;

&lt;p&gt;I still have lots of functionality I’d like to bring to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; and its related projects. I also have some far-flung dreams that may or may not come to fruition. First, here are the things that I definitely intend to complete before the end of this project:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I’d like to upstream the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; AST builder, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; documentation, and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; updates. I’ll be asking for feedback on them soon, but ideally all of this would ship with CRuby to make it easier for it to stay up-to-date with syntax changes as they are built.&lt;/li&gt;
  &lt;li&gt;I’d like to enhance the language server to not only provide the syntax tree as a custom request but to support it on hover so that you can hover over any syntactic structure in your code and have it explained. I think this will help both new programmers coming to Ruby to learn the syntax but also help veteran Rubyists learn new syntax as it comes out.&lt;/li&gt;
  &lt;li&gt;I’d like to enhance the language server to better support incremental changes. At the moment, each time a file is changed the entire file is reparsed. This isn’t necessary because the change request comes with the changes ranges. We can instead only reparse the subset of the file that changed and replace the encapsulating nodes in the tree that correspond to those changes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That’s the extent of the work that corresponds to the proposed work in the grant proposal. However, I have addition desires for other future work beyond the scope of this grant. That includes:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A well-defined interface for programmatic code modification functionality. Currently you &lt;em&gt;can&lt;/em&gt; replace nodes and have them formatted correctly, meaning you can programmatically change Ruby code. However, doing this is definitely not easy and requires a lot of knowledge of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; internals. Ideally this would be a lot easier.&lt;/li&gt;
  &lt;li&gt;A backend for the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt; gem. Ideally I’d like to create an interface layer that would convert &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; nodes into their &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt; gem counterparts. I’d like to do this because it would make it trivial for gems that are consumers of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt; gem to switch to using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; as the parser for some additional speed boosts. Note that this wouldn’t mean switching off the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt; gem, it would just mean that the parsing would be faster.&lt;/li&gt;
  &lt;li&gt;Decoupling the parsing functionality (the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; subclass) from the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; node definitions. In the far future, this could potentially mean being able to switch out the parser backing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; to some other tool but maintaining all of the functionality built into the various node types.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The final report for this grant is due March 18th, and I will be publishing it here. If you’re interested in following this project, you can watch the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;syntax_tree&lt;/code&gt; repository or check/subscribe to this blog.&lt;/p&gt;</content><author><name>Kevin Newton</name></author><summary type="html">In accordance with the Ruby Association’s timeline, this is an intermediate report on the Ruby formatter project.</summary></entry><entry><title type="html">Ripper CHANGELOG 3.1.0</title><link href="https://kddnewton.com/2022/01/08/ripper-changelog-3.1.0.html" rel="alternate" type="text/html" title="Ripper CHANGELOG 3.1.0"><published>2022-01-08T00:00:00+00:00</published><updated>2022-01-08T00:00:00+00:00</updated><id>https://kddnewton.com/2022/01/08/ripper-changelog-3.1.0</id><content type="html" xml:base="https://kddnewton.com/2022/01/08/ripper-changelog-3.1.0.html">&lt;p&gt;The Ripper module ships with the Ruby standard library and gets updated (implicitly or explicitly) every time the Ruby parser changes. Unfortunately, Ripper itself never changes version (it’s been stuck at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0.1.0&lt;/code&gt; &lt;a href=&quot;https://github.com/ruby/ruby/blob/09cfc653b77584d557a551df6a5b8ebddbbd11a2/parse.y#L801&quot;&gt;since it was first shipped&lt;/a&gt; with Ruby in 2004). As such, there isn’t really a dedicated CHANGELOG, and it’s somewhat difficult to determine what changed inside the Ripper module without digging into the source.&lt;/p&gt;

&lt;p&gt;Because I &lt;a href=&quot;https://kddnewton.com/ripper-docs/&quot;&gt;maintain&lt;/a&gt; &lt;a href=&quot;https://github.com/kddnewton/syntax_tree&quot;&gt;a&lt;/a&gt; &lt;a href=&quot;https://github.com/prettier/plugin-ruby&quot;&gt;couple&lt;/a&gt; &lt;a href=&quot;https://github.com/kddnewton/sorbet-eraser&quot;&gt;of&lt;/a&gt; &lt;a href=&quot;https://github.com/kddnewton/preval&quot;&gt;things&lt;/a&gt; that depend on Ripper’s interface, I have some insight into what goes down when Ripper updates. Because of this, I’m putting out this blog post with a list of the changes in the hope that it helps anyone else out there that may be using Ripper for their own purposes.&lt;/p&gt;

&lt;p&gt;First of all, if you’re unfamiliar with how Ripper works, I recommend checking out my &lt;a href=&quot;https://kddnewton.com/ripper-docs/&quot;&gt;documentation project&lt;/a&gt;. It’s there to help explain a lot of the terminology I’m going to use to describe the changes here. If you’re interested in skipping past my description of the changes are want to just see the code that has to change, feel free to take a look at &lt;a href=&quot;https://github.com/kddnewton/syntax_tree/pull/11/files&quot;&gt;this pull request&lt;/a&gt; that I had to make to &lt;a href=&quot;https://github.com/kddnewton/syntax_tree&quot;&gt;kddnewton/syntax_tree&lt;/a&gt; to support Ruby 3.1.0.&lt;/p&gt;

&lt;p&gt;Without further ado, the changes are listed below.&lt;/p&gt;

&lt;h2 id=&quot;blocks-without-names&quot;&gt;Blocks without names&lt;/h2&gt;

&lt;p&gt;Because blocks can now be forwarded without a name, both &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_args_add_block&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_blockarg&lt;/code&gt; have changed somewhat.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;decorated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# ... do something with the block here ...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;decorator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;About to perform the action&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;decorated&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Performed the action&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_args_add_block&lt;/code&gt; - previously you could rely on the second argument (the block argument) to determine whether or not a block was actually passed. Instead, you now need to check if you’ve recently seen an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_op&lt;/code&gt; call with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;&amp;amp;&quot;&lt;/code&gt; argument. If you have, then a block is being passed through without a name.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_blockarg&lt;/code&gt; - the only argument to this event handler is the name of the block argument. Since you can now forward blocks, this can now be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt; instead of always being the result of an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_ident&lt;/code&gt; call.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;hash-keys-without-values&quot;&gt;Hash keys without values&lt;/h2&gt;

&lt;p&gt;You can now create hash keys without values, somewhat similar to how it’s done in JavaScript. Because of this, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_assoc_new&lt;/code&gt; changed.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:,&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;y: &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# =&amp;gt; { x: 1, y: 2 }&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_assoc_new&lt;/code&gt; - this event handler accepts both a key and value argument. The value argument used to be any Ruby expression, but now can also be &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nil&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;endless-methods-without-parentheses&quot;&gt;Endless methods without parentheses&lt;/h2&gt;

&lt;p&gt;You can now create endless methods without using parentheses around the arguments to method calls, which changes &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_bodystmt&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_def&lt;/code&gt;, and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_defs&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;double3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;double3&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# =&amp;gt; 6&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_bodystmt&lt;/code&gt; - this event handler accepts 4 arguments, corresponding to the contained statements and then 3 optional consequent clauses. Previously, the first argument was always the result of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_stmts_new&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_stmts_add&lt;/code&gt;. Now however, if it’s nested inside an endless method definition, it can contain any Ruby expression.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_def&lt;/code&gt;/&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_defs&lt;/code&gt; - both of these method definition event handlers accept as their last argument the statements that comprise the method definition. Previously this was always the result of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_bodystmt&lt;/code&gt; for methods with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt; keywords and a single expression for methods without &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;end&lt;/code&gt; keywords. Now it’s the result of having called &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_bodystmt&lt;/code&gt; with a single expression.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;argument-forwarding&quot;&gt;Argument forwarding&lt;/h2&gt;

&lt;p&gt;When you forward arguments using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;...&lt;/code&gt; operator, it has changed position in its event handler. This changes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_params&lt;/code&gt; event handler.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# ...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:GET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_params&lt;/code&gt; - now when you’re using argument forwarding, the block argument (the last argument to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_params&lt;/code&gt; event handler) is a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:&amp;amp;&lt;/code&gt; symbol literal. The result of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_args_forward&lt;/code&gt; has also changed position from being in the rest position (the 3rd argument) to being in the keyword rest position (the 6th argument).&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pinned-expressions&quot;&gt;Pinned expressions&lt;/h2&gt;

&lt;p&gt;You can now pin expressions and not just identifiers within pattern matching. This changes the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_begin&lt;/code&gt; event handler.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;matched&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_begin&lt;/code&gt; - this event handler used to always accept a single &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_bodystmt&lt;/code&gt; result. It now accepts any Ruby expression in the case that it represents a pinned expression inside of a pattern match. In this case you need to determine if there has been an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_op&lt;/code&gt; call with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;^&quot;&lt;/code&gt; value as its argument to determine if you’re inside a pattern match.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;wrapping-up&quot;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;For a comprehensive list of the changes that went into Ruby 3.1.0, I recommend &lt;a href=&quot;https://rubyreferences.github.io/rubychanges/3.1.html&quot;&gt;this blog post&lt;/a&gt;. If you think I’ve missed anything, feel free to reach out on twitter &lt;a href=&quot;https://twitter.com/kddnewton&quot;&gt;@kddnewton&lt;/a&gt;.&lt;/p&gt;</content><author><name>Kevin Newton</name></author><summary type="html">The Ripper module ships with the Ruby standard library and gets updated (implicitly or explicitly) every time the Ruby parser changes. Unfortunately, Ripper itself never changes version (it’s been stuck at 0.1.0 since it was first shipped with Ruby in 2004). As such, there isn’t really a dedicated CHANGELOG, and it’s somewhat difficult to determine what changed inside the Ripper module without digging into the source.</summary></entry><entry><title type="html">Prettier Ruby 2.0.0</title><link href="https://kddnewton.com/2021/10/28/prettier-ruby-2.0.0.html" rel="alternate" type="text/html" title="Prettier Ruby 2.0.0"><published>2021-10-28T00:00:00+00:00</published><updated>2021-10-28T00:00:00+00:00</updated><id>https://kddnewton.com/2021/10/28/prettier-ruby-2.0.0</id><content type="html" xml:base="https://kddnewton.com/2021/10/28/prettier-ruby-2.0.0.html">&lt;p&gt;I just released the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.0.0&lt;/code&gt; version of the &lt;a href=&quot;https://github.com/prettier/plugin-ruby&quot;&gt;prettier plugin for Ruby&lt;/a&gt;. In this post I’m going to talk about what this project is, how it works, what the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.0.0&lt;/code&gt; release means, and where this project is going.&lt;/p&gt;

&lt;h2 id=&quot;what-is-prettier-for-ruby&quot;&gt;What is prettier for Ruby?&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://prettier.io/&quot;&gt;Prettier&lt;/a&gt; is an opinionated language-agnostic formatter for code. It was started in 2017, and since then has seen a meteoric rise in usage within the frontend ecosystem. By default, it ships with support for JavaScript, HTML, CSS, and markdown of various forms. It also includes variants on all of these, including things like JSX, TypeScript, SCSS, MDX, etc.&lt;/p&gt;

&lt;p&gt;Prettier also ships with a plugin interface to allow it to be extended by various languages. This has resulted in the community adding support for even more languages. The most mature projects include the &lt;a href=&quot;https://github.com/dangmai/prettier-plugin-apex&quot;&gt;Apex plugin&lt;/a&gt;, the &lt;a href=&quot;https://github.com/jhipster/prettier-java&quot;&gt;Java plugin&lt;/a&gt;, the &lt;a href=&quot;https://github.com/prettier/plugin-php&quot;&gt;PHP plugin&lt;/a&gt;, the &lt;a href=&quot;https://github.com/prettier/plugin-xml&quot;&gt;XML/SVG plugin&lt;/a&gt;, and of course the &lt;a href=&quot;https://github.com/prettier/plugin-ruby&quot;&gt;Ruby plugin&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The Ruby plugin adds support for formatting the Ruby programming language to the prettier package. By virtue of plugging into prettier, it also gets a whole set of editor integrations for free, so this package includes that as well.&lt;/p&gt;

&lt;h2 id=&quot;how-prettier-plugins-work&quot;&gt;How prettier plugins work&lt;/h2&gt;

&lt;p&gt;When you’re writing a prettier plugin, you’re effectively writing two parts. The first part is the &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/ruby/parser.ts#L5-L11&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse&lt;/code&gt; function&lt;/a&gt;, which is responsible for transforming a string of source code (given to you by prettier) into some kind of object structure. The structure can actually be anything that you want. If it conforms to certain parameters (like having a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;comments&lt;/code&gt; key at the top of the structure) then prettier will attempt to take care of some of the printing for you.&lt;/p&gt;

&lt;p&gt;Once you’ve transformed the source into your structure, that object will then be accessible through prettier’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AstPath&lt;/code&gt; object that will be passed into your &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/ruby/printer.ts#L123-L138&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print&lt;/code&gt; function&lt;/a&gt;. Your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print&lt;/code&gt; function is responsible for taking the object you generated in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse&lt;/code&gt; function and transforming it into an intermediate representation that prettier calls &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Doc&lt;/code&gt; nodes.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Doc&lt;/code&gt; nodes are small, simple objects that represent various pieces of text that should be printed. The simplest of these is just a string of text, which will be printed literally. There is also the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;indent&lt;/code&gt; node, which will move all of the contents that you pass into it one level higher in indentation. There are also &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;align&lt;/code&gt; nodes, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;fill&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;join&lt;/code&gt; nodes, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dedent&lt;/code&gt; nodes, etc. You can view all of them in the &lt;a href=&quot;https://github.com/prettier/prettier/blob/6106421f0a7f9f241ae1de64fb22f0a21a9c0778/src/document/doc-builders.js&quot;&gt;doc-builders.js&lt;/a&gt; file.&lt;/p&gt;

&lt;p&gt;The most important of these nodes are the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;group&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;line&lt;/code&gt; nodes. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;group&lt;/code&gt; nodes contain other nodes but change slightly how they print. If a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;group&lt;/code&gt; cannot fit its contents onto the current line, then it “breaks” its content up whenever it sees a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;line&lt;/code&gt; node. (Note: this is a slightly simplified version of what actually happens, but you get the point.)&lt;/p&gt;

&lt;p&gt;Once you’ve built up this intermediate representation in your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print&lt;/code&gt; function, prettier can take over, as at this point the structure of your formatter is entirely language-agnostic. It doesn’t matter that originally it was a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class&lt;/code&gt; node or a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;module&lt;/code&gt; node, at this point it’s just text and groups. Prettier will then take its nodes and print them out for you.&lt;/p&gt;

&lt;h2 id=&quot;how-the-ruby-plugin-works&quot;&gt;How the Ruby plugin works&lt;/h2&gt;

&lt;p&gt;In order to write the Ruby plugin, we needed the two pieces mentioned above, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;print&lt;/code&gt; functions. Let’s start with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse&lt;/code&gt; function.&lt;/p&gt;

&lt;h3 id=&quot;parser&quot;&gt;Parser&lt;/h3&gt;

&lt;p&gt;If you want the access the syntax tree (a structure that represents the code and the way it is laid out in source) you have a couple of options in the Ruby ecosystem. There are two main packages that will do this for you: &lt;a href=&quot;https://github.com/seattlerb/ruby_parser&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ruby_parser&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/whitequark/parser&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser&lt;/code&gt;&lt;/a&gt;. There is also one standard library (assuming you’re supporting versions of Ruby &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&amp;lt; 2.7&lt;/code&gt;) that will do this for you: &lt;a href=&quot;https://github.com/ruby/ruby/blob/b9f34062f00d1d2548ca9b6af61a6447c2d0f8e3/ext/ripper/README&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt;&lt;/a&gt;. Due to the nature of this project where it was going to be run as a node project, I didn’t think it would be feasible to rely on the various Ruby load paths for dependencies, so the standard library &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; was the only realistic option.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; is a very interesting tool that effectively forks the bison parser that Ruby uses internally by placing special comments into the source grammar file. Every time a production rule is reduced in the generated parser, it dispatches an “event” for that rule. So for example, if you wanted to get a list of all of the comments in a Ruby source file, you could use &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; like:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CommentRipper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;attr_reader&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:comments&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;
    &lt;span class=&quot;vi&quot;&gt;@comments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_comment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;vi&quot;&gt;@comments&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ripper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;CommentRipper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;~&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;CODE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;sh&quot;&gt;
  # this is a comment
  foo
  # this is another comment
&lt;/span&gt;&lt;span class=&quot;no&quot;&gt;CODE&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ripper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ripper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;comments&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# =&amp;gt; [&quot;# this is a comment\n&quot;, &quot;# this is another comment\n&quot;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This works for this small example, as comments by default are ignored in the final structure anyway. However, if you want to handle more node types, it’s useful to know that the return value of your handler function will get passed up the tree as it’s being built. So for example, let’s say you wanted to write a calculator using ripper. You could write:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CalculatorRipper&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Ripper&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_binary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oper&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;when&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;:/&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;to_i&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_stmts_new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_stmts_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stmts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stmt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stmts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stmt&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;on_program&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stmts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stmts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;first&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;no&quot;&gt;CalculatorRipper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'1 + 2 * 3'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;# =&amp;gt; 7&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Internally, the parse tree for the code that we passed into that example looks something like:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:program&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:stmts_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:stmts_new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:binary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:binary&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;ss&quot;&gt;:int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can see from this structure what’s going to get called first. It’s going to start at the leaves of the tree, so &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_int&lt;/code&gt; is going to get called with the argument &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;2&quot;&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;&quot;3&quot;&lt;/code&gt;. Those are going to get transformed into integers with the call to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;to_i&lt;/code&gt;. They’re both going to be passed into the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_binary&lt;/code&gt; method next, along with the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;:*&lt;/code&gt; operator. That will return &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;6&lt;/code&gt;, which will in turn get passed up to the next &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on_binary&lt;/code&gt; call. Finally we’ll pass everything up to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stmts_add&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;program&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can see how in this way, we can build up whatever structure we want using ripper, provided we implement enough methods. That’s exactly what we’ve done in our prettier plugin, which is to implement a handler method for every node in the parse tree in our &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/ruby/parser.rb&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parser.rb&lt;/code&gt;&lt;/a&gt; file.&lt;/p&gt;

&lt;p&gt;If you’re interested in learning more about ripper and how it works internally, I’ve written up just about everything I know about ripper in a completely separate repository &lt;a href=&quot;https://kddnewton.com/ripper-docs/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;server&quot;&gt;Server&lt;/h3&gt;

&lt;p&gt;When the initial request to parse a file comes into our plugin, it comes in from the parent node process. However, our parser is written in Ruby. So we need a way to communicate between the two languages that will allow us to pass the structure back from Ruby once it’s done parsing. In order to accomplish this, when the first request to parse a file is received, the node process will spawn a Ruby server that handles all current and future parse requests.&lt;/p&gt;

&lt;p&gt;That server is defined in our &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/parser/server.rb&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;server.rb&lt;/code&gt;&lt;/a&gt; file. It is first spawned in our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parseSync.ts&lt;/code&gt; file within our &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/parser/parseSync.ts#L63-L165&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spawnServer&lt;/code&gt;&lt;/a&gt; function. A couple of things happen here that are a little complicated to get everything set up correctly.&lt;/p&gt;

&lt;p&gt;The first issue is that for a prettier plugin, your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse&lt;/code&gt; function &lt;em&gt;must&lt;/em&gt; be synchronous, meaning when you receive code you cannot return a promise that will resolve to syntax tree. The second issue is that node has no built-in way of communicating with a separate server that is synchronous. The only thing that will block the main thread that looks anything like server communication is to spawn another process and wait for it to exit. So this is how we communicate between the two processes. The data flow looks like the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Receive a request to parse code in one of our plugin’s &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parse&lt;/code&gt; functions, as in &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/ruby/parser.ts#L5-L11&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Create a temporary file where our connection information is going to be written &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/parser/parseSync.ts#L68-L69&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Spawn a Ruby process running our server &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/parser/parseSync.ts#L125-L129&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Once the server is booted, it determines the fastest way to connect to it in parallel (looking at tools like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netcat&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;telnet&lt;/code&gt;) &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/parser/server.rb#L110-L135&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Now that the server is booted and knows the best way to connect, it writes out that connection information to the temporary file created in the node process &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/parser/server.rb#L139&quot;&gt;here&lt;/a&gt;. It then blocks the process waiting for future requests&lt;/li&gt;
  &lt;li&gt;Back in the parent node process, spawn another process that will block and wait for the connection information to be written &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/parser/parseSync.ts#L152&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;The child process that waits for the connection information to be written eventually writes back that information to stdout &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/parser/getInfo.js&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Finally, the server is booted and we know how to communicate with it, so send the actual parse request to the server and return the resulting structure &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/parser/parseSync.ts#L187-L213&quot;&gt;here&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While this is a pretty complicated setup, in reality it only needs to be done once for the lifetime of the prettier node process, as after that it’s set up and ready for future requests. The whole cycle takes about 200ms for the first request, whereas future requests are much quicker (measured in double-digit ms).&lt;/p&gt;

&lt;h3 id=&quot;printer&quot;&gt;Printer&lt;/h3&gt;

&lt;p&gt;Now that the structure has been returned, prettier does something nice and attaches our parsed comments to our parse tree for us. It does this by first “decorating” each comments with metadata about its “enclosing” node (the parent node in the tree), its “preceding” node (the node immediately before the comment), and its “following” node (the node immediately after the comment). Any of these nodes can be null. It does that in its &lt;a href=&quot;https://github.com/prettier/prettier/blob/6106421f0a7f9f241ae1de64fb22f0a21a9c0778/src/main/comments.js#L78-L155&quot;&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;decorateComment&lt;/code&gt;&lt;/a&gt; function.&lt;/p&gt;

&lt;p&gt;It determines these surrounding nodes by knowing where the nodes were in the original source using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;locStart&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;locEnd&lt;/code&gt; functions called &lt;a href=&quot;https://github.com/prettier/prettier/blob/6106421f0a7f9f241ae1de64fb22f0a21a9c0778/src/main/comments.js#L95-L96&quot;&gt;here&lt;/a&gt; as well as the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getSortedChildNodes&lt;/code&gt; function called &lt;a href=&quot;https://github.com/prettier/prettier/blob/6106421f0a7f9f241ae1de64fb22f0a21a9c0778/src/main/comments.js#L86&quot;&gt;here&lt;/a&gt;. Those functions &lt;em&gt;must&lt;/em&gt; be provided by the plugin in order for this process to work properly. This is why it’s so important that every node has the ability to know where it was originally in the code.&lt;/p&gt;

&lt;p&gt;As a quick aside, this was not a trivial task. Ripper provides two methods for determining source location, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lineno&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;column&lt;/code&gt;. They internally access the information of the parser when the production rule is being reduced. However, it can take bit of further processing before the parser realizes that a parser event has occurred. In that case, the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;column&lt;/code&gt; information may be incorrect. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;column&lt;/code&gt; itself is measured as a byte offset in the original string as opposed to a character offset as well, so that difference must be taken into account. For even more information on this, check out the documentation &lt;a href=&quot;https://kddnewton.com/ripper-docs/location&quot;&gt;here&lt;/a&gt; and the inline comments &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/ruby/parser.rb#L25-L56&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;With the comments attached, prettier will pass an &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AstPath&lt;/code&gt; object around the structure. The algorithm it uses internally is not all that dissimilar to a depth-first search, in that it will recursive all of the way down to the leaf nodes before building up the overall resulting &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Doc&lt;/code&gt; node. Once that whole tree is built in the prettier intermediate representation, that tree is handed back to prettier for printing.&lt;/p&gt;

&lt;h2 id=&quot;going-200&quot;&gt;Going &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.0.0&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;There are a couple of big things that changed between the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1.6.1&lt;/code&gt; release (the last pre-&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.0.0&lt;/code&gt;) and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.0.0&lt;/code&gt; release. In terms of user-facing changes it’s actually relatively minor. Internally, however, a lot of things have changed.&lt;/p&gt;

&lt;h3 id=&quot;typescript&quot;&gt;TypeScript&lt;/h3&gt;

&lt;p&gt;The codebase for the Ruby plugin is half Ruby and half JavaScript-dialect. Previously the JS-dialect was entire JavaScript, running on node &amp;gt;= 8. All of this is backed by a fairly extensive test suite written in minitest (on the Ruby side) and jest (on the JS side).&lt;/p&gt;

&lt;p&gt;Over time, it became obvious to me that the JS-side of things was really not all that maintainable. Even though I included massive amounts of comments in the source of the plugin, there still were non-obvious checks being done (e.g., &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;node.type !== &quot;args&quot;&lt;/code&gt;, well then what is it!?) that I couldn’t remember the original reason. Overall, due to the nature of walking a tree without a well-defined structure, it just became hard to understand.&lt;/p&gt;

&lt;p&gt;It was at this point that I decided to switch that half of the codebase over to TypeScript. Mind you, this is no small task. Beyond the initial setup and trivial functions, the biggest blocker of them all presented itself: I needed a TypeScript representation of all of the possible syntax trees that my ripper parser could generate. I didn’t know how to get this without doing a lot of manual work, so I paused here for a couple of months until inspiration struck.&lt;/p&gt;

&lt;p&gt;A couple of months into thinking about this problem, I ended up developing a solution that involved parsing every Ruby file I could get my hands on (read: &lt;a href=&quot;https://github.com/ruby/ruby&quot;&gt;ruby&lt;/a&gt;, &lt;a href=&quot;https://github.com/rails/rails&quot;&gt;rails&lt;/a&gt;, &lt;a href=&quot;https://github.com/discourse/discourse&quot;&gt;discourse&lt;/a&gt;, Shopify’s internal monolith because I work there, etc.). Once I had parsed every file I could find, I generated the TypeScript types programmatically based on what I had found. Normally I would have open-sourced this kind of tool, but it was so specific to this project that I ended up scrapping it as soon as the script was finished running. After a lot of manual cleanup, I ended up with &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/types/ruby.ts&quot;&gt;this file&lt;/a&gt; which provided me with the entire tree.&lt;/p&gt;

&lt;p&gt;The next blocker was that prettier’s print functions were not very friendly to type systems. It was originally designed with JavaScript in mind, not TypeScript, so that types for the various print functions were very lacking. Let’s take a look at the following example that illustrates how you would print a tree using the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AstPath&lt;/code&gt; object:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;astPath&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AstPath&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;stmts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;binary&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;printNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;opts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// getValue gets the current node that the path is pointing to. You can&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// recurse using the path.call or path.map member functions that will call&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// back into the print function with an AstPath object pointing at the child&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// nodes.&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;program&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// If we're at the root of our tree, then we know we have a stmts key (see&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// the structure above) that points to an array of other nodes. So we can&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// call path.map to recurse down into that list and then join the result&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// of printing each one with a hardline (forced line break).&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hardline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;stmts&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hardline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;binary&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// If we're at a binary node, then we know we have &quot;left&quot;, &quot;operator&quot;, and&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// &quot;right&quot; keys on this node. In this case we can use path.call to descend&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// into each side of the node, and concat them all together using an&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// array. Since the operator itself is not a node but just a string, we&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// can just interpolate it into the result.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;` &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt; `&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// In the case of an int node, we know we only have the one &quot;value&quot; key&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// which points to a string, so we can just return that.&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The above is a very simplified version of what is happening in the Ruby plugin. You can see why it’s difficult to add a type system to these kinds of function calls. The acceptable arguments at each callsite for &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path.map&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path.call&lt;/code&gt; is dependent on which node the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AstPath&lt;/code&gt; object is currently pointing to. Fortunately, TypeScript’s generics system is pretty incredible, so we can get away with some pretty crazy stuff.&lt;/p&gt;

&lt;p&gt;Effectively, I made it so that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AstPath&lt;/code&gt; was generic over the type of node that it was pointing to. Then, when you go to call something like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path.map&lt;/code&gt;, you can introspect on the properties of the current node that are iterable and only allow those keys. So for example, for a single argument to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;map&lt;/code&gt; function you can write something like:&lt;/p&gt;

&lt;div class=&quot;language-typescript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// For a given object T, return a union of the keys of the object whose values&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// are an array or tuple.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ArrayProperties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;K&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;never&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}[&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;keyof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// For a given object T that is an array, return the type of element that&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// comprises the array.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ArrayElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;infer&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;never&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// For a given node T and a given return type U, the callback will be a function&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// that accepts an element and index of the array and returns U.&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Callback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AstPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ArrayElement&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;any&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;U&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;AstPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;P1&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ArrayProperties&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Callback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;prop1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;P1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;U&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is actually somewhat simplified from the final result which you can see &lt;a href=&quot;https://github.com/prettier/plugin-ruby/blob/f3fb267cb705573ffb62a4db4cefec3875d05d2b/src/types/plugin.ts&quot;&gt;here&lt;/a&gt;. What this is doing is saying that you can only pass keys of the node that the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AstPath&lt;/code&gt; object is currently pointing to that correspond to array values. As it turns out, this works! It becomes more complicated when you have multiple properties (like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;path.map(&quot;stmts&quot;, 0)&lt;/code&gt;), but you can see how that ends up working in the implementation from the link. What you end up doing is accepting another generic for each argument to the function as another function overload.&lt;/p&gt;

&lt;p&gt;Once I had the representation of the Ruby syntax tree and prettier adding a lot of type safety, it became a lot easier to refactor the entire codebase. The types guided me through the refactor and I was able to run the test suite at each step of the way to ensure I kept compatibility. By and large, this refactor was the biggest one I’ve ever pulled on this project, and it was very much worth it.&lt;/p&gt;

&lt;p&gt;One of the side benefits of having gone through the process of converting everything over to TypeScript is that I now have a reliable type system for the syntax tree that I can convert over the Ruby. We’ll revisit this again in the concluding section of this post.&lt;/p&gt;

&lt;h3 id=&quot;server-communication&quot;&gt;Server communication&lt;/h3&gt;

&lt;p&gt;As I mentioned in the server section of this post, the setup to communicate between the node and Ruby processes is anything but trivial. This is actually the third iteration of this piece of the plugin, which includes a refactor even in this release.&lt;/p&gt;

&lt;p&gt;The first version of the parse function spawned a Ruby process every time it wanted to parse a file. This worked flawlessly, so I was reticent to give it up. However, speed was very much an issue. Spawning any process is not cheap, and spawning a Ruby one especially tanked performance of the plugin overall. If you were going to format an entire codebase with hundreds of files, that meant hundreds of Ruby processes were going to be created.&lt;/p&gt;

&lt;p&gt;Fortunately, in the second version of the parse function, we changed all that. Instead of spawning a Ruby process every time, the plugin instead spawned a Ruby process once and then used &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netcat&lt;/code&gt; to communicate with it. The server functioned using UNIX sockets. Whenever a request to format a file was made, the node process would &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spawnSync&lt;/code&gt; a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netcat&lt;/code&gt; process into existence and write the contents of the file onto the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stdin&lt;/code&gt; file input. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netcat&lt;/code&gt; would dutifully take that and forward it on to the UNIX socket that the Ruby process was listening on. The Ruby process would receive that request and write the JSON-serialized result back onto the socket, which &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netcat&lt;/code&gt; would then print to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stdout&lt;/code&gt; and exit. Because &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;spawnSync&lt;/code&gt; blocks, the node process could then continue on and read the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;stdout&lt;/code&gt; of the now-dead child process, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;JSON.parse&lt;/code&gt; the result, and return it.&lt;/p&gt;

&lt;p&gt;This worked much better than the first version because spawning a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netcat&lt;/code&gt; process was much less costly than spawning a Ruby process. It had the benefit of keeping the Ruby server running in the background which made parsing very quick. I added some logic to support environments where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;netcat&lt;/code&gt; might not be available (like the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;rubyNetcatCommand&lt;/code&gt; option for specifying your own executable), and called it a day.&lt;/p&gt;

&lt;p&gt;There were a couple of issues that cropped up as a result of this second iteration. The first had to do with the initial spawn of the Ruby server. In order to make sure that it could do everything it needed to do before we wrote any requests to it, I was shelling out to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt; for a short period of time until the sockfile existed. This turned out to be terrible for portability. The second was that I was relying on UNIX sockets being supported everywhere, which they definitely weren’t.&lt;/p&gt;

&lt;p&gt;The third iteration, and what ended up being a part of the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.0.0&lt;/code&gt; release was to refactor this &lt;em&gt;again&lt;/em&gt; into what is described in the server section above. Effectively this meant spawning a process to spawn the Ruby server initially, and then supporting a TCP server if UNIX sockets weren’t available.&lt;/p&gt;

&lt;h3 id=&quot;windows-support&quot;&gt;Windows support&lt;/h3&gt;

&lt;p&gt;In the midst of all of the server refactoring, an issue was reported that &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt; (and UNIX sockets) weren’t supported on Windows. Fortunately, GitHub actions made it relatively painless to add different Windows boxes to our test suite. Once all of the server communication refactoring work was done and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sleep&lt;/code&gt; call was eliminated, I added the TCP server support to get the Windows test suite green. This worked, so &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2.0.0&lt;/code&gt; is a massive step forward for running this plugin on a Windwos machine.&lt;/p&gt;

&lt;h2 id=&quot;the-future&quot;&gt;The future&lt;/h2&gt;

&lt;p&gt;As much as I have enjoyed maintaining this behemoth of a project for so long, the time has come for some change. Just looking at everything I’ve written at this post is intimidating, let alone thinking about maintaining it for much longer. Ideally, I’d like to do a couple of things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Upstream the parser. Ripper currently ships with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper::SexpBuilder&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Ripper::SexpBuilderPP&lt;/code&gt;, both of which produce a structure of arrays, strings, and symbols. It includes the built-in location information for scanner events but not parser events. Unfortunately there’s not really any names associated with the various edges of the tree, so it’s difficult to work with reliably. I’d like to solve this by having ripper ship with another subclass that is effectively the parser written in this plugin, with a couple of modifications:
    &lt;ul&gt;
      &lt;li&gt;I’d like to replace the usage of all of the various hashes with well-defined classes. I don’t like that everything is being merged into each other, as it’s difficult to distinguish what’s actually going on.&lt;/li&gt;
      &lt;li&gt;I’d like to delineate the logic for serializing to JSON from the logic to do the actual parsing. At the moment we’re just dealing with the final representation, which makes it non-obvious how to change things. (A lot of this is actually an artifact of serializing to JSON: having &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;start_line&lt;/code&gt; spelled out for every node was taking too much space so I reduced it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sl&lt;/code&gt;.)&lt;/li&gt;
      &lt;li&gt;I’d like to move all of the location information into its own object and make it serialize using only an array. Having &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;{ sl:, sc:, el:, ec: }&lt;/code&gt; characters in every node wastes a lot of space.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Convert and upstream the formatting. Fortunately, prettier and the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; standard library share a similar algorithm. It should be possible to convert the bulk of what prettier is doing into enhancements to the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; gem which can be upstreamed. From there, writing the formatter should just be a matter of requiring the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ripper&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;prettyprint&lt;/code&gt; standard libraries and writing a bunch of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pp&lt;/code&gt; methods.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Fortunately, the Ruby association has agreed to sponsor this work (see the announcement &lt;a href=&quot;https://www.ruby.or.jp/en/news/20211025&quot;&gt;here&lt;/a&gt;) so this will be happening of the course of the next six months. Beyond that, I still have more goals for this project as well, including:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Building a language server dedicated to the formatter.&lt;/li&gt;
  &lt;li&gt;Bringing basic linting capability into this project.&lt;/li&gt;
  &lt;li&gt;Explaining syntax on hover for people less familiar with the more esoteric parts of Ruby syntax.&lt;/li&gt;
  &lt;li&gt;Add refactoring support to the language server for a better development experience.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We’ll see what’s possible. It’s an exciting time to work on Ruby dev tools!&lt;/p&gt;</content><author><name>Kevin Newton</name></author><summary type="html">I just released the 2.0.0 version of the prettier plugin for Ruby. In this post I’m going to talk about what this project is, how it works, what the 2.0.0 release means, and where this project is going.</summary></entry></feed>