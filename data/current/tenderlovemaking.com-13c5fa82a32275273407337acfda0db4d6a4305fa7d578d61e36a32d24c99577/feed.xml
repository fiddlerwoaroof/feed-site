<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <id>http://tenderlovemaking.com/</id>
  <title>Tender Lovemaking</title>
  <updated>2022-06-12T12:54:35-07:00</updated>

  <author>
    <name>Aaron Patterson</name>
    <email>tenderlove@ruby-lang.org</email>
  </author>

  <link href="http://tenderlovemaking.com/atom.xml" rel="self">
  <link href="http://tenderlovemaking.com/">

  <rights> Â© Aaron Patterson - tenderlove@ruby-lang.org </rights>

  
    <entry>
      <id>http://tenderlovemaking.com/2022/06/12/cross-platform-machine-code.html</id>
      <title>Cross Platform Machine Code</title>
      <updated>2022-06-12T12:54:35-07:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2022/06/12/cross-platform-machine-code.html">

      <published>2022-06-12T12:54:35-07:00</published>
      <content type="html">&lt;p&gt;I hate writing &lt;code&gt;if&lt;/code&gt; statements.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been working on a couple different assemblers for Ruby.
&lt;a href=&quot;https://github.com/tenderlove/fisk&quot;&gt;Fisk&lt;/a&gt; is a pure Ruby x86 assembler.
You can use it to generate bytes that can be executed on x86 machines.
&lt;a href=&quot;https://github.com/tenderlove/aarch64&quot;&gt;AArch64&lt;/a&gt; is a pure Ruby ARM64 assembler.
You can use it to generate bytes that can be executed on ARM64 machines.&lt;/p&gt;

&lt;p&gt;Both of these libraries just generate bytes that can be interpreted by their respective processors.
Unfortunately you can&amp;rsquo;t just generate bytes and expect the CPU to execute them.
You first need to put the bytes in &lt;strong&gt;executable memory&lt;/strong&gt; before you can hand them off to the CPU for execution.
Executable memory is basically the same thing regardless of CPU architecture, so I decided to make a library called &lt;a href=&quot;https://github.com/tenderlove/jit_buffer&quot;&gt;JITBuffer&lt;/a&gt; that encapsulates executable memory manipulation.&lt;/p&gt;

&lt;p&gt;To use the &lt;code&gt;JITBuffer&lt;/code&gt;, you write platform specific bytes to the buffer, then give the buffer to the CPU for execution.
Here is an example on the ARM64 platform:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;aarch64&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;jit_buffer&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;fiddle&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

asm = &lt;span class=&quot;constant&quot;&gt;AArch64&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Assembler&lt;/span&gt;.new

&lt;span class=&quot;comment&quot;&gt;# Make some instructions.  These instructions simply&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# return the value 0xF00DCAFE&lt;/span&gt;
asm.pretty &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
  asm.movz x0, &lt;span class=&quot;integer&quot;&gt;0xCAFE&lt;/span&gt;
  asm.movk x0, &lt;span class=&quot;integer&quot;&gt;0xF00D&lt;/span&gt;, lsl(&lt;span class=&quot;integer&quot;&gt;16&lt;/span&gt;)
  asm.ret
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Write the bytes to executable memory:&lt;/span&gt;
buf = &lt;span class=&quot;constant&quot;&gt;JITBuffer&lt;/span&gt;.new(&lt;span class=&quot;integer&quot;&gt;4096&lt;/span&gt;)
buf.writeable!
asm.write_to buf
buf.executable!

&lt;span class=&quot;comment&quot;&gt;# Point the CPU at the executable memory&lt;/span&gt;
func = &lt;span class=&quot;constant&quot;&gt;Fiddle&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Function&lt;/span&gt;.new(buf.to_i, [], -&lt;span class=&quot;constant&quot;&gt;Fiddle&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;TYPE_INT&lt;/span&gt;)
p func.call.to_s(&lt;span class=&quot;integer&quot;&gt;16&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; &amp;quot;f00dcafe&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The example uses the &lt;code&gt;AArch64&lt;/code&gt; gem to assemble ARM64 specific bytes, the &lt;code&gt;JITBuffer&lt;/code&gt; gem to allocate executable memory, and the &lt;code&gt;Fiddle&lt;/code&gt; gem to point the CPU at the executable memory and run it.&lt;/p&gt;

&lt;p&gt;Tests are important I guess, so I thought it would be a good idea to write tests for the &lt;code&gt;JITBuffer&lt;/code&gt; gem.
My goal for the test is to ensure that it&amp;rsquo;s actually possible to execute the bytes in the buffer itself.
I&amp;rsquo;m not a huge fan of stubs or mocks and I try to avoid them if possible, so I wanted to write a test that would &lt;em&gt;actually execute&lt;/em&gt; the bytes in the buffer.
I also want the test to be &amp;ldquo;cross platform&amp;rdquo; (where &amp;ldquo;cross platform&amp;rdquo; means &amp;ldquo;works on x86_64 and ARM64&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;Writing a test like this would mean writing something like the following:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;test_can_execute&lt;/span&gt;
  buf = &lt;span class=&quot;constant&quot;&gt;JITBuffer&lt;/span&gt;.new(&lt;span class=&quot;integer&quot;&gt;4096&lt;/span&gt;)

  platform = figure_out_what_platform_we_are_on()
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; platform == &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;arm64&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;# write arm64 specific bytes&lt;/span&gt;
    buf.write(...)
  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;# write x86_64 specific bytes&lt;/span&gt;
    buf.write(...)
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;comment&quot;&gt;# Use fiddle to execute&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;As I said at the start though, I hate writing &lt;code&gt;if&lt;/code&gt; statements, and I&amp;rsquo;d rather avoid it if possible.
In addition, how do you reliably figure out what platform you&amp;rsquo;re executing on?
I really don&amp;rsquo;t want to figure that out.
Not to mention, I just don&amp;rsquo;t think this code is &lt;em&gt;cool&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;My test requirements:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;No if statements&lt;/li&gt;
  &lt;li&gt;Self contained (I don&amp;rsquo;t want to shell out or use other libraries)&lt;/li&gt;
  &lt;li&gt;Must have pizzazz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since machine code is just bytes that the CPU interprets, it made me wonder &amp;ldquo;is there a set of bytes that execute both on an x86_64 CPU &lt;strong&gt;and&lt;/strong&gt; an ARM64 CPU?&amp;rdquo;
It turns out there are, and I want to walk through them here.&lt;/p&gt;

&lt;h2 id=&quot;x8664-instructions&quot;&gt;x86_64 Instructions&lt;/h2&gt;

&lt;p&gt;First lets look at the x86_64 instructions we&amp;rsquo;ll execute.
Below is the assembly code (in Intel syntax):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.start:
  mov rax, 0x2b ; put 0x2b in the rax register
  ret           ; return from the function
  jmp start     ; jump to .start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This assembly code puts the value &lt;code&gt;0x2b&lt;/code&gt; in the &lt;code&gt;rax&lt;/code&gt; register and returns from the current &amp;ldquo;C&amp;rdquo; function.
I put &amp;ldquo;C&amp;rdquo; in quotes because we&amp;rsquo;re writing assembly code, but the assembly code is conforming to the C calling convention and we&amp;rsquo;ll treat it as if it&amp;rsquo;s a C function when we call it.
The x86 C calling convention states that the value in the &lt;code&gt;rax&lt;/code&gt; register is the &amp;ldquo;return value&amp;rdquo; of the C function.
So we&amp;rsquo;ve created a function that returns &lt;code&gt;0x2b&lt;/code&gt;.
At the end of the code there is a &lt;code&gt;jmp&lt;/code&gt; instruction that jumps to the start of this sequence.
However, since we return from the function before getting to the jump, the jump is never used (or is it?????)&lt;/p&gt;

&lt;p&gt;Machine code is just bytes, and here are the bytes for the above x86 machine code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0x48 0xC7 0xC0 0x2b 0x00 0x00 0x00  ; mov rax, 0x2b
0xC3                                ; ret
0xEB 0xF6                           ; jmp start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;x86 uses a &amp;ldquo;variable width&amp;rdquo; encoding, meaning that the number of bytes each instruction uses can vary.
In this example, the &lt;code&gt;mov&lt;/code&gt; instruction used 7 bytes, and the &lt;code&gt;ret&lt;/code&gt; instruction used 1 byte.
This means that the &lt;code&gt;jmp&lt;/code&gt; instruction is the 9th byte, or offset 8.&lt;/p&gt;

&lt;h2 id=&quot;arm64-instructions&quot;&gt;ARM64 Instructions&lt;/h2&gt;

&lt;p&gt;Below are some ARM64 instructions we can execute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;movz X11, 0x7b7 ; put 0x7b7 in the X11 register
movz X0, 0x2b   ; put 0x2b in the X0 register
ret             ; return from the function
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This machine code puts the value 0x7b7 in to the register &lt;code&gt;X11&lt;/code&gt;.
Then it puts the value 0x2b in the &lt;code&gt;X0&lt;/code&gt; register.
The third instruction returns from the function.
Again we are abiding by the C calling convention, but this time on the ARM64 platform.
On the ARM64 platform, the value stored in &lt;code&gt;X0&lt;/code&gt; is the return value.
So the above machine code will return the value &lt;code&gt;0x2b&lt;/code&gt; to the caller just like the x86_64 machine code did.&lt;/p&gt;

&lt;p&gt;Here are the bytes that represent the above ARM64 machine code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0xEB 0xF6 0x80 0xD2  ; movz X11, 0x7b7
0x60 0x05 0x80 0xD2  ; movz X0, 0x2b
0xC0 0x03 0x5F 0xD6  ; ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ARM64 uses &lt;em&gt;fixed width&lt;/em&gt; instructions.
All instructions on ARM64 are 32 bits wide.&lt;/p&gt;

&lt;h2 id=&quot;cross-platform-machine-code&quot;&gt;Cross Platform Machine Code&lt;/h2&gt;

&lt;p&gt;Lets look at the byte blocks next to each other:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;; x86_64 bytes
0x48 0xC7 0xC0 0x2b 0x00 0x00 0x00  ; mov rax, 0x2b
0xC3                                ; ret
0xEB 0xF6                           ; jmp start
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;; ARM64 bytes
0xEB 0xF6 0x80 0xD2  ; movz X11, 0x7b7
0x60 0x05 0x80 0xD2  ; movz X0, 0x2b
0xC0 0x03 0x5F 0xD6  ; ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at the bytes, you&amp;rsquo;ll notice that the first two bytes of the ARM64 code (&lt;code&gt;0xEB 0xF6&lt;/code&gt;) are &lt;strong&gt;exactly the same&lt;/strong&gt; as the last two bytes of the x86_64 code.
The first &lt;code&gt;movz&lt;/code&gt; instruction in the ARM64 code was specially crafted as to have the same bytes as the last &lt;code&gt;jmp&lt;/code&gt; instruction in the x86 code.&lt;/p&gt;

&lt;p&gt;If we &lt;em&gt;combine&lt;/em&gt; these bytes, then tell the CPU to execute starting at a particular offset, then &lt;em&gt;the interpretation&lt;/em&gt; of the bytes will change depending on the CPU, but &lt;em&gt;the result&lt;/em&gt; is the same.&lt;/p&gt;

&lt;p&gt;Here are the bytes combined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          0x48 0xC7 0xC0 0x2b 0x00 0x00 0x00  ; mov rax, 0x2b
          0xC3                                ; ret
start -&amp;gt;  0xEB 0xF6 0x80 0xD2                 ; (jmp start, or movz X11, 0x7b7)
          0x60 0x05 0x80 0xD2                 ; movz X0, 0x2b
          0xC0 0x03 0x5F 0xD6                 ; ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Regardless of platform, we&amp;rsquo;ll tell the CPU to start executing from offset 8 in the byte buffer.
If it&amp;rsquo;s an x86 CPU, it will interpret the bytes as a jump, execute the top bytes, return at the &lt;code&gt;ret&lt;/code&gt;, and ignore the rest of the bytes in the buffer (as they are never reached).
If it&amp;rsquo;s an ARM64 machine, then it will interpret the bytes as &amp;ldquo;put 0x7b7 in the X11 register&amp;rdquo; and continue, never seeing the x86 specific bytes at the start of the buffer.&lt;/p&gt;

&lt;p&gt;Both x86_64 and ARM64 platforms will return the same value 0x2b.&lt;/p&gt;

&lt;p&gt;Now we can write a test without &lt;code&gt;if&lt;/code&gt; statements like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;test_execute&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;# Cross platform bytes&lt;/span&gt;
  bytes = [&lt;span class=&quot;integer&quot;&gt;0x48&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0xc7&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0xc0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0x2b&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0x00&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0x00&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0x00&lt;/span&gt;, &lt;span class=&quot;comment&quot;&gt;# x86_64 mov rax, 0x2b&lt;/span&gt;
           &lt;span class=&quot;integer&quot;&gt;0xc3&lt;/span&gt;,                                     &lt;span class=&quot;comment&quot;&gt;# x86_64 ret&lt;/span&gt;
           &lt;span class=&quot;integer&quot;&gt;0xeb&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0xf6&lt;/span&gt;,                               &lt;span class=&quot;comment&quot;&gt;# x86 jmp&lt;/span&gt;
           &lt;span class=&quot;integer&quot;&gt;0x80&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0xd2&lt;/span&gt;,                               &lt;span class=&quot;comment&quot;&gt;# ARM movz X11, 0x7b7&lt;/span&gt;
           &lt;span class=&quot;integer&quot;&gt;0x60&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0x05&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0x80&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0xd2&lt;/span&gt;,                   &lt;span class=&quot;comment&quot;&gt;# ARM movz X0, #0x2b&lt;/span&gt;
           &lt;span class=&quot;integer&quot;&gt;0xc0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0x03&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0x5f&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0xd6&lt;/span&gt;]                   &lt;span class=&quot;comment&quot;&gt;# ARM ret&lt;/span&gt;

  &lt;span class=&quot;comment&quot;&gt;# Write them to the buffer&lt;/span&gt;
  jit = &lt;span class=&quot;constant&quot;&gt;JITBuffer&lt;/span&gt;.new(&lt;span class=&quot;integer&quot;&gt;4096&lt;/span&gt;)
  jit.writeable!
  jit.write bytes.pack(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;C*&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
  jit.executable!

  &lt;span class=&quot;comment&quot;&gt;# start at offset 8&lt;/span&gt;
  offset = &lt;span class=&quot;integer&quot;&gt;8&lt;/span&gt;
  func = &lt;span class=&quot;constant&quot;&gt;Fiddle&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Function&lt;/span&gt;.new(jit.to_i + offset, [], &lt;span class=&quot;constant&quot;&gt;Fiddle&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;TYPE_INT&lt;/span&gt;)

  &lt;span class=&quot;comment&quot;&gt;# Check the return value&lt;/span&gt;
  assert_equal &lt;span class=&quot;integer&quot;&gt;0x2b&lt;/span&gt;, func.call
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;So simple!&lt;/p&gt;

&lt;p&gt;So cool!&lt;/p&gt;

&lt;p&gt;Tons of pizzazz!&lt;/p&gt;

&lt;p&gt;This test will execute machine code on both x86_64 as well as ARM64 and the machine code will return the same value.
Not to mention, there&amp;rsquo;s no way RuboCop or Flay could possibly complain about this code. ð¤£&lt;/p&gt;

&lt;p&gt;I hope this inspires you to try writing cross platform machine code.
This code only supports 2 platforms, but it does make me wonder how far we could stretch this and how many platforms we could support.&lt;/p&gt;

&lt;p&gt;Anyway, hope you have a good day!&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2022/01/07/homebrew-rosetta-and-ruby.html</id>
      <title>Homebrew, Rosetta, and Ruby</title>
      <updated>2022-01-07T12:39:42-08:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2022/01/07/homebrew-rosetta-and-ruby.html">

      <published>2022-01-07T12:39:42-08:00</published>
      <content type="html">&lt;p&gt;Hi everyone!  I finally upgraded to an M1.  It&amp;rsquo;s really really great, but the
main problem is that some projects I work on like &lt;a href=&quot;https://github.com/tenderlove/tenderjit&quot;&gt;TenderJIT&lt;/a&gt; and
&lt;a href=&quot;https://github.com/Shopify/yjit&quot;&gt;YJIT&lt;/a&gt; only really work on x86_64 and these
new M1 machines use ARM chips.  Fortunately we can run x86_64 software via &lt;a href=&quot;https://en.wikipedia.org/wiki/Rosetta_(software)&quot;&gt;Rosetta&lt;/a&gt;, so we can still do development work on x86 specific software.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve seen some solutions for setting up a dev environment that uses Rosetta,
but I&amp;rsquo;d like to share what I did.&lt;/p&gt;

&lt;h2 id=&quot;installing-homebrew&quot;&gt;Installing Homebrew&lt;/h2&gt;

&lt;p&gt;I think most people recommend that you install
two different versions of Homebrew, one that targets ARM, and the other that targets x86.&lt;/p&gt;

&lt;p&gt;So far, I&amp;rsquo;ve found this to be the best solution, so I went with it.  Just do the
normal Homebrew installation for ARM like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then run the installer again under Rosetta like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ arch -x86_64 /bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After doing this, I ended up with a Homebrew installation in &lt;code&gt;/opt/homebrew&lt;/code&gt; (the ARM version),
and another installation in &lt;code&gt;/usr/local&lt;/code&gt; (the x86 version).&lt;/p&gt;

&lt;h2 id=&quot;configuring-your-terminal&quot;&gt;Configuring your Terminal&lt;/h2&gt;

&lt;p&gt;I read many places on the web that recommend you duplicate terminal, then rename
it and modify the renamed version to run under Rosetta.&lt;/p&gt;

&lt;p&gt;I really didn&amp;rsquo;t like this solution.  The problem for me is that I&amp;rsquo;d end up with two
different terminal icons when doing &lt;code&gt;cmd-tab&lt;/code&gt;, and I really can&amp;rsquo;t be bothered
to read whether the terminal is the Rosetta one or not.  It makes switching to
the right terminal take &lt;em&gt;way&lt;/em&gt; too long.&lt;/p&gt;

&lt;p&gt;Instead I decided to make my shell figure out what architecture I&amp;rsquo;m using, then
update &lt;code&gt;$PATH&lt;/code&gt; depending on whether I&amp;rsquo;m using x86 or ARM.  To accomplish this,
I installed Fish (I use Fish shell) in both the x86 and ARM installations of
Homebrew:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ /opt/homebrew/bin/brew install fish
$ arch -x86_64 /usr/local/bin/brew install fish
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re not using Fish you don&amp;rsquo;t need to do this step. ð&lt;/p&gt;

&lt;p&gt;Next is the &amp;ldquo;interesting&amp;rdquo; part.  In my &lt;code&gt;config.fish&lt;/code&gt;, I added this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if test (arch) = &quot;i386&quot;
  set HOMEBREW_PREFIX /usr/local
else
  set HOMEBREW_PREFIX /opt/homebrew
end

# Add the Homebrew prefix to $PATH. -m flag ensures it's at the beginning
# of the path since the path might already be in $PATH (just not at the start)
fish_add_path -m --path $HOMEBREW_PREFIX/bin

alias intel 'arch -x86_64 /usr/local/bin/fish'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;arch&lt;/code&gt; command will tell you which architecture you&amp;rsquo;re on.  If I&amp;rsquo;m on i386,
set the Homebrew prefix to &lt;code&gt;/usr/local&lt;/code&gt;, otherwise set it to &lt;code&gt;/opt/homebrew&lt;/code&gt;.
Then use &lt;code&gt;fish_add_path&lt;/code&gt; to prepend the Homebrew prefix to my &lt;code&gt;$PATH&lt;/code&gt; environment
variable.  The &lt;code&gt;-m&lt;/code&gt; switch moves the path to the front if &lt;code&gt;$PATH&lt;/code&gt; already contained
the path I&amp;rsquo;m trying to add.&lt;/p&gt;

&lt;p&gt;Finally I added an alias &lt;code&gt;intel&lt;/code&gt; that just starts a new shell but under Rosetta.
So my default workflow is to open a terminal under ARM, and if I need to work
on an intel project, just run &lt;code&gt;intel&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;how-do-i-know-my-current-architecture&quot;&gt;How do I know my current architecture?&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;arch&lt;/code&gt; command will tell you the current architecture, but I don&amp;rsquo;t want to
run that every time I want to verify my current architecture.  My solution was
to add an emoji to my prompt.  I don&amp;rsquo;t like adding more text to my prompt, but
this seems important enough to warrant the addition.&lt;/p&gt;

&lt;p&gt;My &lt;code&gt;fish_prompt&lt;/code&gt; function looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function fish_prompt --description 'Write out the prompt'
    if not set -q __fish_prompt_normal
        set -g __fish_prompt_normal (set_color normal)
    end

    if not set -q __fish_prompt_cwd
        set -g __fish_prompt_cwd (set_color $fish_color_cwd)
    end

    if test (arch) = &quot;i386&quot;
      set emote ð§
    else
      set emote ðª
    end

    echo -n -s &quot;[$USER&quot; @ (prompt_hostname) $emote ' ' &quot;$__fish_prompt_cwd&quot; (prompt_pwd) (__fish_vcs_prompt) &quot;$__fish_prompt_normal&quot; ']$ '
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I&amp;rsquo;m on ARM, the prompt will have an ðª emoji, and if I&amp;rsquo;m on x86, the prompt
will have a ð§ emoji.&lt;/p&gt;

&lt;p&gt;Just to give an example, here is a sample session in my terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Last login: Fri Jan  7 12:37:59 on ttys001
Welcome to fish, the friendly interactive shell
[aaron@tc-lan-adapterðª ~]$ which brew
/opt/homebrew/bin/brew
[aaron@tc-lan-adapterðª ~]$ arch
arm64
[aaron@tc-lan-adapterðª ~]$ intel
Welcome to fish, the friendly interactive shell
[aaron@tc-lan-adapterð§ ~]$ which brew
/usr/local/bin/brew
[aaron@tc-lan-adapterð§ ~]$ arch
i386
[aaron@tc-lan-adapterð§ ~]$ exit
[aaron@tc-lan-adapterðª ~]$ arch
arm64
[aaron@tc-lan-adapterðª ~]$ which brew
/opt/homebrew/bin/brew
[aaron@tc-lan-adapterðª ~]$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can easily switch back and forth between x86 and ARM and my prompt tells
me which I&amp;rsquo;m using.&lt;/p&gt;

&lt;h2 id=&quot;ruby-with-chruby&quot;&gt;Ruby with chruby&lt;/h2&gt;

&lt;p&gt;My Ruby dev environment is still a work in progress.  I use &lt;a href=&quot;https://github.com/postmodern/chruby&quot;&gt;chruby&lt;/a&gt; for changing Ruby versions.
The problem is that all Ruby versions live in the same directory.  chruby doesn&amp;rsquo;t
know the difference between ARM versions and x86 versions.  So for now I&amp;rsquo;m adding
the architecture name to the directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[aaron@tc-lan-adapterðª ~]$ chruby
   ruby-3.0.2
   ruby-arm64
   ruby-i386
   ruby-trunk
[aaron@tc-lan-adapterðª ~]$
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So I have to be careful which Ruby I switch to.  I&amp;rsquo;ve &lt;a href=&quot;https://github.com/postmodern/ruby-install/issues/413&quot;&gt;filed a ticket on ruby-install&lt;/a&gt;, and I think we can make this nicer.&lt;/p&gt;

&lt;p&gt;Specifically I&amp;rsquo;d like to add a subfolder in &lt;code&gt;~/.rubies&lt;/code&gt; for each architecture,
then point chruby at the right subfolder depending on my current architecture.
Essentially the same trick I used for &lt;code&gt;$PATH&lt;/code&gt; and Homebrew, but for pointing
chruby at the right place given my current architecture.&lt;/p&gt;

&lt;p&gt;For now I just have to be careful though!&lt;/p&gt;

&lt;p&gt;One &lt;em&gt;huge&lt;/em&gt; caveat for Fish users is that the current version of chruby-fish is
broken such that changes to &lt;code&gt;$PATH&lt;/code&gt; end up getting lost (see &lt;a href=&quot;https://github.com/JeanMertz/chruby-fish/issues/31&quot;&gt;this issue&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;To work around that issue, I&amp;rsquo;m using @ioquatix&amp;rsquo;s fork of chruby-fish which can
be found &lt;a href=&quot;https://github.com/ioquatix/chruby-fish&quot;&gt;here&lt;/a&gt;.  I just checked out
that version of chruby-fish in my git project folder and added this to my &lt;code&gt;config.fish&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Point Fish at our local checkout of chruby-fish
set fish_function_path $fish_function_path $HOME/git/chruby-fish/share/fish/vendor_functions.d
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Getting a dev environment up and running with Rosetta wasn&amp;rsquo;t too bad, but I think
having the shell fix up &lt;code&gt;$PATH&lt;/code&gt; is a better solution than having two copies of Terminal.app&lt;/p&gt;

&lt;p&gt;The scripts I presented here were all Fish specific, but I don&amp;rsquo;t think it should
be too hard to translate them to whatever shell you use.&lt;/p&gt;

&lt;p&gt;Anyway, I hope you have a good weekend!&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2021/10/26/publishing-gems-with-your-yubikey.html</id>
      <title>Publishing Gems With Your YubiKey</title>
      <updated>2021-10-26T15:17:51-07:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2021/10/26/publishing-gems-with-your-yubikey.html">

      <published>2021-10-26T15:17:51-07:00</published>
      <content type="html">&lt;p&gt;The recent &lt;a href=&quot;https://github.com/faisalman/ua-parser-js/issues/536&quot;&gt;compromise of &lt;code&gt;ua-parser-js&lt;/code&gt;&lt;/a&gt; has put the security and trust of published packages at the top of my mind lately.
In order to mitigate the risk of any Ruby Gems I manage from being hijacked, I enabled 2FA on my RubyGems.org account.
This means that whenever I publish a Ruby Gem, I have to enter a one time passcode.&lt;/p&gt;

&lt;p&gt;I have to admit, I find this to be a pain.  Whenever I do a release of Rails, I
have to enter a passcode over and over again because you can only push one Gem
at a time.&lt;/p&gt;

&lt;p&gt;Finally I&amp;rsquo;ve found a way to deal with this.  I can maintain account security
and also not be hassled with OTP codes again, thanks to my YubiKey.&lt;/p&gt;

&lt;p&gt;This is just a short post about how to set up your YubiKey as an authenticator
for RubyGems.org, and how to publish Gems without getting an OTP prompt.&lt;/p&gt;

&lt;h2 id=&quot;install-ykman&quot;&gt;Install &lt;code&gt;ykman&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ykman&lt;/code&gt; is a command line utility for interacting with your YubiKey.  I installed
it on my Mac with Homebrew:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install ykman
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;set-up-2fa-as-usual&quot;&gt;Set up 2FA as usual&lt;/h2&gt;

&lt;p&gt;If you already have 2FA enabled, you&amp;rsquo;ll have to temporarily disable it.&lt;/p&gt;

&lt;p&gt;Just go through &lt;a href=&quot;https://guides.rubygems.org/setting-up-multifactor-authentication/&quot;&gt;the normal 2FA setup process&lt;/a&gt; and when you&amp;rsquo;re presented with a QR code, you&amp;rsquo;ll use the text
key to configure your YubiKey.&lt;/p&gt;

&lt;p&gt;Just do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ykman oath accounts add -t -o TOTP rubygems.org:youremail@example.org 123456
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But use your email address and replace 123456 with the code you got from RubyGems.org.
The &lt;code&gt;-t&lt;/code&gt; flag will require you to touch the YubiKey when you want to generate an
OTP.&lt;/p&gt;

&lt;h2 id=&quot;generate-an-otp&quot;&gt;Generate an OTP&lt;/h2&gt;

&lt;p&gt;You can now generate an OTP like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ykman oath accounts code -s rubygems.org
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;publishing-a-gem-without-otp-prompts&quot;&gt;Publishing a Gem without OTP Prompts&lt;/h2&gt;

&lt;p&gt;You can supply an OTP code to the &lt;code&gt;gem&lt;/code&gt; interface via an environment variable
or a command line argument.&lt;/p&gt;

&lt;p&gt;The environment variable version is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ GEM_HOST_OTP_CODE=$(ykman oath accounts code -s rubygems.org) gem push cool-gem-0.0.0.gem
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The command line argument is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem push cool-gem-0.0.0.gem --otp $(ykman oath accounts code -s rubygems.org)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve used the environment variable version, but not the command line argument though.&lt;/p&gt;

&lt;h2 id=&quot;final-thoughts&quot;&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;I also did this for NPM, but I haven&amp;rsquo;t tried pushing a package yet so I&amp;rsquo;ll see how that goes.
I don&amp;rsquo;t really have any other thoughts except that everyone should enable 2FA so that we can prevent situations like &lt;code&gt;ua-parser-js&lt;/code&gt;.
I&amp;rsquo;m not particularly interested in installing someone&amp;rsquo;s Bitcoin miner on my machine, and I&amp;rsquo;m also not interested in being hassled because my package was hijacked.&lt;/p&gt;

&lt;p&gt;Everyone, please stay safe and enable 2FA!&lt;/p&gt;

&lt;p&gt;&amp;ndash;Aaron&lt;/p&gt;

&lt;p&gt;&amp;lt;3 &amp;lt;3&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2021/02/03/debugging-a-segv-in-ruby.html</id>
      <title>Debugging an Assertion Error in Ruby</title>
      <updated>2021-02-03T17:13:28-08:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2021/02/03/debugging-a-segv-in-ruby.html">

      <published>2021-02-03T17:13:28-08:00</published>
      <content type="html">&lt;p&gt;I hope nobody runs in to a problem where they need the information in this post, but in case you do, I hope this post is helpful.
(I&amp;rsquo;m talking to you, future Aaron! lol)&lt;/p&gt;

&lt;p&gt;I committed &lt;a href=&quot;https://github.com/ruby/ruby/commit/1be84e53d76cff30ae371f0b397336dee934499d&quot;&gt;a patch to Ruby&lt;/a&gt; that caused the tests to start failing.
This was the patch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;commit 1be84e53d76cff30ae371f0b397336dee934499d
Author: Aaron Patterson &amp;lt;tenderlove@ruby-lang.org&amp;gt;
Date:   Mon Feb 1 10:42:13 2021 -0800

    Don't pin `val` passed in to `rb_define_const`.
    
    The caller should be responsible for holding a pinned reference (if they
    need that)

diff --git a/variable.c b/variable.c
index 92d7d11eab..ff4f7964a7 100644
--- a/variable.c
+++ b/variable.c
@@ -3154,7 +3154,6 @@ rb_define_const(VALUE klass, const char *name, VALUE val)
     if (!rb_is_const_id(id)) {
        rb_warn(&quot;rb_define_const: invalid name `%s' for constant&quot;, name);
     }
-    rb_gc_register_mark_object(val);
     rb_const_set(klass, id, val);
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This patch is supposed to allow objects passed in to &lt;code&gt;rb_define_const&lt;/code&gt; to move.
As the commit message says, the caller should be responsible for keeping the value pinned.
At the time I committed the patch, I thought that most callers of the function were marking the value passed in (as &lt;code&gt;val&lt;/code&gt;), so we were pinning objects that something else would already pin.
In other words, this code was being wasteful by chewing up GC time by pinning objects that were already pinned.&lt;/p&gt;

&lt;p&gt;Unfortunately the CI started to error shortly after I committed this patch.
Clearly the patch was related, but how?&lt;/p&gt;

&lt;p&gt;In this post I am going to walk through the debugging tricks I used to find the error.&lt;/p&gt;

&lt;h2 id=&quot;reproduction&quot;&gt;Reproduction&lt;/h2&gt;

&lt;p&gt;I was able to reproduce the error on my Linux machine by running the same command CI ran.
Unfortunately since this bug is related to GC, the error was intermittent.
To reproduce it, I just ran the tests in a loop until the process crashed like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ while test $status -eq 0
    env RUBY_TESTOPTS='-q --tty=no' make -j16 -s check
  end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Before running this loop though, I made sure to do &lt;code&gt;ulimit -c unlimited&lt;/code&gt; so that I would get a core file when the process crashed.&lt;/p&gt;

&lt;h2 id=&quot;the-error&quot;&gt;The Error&lt;/h2&gt;

&lt;p&gt;After the process crashed, the top of the error looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;OBJ_INFO:rb_ractor_confirm_belonging@./ractor_core.h:327&amp;gt; 0x000055be8657f180 [0     ] T_NONE 
/home/aaron/git/ruby/lib/bundler/environment_preserver.rb:47: [BUG] id == 0 but not shareable
ruby 3.1.0dev (2021-02-03T17:35:37Z master 6b4814083b) [x86_64-linux]

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Ractor verification routines crashed the process because a &lt;code&gt;T_NONE&lt;/code&gt; object is &amp;ldquo;not sharable&amp;rdquo;.
In other words you can&amp;rsquo;t share an object of type T_NONE between Ractors.
This makes sense because &lt;code&gt;T_NONE&lt;/code&gt; objects are actually empty slots in the GC.
If a Ractor, or any other Ruby code sees a &lt;code&gt;T_NONE&lt;/code&gt; object, then it&amp;rsquo;s clearly an error.
Only the GC internals should ever be dealing with this type.&lt;/p&gt;

&lt;p&gt;The top of the C backtrace looked like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-- C level backtrace information -------------------------------------------
/home/aaron/git/ruby/ruby(rb_print_backtrace+0x14) [0x55be856e9816] vm_dump.c:758
/home/aaron/git/ruby/ruby(rb_vm_bugreport) vm_dump.c:1020
/home/aaron/git/ruby/ruby(bug_report_end+0x0) [0x55be854e2a69] error.c:778
/home/aaron/git/ruby/ruby(rb_bug_without_die) error.c:778
/home/aaron/git/ruby/ruby(rb_bug+0x7d) [0x55be854e2bb0] error.c:786
/home/aaron/git/ruby/ruby(rb_ractor_confirm_belonging+0x102) [0x55be856cf6e2] ./ractor_core.h:328
/home/aaron/git/ruby/ruby(vm_exec_core+0x4ff3) [0x55be856b0003] vm.inc:2224
/home/aaron/git/ruby/tool/lib/test/unit/parallel.rb(rb_vm_exec+0x886) [0x55be856c9946]
/home/aaron/git/ruby/ruby(load_iseq_eval+0xbb) [0x55be8554f66b] load.c:594
/home/aaron/git/ruby/ruby(require_internal+0x394) [0x55be8554e3e4] load.c:1065
/home/aaron/git/ruby/ruby(rb_require_string+0x973c4) [0x55be8554d8a4] load.c:1142
/home/aaron/git/ruby/ruby(rb_f_require) load.c:838
/home/aaron/git/ruby/ruby(vm_call_cfunc_with_frame+0x11a) [0x55be856dd6fa] ./vm_insnhelper.c:2897
/home/aaron/git/ruby/ruby(vm_call_method_each_type+0xaa) [0x55be856d4d3a] ./vm_insnhelper.c:3387
/home/aaron/git/ruby/ruby(vm_call_alias+0x87) [0x55be856d68e7] ./vm_insnhelper.c:3037
/home/aaron/git/ruby/ruby(vm_sendish+0x200) [0x55be856d08e0] ./vm_insnhelper.c:4498
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The function &lt;code&gt;rb_ractor_confirm_belonging&lt;/code&gt; was the function raising an exception.&lt;/p&gt;

&lt;h2 id=&quot;debugging-the-core-file-with-lldb&quot;&gt;Debugging the Core File with LLDB&lt;/h2&gt;

&lt;p&gt;I usually use clang / lldb when debugging.
I&amp;rsquo;ve added scripts to Ruby&amp;rsquo;s lldb tools that let me track down problems more easily, so I prefer it over gcc / gdb.&lt;/p&gt;

&lt;p&gt;First I inspected the backtrace in the corefile:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(lldb) target create &quot;./ruby&quot; --core &quot;core.456156&quot;
Core file '/home/aaron/git/ruby/core.456156' (x86_64) was loaded.
(lldb) bt
* thread #1, name = 'ruby', stop reason = signal SIGABRT
  * frame #0: 0x00007fdc5fc8918b libc.so.6`raise + 203
    frame #1: 0x00007fdc5fc68859 libc.so.6`abort + 299
    frame #2: 0x000056362ac38bc6 ruby`die at error.c:765:5
    frame #3: 0x000056362ac38bb5 ruby`rb_bug(fmt=&amp;lt;unavailable&amp;gt;) at error.c:788:5
    frame #4: 0x000056362ae256e2 ruby`rb_ractor_confirm_belonging(obj=&amp;lt;unavailable&amp;gt;) at ractor_core.h:328:13
    frame #5: 0x000056362ae06003 ruby`vm_exec_core(ec=&amp;lt;unavailable&amp;gt;, initial=&amp;lt;unavailable&amp;gt;) at vm.inc:2224:5
    frame #6: 0x000056362ae1f946 ruby`rb_vm_exec(ec=&amp;lt;unavailable&amp;gt;, mjit_enable_p=&amp;lt;unavailable&amp;gt;) at vm.c:0
    frame #7: 0x000056362aca566b ruby`load_iseq_eval(ec=0x000056362b176710, fname=0x000056362ce96660) at load.c:594:5
    frame #8: 0x000056362aca43e4 ruby`require_internal(ec=&amp;lt;unavailable&amp;gt;, fname=&amp;lt;unavailable&amp;gt;, exception=1) at load.c:1065:21
    frame #9: 0x000056362aca38a4 ruby`rb_f_require [inlined] rb_require_string(fname=0x00007fdc38033178) at load.c:1142:18
    frame #10: 0x000056362aca3880 ruby`rb_f_require(obj=&amp;lt;unavailable&amp;gt;, fname=0x00007fdc38033178) at load.c:838
    frame #11: 0x000056362ae336fa ruby`vm_call_cfunc_with_frame(ec=0x000056362b176710, reg_cfp=0x00007fdc5f958de0, calling=&amp;lt;unavailable&amp;gt;) at vm_insnhelper.c:2897:11
    frame #12: 0x000056362ae2ad3a ruby`vm_call_method_each_type(ec=0x000056362b176710, cfp=0x00007fdc5f958de0, calling=0x00007ffe3b552128) at vm_insnhelper.c:3387:16
    frame #13: 0x000056362ae2c8e7 ruby`vm_call_alias(ec=0x000056362b176710, cfp=0x00007fdc5f958de0, calling=0x00007ffe3b552128) at vm_insnhelper.c:3037:12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s very similar to the backtrace in the crash report.
The first thing that was interesting to me was frame 5 in &lt;code&gt;vm_exec_core&lt;/code&gt;.
&lt;code&gt;vm_exec_core&lt;/code&gt; is the main loop for the YARV VM.
This program was crashing when executing some kind of instruction in the virtual machine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(lldb) f 5
frame #5: 0x000056362ae06003 ruby`vm_exec_core(ec=&amp;lt;unavailable&amp;gt;, initial=&amp;lt;unavailable&amp;gt;) at vm.inc:2224:5
   2221	    /* ### Instruction trailers. ### */
   2222	    CHECK_VM_STACK_OVERFLOW_FOR_INSN(VM_REG_CFP, INSN_ATTR(retn));
   2223	    CHECK_CANARY(leaf, INSN_ATTR(bin));
-&amp;gt; 2224	    PUSH(val);
   2225	    if (leaf) ADD_PC(INSN_ATTR(width));
   2226	#   undef INSN_ATTR
   2227	
(lldb) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Checking frame 5, we can see that it&amp;rsquo;s crashing when we &lt;em&gt;push&lt;/em&gt; a value on to the stack.
The Ractor function checks the value of objects being pushed on the VM stack, and in this case we have an object that is a &lt;code&gt;T_NONE&lt;/code&gt;.
The question is where did this value come from?&lt;/p&gt;

&lt;p&gt;The crash happened in the file &lt;code&gt;vm.inc&lt;/code&gt;, line 2224.  This file is a generated
file, so I can&amp;rsquo;t link to it, but I wanted to know &lt;em&gt;which&lt;/em&gt; instruction was being
executed, so I pulled up that file.&lt;/p&gt;

&lt;p&gt;Line 2224 happened to be inside the &lt;code&gt;opt_send_without_block&lt;/code&gt; instruction.
So something is calling a method, and the return value of the method is a &lt;code&gt;T_NONE&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;But what method is being called, and on what object?&lt;/p&gt;

&lt;h2 id=&quot;finding-the-called-method&quot;&gt;Finding the called method&lt;/h2&gt;

&lt;p&gt;The value &lt;code&gt;ec&lt;/code&gt;, or &amp;ldquo;Execution Context&amp;rdquo; contains information about the virtual machine at runtime.
On the &lt;code&gt;ec&lt;/code&gt;, we can find the &lt;code&gt;cfp&lt;/code&gt; or &amp;ldquo;Control Frame Pointer&amp;rdquo; which is a data structure representing the current executing stack frame.
In lldb, I could see that frame 7 had the &lt;code&gt;ec&lt;/code&gt; available, so I went to that frame to look at the &lt;code&gt;cfp&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(lldb) f 7
frame #7: 0x000056362aca566b ruby`load_iseq_eval(ec=0x000056362b176710, fname=0x000056362ce96660) at load.c:594:5
   591 	        rb_ast_dispose(ast);
   592 	    }
   593 	    rb_exec_event_hook_script_compiled(ec, iseq, Qnil);
-&amp;gt; 594 	    rb_iseq_eval(iseq);
   595 	}
   596 	
   597 	static inline enum ruby_tag_type
(lldb) p *ec-&amp;gt;cfp
(rb_control_frame_t) $1 = {
  pc = 0x000056362c095d58
  sp = 0x00007fdc5f859330
  iseq = 0x000056362ca051f0
  self = 0x000056362b1d92c0
  ep = 0x00007fdc5f859328
  block_code = 0x0000000000000000
  __bp__ = 0x00007fdc5f859330
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The control frame pointer has a pointer to the &lt;code&gt;iseq&lt;/code&gt; or &amp;ldquo;Instruction Sequence&amp;rdquo; that is currently being executed.
It also has a &lt;code&gt;pc&lt;/code&gt; or &amp;ldquo;Program Counter&amp;rdquo;, and the program counter usually points at the instruction that will be executed &lt;em&gt;next&lt;/em&gt; (in other words, not the currently executing instruction).
Of other interest, the &lt;code&gt;iseq&lt;/code&gt; also has the source location that corresponds to those instructions.&lt;/p&gt;

&lt;h2 id=&quot;getting-the-source-file&quot;&gt;Getting the Source File&lt;/h2&gt;

&lt;p&gt;If we examine the iseq structure, we can find the source location of the code that is currently being executed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(lldb) p ec-&amp;gt;cfp-&amp;gt;iseq-&amp;gt;body-&amp;gt;location
(rb_iseq_location_t) $4 = {
  pathobj = 0x000056362ca06960
  base_label = 0x000056362ce95a30
  label = 0x000056362ce95a30
  first_lineno = 0x0000000000000051
  node_id = 137
  code_location = {
    beg_pos = (lineno = 40, column = 4)
    end_pos = (lineno = 50, column = 7)
  }
}
(lldb) command script import -r ~/git/ruby/misc/lldb_cruby.py
lldb scripts for ruby has been installed.
(lldb) rp 0x000056362ca06960
bits [     ]
T_STRING: [FROZEN] (const char [57]) $6 = &quot;/home/aaron/git/ruby/lib/bundler/environment_preserver.rb&quot;
(lldb) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The location info clearly shows us that the instructions are on line 40.
The &lt;code&gt;pathobj&lt;/code&gt; member contains the file name, but it is stored as a Ruby string.
To print out the string, I imported the lldb CRuby extensions, then used the &lt;code&gt;rp&lt;/code&gt; command and gave it the address of the path object.&lt;/p&gt;

&lt;p&gt;From the output, we can see that it&amp;rsquo;s crashing in the &amp;ldquo;environment_preserver.rb&amp;rdquo; file inside of the instructions that are defined on line 40.
We&amp;rsquo;re not crashing on line 40, but the instructions are defined there.&lt;/p&gt;

&lt;p&gt;Those instructions are &lt;a href=&quot;https://github.com/ruby/ruby/blob/33d6e92e0c6eaf1308ce7108e653c53bb5fb106c/lib/bundler/environment_preserver.rb#L40-L50&quot;&gt;this method&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;replace_with_backup&lt;/span&gt;
      &lt;span class=&quot;predefined-constant&quot;&gt;ENV&lt;/span&gt;.replace(backup) &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; &lt;span class=&quot;constant&quot;&gt;Gem&lt;/span&gt;.win_platform?

      &lt;span class=&quot;comment&quot;&gt;# Fallback logic for Windows below to workaround&lt;/span&gt;
      &lt;span class=&quot;comment&quot;&gt;# https://bugs.ruby-lang.org/issues/16798. Can be dropped once all&lt;/span&gt;
      &lt;span class=&quot;comment&quot;&gt;# supported rubies include the fix for that.&lt;/span&gt;

      &lt;span class=&quot;predefined-constant&quot;&gt;ENV&lt;/span&gt;.clear

      backup.each {|k, v| &lt;span class=&quot;predefined-constant&quot;&gt;ENV&lt;/span&gt;[k] = v }
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;It&amp;rsquo;s still not clear which of these method calls is breaking.
In this function we have some method call that is returning a &lt;code&gt;T_NONE&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;finding-the-method-call&quot;&gt;Finding The Method Call&lt;/h2&gt;

&lt;p&gt;To find the method call, I disassembled the instruction sequence and checked the program counter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(lldb) command script import -r misc/lldb_disasm.py
lldb Ruby disasm installed.
(lldb) rbdisasm ec-&amp;gt;cfp-&amp;gt;iseq
PC             IDX  insn_name(operands) 
0x56362c095c20 0000 opt_getinlinecache( 6, (struct iseq_inline_cache_entry *)0x56362c095ee0 )
0x56362c095c38 0003 putobject( (VALUE)0x14 )
0x56362c095c48 0005 getconstant( ID: 0x807b )
0x56362c095c58 0007 opt_setinlinecache( (struct iseq_inline_cache_entry *)0x56362c095ee0 )
0x56362c095c68 0009 opt_send_without_block( (struct rb_call_data *)0x56362c095f20 )
0x56362c095c78 0011 branchif( 15 )
0x56362c095c88 0013 opt_getinlinecache( 6, (struct iseq_inline_cache_entry *)0x56362c095ef0 )
0x56362c095ca0 0016 putobject( (VALUE)0x14 )
0x56362c095cb0 0018 getconstant( ID: 0x370b )
0x56362c095cc0 0020 opt_setinlinecache( (struct iseq_inline_cache_entry *)0x56362c095ef0 )
0x56362c095cd0 0022 putself
0x56362c095cd8 0023 opt_send_without_block( (struct rb_call_data *)0x56362c095f30 )
0x56362c095ce8 0025 opt_send_without_block( (struct rb_call_data *)0x56362c095f40 )
0x56362c095cf8 0027 pop
0x56362c095d00 0028 opt_getinlinecache( 6, (struct iseq_inline_cache_entry *)0x56362c095f00 )
0x56362c095d18 0031 putobject( (VALUE)0x14 )
0x56362c095d28 0033 getconstant( ID: 0x370b )
0x56362c095d38 0035 opt_setinlinecache( (struct iseq_inline_cache_entry *)0x56362c095f00 )
0x56362c095d48 0037 opt_send_without_block( (struct rb_call_data *)0x56362c095f50 )
0x56362c095d58 0039 pop
0x56362c095d60 0040 putself
0x56362c095d68 0041 opt_send_without_block( (struct rb_call_data *)0x56362c095f60 )
0x56362c095d78 0043 send( (struct rb_call_data *)0x56362c095f70, (rb_iseq_t *)0x56362ca05178 )
0x56362c095d90 0046 leave
(lldb) p ec-&amp;gt;cfp-&amp;gt;pc
(const VALUE *) $9 = 0x000056362c095d58
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;First I loaded the disassembly helper script.  It provides the &lt;code&gt;rbdisasm&lt;/code&gt; function.
Then I used &lt;code&gt;rbdisasm&lt;/code&gt; on the instruction sequence.
This printed out the instructions in mostly human readable form.
Printing the PC showed a value of &lt;code&gt;0x000056362c095d58&lt;/code&gt;.
Looking at the PC list in the disassembly shows that &lt;code&gt;0x000056362c095d58&lt;/code&gt; corresponds to a &lt;code&gt;pop&lt;/code&gt; instruction.
But the PC always points at the &lt;em&gt;next&lt;/em&gt; instruction that will execute, not the &lt;em&gt;currently&lt;/em&gt; executing instruction.
The currently executing instruction is the one right before the PC.
In this case we can see it is &lt;code&gt;opt_send_without_block&lt;/code&gt;, which lines up with the information we discovered from &lt;code&gt;vm.inc&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is the 3rd from last method call in the block.
At &lt;code&gt;0041&lt;/code&gt; there is another &lt;code&gt;opt_send_without_block&lt;/code&gt;, and then at &lt;code&gt;0043&lt;/code&gt; there is a generic &lt;code&gt;send&lt;/code&gt; call.&lt;/p&gt;

&lt;p&gt;Looking at the Ruby code, from the bottom of the method, we see a call to &lt;code&gt;backup&lt;/code&gt;.
It&amp;rsquo;s not a local variable, so it must be a method call.
The code calls &lt;code&gt;each&lt;/code&gt; on that, and &lt;code&gt;each&lt;/code&gt; takes a block.
These must correspond to the &lt;code&gt;opt_send_without_block&lt;/code&gt; and the &lt;code&gt;send&lt;/code&gt; at the end of the instruction sequence.
Our crash is happening just before these two, so it must be the call to &lt;code&gt;ENV.clear&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If we read the implementation of &lt;code&gt;ENV.clear&lt;/code&gt;, we can see that &lt;a href=&quot;https://github.com/ruby/ruby/blob/986b38f301ff0f39961f03c568dd7498f48e9852/hash.c#L5860&quot;&gt;it returns a global variable&lt;/a&gt; called &lt;code&gt;envtbl&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;VALUE
rb_env_clear(&lt;span class=&quot;directive&quot;&gt;void&lt;/span&gt;)
{
    VALUE keys;
    &lt;span class=&quot;predefined-type&quot;&gt;long&lt;/span&gt; i;

    keys = env_keys(TRUE);
    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (i=&lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;; i&amp;lt;RARRAY_LEN(keys); i++) {
        VALUE key = RARRAY_AREF(keys, i);
        &lt;span class=&quot;directive&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;predefined-type&quot;&gt;char&lt;/span&gt; *nam = RSTRING_PTR(key);
        ruby_setenv(nam, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;);
    }
    RB_GC_GUARD(keys);
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; envtbl;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;This object is allocated &lt;a href=&quot;https://github.com/ruby/ruby/blob/986b38f301ff0f39961f03c568dd7498f48e9852/hash.c#L7162&quot;&gt;here&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;    envtbl = rb_obj_alloc(rb_cObject);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;And then it &lt;a href=&quot;https://github.com/ruby/ruby/blob/986b38f301ff0f39961f03c568dd7498f48e9852/hash.c#L7218&quot;&gt;calls &lt;code&gt;rb_define_global_const&lt;/code&gt;&lt;/a&gt; to define the &lt;code&gt;ENV&lt;/code&gt; constant as a global:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;comment&quot;&gt;/*
     * ENV is a Hash-like accessor for environment variables.
     *
     * See ENV (the class) for more details.
     */&lt;/span&gt;
    rb_define_global_const(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;ENV&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, envtbl);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;If we read &lt;code&gt;rb_define_global_const&lt;/code&gt; we can see &lt;a href=&quot;https://github.com/ruby/ruby/blob/986b38f301ff0f39961f03c568dd7498f48e9852/variable.c#L3161-L3165&quot;&gt;that it just calls &lt;code&gt;rb_define_const&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;directive&quot;&gt;void&lt;/span&gt;
rb_define_global_const(&lt;span class=&quot;directive&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;predefined-type&quot;&gt;char&lt;/span&gt; *name, VALUE val)
{
    rb_define_const(rb_cObject, name, val);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Before my patch, any object passed to &lt;code&gt;rb_define_const&lt;/code&gt; would be pinned.
Once I removed the pinning, that allowed the &lt;code&gt;ENV&lt;/code&gt; variable to move around even though it shouldn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;I reverted that patch &lt;a href=&quot;https://github.com/ruby/ruby/commit/33d6e92e0c6eaf1308ce7108e653c53bb5fb106c&quot;&gt;here&lt;/a&gt;, and then sent a pull request to make &lt;code&gt;rb_gc_register_mark_object&lt;/code&gt; a little bit smarter &lt;a href=&quot;https://github.com/ruby/ruby/pull/4152&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;TBH I don&amp;rsquo;t know what to conclude this with.
Debugging errors kind of sucks, but I hope that the LLDB scripts I wrote make it suck a little less.
Hope you&amp;rsquo;re having a good day!!!&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2020/08/26/counting-write-barrier-unprotected-objects.html</id>
      <title>Counting Write Barrier Unprotected Objects</title>
      <updated>2020-08-26T15:29:01-07:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2020/08/26/counting-write-barrier-unprotected-objects.html">

      <published>2020-08-26T15:29:01-07:00</published>
      <content type="html">&lt;p&gt;This is just a quick post mostly as a note to myself (because I forget the &lt;code&gt;jq&lt;/code&gt; commands).
Ruby objects that are not protected with a write barrier must be examined on every minor GC.
That means that any objects in your system that live for a long time and &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; have write barrier protection will cause unnecessary overhead on every minor collection.&lt;/p&gt;

&lt;p&gt;Heap dumps will tell you which objects have a write barrier.
In Rails apps I use a small script to get a dump of the heap after boot:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;objspace&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;config/environment&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;GC&lt;/span&gt;.start

&lt;span class=&quot;constant&quot;&gt;File&lt;/span&gt;.open(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;heap.dump&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;wb&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |f|
  &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.dump_all(&lt;span class=&quot;key&quot;&gt;output&lt;/span&gt;: f)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;heap.dump&lt;/code&gt; file will have a list of all of the objects in the heap.&lt;/p&gt;

&lt;p&gt;Here is an example of an object &lt;em&gt;with&lt;/em&gt; a write barrier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&quot;address&quot;:&quot;0x7fec1b2ff940&quot;, &quot;type&quot;:&quot;IMEMO&quot;, &quot;class&quot;:&quot;0x7fec1b2ffd50&quot;, &quot;imemo_type&quot;:&quot;ment&quot;, &quot;references&quot;:[&quot;0x7fec1b314908&quot;, &quot;0x7fec1b2ffcd8&quot;], &quot;memsize&quot;:48, &quot;flags&quot;:{&quot;wb_protected&quot;:true, &quot;old&quot;:true, &quot;uncollectible&quot;:true, &quot;marked&quot;:true}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is an example of an object &lt;em&gt;without&lt;/em&gt; a write barrier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{&quot;address&quot;:&quot;0x7fec1b2ff760&quot;, &quot;type&quot;:&quot;ICLASS&quot;, &quot;class&quot;:&quot;0x7fec1a8c0f60&quot;, &quot;references&quot;:[&quot;0x7fec1a8c9250&quot;, &quot;0x7fec1b2fefe0&quot;], &quot;memsize&quot;:40}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Objects &lt;em&gt;with&lt;/em&gt; a write barrier will have &lt;code&gt;&quot;wb_protected&quot;:true&lt;/code&gt; in their flags section.&lt;/p&gt;

&lt;p&gt;I like to use &lt;code&gt;jq&lt;/code&gt; to process heap dumps.
Here is a command to find all of the unprotected objects, group them by type, then count them up:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ jq 'select(.flags.wb_protected | not) | .type' heap.dump  | sort | uniq -c | sort -n
   1 &quot;MATCH&quot;
   2 &quot;ARRAY&quot;
   5 &quot;ROOT&quot;
   9 &quot;FILE&quot;
 323 &quot;MODULE&quot;
 927 &quot;ICLASS&quot;
1631 &quot;DATA&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All of the objects listed here will be examined on every minor GC.
If my Rails app is spending a lot of time in minor GCs, this is a good place to look.&lt;/p&gt;

&lt;p&gt;Ruby 2.8 (or 3.0) will eliminate &lt;code&gt;ICLASS&lt;/code&gt; from this list (&lt;a href=&quot;https://github.com/ruby/ruby/commit/264e4cd04fbcdcb739a1ff9a84e19afe66005cb2&quot;&gt;here is the commit&lt;/a&gt;).&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2020/01/13/guide-to-string-encoding-in-ruby.html</id>
      <title>Guide to String Encoding in Ruby</title>
      <updated>2020-01-13T06:00:39-08:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2020/01/13/guide-to-string-encoding-in-ruby.html">

      <published>2020-01-13T06:00:39-08:00</published>
      <content type="html">&lt;p&gt;Encoding issues don&amp;rsquo;t seem to happen frequently, but that is a blessing and a curse.
It&amp;rsquo;s great not to fix them very frequently, but when you do need to fix them, lack
of experience can leave you feeling lost.&lt;/p&gt;

&lt;p&gt;This post is meant to be a sort of guide about what to do when you encounter different types
of encoding errors in Ruby.
First we&amp;rsquo;ll cover what an encoding object is, then we&amp;rsquo;ll look at common encoding exceptions
and how to fix them.&lt;/p&gt;

&lt;h2 id=&quot;what-are-string-encodings-in-ruby&quot;&gt;What are String encodings in Ruby?&lt;/h2&gt;

&lt;p&gt;In Ruby, strings are a combination of an array of bytes, and an encoding object.
We can access the encoding object on the string by calling &lt;code&gt;encoding&lt;/code&gt; on the
string object.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = 'Hello World'
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:UTF-8&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In my environment, the default encoding object associated with a string us the &amp;ldquo;UTF-8&amp;rdquo; encoding object.
A graph of the object relationship looks something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/encoding1.png&quot; alt=&quot;string points at encoding&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;changing-a-strings-encoding&quot;&gt;Changing a String&amp;rsquo;s Encoding&lt;/h2&gt;

&lt;p&gt;We can change encoding by two different methods:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;String#force_encoding&lt;/li&gt;
  &lt;li&gt;String#encode&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;force_encoding&lt;/code&gt; method will mutate the string object and only change which encoding object the string points to.
It does nothing to the bytes of the string, it merely changes the encoding object associated with the string.
Here we can see that the return value of &lt;code&gt;encoding&lt;/code&gt; changes after we call the &lt;code&gt;force_encode&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = 'Hello World'
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:UTF-8&amp;gt;
&amp;gt;&amp;gt; x.force_encoding &quot;US-ASCII&quot;
=&amp;gt; &quot;Hello World&quot;
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:US-ASCII&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;encode&lt;/code&gt; method will create a new string based on the bytes of the old string and associate the encoding object with the new string.&lt;/p&gt;

&lt;p&gt;Here we can see that the encoding of &lt;code&gt;x&lt;/code&gt; remains the same, and
calling &lt;code&gt;encode&lt;/code&gt; returns a new string &lt;code&gt;y&lt;/code&gt; which is associated with the new encoding:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = 'Hello World'
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:UTF-8&amp;gt;
&amp;gt;&amp;gt; y = x.encode(&quot;US-ASCII&quot;)
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:UTF-8&amp;gt;
&amp;gt;&amp;gt; y.encoding
=&amp;gt; #&amp;lt;Encoding:US-ASCII&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here is a visualization of the difference:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/change_encoding.png&quot; alt=&quot;changing encoding&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Calling &lt;code&gt;force_encoding&lt;/code&gt; mutates the original string, where &lt;code&gt;encode&lt;/code&gt; creates a new string with a different encoding.
Translating a string from one encoding to another is probably the &amp;ldquo;normal&amp;rdquo; use of encodings.
However, developers will rarely call the &lt;code&gt;encode&lt;/code&gt; method because Ruby will typically handle any necessary translations automatically.
It&amp;rsquo;s probably more common to call the &lt;code&gt;force_encoding&lt;/code&gt; method, and that is because strings can be associated with the &lt;em&gt;wrong&lt;/em&gt; encoding.&lt;/p&gt;

&lt;h2 id=&quot;strings-can-have-the-wrong-encoding&quot;&gt;Strings Can Have the Wrong Encoding&lt;/h2&gt;

&lt;p&gt;Strings can be associated with the wrong encoding object, and that is the source of most if not all encoding related exceptions.
Let&amp;rsquo;s look at an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello \x93\xfa\x96\x7b&quot;
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:UTF-8&amp;gt;
&amp;gt;&amp;gt; x.valid_encoding?
=&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, Ruby associated the string &lt;code&gt;&quot;Hello \x93\xfa\x96\x7b&quot;&lt;/code&gt; with the default encoding UTF-8.
However, many of the bytes in the string are not valid Unicode characters.
We can check if the string is associated with a valid encoding object by calling &lt;code&gt;valid_encoding?&lt;/code&gt; method.
The &lt;code&gt;valid_encoding?&lt;/code&gt; method will scan all bytes to see if they are valid for that particular encoding object.&lt;/p&gt;

&lt;p&gt;So how do we fix this?
The answer depends on the situation.
We need to think about where the data came from and where the data is going.
Let&amp;rsquo;s say we&amp;rsquo;ll display this string on a webpage, but we do not know the correct encoding for the string.
In that case we probably want to make sure the string is valid UTF-8, but since we don&amp;rsquo;t know the correct encoding for the string, our only choice is to remove the bad bytes from the string.&lt;/p&gt;

&lt;p&gt;We can remove the unknown bytes by using the &lt;code&gt;scrub&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello \x93\xfa\x96\x7b&quot;
&amp;gt;&amp;gt; x.valid_encoding?
=&amp;gt; false
&amp;gt;&amp;gt; y = x.scrub
&amp;gt;&amp;gt; y
=&amp;gt; &quot;Hello ï¿½ï¿½ï¿½{&quot;
&amp;gt;&amp;gt; y.encoding
=&amp;gt; #&amp;lt;Encoding:UTF-8&amp;gt;
&amp;gt;&amp;gt; y.valid_encoding?
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;scrub&lt;/code&gt; method will return a new string associated with the encoding but with all of the invalid bytes replaced by a replacement character, the diamond question mark thing.&lt;/p&gt;

&lt;p&gt;What if we do know the encoding of the source string?
Actually the example above is using a string that&amp;rsquo;s encoding using Shift JIS.
Let&amp;rsquo;s say we know the encoding, and we want to display the string on a webpage.
In that case we tag the string by using &lt;code&gt;force_encoding&lt;/code&gt;, and transcode to UTF-8:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello \x93\xfa\x96\x7b&quot;
&amp;gt;&amp;gt; x.force_encoding &quot;Shift_JIS&quot;
=&amp;gt; &quot;Hello \x{93FA}\x{967B}&quot;
&amp;gt;&amp;gt; x.valid_encoding?
=&amp;gt; true
&amp;gt;&amp;gt; x.encode &quot;UTF-8&quot; # display as UTF-8
=&amp;gt; &quot;Hello æ¥æ¬&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most important thing to think about when dealing with encoding issues is &amp;ldquo;where did this data come from?&amp;rdquo; and &amp;ldquo;what will we do with this data?&amp;rdquo;
Answering those two questions will drive all decisions about which encoding to use with which string.&lt;/p&gt;

&lt;h2 id=&quot;encoding-depends-on-the-context&quot;&gt;Encoding Depends on the Context&lt;/h2&gt;

&lt;p&gt;Before we look at some common errors and their remediation, let&amp;rsquo;s look at one more example of the encoding context dependency.
In this example, we&amp;rsquo;ll use some user input as a cache key, but we&amp;rsquo;ll also display the user input on a webpage.
We&amp;rsquo;re going to use our source data (the user input) in two places: as a cache key, and something to display on a web page.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the code:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;digest/md5&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;cgi&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Make a checksum&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;make_checksum&lt;/span&gt; string
  &lt;span class=&quot;constant&quot;&gt;Digest&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;MD5&lt;/span&gt;.hexdigest string
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Not good HTML escaping (don't use this)&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# Returns a string with UTF-8 compatible encoding for display on a webpage&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;display_on_web&lt;/span&gt; string
  string.gsub(&lt;span class=&quot;regexp&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;/&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# User input from an unknown source&lt;/span&gt;
x = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;Hello &lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x93&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\xfa&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x96&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x7b&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
p &lt;span class=&quot;key&quot;&gt;ENCODING&lt;/span&gt;: x.encoding
p &lt;span class=&quot;key&quot;&gt;VALID_ENCODING&lt;/span&gt;: x.valid_encoding?

p display_on_web x
p make_checksum x
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;If we run this code, we&amp;rsquo;ll get an exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby thing.rb
{:ENCODING=&amp;gt;#&amp;lt;Encoding:UTF-8&amp;gt;}
{:VALID_ENCODING=&amp;gt;false}
Traceback (most recent call last):
        2: from thing.rb:20:in `&amp;lt;main&amp;gt;'
        1: from thing.rb:12:in `display_on_web'
thing.rb:12:in `gsub': invalid byte sequence in UTF-8 (ArgumentError)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The problem is that we have a string of unknown input with bytes that are not valid UTF-8 characters.
We know we want to display this string on a UTF-8 encoded webpage, so lets scrub the string:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;digest/md5&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;cgi&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Make a checksum&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;make_checksum&lt;/span&gt; string
  &lt;span class=&quot;constant&quot;&gt;Digest&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;MD5&lt;/span&gt;.hexdigest string
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Not good HTML escaping (don't use this)&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# Returns a string with UTF-8 compatible encoding for display on a webpage&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;display_on_web&lt;/span&gt; string
  string.gsub(&lt;span class=&quot;regexp&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;/&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# User input from an unknown source&lt;/span&gt;
x = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;Hello &lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x93&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\xfa&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x96&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x7b&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;.scrub
p &lt;span class=&quot;key&quot;&gt;ENCODING&lt;/span&gt;: x.encoding
p &lt;span class=&quot;key&quot;&gt;VALID_ENCODING&lt;/span&gt;: x.valid_encoding?

p display_on_web x
p make_checksum x
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Now when we run the program, the output is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby thing.rb
{:ENCODING=&amp;gt;#&amp;lt;Encoding:UTF-8&amp;gt;}
{:VALID_ENCODING=&amp;gt;true}
&quot;Hello ï¿½ï¿½ï¿½{&quot;
&quot;4dab6f63b4d3ae3279345c9df31091eb&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great!  We&amp;rsquo;ve build some HTML and generated a checksum.
Unfortunately there is a bug in this code (of course the mere fact that we&amp;rsquo;ve written code means there&amp;rsquo;s a bug! lol)
Let&amp;rsquo;s introduce a second user input string with slightly different bytes than the first input string:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;digest/md5&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;cgi&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Make a checksum&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;make_checksum&lt;/span&gt; string
  &lt;span class=&quot;constant&quot;&gt;Digest&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;MD5&lt;/span&gt;.hexdigest string
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Not good HTML escaping (don't use this)&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# Returns a string with UTF-8 compatible encoding for display on a webpage&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;display_on_web&lt;/span&gt; string
  string.gsub(&lt;span class=&quot;regexp&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;/&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# User input from an unknown source&lt;/span&gt;
x = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;Hello &lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x93&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\xfa&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x96&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x7b&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;.scrub
p &lt;span class=&quot;key&quot;&gt;ENCODING&lt;/span&gt;: x.encoding
p &lt;span class=&quot;key&quot;&gt;VALID_ENCODING&lt;/span&gt;: x.valid_encoding?

p display_on_web x
p make_checksum x

&lt;span class=&quot;comment&quot;&gt;# Second user input from an unknown source with slightly different bytes&lt;/span&gt;
y = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;Hello &lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x94&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\xfa&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x97&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x7b&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;.scrub
p &lt;span class=&quot;key&quot;&gt;ENCODING&lt;/span&gt;: y.encoding
p &lt;span class=&quot;key&quot;&gt;VALID_ENCODING&lt;/span&gt;: y.valid_encoding?

p display_on_web y
p make_checksum y
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Here is the output from the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby thing.rb
{:ENCODING=&amp;gt;#&amp;lt;Encoding:UTF-8&amp;gt;}
{:VALID_ENCODING=&amp;gt;true}
&quot;Hello ï¿½ï¿½ï¿½{&quot;
&quot;4dab6f63b4d3ae3279345c9df31091eb&quot;
{:ENCODING=&amp;gt;#&amp;lt;Encoding:UTF-8&amp;gt;}
{:VALID_ENCODING=&amp;gt;true}
&quot;Hello ï¿½ï¿½ï¿½{&quot;
&quot;4dab6f63b4d3ae3279345c9df31091eb&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The program works in the sense that there is no exception.
But both user input strings have the same checksum despite the fact that the original strings clearly have different bytes!
So what is the correct fix for this program?
Again, we need to think about the source of the data (where did it come from), as well as what we will do with it (where it is going).
In this case we have one source, from a user, and the user provided us with no encoding information.
In other words, the encoding information of the source data is unknown, so we can only treat it as a sequence of bytes.
We have two output cases, one is a UTF-8 HTML the other output is &lt;em&gt;the input&lt;/em&gt; to our checksum function.
The HTML requires that our string be UTF-8 so making the string valid UTF-8, in other words &amp;ldquo;scrubbing&amp;rdquo; it, before displaying makes sense.
However, our checksum function requires seeing the original bytes of the string.
Since the checksum is only concerned with the bytes in the string, any encoding including an invalid encoding will work.
It&amp;rsquo;s nice to make sure all our strings have valid encodings though, so we&amp;rsquo;ll fix this example such that everything has a valid encoding.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;digest/md5&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;cgi&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Make a checksum&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;make_checksum&lt;/span&gt; string
  &lt;span class=&quot;constant&quot;&gt;Digest&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;MD5&lt;/span&gt;.hexdigest string
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Not good HTML escaping (don't use this)&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# Returns a string with UTF-8 compatible encoding for display on a webpage&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;display_on_web&lt;/span&gt; string
  string.gsub(&lt;span class=&quot;regexp&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;/&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# User input from an unknown source&lt;/span&gt;
x = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;Hello &lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x93&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\xfa&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x96&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x7b&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;.b
p &lt;span class=&quot;key&quot;&gt;ENCODING&lt;/span&gt;: x.encoding
p &lt;span class=&quot;key&quot;&gt;VALID_ENCODING&lt;/span&gt;: x.valid_encoding?

p display_on_web x.encode(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;UTF-8&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;key&quot;&gt;undef&lt;/span&gt;: &lt;span class=&quot;symbol&quot;&gt;:replace&lt;/span&gt;)
p make_checksum x

&lt;span class=&quot;comment&quot;&gt;# Second user input from an unknown source with slightly different bytes&lt;/span&gt;
y = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;Hello &lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x94&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\xfa&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x97&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x7b&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;.b
p &lt;span class=&quot;key&quot;&gt;ENCODING&lt;/span&gt;: y.encoding
p &lt;span class=&quot;key&quot;&gt;VALID_ENCODING&lt;/span&gt;: y.valid_encoding?

p display_on_web y.encode(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;UTF-8&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;key&quot;&gt;undef&lt;/span&gt;: &lt;span class=&quot;symbol&quot;&gt;:replace&lt;/span&gt;)
p make_checksum y
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Here is the output of the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby thing.rb
{:ENCODING=&amp;gt;#&amp;lt;Encoding:ASCII-8BIT&amp;gt;}
{:VALID_ENCODING=&amp;gt;true}
&quot;Hello ï¿½ï¿½ï¿½{&quot;
&quot;96cf6db2750fd4d2488fac57d8e4d45a&quot;
{:ENCODING=&amp;gt;#&amp;lt;Encoding:ASCII-8BIT&amp;gt;}
{:VALID_ENCODING=&amp;gt;true}
&quot;Hello ï¿½ï¿½ï¿½{&quot;
&quot;b92854c0db4f2c2c20eff349a9a8e3a0&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To fix our program, we&amp;rsquo;ve changed a couple things.
First we tagged the string of unknown encoding as &amp;ldquo;binary&amp;rdquo; by using the &lt;code&gt;.b&lt;/code&gt; method.
The &lt;code&gt;.b&lt;/code&gt; method returns a new string that is associated with the &lt;code&gt;ASCII-8BIT&lt;/code&gt; encoding.
The name &lt;code&gt;ASCII-8BIT&lt;/code&gt; is somewhat confusing because it has the word &amp;ldquo;ASCII&amp;rdquo; in it.
It&amp;rsquo;s better to think of this encoding as either &amp;ldquo;unknown&amp;rdquo; or &amp;ldquo;binary data&amp;rdquo;.
Unknown meaning we have some data that may have a valid encoding, but we don&amp;rsquo;t know what it is.
Or binary data, as in the bytes read from a JPEG file or some such binary format.
Anyway, we pass the binary string in to the checksum function because the checksum only cares about the bytes in the string, not about the encoding.&lt;/p&gt;

&lt;p&gt;The second change we made is to call &lt;code&gt;encode&lt;/code&gt; with the encoding we want (UTF-8) along with &lt;code&gt;undef: :replace&lt;/code&gt; meaning that any time Ruby encounters bytes it doesn&amp;rsquo;t know how to convert to the target encoding, it will replace them with the replacement character (the diamond question thing).&lt;/p&gt;

&lt;p&gt;SIDE NOTE: This is probably not important, but it is fun!
We can specify what Ruby uses for replacing unknown bytes.
Here&amp;rsquo;s an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello \x94\xfa\x97\x7b&quot;.b
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:ASCII-8BIT&amp;gt;
&amp;gt;&amp;gt; x.encode(&quot;UTF-8&quot;, undef: :replace, replace: &quot;Aaron&quot;)
=&amp;gt; &quot;Hello AaronAaronAaron{&quot;
&amp;gt;&amp;gt; x.encode(&quot;UTF-8&quot;, undef: :replace, replace: &quot;ð¤£&quot;)
=&amp;gt; &quot;Hello ð¤£ð¤£ð¤£{&quot;
&amp;gt;&amp;gt; [_.encoding, _.valid_encoding?]
=&amp;gt; [#&amp;lt;Encoding:UTF-8&amp;gt;, true]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lets take a look at some common encoding errors in Ruby and what to do about them.&lt;/p&gt;

&lt;h2 id=&quot;encodinginvalidbytesequenceerror&quot;&gt;&lt;code&gt;Encoding::InvalidByteSequenceError&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;This exception occurs when Ruby needs to examine the bytes in a string and the bytes do not match the encoding.
Here is an example of this exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello \x93\xfa\x96\x7b&quot;
&amp;gt;&amp;gt; x.encode &quot;UTF-16&quot;
Traceback (most recent call last):
        5: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `&amp;lt;main&amp;gt;'
        4: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `load'
        3: from /Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.7.0/gems/irb-1.2.0/exe/irb:11:in `&amp;lt;top (required)&amp;gt;'
        2: from (irb):4
        1: from (irb):4:in `encode'
Encoding::InvalidByteSequenceError (&quot;\x93&quot; on UTF-8)
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:UTF-8&amp;gt;
&amp;gt;&amp;gt; x.valid_encoding?
=&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The string &lt;code&gt;x&lt;/code&gt; contains bytes that aren&amp;rsquo;t valid UTF-8, yet it is associated with the UTF-8 encoding object.
When we try to convert &lt;code&gt;x&lt;/code&gt; to UTF-16, an exception occurs.&lt;/p&gt;

&lt;h3 id=&quot;how-to-fix-encodinginvalidbytesequenceerror&quot;&gt;How to fix &lt;code&gt;Encoding::InvalidByteSequenceError&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Like most encoding issues, our string &lt;code&gt;x&lt;/code&gt; is tagged with the wrong encoding.
The way to fix this issue is to tag the string with the correct encoding.
But what is the correct encoding?
To figure out the correct encoding, you need to know where the string came from.
For example if the string came from a Mime attachment, the Mime attachment should specify the encoding (or the RFC will tell you).&lt;/p&gt;

&lt;p&gt;In this case, the string is a valid Shift JIS string, but I know that because I looked up the bytes and manually entered them.
So we&amp;rsquo;ll tag this as Shift JIS, and the exception goes away:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello \x93\xfa\x96\x7b&quot;
&amp;gt;&amp;gt; x.force_encoding &quot;Shift_JIS&quot;
=&amp;gt; &quot;Hello \x{93FA}\x{967B}&quot;
&amp;gt;&amp;gt; x.encode &quot;UTF-16&quot;
=&amp;gt; &quot;\uFEFFHello \u65E5\u672C&quot;
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:Shift_JIS&amp;gt;
&amp;gt;&amp;gt; x.valid_encoding?
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t know the source of the string, an alternative solution is to tag as UTF-8 and then scrub the bytes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello \x93\xfa\x96\x7b&quot;
&amp;gt;&amp;gt; x.force_encoding &quot;UTF-8&quot;
=&amp;gt; &quot;Hello \x93\xFA\x96{&quot;
&amp;gt;&amp;gt; x.scrub!
=&amp;gt; &quot;Hello ï¿½ï¿½ï¿½{&quot;
&amp;gt;&amp;gt; x.encode &quot;UTF-16&quot;
=&amp;gt; &quot;\uFEFFHello \uFFFD\uFFFD\uFFFD{&quot;
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:UTF-8&amp;gt;
&amp;gt;&amp;gt; x.valid_encoding?
=&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course this works, but it means that you&amp;rsquo;ve lost data.
The best solution is to figure out what the encoding of the string &lt;em&gt;should&lt;/em&gt; be depending on its source and tag it with the correct encoding.&lt;/p&gt;

&lt;h2 id=&quot;encodingundefinedconversionerror&quot;&gt;&lt;code&gt;Encoding::UndefinedConversionError&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;This exception occurs when a string of one encoding can&amp;rsquo;t be converted to another encoding.&lt;/p&gt;

&lt;p&gt;Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;å\u2160&quot;
&amp;gt;&amp;gt; x
=&amp;gt; &quot;åâ &quot;
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:UTF-8&amp;gt;
&amp;gt;&amp;gt; x.valid_encoding?
=&amp;gt; true
&amp;gt;&amp;gt; x.encode &quot;Shift_JIS&quot;
Traceback (most recent call last):
        5: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `&amp;lt;main&amp;gt;'
        4: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `load'
        3: from /Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.7.0/gems/irb-1.2.0/exe/irb:11:in `&amp;lt;top (required)&amp;gt;'
        2: from (irb):23
        1: from (irb):23:in `encode'
Encoding::UndefinedConversionError (U+2160 from UTF-8 to Shift_JIS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example, we have two characters: &amp;ldquo;å&amp;rdquo;, and the Roman numeral 1 (&amp;ldquo;â &amp;rdquo;).
Unicode Roman numeral 1 cannot be converted to Shift JIS because there are &lt;em&gt;two&lt;/em&gt; codepoints that represent that character in Shift JIS.
This means the conversion is ambiguous, so Ruby will raise an exception.&lt;/p&gt;

&lt;h3 id=&quot;how-to-fix-encodingundefinedconversionerror&quot;&gt;How to fix &lt;code&gt;Encoding::UndefinedConversionError&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Our original string is correctly tagged as UTF-8, but we need to convert to Shift JIS.
In this case we&amp;rsquo;ll use a replacement character when converting to Shift JIS:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;å\u2160&quot;
&amp;gt;&amp;gt; y = x.encode(&quot;Shift_JIS&quot;, undef: :replace)
&amp;gt;&amp;gt; y
=&amp;gt; &quot;\x{8E6C}?&quot;
&amp;gt;&amp;gt; y.encoding
=&amp;gt; #&amp;lt;Encoding:Shift_JIS&amp;gt;
&amp;gt;&amp;gt; y.valid_encoding?
=&amp;gt; true
&amp;gt;&amp;gt; y.encode &quot;UTF-8&quot;
=&amp;gt; &quot;å?&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We were able to convert to Shift JIS, but we did lose some data.&lt;/p&gt;

&lt;h2 id=&quot;argumenterror&quot;&gt;&lt;code&gt;ArgumentError&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;When a string contains invalid bytes, sometimes Ruby will raise an &lt;code&gt;ArgumentError&lt;/code&gt; exception:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello \x93\xfa\x96\x7b&quot;
&amp;gt;&amp;gt; x.downcase
Traceback (most recent call last):
        5: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `&amp;lt;main&amp;gt;'
        4: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `load'
        3: from /Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.7.0/gems/irb-1.2.0/exe/irb:11:in `&amp;lt;top (required)&amp;gt;'
        2: from (irb):34
        1: from (irb):34:in `downcase'
ArgumentError (input string invalid)
&amp;gt;&amp;gt; x.gsub(/ello/, &quot;i&quot;)
Traceback (most recent call last):
        6: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `&amp;lt;main&amp;gt;'
        5: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `load'
        4: from /Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.7.0/gems/irb-1.2.0/exe/irb:11:in `&amp;lt;top (required)&amp;gt;'
        3: from (irb):34
        2: from (irb):35:in `rescue in irb_binding'
        1: from (irb):35:in `gsub'
ArgumentError (invalid byte sequence in UTF-8)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again we use our incorrectly tagged Shift JIS string.
Calling &lt;code&gt;downcase&lt;/code&gt; or &lt;code&gt;gsub&lt;/code&gt; both result in an &lt;code&gt;ArgumentError&lt;/code&gt;.
I personally think these exceptions are not great.
We didn&amp;rsquo;t pass anything to &lt;code&gt;downcase&lt;/code&gt;, so why is it an &lt;code&gt;ArgumentError&lt;/code&gt;?
There is nothing wrong with the arguments we passed to &lt;code&gt;gsub&lt;/code&gt;, so why is it an &lt;code&gt;ArgumentError&lt;/code&gt;?
Why does one say &amp;ldquo;input string invalid&amp;rdquo; where the other gives us a slightly more helpful exception of &amp;ldquo;invalid byte sequence in UTF-8&amp;rdquo;?
I think these should both result in &lt;code&gt;Encoding::InvalidByteSequenceError&lt;/code&gt; exceptions, as it&amp;rsquo;s a problem with the encoding, not the arguments.&lt;/p&gt;

&lt;p&gt;Regardless, these errors both stem from the fact that the Shift JIS string is incorrectly tagged as UTF-8.&lt;/p&gt;

&lt;h3 id=&quot;fixing-argumenterror&quot;&gt;Fixing &lt;code&gt;ArgumentError&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Fixing this issue is just like fixing &lt;code&gt;Encoding::InvalidByteSequenceError&lt;/code&gt;.
We need to figure out the correct encoding of the source string, then tag the source string with that encoding.
If the encoding of the source string is truly unknown, scrub it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello \x93\xfa\x96\x7b&quot;
&amp;gt;&amp;gt; x.force_encoding &quot;Shift_JIS&quot;
=&amp;gt; &quot;Hello \x{93FA}\x{967B}&quot;
&amp;gt;&amp;gt; x.downcase
=&amp;gt; &quot;hello \x{93FA}\x{967B}&quot;
&amp;gt;&amp;gt; x.gsub(/ello/, &quot;i&quot;)
=&amp;gt; &quot;Hi \x{93FA}\x{967B}&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;encodingcompatibilityerror&quot;&gt;&lt;code&gt;Encoding::CompatibilityError&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;This exception occurs when we try to combine strings of two different encodings and those encodings are incompatible.
For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;å\u2160&quot;
&amp;gt;&amp;gt; y = &quot;Hello \x93\xfa\x96\x7b&quot;.force_encoding(&quot;Shift_JIS&quot;)
&amp;gt;&amp;gt; [x.encoding, x.valid_encoding?]
=&amp;gt; [#&amp;lt;Encoding:UTF-8&amp;gt;, true]
&amp;gt;&amp;gt; [y.encoding, y.valid_encoding?]
=&amp;gt; [#&amp;lt;Encoding:Shift_JIS&amp;gt;, true]
&amp;gt;&amp;gt; x + y
Traceback (most recent call last):
        5: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `&amp;lt;main&amp;gt;'
        4: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `load'
        3: from /Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.7.0/gems/irb-1.2.0/exe/irb:11:in `&amp;lt;top (required)&amp;gt;'
        2: from (irb):50
        1: from (irb):50:in `+'
Encoding::CompatibilityError (incompatible character encodings: UTF-8 and Shift_JIS)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this example we have a valid UTF-8 string and a valid Shift JIS string.
However, these two encodings are not compatible, so we get an exception when combining.&lt;/p&gt;

&lt;h3 id=&quot;fixing-encodingcompatibilityerror&quot;&gt;Fixing &lt;code&gt;Encoding::CompatibilityError&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;To fix this exception, we need to manually convert one string to a new string that has a compatible encoding.
In the case above, we can choose whether we want the output string to be UTF-8 or Shift JIS, and then call &lt;code&gt;encode&lt;/code&gt; on the appropriate string.&lt;/p&gt;

&lt;p&gt;In the case we want UTF-8 output, we can do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;å&quot;
&amp;gt;&amp;gt; y = &quot;Hello \x93\xfa\x96\x7b&quot;.force_encoding(&quot;Shift_JIS&quot;)
&amp;gt;&amp;gt; x + y.encode(&quot;UTF-8&quot;)
=&amp;gt; &quot;åHello æ¥æ¬&quot;
&amp;gt;&amp;gt; [_.encoding, _.valid_encoding?]
=&amp;gt; [#&amp;lt;Encoding:UTF-8&amp;gt;, true]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we wanted Shift JIS, we could do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;å&quot;
&amp;gt;&amp;gt; y = &quot;Hello \x93\xfa\x96\x7b&quot;.force_encoding(&quot;Shift_JIS&quot;)
&amp;gt;&amp;gt; x.encode(&quot;Shift_JIS&quot;) + y
=&amp;gt; &quot;\x{8E6C}Hello \x{93FA}\x{967B}&quot;
&amp;gt;&amp;gt; [_.encoding, _.valid_encoding?]
=&amp;gt; [#&amp;lt;Encoding:Shift_JIS&amp;gt;, true]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another possible solution is to scrub bytes and concatenate, but again that results in data loss.&lt;/p&gt;

&lt;h3 id=&quot;what-is-a-compatible-encoding&quot;&gt;What is a compatible encoding?&lt;/h3&gt;

&lt;p&gt;If there are incompatible encodings, there must be compatible encodings too (at least I would think that).
Here is an example of compatible encodings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello World!&quot;.force_encoding &quot;US-ASCII&quot;
&amp;gt;&amp;gt; [x.encoding, x.valid_encoding?]
=&amp;gt; [#&amp;lt;Encoding:US-ASCII&amp;gt;, true]
&amp;gt;&amp;gt; y = &quot;ããã«ã¡ã¯&quot;
&amp;gt;&amp;gt; [y.encoding, y.valid_encoding?]
=&amp;gt; [#&amp;lt;Encoding:UTF-8&amp;gt;, true]
&amp;gt;&amp;gt; y + x
=&amp;gt; &quot;ããã«ã¡ã¯Hello World!&quot;
&amp;gt;&amp;gt; [_.encoding, _.valid_encoding?]
=&amp;gt; [#&amp;lt;Encoding:UTF-8&amp;gt;, true]
&amp;gt;&amp;gt; x + y
=&amp;gt; &quot;Hello World!ããã«ã¡ã¯&quot;
&amp;gt;&amp;gt; [_.encoding, _.valid_encoding?]
=&amp;gt; [#&amp;lt;Encoding:UTF-8&amp;gt;, true]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;x&lt;/code&gt; string is encoded with &amp;ldquo;US ASCII&amp;rdquo; encoding and the &lt;code&gt;y&lt;/code&gt; string UTF-8.
US ASCII is fully compatible with UTF-8, so even though these two strings have different encoding, concatenation works fine.&lt;/p&gt;

&lt;p&gt;String literals may default to UTF-8, but some functions will return US ASCII encoded strings.
For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; require &quot;digest/md5&quot;
=&amp;gt; true
&amp;gt;&amp;gt; Digest::MD5.hexdigest(&quot;foo&quot;).encoding
=&amp;gt; #&amp;lt;Encoding:US-ASCII&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A hexdigest will only ever contain ASCII characters, so the implementation tags the returned string as US-ASCII.&lt;/p&gt;

&lt;h2 id=&quot;encoding-gotchas&quot;&gt;Encoding Gotchas&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s look at a couple encoding gotcha&amp;rsquo;s.&lt;/p&gt;

&lt;h3 id=&quot;infectious-invalid-encodings&quot;&gt;Infectious Invalid Encodings&lt;/h3&gt;

&lt;p&gt;When a string is incorrectly tagged, Ruby will typically only raise an exception when it needs to actually examine the bytes.
Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello \x93\xfa\x96\x7b&quot;
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:UTF-8&amp;gt;
&amp;gt;&amp;gt; x.valid_encoding?
=&amp;gt; false
&amp;gt;&amp;gt; x + &quot;ã»ã&quot;
=&amp;gt; &quot;Hello \x93\xFA\x96{ã»ã&quot;
&amp;gt;&amp;gt; y = _
&amp;gt;&amp;gt; y
=&amp;gt; &quot;Hello \x93\xFA\x96{ã»ã&quot;
&amp;gt;&amp;gt; [y.encoding, y.valid_encoding?]
=&amp;gt; [#&amp;lt;Encoding:UTF-8&amp;gt;, false]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again we have the incorrectly tagged Shift JIS string.
We&amp;rsquo;re able to append a correctly tagged UTF-8 string and no exception is raised.
Why is that?
Ruby assumes that if both strings have the same encoding, there is no reason to validate the bytes in either string so it will just append them.
That means we can have an incorrectly tagged string &amp;ldquo;infect&amp;rdquo; what would otherwise be correctly tagged UTF-8 strings.
Say we have some code like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;append&lt;/span&gt; string
  string + &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;ã»ã&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

p append(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;ã»ã&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;).valid_encoding? &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; true&lt;/span&gt;
p append(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;Hello &lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x93&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\xfa&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x96&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\x7b&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;).valid_encoding? &lt;span class=&quot;comment&quot;&gt;# = false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;When debugging this code, we may be tempted to think the problem is in the &lt;code&gt;append&lt;/code&gt; method.
But actually the issue is with &lt;em&gt;the caller&lt;/em&gt;.
The caller is passing in incorrectly tagged strings, and unfortunately we might not get an exception until the return value of &lt;code&gt;append&lt;/code&gt; is used somewhere far away.&lt;/p&gt;

&lt;h3 id=&quot;ascii-8bit-is-special&quot;&gt;ASCII-8BIT is Special&lt;/h3&gt;

&lt;p&gt;Sometimes ASCII-8BIT is considered to be a &amp;ldquo;compatible&amp;rdquo; encoding and sometimes it isn&amp;rsquo;t.
Here is an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;\x93\xfa\x96\x7b&quot;.b
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:ASCII-8BIT&amp;gt;
&amp;gt;&amp;gt; y = &quot;ã»ã&quot;
&amp;gt;&amp;gt; y + x
Traceback (most recent call last):
        5: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `&amp;lt;main&amp;gt;'
        4: from /Users/aaron/.rbenv/versions/ruby-trunk/bin/irb:23:in `load'
        3: from /Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.7.0/gems/irb-1.2.0/exe/irb:11:in `&amp;lt;top (required)&amp;gt;'
        2: from (irb):89
        1: from (irb):89:in `+'
Encoding::CompatibilityError (incompatible character encodings: UTF-8 and ASCII-8BIT)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we have a binary string stored in &lt;code&gt;x&lt;/code&gt;.
Maybe it came from a JPEG file or something (it didn&amp;rsquo;t, I just typed it in!)
When we try to concatenate the binary string with the UTF-8 string, we get an exception.
But this may actually be an exception we want!
It doesn&amp;rsquo;t make sense to be concatenating some JPEG data with an actual string we want to view, so it&amp;rsquo;s &lt;em&gt;good&lt;/em&gt; we got an exception here.&lt;/p&gt;

&lt;p&gt;Now here is the same code, but with the contents of &lt;code&gt;x&lt;/code&gt; changed somewhat:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; x = &quot;Hello World&quot;.b
&amp;gt;&amp;gt; x.encoding
=&amp;gt; #&amp;lt;Encoding:ASCII-8BIT&amp;gt;
&amp;gt;&amp;gt; y = &quot;ã»ã&quot;
&amp;gt;&amp;gt; y + x
=&amp;gt; &quot;ã»ãHello World&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have the same code with the same encodings at play.
The only thing that changed is the actual contents of the &lt;code&gt;x&lt;/code&gt; string.&lt;/p&gt;

&lt;p&gt;When Ruby concatenates ASCII-8BIT strings, it will examine the contents of that string.
If all bytes in the string are ASCII characters, it will treat it as a US-ASCII string and consider it to be &amp;ldquo;compatible&amp;rdquo;.
If the string contains non-ASCII characters, it will consider it to be incompatible.&lt;/p&gt;

&lt;p&gt;This means that if you had read some data from your JPEG, and that data happened to all be ASCII characters, you would not get an exception even though maybe you really wanted one.&lt;/p&gt;

&lt;p&gt;In my personal opinion, concatenating an ASCII-8BIT string with anything besides another ASCII-8BIT string should be an exception.&lt;/p&gt;

&lt;p&gt;Anyway, this is all I feel like writing today.  I hope you have a good day, and remember to check your encodings!&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2019/10/12/my-career-goals.html</id>
      <title>My Career Goals</title>
      <updated>2019-10-12T12:40:41-07:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2019/10/12/my-career-goals.html">

      <published>2019-10-12T12:40:41-07:00</published>
      <content type="html">&lt;p&gt;I was going to tweet about this, but then I thought I&amp;rsquo;d have to make a bunch of tweets, and writing a blurgh post just seemed easier.
Plus I don&amp;rsquo;t really have any puns in this post, so I can&amp;rsquo;t tweet it!&lt;/p&gt;

&lt;h2 id=&quot;my-career-goals&quot;&gt;My Career Goals&lt;/h2&gt;

&lt;p&gt;I think many people aren&amp;rsquo;t sure what they want to do in their career.
When I first started programming, I wasn&amp;rsquo;t sure what I wanted to do with my career.
But after years of experience, my career aspirations have become crystal clear.
I would like my job to be:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Improving Ruby and Rails internals&lt;/li&gt;
  &lt;li&gt;Teaching people&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;improving-ruby-and-rails-internals&quot;&gt;Improving Ruby and Rails internals&lt;/h2&gt;

&lt;p&gt;I got my first job programming in 1999.
At that time, I didn&amp;rsquo;t know I wanted to be a programmer, it was just a way for me to pay for school.
It turned out that I was pretty good at programming, so I decided that would be my career.
To be honest, at that time I didn&amp;rsquo;t really love programming.
I just found that I was good at it, and I could make decent money.
In 2005 I found Ruby and Rails and that&amp;rsquo;s when I actually learned that I love programming.
I loved Ruby so much that I learned Japanese so I could read blog posts about Ruby.
14 years later, I can easily read those blog posts, but I don&amp;rsquo;t actually need them.  Oops!&lt;/p&gt;

&lt;p&gt;The reason I want to work on Ruby and Rails internals is that I want the language and framework to be performant, stable, easy to use.
I want Ruby and Rails to be a great choice for people to use in production.
I want others to experience the same joy I felt writing Ruby, and I want to make sure there are business that will employ those people.&lt;/p&gt;

&lt;h2 id=&quot;teaching-people&quot;&gt;Teaching People&lt;/h2&gt;

&lt;p&gt;I love to teach people things I know.
I also love learning new things.
As I hack on language and framework internals, I try to take that knowledge an disseminate it to as many people as I can.&lt;/p&gt;

&lt;p&gt;Why?&lt;/p&gt;

&lt;p&gt;First, I don&amp;rsquo;t think people can feel the joy of programming in Ruby/Rails unless they know how to actually program with Ruby/Rails.
So I&amp;rsquo;m happy to help new folks get in to the language and framework.&lt;/p&gt;

&lt;p&gt;Second, I realize I&amp;rsquo;m not going to be around forever, and I want to make sure that these technologies will outlive me.
If these technologies are going to survive in to the future, people need to understand how they work.
Simply put: it&amp;rsquo;s an insurance policy for the future.&lt;/p&gt;

&lt;p&gt;Third, it&amp;rsquo;s just fun.&lt;/p&gt;

&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;/h2&gt;

&lt;p&gt;My dream job is to hack Ruby/Rails internals and teach people everything I know.
Doing it is fun for me, and it&amp;rsquo;s the best way I can use my skills to make a real impact on the world.&lt;/p&gt;

&lt;p&gt;The End.&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2019/09/03/esp8266-and-plantower-particle-sensor.html</id>
      <title>ESP8266 and Plantower Particle Sensor</title>
      <updated>2019-09-03T08:20:26-07:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2019/09/03/esp8266-and-plantower-particle-sensor.html">

      <published>2019-09-03T08:20:26-07:00</published>
      <content type="html">&lt;p&gt;Since forest fires have started to become a normal thing in the PNW, I&amp;rsquo;ve gotten interested in monitoring the air quality in and around my house.
I found some sensors that will measure PM2.5 which is a standard for measuring air quality.
The sensor I&amp;rsquo;m using is a &lt;a href=&quot;https://www.aliexpress.com/item/32834164058.html&quot;&gt;PMS5003&lt;/a&gt;, and you can see the data sheet for it &lt;a href=&quot;http://www.aqmd.gov/docs/default-source/aq-spec/resources-page/plantower-pms5003-manual_v2-3.pdf&quot;&gt;here&lt;/a&gt;.
I like this sensor because it supports UART, so I was able to hook it to an &lt;a href=&quot;https://www.aliexpress.com/item/2035873939.html&quot;&gt;FTDI&lt;/a&gt; and read data directly from my computer.
I wanted to log the data, so I hooked it up to a Raspberry PI.
However, I decided I&amp;rsquo;d like to measure the air quality in my office, a second room in the house, and also outside.
Buying a Raspberry Pi for every sensor I purchase seems a little unreasonable, so I investigated a different solution.
I settled on the &lt;a href=&quot;https://www.aliexpress.com/item/32279043338.html&quot;&gt;ESP8266 E-01&lt;/a&gt;.
This part can connect to wifi, knows how to speak UART, and is powerful enough to program directly.
My plan was to read data from the sensor, then broadcast the data via UDP and have a central Raspberry Pi collect the data and report on it.
Unfortunately, this plan has taken me many months to execute, so I&amp;rsquo;m going to write here the stuff I wish I had known when getting started.&lt;/p&gt;

&lt;h2 id=&quot;parts&quot;&gt;Parts&lt;/h2&gt;

&lt;p&gt;Here are the parts I used:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.aliexpress.com/item/32279043338.html&quot;&gt;ESP8266&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.aliexpress.com/item/32834164058.html&quot;&gt;Plantower PMS5003&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/gp/product/B01G6HK3KW/&quot;&gt;ESP8266 Breadboard Adapter&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.amazon.com/gp/product/B07KF119YB/&quot;&gt;ESP8266 Programmer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;wiring&quot;&gt;Wiring&lt;/h2&gt;

&lt;p&gt;Basically I just hooked the TX / RX pins to the Plantower sensor and set the CHPD and RST pins to high.&lt;/p&gt;

&lt;h2 id=&quot;challenges-with-the-esp8266&quot;&gt;Challenges with the ESP8266&lt;/h2&gt;

&lt;p&gt;Now I&amp;rsquo;m basically going to complain about this chip, and then I&amp;rsquo;ll post the code I used.&lt;/p&gt;

&lt;p&gt;The first issue I ran in to is that I&amp;rsquo;m not sure what to call this thing, so searching the internet became a challenge.
It seems that &amp;ldquo;ESP8266&amp;rdquo; refers to the chip, but E-01 refers to the package?
I&amp;rsquo;m still not actually sure.
It seems there are several boards that have an ESP8266 mounted on them, but searching for ESP8266 with E01 seemed to work.&lt;/p&gt;

&lt;p&gt;The second issue is programming the chip.
I prefer to use C when developing for embedded systems, but no matter how hard I tried, I could not get the native toolchain running on MacOS.
Finally I gave up and just used the Arduino toolchain.
Somehow, you can write programs for the ESP8266 in Arduino, but doing it in C seems impossible (on Mac anyway).&lt;/p&gt;

&lt;p&gt;Building a circuit to program the chip seems impossible.
I found some schematics online for building a programmer, but I couldn&amp;rsquo;t get anything to work.
Instead, I ended up buying a &lt;a href=&quot;https://www.amazon.com/gp/product/B07KF119YB/&quot;&gt;dedicated programmer&lt;/a&gt;, and it seems to work well.&lt;/p&gt;

&lt;p&gt;Power requirements are extremely finicky.
The chip wants 3.3v and at times 400mA.
If either of these criteria aren&amp;rsquo;t met, the chip won&amp;rsquo;t work.
Sometimes the chip wouldn&amp;rsquo;t do anything.
Sometimes it would start, but when it tried to do wifi it would just restart.
I ended up connecting a dedicated power supply to get the right power requirements.&lt;/p&gt;

&lt;p&gt;The ESP8266 E-01 is not breadboard friendly.
I ended up buying some &lt;a href=&quot;https://www.amazon.com/gp/product/B01G6HK3KW/&quot;&gt;breadboard adapters&lt;/a&gt; so I could prototype.&lt;/p&gt;

&lt;p&gt;CHPD and RST need to be pulled HIGH for the chip to boot.
This got me for a long time.
I was able to program the chip with the programmer, but as soon as I moved it to the breadboard, nothing worked.
In order to get the chip to actually boot, both CHPD and RST need to be pulled high.&lt;/p&gt;

&lt;p&gt;The air quality sensor is 5v.
This isn&amp;rsquo;t too much of a problem, just kind of annoying that I really really have to use two different voltages for this task.&lt;/p&gt;

&lt;h2 id=&quot;picture&quot;&gt;Picture&lt;/h2&gt;

&lt;p&gt;Here is a picture of the breadboard setup I have now:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/plantower-sensor.jpg&quot; alt=&quot;ESP8266 and Plantower on a Breadboard&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The blue box on the right is the air quality sensor, in the middle on the breadboard is the ESP8266, and up top is the power supply.&lt;/p&gt;

&lt;h2 id=&quot;code&quot;&gt;Code&lt;/h2&gt;

&lt;p&gt;Here is the Arduino code I used:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;preprocessor&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;include&quot;&gt;&amp;lt;ESP8266WiFi.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;include&quot;&gt;&amp;lt;WiFiUdp.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;include&quot;&gt;&amp;lt;ESP8266WiFiMulti.h&amp;gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;include&quot;&gt;&amp;lt;base64.h&amp;gt;&lt;/span&gt;

&lt;span class=&quot;preprocessor&quot;&gt;#ifndef&lt;/span&gt; STASSID
&lt;span class=&quot;preprocessor&quot;&gt;#define&lt;/span&gt; STASSID &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;WifiAPName&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#define&lt;/span&gt; STAPSK  &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;WifiPassword&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;preprocessor&quot;&gt;#endif&lt;/span&gt;

&lt;span class=&quot;directive&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;predefined-type&quot;&gt;char&lt;/span&gt;* ssid     = STASSID;
&lt;span class=&quot;directive&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;predefined-type&quot;&gt;char&lt;/span&gt;* password = STAPSK;

ESP8266WiFiMulti WiFiMulti;
WiFiUDP udp;
IPAddress broadcastIp(&lt;span class=&quot;integer&quot;&gt;224&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;);

byte inputString[&lt;span class=&quot;integer&quot;&gt;32&lt;/span&gt;];
&lt;span class=&quot;predefined-type&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;;
&lt;span class=&quot;predefined-type&quot;&gt;int&lt;/span&gt; recordId = &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;;

&lt;span class=&quot;directive&quot;&gt;void&lt;/span&gt; setup() {
  Serial.begin(&lt;span class=&quot;integer&quot;&gt;9600&lt;/span&gt;);

  WiFi.mode(WIFI_STA);
  WiFiMulti.addAP(ssid, password);

  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (WiFiMulti.run() != WL_CONNECTED) {
    delay(&lt;span class=&quot;integer&quot;&gt;500&lt;/span&gt;);
  }

  delay(&lt;span class=&quot;integer&quot;&gt;500&lt;/span&gt;);
}

&lt;span class=&quot;directive&quot;&gt;void&lt;/span&gt; loop() {
  &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (Serial.available()) {
    inputString[i] = Serial.read();
    i++;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i == &lt;span class=&quot;integer&quot;&gt;2&lt;/span&gt;) { &lt;span class=&quot;comment&quot;&gt;// Check for start of packet&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (!(inputString[&lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;] == &lt;span class=&quot;hex&quot;&gt;0x42&lt;/span&gt; &amp;amp;&amp;amp; inputString[&lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;] == &lt;span class=&quot;hex&quot;&gt;0x4d&lt;/span&gt;)) {
        i = &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;;
      }
    }
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (i == &lt;span class=&quot;integer&quot;&gt;32&lt;/span&gt;) {
      i = &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;;
      String encoded = base64::encode(inputString, &lt;span class=&quot;integer&quot;&gt;32&lt;/span&gt;);
      udp.beginPacketMulticast(broadcastIp, &lt;span class=&quot;integer&quot;&gt;9000&lt;/span&gt;, WiFi.localIP());
      udp.print(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;aq&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;,{&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;mac&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
      udp.print(WiFi.macAddress());
      udp.print(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;record_id&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
      udp.print(recordId);
      udp.print(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
      udp.print(encoded);
      udp.print(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;char&quot;&gt;\&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;}]&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;);
      udp.endPacket();
      recordId++;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;I haven&amp;rsquo;t added CRC checking in this code, but it seems to work fine.
Basically it reads data from the AQ sensor, Base64 encodes the data, then broadcasts the info as JSON over UDP on my network.&lt;/p&gt;

&lt;p&gt;Here is the client code:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;socket&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;ipaddr&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;json&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;MULTICAST_ADDR&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;224.0.0.1&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;BIND_ADDR&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;0.0.0.0&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;PORT&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;9000&lt;/span&gt;

if_addr = &lt;span class=&quot;constant&quot;&gt;Socket&lt;/span&gt;.getifaddrs.find { |s| s.addr.ipv4? &amp;amp;&amp;amp; !s.addr.ipv4_loopback? }
p if_addr.addr.ip_address

socket = &lt;span class=&quot;constant&quot;&gt;UDPSocket&lt;/span&gt;.new
membership = &lt;span class=&quot;constant&quot;&gt;IPAddr&lt;/span&gt;.new(&lt;span class=&quot;constant&quot;&gt;MULTICAST_ADDR&lt;/span&gt;).hton + &lt;span class=&quot;constant&quot;&gt;IPAddr&lt;/span&gt;.new(&lt;span class=&quot;constant&quot;&gt;BIND_ADDR&lt;/span&gt;).hton

socket.setsockopt(&lt;span class=&quot;symbol&quot;&gt;:IPPROTO_IP&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:IP_ADD_MEMBERSHIP&lt;/span&gt;, membership)
socket.setsockopt(&lt;span class=&quot;symbol&quot;&gt;:IPPROTO_IP&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:IP_MULTICAST_TTL&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;)
socket.setsockopt(&lt;span class=&quot;symbol&quot;&gt;:SOL_SOCKET&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:SO_REUSEPORT&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;)

socket.bind(&lt;span class=&quot;constant&quot;&gt;BIND_ADDR&lt;/span&gt;, &lt;span class=&quot;constant&quot;&gt;PORT&lt;/span&gt;)

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Sample&lt;/span&gt; &amp;lt; &lt;span class=&quot;constant&quot;&gt;Struct&lt;/span&gt;.new(&lt;span class=&quot;symbol&quot;&gt;:time&lt;/span&gt;,
                          &lt;span class=&quot;symbol&quot;&gt;:pm1_0_standard&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:pm2_5_standard&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:pm10_standard&lt;/span&gt;,
                          &lt;span class=&quot;symbol&quot;&gt;:pm1_0_env&lt;/span&gt;,      &lt;span class=&quot;symbol&quot;&gt;:pm2_5_env&lt;/span&gt;,
                          &lt;span class=&quot;symbol&quot;&gt;:concentration_unit&lt;/span&gt;,

                          &lt;span class=&quot;comment&quot;&gt;# These fields are &amp;quot;number of particles beyond N um&lt;/span&gt;
                          &lt;span class=&quot;comment&quot;&gt;# per 0.1L of air&amp;quot;. These numbers are multiplied by&lt;/span&gt;
                          &lt;span class=&quot;comment&quot;&gt;# 10, so 03um == &amp;quot;number of particles beyond 0.3um&lt;/span&gt;
                          &lt;span class=&quot;comment&quot;&gt;# in 0.1L of air&amp;quot;&lt;/span&gt;
                          &lt;span class=&quot;symbol&quot;&gt;:particle_03um&lt;/span&gt;,   &lt;span class=&quot;symbol&quot;&gt;:particle_05um&lt;/span&gt;,   &lt;span class=&quot;symbol&quot;&gt;:particle_10um&lt;/span&gt;,
                          &lt;span class=&quot;symbol&quot;&gt;:particle_25um&lt;/span&gt;,   &lt;span class=&quot;symbol&quot;&gt;:particle_50um&lt;/span&gt;,   &lt;span class=&quot;symbol&quot;&gt;:particle_100um&lt;/span&gt;)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

loop &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
  m, _ = socket.recvfrom(&lt;span class=&quot;integer&quot;&gt;2000&lt;/span&gt;)
  record = &lt;span class=&quot;constant&quot;&gt;JSON&lt;/span&gt;.load(m)[&lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;]

  data = record[&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;record&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;].unpack(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;m0&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;).first
  unpack = data.unpack(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;CCnn14&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
  crc = &lt;span class=&quot;integer&quot;&gt;0x42&lt;/span&gt; + &lt;span class=&quot;integer&quot;&gt;0x4d&lt;/span&gt; + &lt;span class=&quot;integer&quot;&gt;28&lt;/span&gt; + data.bytes.drop(&lt;span class=&quot;integer&quot;&gt;4&lt;/span&gt;).first(&lt;span class=&quot;integer&quot;&gt;26&lt;/span&gt;).inject(&lt;span class=&quot;symbol&quot;&gt;:+&lt;/span&gt;)
  &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; crc != unpack.last
    p &lt;span class=&quot;constant&quot;&gt;Sample&lt;/span&gt;.new(&lt;span class=&quot;constant&quot;&gt;Time&lt;/span&gt;.now.utc, *unpack.drop(&lt;span class=&quot;integer&quot;&gt;3&lt;/span&gt;).first(&lt;span class=&quot;integer&quot;&gt;12&lt;/span&gt;))
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;This code just listens for incoming data and prints it out.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve posted the code &lt;a href=&quot;https://github.com/tenderlove/esp8266aq&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This is what I did over the long weekend!
Since the AQ sensor only uses the RX and TX pins on the ESP8266, it means I&amp;rsquo;ve got at least two more GPIO pins left.
Next I&amp;rsquo;ll add temperature and humidity sensor, then make something a bit more permanent.&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2019/06/26/instance-variable-performance.html</id>
      <title>Instance Variable Performance</title>
      <updated>2019-06-26T08:14:14-07:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2019/06/26/instance-variable-performance.html">

      <published>2019-06-26T08:14:14-07:00</published>
      <content type="html">&lt;p&gt;Let&amp;rsquo;s start today&amp;rsquo;s post with a weird Ruby benchmark:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;benchmark/ips&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Foo&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt; forward
    forward ? go_forward : go_backward
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  ivars = (&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;..&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;zz&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;).map { |name| &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;inline&quot;&gt;&lt;span class=&quot;inline-delimiter&quot;&gt;#{&lt;/span&gt;name&lt;span class=&quot;inline-delimiter&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt; = 5&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; }

  &lt;span class=&quot;comment&quot;&gt;# define the go_forward method&lt;/span&gt;
  eval &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;def go_forward; &lt;/span&gt;&lt;span class=&quot;inline&quot;&gt;&lt;span class=&quot;inline-delimiter&quot;&gt;#{&lt;/span&gt;ivars.join(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;; &lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;inline-delimiter&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt; end&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

  &lt;span class=&quot;comment&quot;&gt;# define the go_backward method&lt;/span&gt;
  eval &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;def go_backward; &lt;/span&gt;&lt;span class=&quot;inline&quot;&gt;&lt;span class=&quot;inline-delimiter&quot;&gt;#{&lt;/span&gt;ivars.reverse.join(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;; &lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;inline-delimiter&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt; end&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Heat&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;false&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;Benchmark&lt;/span&gt;.ips &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |x|
  x.report(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;backward&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;) { &lt;span class=&quot;integer&quot;&gt;5000&lt;/span&gt;.times { &lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;false&lt;/span&gt; } }
  x.report(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)  { &lt;span class=&quot;integer&quot;&gt;5000&lt;/span&gt;.times { &lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;true&lt;/span&gt; } }
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;This code defines a class that sets a bunch of instance variables, but the order
that the instance variables are set depends on the parameter passed in to the
constructor.  When we pass &lt;code&gt;true&lt;/code&gt;, it defines instance variables &amp;ldquo;a&amp;rdquo; through
&amp;ldquo;zz&amp;rdquo;, and when we pass &lt;code&gt;false&lt;/code&gt; it defines them &amp;ldquo;zz&amp;rdquo; through &amp;ldquo;a&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the result of the benchmark on my machine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby weird_bench.rb
Warming up --------------------------------------
            backward     3.000  i/100ms
             forward     2.000  i/100ms
Calculating -------------------------------------
            backward     38.491  (Â±10.4%) i/s -    192.000  in   5.042515s
             forward     23.038  (Â± 8.7%) i/s -    114.000  in   5.004367s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For some reason, defining the instance variables backwards is faster than
defining the instance variables forwards.  In this post we&amp;rsquo;ll discuss why.  But
for now, just know that if you want performant code, always define your instance
variables backwards (just kidding, don&amp;rsquo;t do that).&lt;/p&gt;

&lt;h2 id=&quot;how-are-instance-variables-stored&quot;&gt;How Are Instance Variables Stored?&lt;/h2&gt;

&lt;p&gt;In Ruby (specifically MRI), object instances point at an array, and instance
variables are stored in that array.  Of course, we refer to instance variables
by names, not by array indexes, so Ruby keeps a map of &amp;ldquo;names to indexes&amp;rdquo; which
is stored &lt;em&gt;on the class&lt;/em&gt; of the object.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say we have some code like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Foo&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@a&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@b&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@c&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@d&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;hoge&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Internally, the object relationship will look something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ivar_rel.png&quot; alt=&quot;Instance Variable Relationship&quot; height=&quot;400&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The class points at a map of &amp;ldquo;names to indexes&amp;rdquo; called the &amp;ldquo;IV Index Table&amp;rdquo;.
The IV Index Table contains the names of the instance variables along with the
index of where to find that instance variable.&lt;/p&gt;

&lt;p&gt;The instance points at the class, and also points at an array that contains the
actual values of the instance variables.&lt;/p&gt;

&lt;p&gt;Why go to all this trouble to map instance variable names to array offsets?  The
reason is that it is much faster to access an array element than look up
something from a hash.  We do have to do a hash lookup to find the array
element, but instance variables have their own &lt;a href=&quot;/2015/12/23/inline-caching-in-mri.html&quot;&gt;inline cache&lt;/a&gt;,
so the lookup doesn&amp;rsquo;t occur very often.&lt;/p&gt;

&lt;h2 id=&quot;setting-instance-variables-in-slow-motion&quot;&gt;Setting Instance Variables in Slow Motion&lt;/h2&gt;

&lt;p&gt;I want to walk through exactly what happens when instance variables are set, but
we&amp;rsquo;re going to do it twice.  We&amp;rsquo;ll use the code below:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Foo&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@a&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@b&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@c&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@d&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;hoge&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Ruby creates the instance variable index table lazily, so it doesn&amp;rsquo;t actually
exist until the first time the code executes.  The following GIF shows the
execution flow for the first time &lt;code&gt;Foo.new&lt;/code&gt; is called:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ivar_first_time.gif&quot; alt=&quot;Ivar Execution&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The first time &lt;code&gt;initialize&lt;/code&gt; is executed, the &lt;code&gt;Foo&lt;/code&gt; class doesn&amp;rsquo;t have an
instance variable index table associated with it, so when the first instance
variable &lt;code&gt;@a&lt;/code&gt; is set, we create a new index table, then set &lt;code&gt;@a&lt;/code&gt; to be index 0,
then set the value &amp;ldquo;foo&amp;rdquo; in the instance variable array at index 0.&lt;/p&gt;

&lt;p&gt;When we see instance variable &lt;code&gt;@b&lt;/code&gt;, it doesn&amp;rsquo;t have an entry in the index table,
so we add a new entry that points to position 1, then set position 1 in the
array to &amp;ldquo;bar&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;This process repeats for each of the instance variables in the method.&lt;/p&gt;

&lt;p&gt;Now lets look at what happens the second time we call &lt;code&gt;Foo.new&lt;/code&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ivar_second_time.gif&quot; alt=&quot;Ivar Execution Second Time&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This time, the class already has an instance variable index table associated
with it.  When the instance variable &lt;code&gt;@a&lt;/code&gt; is set, it exists in the index table
with position 0, so we set &amp;ldquo;foo&amp;rdquo; to position 0 in the instance variable list.&lt;/p&gt;

&lt;p&gt;When we see instance variable &lt;code&gt;@b&lt;/code&gt;, it already has an entry in the index table
with position 1, so we set &amp;ldquo;bar&amp;rdquo; to position 1 in the instance variable list.&lt;/p&gt;

&lt;p&gt;This process repeats for each of the variables in the method.&lt;/p&gt;

&lt;p&gt;We can actually observe the lazy creation of the index table by using
&lt;code&gt;ObjectSpace.memsize_of&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;objspace&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Foo&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@a&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@b&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@c&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@d&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;hoge&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; 520&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new
p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; 672&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new
p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; 672&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The size of &lt;code&gt;Foo&lt;/code&gt; is smaller before we instantiate our first instance, but
remains the same size after subsequent allocations.  Neat!&lt;/p&gt;

&lt;p&gt;Lets do one more example, but with the following code:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Foo&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt; init_all
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; init_all
      &lt;span class=&quot;instance-variable&quot;&gt;@a&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
      &lt;span class=&quot;instance-variable&quot;&gt;@b&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
      &lt;span class=&quot;instance-variable&quot;&gt;@c&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
      &lt;span class=&quot;instance-variable&quot;&gt;@d&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;hoge&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;
      &lt;span class=&quot;instance-variable&quot;&gt;@c&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
      &lt;span class=&quot;instance-variable&quot;&gt;@d&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;hoge&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;true&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;false&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;After the first call of &lt;code&gt;Foo.new true&lt;/code&gt;, the &lt;code&gt;Foo&lt;/code&gt; class will have an instance
variable index table just like the previous examples.  &lt;code&gt;@a&lt;/code&gt; will be associated
with position 0, &lt;code&gt;@b&lt;/code&gt; with position 1, and so on.  But what happens on the
second allocation at &lt;code&gt;Foo.new false&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ivar_third_time.gif&quot; alt=&quot;Ivar Execution Third Time&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In this case, we already have an index table associated with the class, but &lt;code&gt;@c&lt;/code&gt;
is associated with position 2 in the instance variable array, so we have to
expand the array leaving position 0 and 1 unset (internally Ruby sets them to
&lt;code&gt;Qundef&lt;/code&gt;).  Then &lt;code&gt;@d&lt;/code&gt; is associated with position 3, and it is set as usual.&lt;/p&gt;

&lt;p&gt;The important part about this is that instance variable lists must expand to the
width required for the index offset.  Now lets talk about how the list expands.&lt;/p&gt;

&lt;h2 id=&quot;instance-variable-list-allocation-and-expansion&quot;&gt;Instance Variable List Allocation and Expansion&lt;/h2&gt;

&lt;p&gt;We saw how the instance variable index table is created.  Now I want to spend
some time focusing on the instance variable list.  This list is associated with
the instance and stores references to our actual instance variable values.&lt;/p&gt;

&lt;p&gt;This list is lazily allocated and expands as it needs to accommodate more
values.  &lt;a href=&quot;https://github.com/ruby/ruby/blob/24c4e6dec109e105c13bd4c1b7f7cd51e534a3c3/variable.c#L947-L957&quot;&gt;Here is the code&lt;/a&gt; that figures out by how much the array should grow.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve translated that function to Ruby code and added a few more comments:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;iv_index_tbl_newsize&lt;/span&gt;(ivup)
  index = ivup.index
  newsize = (index + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;) + (index + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;)/&lt;span class=&quot;integer&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# (index + 1) * 1.25&lt;/span&gt;


  &lt;span class=&quot;comment&quot;&gt;# if the index table *wasn't* extended, then clamp the newsize down to&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;# the size of the index table.  Otherwise, use a size 25% larger than&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;# the requested index&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; !ivup.iv_extended &amp;amp;&amp;amp; ivup.index_table.size &amp;lt; newsize
    ivup.index_table.size
  &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;
    newsize
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;IVarUpdate&lt;/span&gt; = &lt;span class=&quot;constant&quot;&gt;Struct&lt;/span&gt;.new(&lt;span class=&quot;symbol&quot;&gt;:index&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:iv_extended&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:index_table&lt;/span&gt;)
index_table = { &lt;span class=&quot;key&quot;&gt;a&lt;/span&gt;: &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;key&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;key&quot;&gt;c&lt;/span&gt;: &lt;span class=&quot;integer&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;key&quot;&gt;d&lt;/span&gt;: &lt;span class=&quot;integer&quot;&gt;3&lt;/span&gt; } &lt;span class=&quot;comment&quot;&gt;# table from our examples&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# We're setting `@c`, which has an index of 2. `false` means we didn't mutate&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# the index table.&lt;/span&gt;
p iv_index_tbl_newsize(&lt;span class=&quot;constant&quot;&gt;IVarUpdate&lt;/span&gt;.new(index_table[&lt;span class=&quot;symbol&quot;&gt;:c&lt;/span&gt;], &lt;span class=&quot;predefined-constant&quot;&gt;false&lt;/span&gt;, index_table))
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The return value of &lt;code&gt;iv_index_tbl_newsize&lt;/code&gt; is used to determine how much memory
we need for the instance variable array.  As you can see, its return value is
based on the index of the instance variable, and we got that index from the
index table.&lt;/p&gt;

&lt;p&gt;If the index table was mutated, then we&amp;rsquo;ll allow the instance variable list to
grow without bounds.  But if the index table was &lt;em&gt;not&lt;/em&gt; mutated, then we clamp
the array size to the size of the index table.&lt;/p&gt;

&lt;p&gt;This means that the first time we allocate a particular Ruby object, it can be
&lt;em&gt;larger&lt;/em&gt; than subsequent allocations.  Again, we can use
&lt;code&gt;ObjectSpace.memsize_of&lt;/code&gt; to observe this behavior:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;objspace&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Foo&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@a&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@b&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;bar&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@c&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;baz&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@d&lt;/span&gt; = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;hoge&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new) &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; 80&lt;/span&gt;
p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new) &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; 72&lt;/span&gt;
p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new) &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; 72&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The first allocation is larger because it&amp;rsquo;s the first time we&amp;rsquo;ve &amp;ldquo;seen&amp;rdquo; these
instance variables.  The subsequent allocations are smaller because Ruby clamps
the instance variable array size.&lt;/p&gt;

&lt;h3 id=&quot;watching-the-instance-variable-array-grow&quot;&gt;Watching the Instance Variable Array Grow&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s do one more experiment before we get on to why the initial benchmark behaves
the way it does.  Here we&amp;rsquo;re going to watch the size of the object grow as we
add instance variables (again, using &lt;code&gt;ObjectSpace.memsize_of&lt;/code&gt;):&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;objspace&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Foo&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@a&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@b&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@c&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@d&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@e&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@f&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@g&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@h&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;First&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new
puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Here&amp;rsquo;s the output from the program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby ~/thing.rb 
First
40
40
40
80
80
96
96
120
Second
40
40
40
80
80
96
96
104
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can see that as we add instance variables to the object, the object gets
bigger!  Let&amp;rsquo;s make one change to the benchmark and run it again.  This time
we&amp;rsquo;ll add an option that lets us define the &amp;ldquo;last&amp;rdquo; instance variable first:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;objspace&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Foo&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt; eager_h
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; eager_h
      &lt;span class=&quot;instance-variable&quot;&gt;@h&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@a&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@b&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@c&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@d&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@e&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@f&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@g&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
    &lt;span class=&quot;instance-variable&quot;&gt;@h&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.memsize_of(&lt;span class=&quot;predefined-constant&quot;&gt;self&lt;/span&gt;)
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;First&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;false&lt;/span&gt;
puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;Second&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Here&amp;rsquo;s the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby ~/thing.rb
First
40
40
40
80
80
96
96
120
Second
104
104
104
104
104
104
104
104
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the first allocation, we can observe the size of the object gradually expand
as usual.  However, on the second allocation, we ask it to eagerly set &lt;code&gt;@h&lt;/code&gt; and
the growth pattern is totally different.  In fact, it doesn&amp;rsquo;t grow at all!&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;@h&lt;/code&gt; is last in our index table, Ruby immediately expands the array list
in order to set the value for the &lt;code&gt;@h&lt;/code&gt; slot.  Since the instance variable array
is now at maximum capacity, none of the subsequent instance variable sets need
the array to expand.&lt;/p&gt;

&lt;h2 id=&quot;back-to-our-initial-benchmark&quot;&gt;Back To Our Initial Benchmark&lt;/h2&gt;

&lt;p&gt;Every time Ruby needs to expand the instance variable array, it requires calling
&lt;code&gt;realloc&lt;/code&gt; in order to expand that chunk of memory.  We can observe calls to
&lt;code&gt;realloc&lt;/code&gt; using &lt;code&gt;dtrace&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Foo&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt; forward
    forward ? go_forward : go_backward
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  ivars = (&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;..&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;zz&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;).map { |name| &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;inline&quot;&gt;&lt;span class=&quot;inline-delimiter&quot;&gt;#{&lt;/span&gt;name&lt;span class=&quot;inline-delimiter&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt; = 5&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; }

  &lt;span class=&quot;comment&quot;&gt;# define the go_forward method&lt;/span&gt;
  eval &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;def go_forward; &lt;/span&gt;&lt;span class=&quot;inline&quot;&gt;&lt;span class=&quot;inline-delimiter&quot;&gt;#{&lt;/span&gt;ivars.join(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;; &lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;inline-delimiter&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt; end&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;

  &lt;span class=&quot;comment&quot;&gt;# define the go_backward method&lt;/span&gt;
  eval &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;def go_backward; &lt;/span&gt;&lt;span class=&quot;inline&quot;&gt;&lt;span class=&quot;inline-delimiter&quot;&gt;#{&lt;/span&gt;ivars.reverse.join(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;; &lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;)&lt;span class=&quot;inline-delimiter&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt; end&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Heat&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;true&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;predefined-constant&quot;&gt;ARGV&lt;/span&gt;[&lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;]
  &lt;span class=&quot;integer&quot;&gt;1000&lt;/span&gt;.times { &lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;false&lt;/span&gt; }
&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;
  &lt;span class=&quot;integer&quot;&gt;1000&lt;/span&gt;.times { &lt;span class=&quot;constant&quot;&gt;Foo&lt;/span&gt;.new &lt;span class=&quot;predefined-constant&quot;&gt;true&lt;/span&gt; }
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Here I&amp;rsquo;ve rewritten the benchmark so that we can control the direction via an
environment variable.  Let&amp;rsquo;s use &lt;code&gt;dtrace&lt;/code&gt; to measure the number of calls to
&lt;code&gt;realloc&lt;/code&gt; in both situations.&lt;/p&gt;

&lt;p&gt;This case is always going forward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo dtrace -q -n 'pid$target::realloc:entry { @ = count(); }' -c &quot;/Users/aaron/.rbenv/versions/ruby-trunk/bin/ruby thing.rb&quot;
dtrace: system integrity protection is on, some features will not be available


             8369
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This case is forward once, then reverse the rest of the time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo dtrace -q -n 'pid$target::realloc:entry { @ = count(); }' -c &quot;/Users/aaron/.rbenv/versions/ruby-trunk/bin/ruby thing.rb reverse&quot;
dtrace: system integrity protection is on, some features will not be available


             4369
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see that &amp;ldquo;starting from the end&amp;rdquo; decreases the number of calls to
&lt;code&gt;realloc&lt;/code&gt; significantly.  These increased calls to &lt;code&gt;realloc&lt;/code&gt; are why it&amp;rsquo;s faster
to define our instance variables forward once, then backward the rest of the
time!&lt;/p&gt;

&lt;p&gt;I hope this was an interesting article.  Please have a good day!&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2018/02/12/speeding-up-ruby-with-shared-strings.html</id>
      <title>Speeding up Ruby with Shared Strings</title>
      <updated>2018-02-12T10:00:00-08:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2018/02/12/speeding-up-ruby-with-shared-strings.html">

      <published>2018-02-12T10:00:00-08:00</published>
      <content type="html">&lt;p&gt;It&amp;rsquo;s not often I am able to write a patch that not only reduces memory usage,
but increases speed as well.  Usually I find myself trading memory for speed, so
it&amp;rsquo;s a real treat when I can improve both in one patch.  Today I want to talk
about the patch I submitted to Ruby in &lt;a href=&quot;https://bugs.ruby-lang.org/issues/14460&quot;&gt;this ticket&lt;/a&gt;.
It decreases &amp;ldquo;after boot&amp;rdquo; memory usage of a Rails application by 4% and speeds
up &lt;code&gt;require&lt;/code&gt; by about 35%.&lt;/p&gt;

&lt;p&gt;When I was writing this patch, I was actually focusing on trying to reduce
memory usage.  It just happens that reducing memory usage also resulted in
faster runtime.  So really I wanted to title this post &amp;ldquo;Reducing Memory Usage in
Ruby&amp;rdquo;, but &lt;a href=&quot;/2018/01/23/reducing-memory-usage-in-ruby.html&quot;&gt;I already made a post with that title&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;shared-string-optimization&quot;&gt;Shared String Optimization&lt;/h2&gt;

&lt;p&gt;As I mentioned in previous posts, Ruby objects are limited to 40
bytes.  But a string can be much longer than 40 bytes, so how are they
stored?  If we look at &lt;a href=&quot;https://github.com/ruby/ruby/blob/b16eaf86324b000c4c349e072e15b97dde701e48/include/ruby/ruby.h#L956-L969&quot;&gt;the struct that represents strings&lt;/a&gt;, we&amp;rsquo;ll find there is a &lt;code&gt;char *&lt;/code&gt; pointer:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; RString {
    &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; RBasic basic;
    &lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; {
        &lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; {
            &lt;span class=&quot;predefined-type&quot;&gt;long&lt;/span&gt; len;
            &lt;span class=&quot;predefined-type&quot;&gt;char&lt;/span&gt; *ptr;
            &lt;span class=&quot;keyword&quot;&gt;union&lt;/span&gt; {
                &lt;span class=&quot;predefined-type&quot;&gt;long&lt;/span&gt; capa;
                VALUE shared;
            } aux;
        } heap;
        &lt;span class=&quot;predefined-type&quot;&gt;char&lt;/span&gt; ary[RSTRING_EMBED_LEN_MAX + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;];
    } as;
};
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;ptr&lt;/code&gt; field in the string struct points to a byte array which is our string.
So the actual memory usage of a string is approximately 40 bytes for the object,
plus however long the string is.  If we were to visualize the layout, it would
look something like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/string_layout.png&quot; alt=&quot;RString pointing to char array&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In this case, there are really two allocations: the &lt;code&gt;RString&lt;/code&gt; object and the
&amp;ldquo;hello world&amp;rdquo; character array.  The &lt;code&gt;RString&lt;/code&gt; object is the 40 byte Ruby object
allocated using the GC, and the character array was allocated using the system&amp;rsquo;s
&lt;code&gt;malloc&lt;/code&gt; implementation.&lt;/p&gt;

&lt;p&gt;Side note: There is another optimization called &amp;ldquo;embedding&amp;rdquo;.  Without getting
too far off track, &amp;ldquo;embedding&amp;rdquo; is just keeping strings that are &amp;ldquo;small enough&amp;rdquo;
stored directly inside the &lt;code&gt;RString&lt;/code&gt; structure.  We can talk about that in a
different post, but today pretend there are always two distinct allocations.&lt;/p&gt;

&lt;p&gt;We can take advantage of this character array and represent substrings by just
pointing at a different location.  For example, we can have two Ruby objects,
one representing the string &amp;ldquo;hello world&amp;rdquo; and the other representing the string
&amp;ldquo;world&amp;rdquo; and only allocate one character array buffer:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/string_layout_shared.png&quot; alt=&quot;RStrings sharing a char array&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This example only has 3 allocations: 2 from the GC for the Ruby string objects,
and one &lt;code&gt;malloc&lt;/code&gt; for the character array.  Using &lt;code&gt;ObjectSpace&lt;/code&gt;, we can actually
observe this optimization by measuring memory size of the objects after slicing
them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; require 'objspace'
=&amp;gt; true
&amp;gt;&amp;gt; str = &quot;x&quot; * 9000; nil
=&amp;gt; nil
&amp;gt;&amp;gt; ObjectSpace.memsize_of str
=&amp;gt; 9041
&amp;gt;&amp;gt; substr = str[30, str.length - 30]; nil
=&amp;gt; nil
&amp;gt;&amp;gt; str.length
=&amp;gt; 9000
&amp;gt;&amp;gt; substr.length
=&amp;gt; 8970
&amp;gt;&amp;gt; ObjectSpace.memsize_of substr
=&amp;gt; 40
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The example above first allocates a string that is 9000 characters.  Next we
measure the memory size of the string.  The total size is 9000 for the
characters, plus some overhead for the Ruby object for a total of 9041.  Next we
take a substring, slicing off the first 30 characters of the original.  As
expected, the original string is 9000 characters, and the substring is 8970.
However, if we measure the size of the substring it is only 40 bytes!  This is
because the new string only requires a new Ruby object to be allocated, and the
new object just points at a different location in the original string&amp;rsquo;s
character buffer, just like the graph above showed.&lt;/p&gt;

&lt;p&gt;This optimization isn&amp;rsquo;t limited to just strings, we can use it with arrays too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; list = [&quot;x&quot;] * 9000; nil
=&amp;gt; nil
&amp;gt;&amp;gt; ObjectSpace.memsize_of(list)
=&amp;gt; 72040
&amp;gt;&amp;gt; list2 = list[30, list.length - 30]; nil
=&amp;gt; nil
&amp;gt;&amp;gt; ObjectSpace.memsize_of(list2)
=&amp;gt; 40
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, functional languages where data structures are immutable can take great
advantage of this optimization.  In languages that allow mutations, we have to
deal with the case that the original string might be mutated, where languages
with immutable data structures can be even more aggressive about optimization.&lt;/p&gt;

&lt;h2 id=&quot;limits-of-the-shared-string-optimization&quot;&gt;Limits of the Shared String Optimization&lt;/h2&gt;

&lt;p&gt;This shared string optimization isn&amp;rsquo;t without limits though.  To take advantage
of this optimization, we have to always &lt;em&gt;go to the end of the string&lt;/em&gt;.  In other
words, we can&amp;rsquo;t take a slice from the middle of the string and get the
optimization.  Lets take our sample string and slice 15 characters off each side
and see what the memsize is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; str = &quot;x&quot; * 9000; nil
=&amp;gt; nil
&amp;gt;&amp;gt; str.length
=&amp;gt; 9000
&amp;gt;&amp;gt; substr = str[15, str.length - 30]; nil
=&amp;gt; nil
&amp;gt;&amp;gt; substr.length
=&amp;gt; 8970
&amp;gt;&amp;gt; ObjectSpace.memsize_of(substr)
=&amp;gt; 9011
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can see in the above example that the memsize of the substring is much larger
than in the first example.  That is because Ruby had to create a new buffer to
store the substring.  So our lesson here is: if you have to slice strings, start
from the left and go all the way to the end.&lt;/p&gt;

&lt;p&gt;Here is an interesting thing to think about.  At the end of the following
program, what is the memsize of &lt;code&gt;substr&lt;/code&gt;?  How much memory is this program
actually consuming?  Is the &lt;code&gt;str&lt;/code&gt; object still alive, and how can we find out?&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;objspace&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;

str = &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;9000&lt;/span&gt;
substr = str[&lt;span class=&quot;integer&quot;&gt;30&lt;/span&gt;, str.length - &lt;span class=&quot;integer&quot;&gt;30&lt;/span&gt;]
str = &lt;span class=&quot;predefined-constant&quot;&gt;nil&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;GC&lt;/span&gt;.start

&lt;span class=&quot;comment&quot;&gt;# What is the memsize of substr?&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# How much memory is this program actually consuming?&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# Is `str` still alive even though we did a GC?&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# Hint: use `ObjectSpace.dump_all`&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# (if you try this out, I recommend running the program with `--disable-gems`)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The optimization I explained above works exactly the same way for strings in C
as it does in Ruby.  We will use this optimization to reduce memory usage and
speed up &lt;code&gt;require&lt;/code&gt; in Ruby.&lt;/p&gt;

&lt;h2 id=&quot;reducing-memory-usage-and-speeding-up-require&quot;&gt;Reducing Memory Usage and Speeding Up &lt;code&gt;require&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve already described the technique we&amp;rsquo;re going to use to speed up &lt;code&gt;require&lt;/code&gt;,
so lets take a look at the problem.  After that, we&amp;rsquo;ll apply the shared string
optimization to improve performance of &lt;code&gt;require&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Every time a program requires a file, Ruby has to check to see if that file has
already been required.  The global variable &lt;code&gt;$LOADED_FEATURES&lt;/code&gt; is a list of all
the files that have been required so far.  Of course, searching through a list
for a file would be quite slow and get slower as the list grows, so Ruby keeps a
hash to look up entries in the &lt;code&gt;$LOADED_FEATURES&lt;/code&gt; list.  This hash is called the
&lt;code&gt;loaded_features_index&lt;/code&gt;, and it&amp;rsquo;s stored on the virtual machine structure
&lt;a href=&quot;https://github.com/ruby/ruby/blob/b16eaf86324b000c4c349e072e15b97dde701e48/vm_core.h#L563&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The keys of this hash are strings that could be passed to &lt;code&gt;require&lt;/code&gt; to require a
particular file, and the value is the index in the &lt;code&gt;$LOADED_FEATURES&lt;/code&gt; array of
the file that actually got required.  So, for example if you have a file on your
system: &lt;code&gt;/a/b/c.rb&lt;/code&gt;, the keys to the hash will be:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&amp;ldquo;/a/b/c.rb&amp;rdquo;&lt;/li&gt;
  &lt;li&gt;&amp;ldquo;a/b/c.rb&amp;rdquo;&lt;/li&gt;
  &lt;li&gt;&amp;ldquo;b/c.rb&amp;rdquo;&lt;/li&gt;
  &lt;li&gt;&amp;ldquo;c.rb&amp;rdquo;&lt;/li&gt;
  &lt;li&gt;&amp;ldquo;/a/b/c&amp;rdquo;&lt;/li&gt;
  &lt;li&gt;&amp;ldquo;a/b/c&amp;rdquo;&lt;/li&gt;
  &lt;li&gt;&amp;ldquo;b/c&amp;rdquo;&lt;/li&gt;
  &lt;li&gt;&amp;ldquo;c&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given a well crafted load path, any of the strings above &lt;em&gt;could&lt;/em&gt; be used to load
the &lt;code&gt;/a/b/c.rb&lt;/code&gt; file, so the index needs to keep all of them.  For example, you
could do &lt;code&gt;ruby -I / -e&quot;require 'a/b/c'&quot;&lt;/code&gt;, or &lt;code&gt;ruby -I /a -e&quot;require 'b/c'&quot;'&lt;/code&gt;,
etc, and they all point to the same file.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;loaded_features_index&lt;/code&gt; hash is built in the &lt;a href=&quot;https://github.com/ruby/ruby/blob/b16eaf86324b000c4c349e072e15b97dde701e48/load.c#L215-L255&quot;&gt;&lt;code&gt;features_index_add&lt;/code&gt;
function&lt;/a&gt;.
Lets pick apart this function a little.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;directive&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;directive&quot;&gt;void&lt;/span&gt;
features_index_add(VALUE feature, VALUE offset)
{
    VALUE short_feature;
    &lt;span class=&quot;directive&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;predefined-type&quot;&gt;char&lt;/span&gt; *feature_str, *feature_end, *ext, *p;

    feature_str = StringValuePtr(feature);
    feature_end = feature_str + RSTRING_LEN(feature);

    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (ext = feature_end; ext &amp;gt; feature_str; ext--)
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (*ext == &lt;span class=&quot;char&quot;&gt;'.'&lt;/span&gt; || *ext == &lt;span class=&quot;char&quot;&gt;'/'&lt;/span&gt;)
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (*ext != &lt;span class=&quot;char&quot;&gt;'.'&lt;/span&gt;)
        ext = &lt;span class=&quot;predefined-constant&quot;&gt;NULL&lt;/span&gt;;
    &lt;span class=&quot;comment&quot;&gt;/* Now `ext` points to the only string matching %r{^\.[^./]*$} that is
       at the end of `feature`, or is NULL if there is no such string. */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;This function takes a &lt;code&gt;feature&lt;/code&gt; and an &lt;code&gt;offset&lt;/code&gt; as parameters.  The &lt;code&gt;feature&lt;/code&gt; is
the full name of the file that was required, extension and everything.  &lt;code&gt;offset&lt;/code&gt;
is the index in the loaded features list where this string is.  The first part
of this function starts at the end of the string and scans backwards looking for
a period or a forward slash.  If it finds a period, we know the file has an
extension (it is possible to require a Ruby file without an extension!), if it
finds a forward slash, it gives up and assumes there is no extension.&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;) {
        &lt;span class=&quot;predefined-type&quot;&gt;long&lt;/span&gt; beg;

        p--;
        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (p &amp;gt;= feature_str &amp;amp;&amp;amp; *p != &lt;span class=&quot;char&quot;&gt;'/'&lt;/span&gt;)
            p--;
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (p &amp;lt; feature_str)
            &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
        &lt;span class=&quot;comment&quot;&gt;/* Now *p == '/'.  We reach this point for every '/' in `feature`. */&lt;/span&gt;
        beg = p + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt; - feature_str;
        short_feature = rb_str_subseq(feature, beg, feature_end - p - &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;);
        features_index_add_single(short_feature, offset);
        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ext) {
            short_feature = rb_str_subseq(feature, beg, ext - p - &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;);
            features_index_add_single(short_feature, offset);
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Next we scan backwards in the string looking for forward slashes.  Every time
 it finds a forward slash, it uses &lt;code&gt;rb_str_subseq&lt;/code&gt; to get a substring and then
 calls &lt;code&gt;features_index_add_single&lt;/code&gt; to register that substring.  &lt;code&gt;rb_str_subseq&lt;/code&gt;
 gets substrings in the same way we were doing above in Ruby, and applies the
 same optimizations.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;if (ext)&lt;/code&gt; conditional deals with files that have an extension, and this is
 really where our problems begin.  This conditional gets a substring of
 &lt;code&gt;feature&lt;/code&gt;, but &lt;em&gt;it doesn&amp;rsquo;t go all the way to the end of the string&lt;/em&gt;.  It must
 exclude the file extension.  This means it will &lt;strong&gt;copy&lt;/strong&gt; the underlying string.
 So these two calls to &lt;code&gt;rb_str_subseq&lt;/code&gt; do 3 allocations total: 2 Ruby objects
 (the function returns a Ruby object) and one malloc to copy the string for the
 &amp;ldquo;no extension substring&amp;rdquo; case.&lt;/p&gt;

&lt;p&gt;This function calls &lt;code&gt;features_index_add_single&lt;/code&gt; to add the substring to the
 index.  I want to call out one excerpt from &lt;a href=&quot;https://github.com/ruby/ruby/blob/b16eaf86324b000c4c349e072e15b97dde701e48/load.c#L175-L205&quot;&gt;the &lt;code&gt;features_index_add_single&lt;/code&gt;
 function&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;    features_index = get_loaded_features_index_raw();
    st_lookup(features_index, (st_data_t)short_feature_cstr, (st_data_t *)&amp;amp;this_feature_index);

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (NIL_P(this_feature_index)) {
        st_insert(features_index, (st_data_t)ruby_strdup(short_feature_cstr), (st_data_t)offset);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;This code looks up the string in the index, and if the string isn&amp;rsquo;t in the
index, it adds it to the index.  The caller allocated a new Ruby
string, and that string could get garbage collected, so this function calls
&lt;code&gt;ruby_strdup&lt;/code&gt; to copy the string for the hash key.  It&amp;rsquo;s important to note that the
keys to this hash &lt;strong&gt;aren&amp;rsquo;t&lt;/strong&gt; Ruby objects, but &lt;code&gt;char *&lt;/code&gt; pointers that came from
Ruby objects (the &lt;code&gt;char *ptr&lt;/code&gt; field that we were looking at earlier).&lt;/p&gt;

&lt;p&gt;Lets count the allocations.  So far, we have 2 Ruby objects: one with a file
extension and one without, 1 malloc for the non-sharable substring, then 2 more
mallocs to copy the string in to the hash.  So each iteration of the while loop
in &lt;code&gt;features_index_add&lt;/code&gt; will do 5 allocations: 2 Ruby objects, and 3 mallocs.&lt;/p&gt;

&lt;p&gt;In cases like this, a picture might help explain better.  Below is a diagram of
the allocated memory and how they relate to each other.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/index-trunk.png&quot; alt=&quot;Allocations on Trunk&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This diagram shows what the memory layout looks like when adding the path
&lt;code&gt;/a/b/c.rb&lt;/code&gt; to the index, resulting in 8 hash entries.&lt;/p&gt;

&lt;p&gt;Blue nodes are allocations that were alive before the call to add the path to
the index.  Red nodes are intermediate allocations done while populating the
index, and will be freed at some point.  Black nodes are allocations made while
adding the path to the index but live &lt;em&gt;after&lt;/em&gt; we&amp;rsquo;ve finished adding the path to
the index.  Solid arrows represent actual references, where dotted lines
indicate a relationship but not actually a reference (like one string was
&lt;code&gt;ruby_strdup&lt;/code&gt;&amp;lsquo;d from another).&lt;/p&gt;

&lt;p&gt;The graph has lots of nodes and is very complicated, but we will clean it up!&lt;/p&gt;

&lt;h2 id=&quot;applying-the-shared-string-optimization&quot;&gt;Applying the Shared String Optimization&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve translated the C code to Ruby code so that we can more easily see the
optimization at work:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;global-variable&quot;&gt;$features_index&lt;/span&gt; = {}

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;features_index_add&lt;/span&gt;(feature, index)
  ext = feature.index(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)
  p = ext ? ext : feature.length

  loop &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
    p -= &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; p &amp;gt; &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; feature[p] != &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
      p -= &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; p == &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;

    short_feature = feature[p + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;, feature.length - p - &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;# New Ruby Object&lt;/span&gt;
    features_index_add_single(short_feature, index)

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ext &lt;span class=&quot;comment&quot;&gt;# slice out the file extension if there is one&lt;/span&gt;
      short_feature = feature[p + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;, ext - p - &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;# New Ruby Object + malloc&lt;/span&gt;
      features_index_add_single(short_feature, index)
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;features_index_add_single&lt;/span&gt;(str, index)
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;global-variable&quot;&gt;$features_index&lt;/span&gt;.key?(str)

  &lt;span class=&quot;global-variable&quot;&gt;$features_index&lt;/span&gt;[str.dup] = index &lt;span class=&quot;comment&quot;&gt;# malloc&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

features_index_add &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;/a/b/c.rb&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;As we already learned, the shared string optimization only works when the
substrings include the end of the shared string.  That is, we can only take
substrings from the left side of the string.&lt;/p&gt;

&lt;p&gt;The first change we can make is to split the strings in to two cases: one with
an extension, and one without.  Since the &amp;ldquo;no extension&amp;rdquo; if statement &lt;strong&gt;does
not&lt;/strong&gt; scan to the end of the string, it always allocates a new string.  If we
make a new string that doesn&amp;rsquo;t contain the extension, then we can eliminate one
of the malloc cases:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;global-variable&quot;&gt;$features_index&lt;/span&gt; = {}

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;features_index_add&lt;/span&gt;(feature, index)
  no_ext_feature = &lt;span class=&quot;predefined-constant&quot;&gt;nil&lt;/span&gt;
  p              = feature.length
  ext            = feature.index(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;)

  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ext
    p = ext
    no_ext_feature = feature[&lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, ext] &lt;span class=&quot;comment&quot;&gt;# New Ruby Object + malloc&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  loop &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
    p -= &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; p &amp;gt; &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; feature[p] != &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
      p -= &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; p == &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;

    short_feature = feature[p + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;, feature.length - p - &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;# New Ruby Object&lt;/span&gt;
    features_index_add_single(short_feature, index)

    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ext
      len = no_ext_feature.length
      short_feature = no_ext_feature[p + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;, len - p - &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;] &lt;span class=&quot;comment&quot;&gt;# New Ruby Object&lt;/span&gt;
      features_index_add_single(short_feature, index)
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;features_index_add_single&lt;/span&gt;(str, index)
  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;global-variable&quot;&gt;$features_index&lt;/span&gt;.key?(str)

  &lt;span class=&quot;global-variable&quot;&gt;$features_index&lt;/span&gt;[str.dup] = index &lt;span class=&quot;comment&quot;&gt;# malloc&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

features_index_add &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;/a/b/c.rb&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;This changes the function to allocate one new string, but always scan to the end
of both strings.  Now we have two strings that we can use to &amp;ldquo;scan from the
left&amp;rdquo;, we&amp;rsquo;re able to avoid new substring mallocs in the loop.  You can see this
change, where I allocate a new string &lt;em&gt;without&lt;/em&gt; an extension
&lt;a href=&quot;https://github.com/github/ruby/commit/bec1637da7fc5bafd9c91ba6443ad38c29ec656f#diff-8962f5c4e82fc86da33bb950a9147069L232&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Below is a graph of what the memory layout and relationships look like after
pulling up one slice, then sharing the string:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/index-new-slice.png&quot; alt=&quot;Allocations after shared slice&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can see from this graph that we were able to eliminate string buffers by
allocating the &amp;ldquo;extensionless&amp;rdquo; substring first, then taking slices from it.&lt;/p&gt;

&lt;p&gt;There are two more optimizations I applied in this patch.  Unfortunately they
are specific to the C language and not easy to explain using Ruby.&lt;/p&gt;

&lt;h2 id=&quot;eliminating-ruby-object-allocations&quot;&gt;Eliminating Ruby Object Allocations&lt;/h2&gt;

&lt;p&gt;The existing code uses Ruby to slice strings.  This allocates a new Ruby object.
Now that we have two strings, we can always take substrings from the left, and
that means we can use pointers in C to &amp;ldquo;create&amp;rdquo; substrings.  Rather than asking
Ruby APIs to slice the string for us, we simply use a pointer in C to point at
where we want the substring to start.  The hash table that maintains the index
uses C strings as keys, so instead of passing Ruby objects around, we&amp;rsquo;ll just
pass a pointer in to the string:&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line delete&quot;&gt;&lt;span class=&quot;delete&quot;&gt;-&lt;/span&gt;       short_feature = rb_str_subseq(feature, beg, feature_end - p - 1);&lt;/span&gt;
&lt;span class=&quot;line delete&quot;&gt;&lt;span class=&quot;delete&quot;&gt;-&lt;/span&gt;       features_index_add_single(short_feature, offset);&lt;/span&gt;
&lt;span class=&quot;line insert&quot;&gt;&lt;span class=&quot;insert&quot;&gt;+&lt;/span&gt;       features_index_add_single(feature_str + beg, offset);&lt;/span&gt;
        if (ext) {
&lt;span class=&quot;line delete&quot;&gt;&lt;span class=&quot;delete&quot;&gt;-&lt;/span&gt;           short_feature = rb_str_subseq(feature, beg, ext - p - 1);&lt;/span&gt;
&lt;span class=&quot;line delete&quot;&gt;&lt;span class=&quot;delete&quot;&gt;-&lt;/span&gt;           features_index_add_single(short_feature, offset);&lt;/span&gt;
&lt;span class=&quot;line insert&quot;&gt;&lt;span class=&quot;insert&quot;&gt;+&lt;/span&gt;           features_index_add_single(feature_no_ext_str + beg, offset);&lt;/span&gt;
        }
     }
&lt;span class=&quot;line delete&quot;&gt;&lt;span class=&quot;delete&quot;&gt;-&lt;/span&gt;    features_index_add_single(feature, offset);&lt;/span&gt;
&lt;span class=&quot;line insert&quot;&gt;&lt;span class=&quot;insert&quot;&gt;+&lt;/span&gt;    features_index_add_single(feature&lt;span class=&quot;eyecatcher&quot;&gt;_str&lt;/span&gt;, offset);&lt;/span&gt;
     if (ext) {
&lt;span class=&quot;line delete&quot;&gt;&lt;span class=&quot;delete&quot;&gt;-&lt;/span&gt;       short_feature = rb_str_subseq(feature, 0, ext - feature_str);&lt;/span&gt;
&lt;span class=&quot;line delete&quot;&gt;&lt;span class=&quot;delete&quot;&gt;-&lt;/span&gt;       features_index_add_single(short_feature, offset);&lt;/span&gt;
&lt;span class=&quot;line insert&quot;&gt;&lt;span class=&quot;insert&quot;&gt;+&lt;/span&gt;       features_index_add_single(feature_no_ext_str, offset);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;In this case, using a pointer in to the string simplifies our code.
&lt;code&gt;feature_str&lt;/code&gt; is a pointer to the head of the string that &lt;em&gt;has&lt;/em&gt; a file
extension, and &lt;code&gt;feature_no_ext_str&lt;/code&gt; is a pointer to the head of the string that
&lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; have a file extension.  &lt;code&gt;beg&lt;/code&gt; is the number of characters from the
head of the string where we want to slice.  All we have to do now is just add
&lt;code&gt;beg&lt;/code&gt; to the head of each pointer and pass that to &lt;code&gt;features_index_add_single&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In this graph you can see we no longer need the intermediate Ruby objects
because the &amp;ldquo;add single&amp;rdquo; function directly accesses the underlying &lt;code&gt;char *&lt;/code&gt;
pointer:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/slice-then-ptr.png&quot; alt=&quot;Allocations after pointer substrings&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;eliminating-malloc-calls&quot;&gt;Eliminating malloc Calls&lt;/h2&gt;

&lt;p&gt;Finally, lets eliminate the &lt;code&gt;ruby_strdup&lt;/code&gt; calls.  As we covered earlier, new
Ruby strings could get allocated.  These Ruby strings would get free&amp;rsquo;d by the
garbage collector, so we had to call &lt;code&gt;ruby_strdup&lt;/code&gt; to keep a copy around inside
the index hash.  The &lt;code&gt;feature&lt;/code&gt; string passed in is also stored in the
&lt;code&gt;$LOADED_FEATURES&lt;/code&gt; global array, so there is no need to copy that string as the
array will prevent the GC from collecting it.  However, we created a new string
that does not have an extension, and that object could get collected.  If we can
prevent the GC from collecting &lt;em&gt;those&lt;/em&gt; strings, then we don&amp;rsquo;t need to copy
anything.&lt;/p&gt;

&lt;p&gt;To keep these new strings alive, I added an array to the virtual machine (the
virtual machine lives for the life of the process):&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;     vm-&amp;gt;loaded_features = rb_ary_new();
     vm-&amp;gt;loaded_features_snapshot = rb_ary_tmp_new(0);
     vm-&amp;gt;loaded_features_index = st_init_strtable();
&lt;span class=&quot;line insert&quot;&gt;&lt;span class=&quot;insert&quot;&gt;+&lt;/span&gt;    vm-&amp;gt;loaded_features_index_pool = rb_ary_new();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Then I add the new string to the array via &lt;code&gt;rb_ary_push&lt;/code&gt; right after allocation:&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line insert&quot;&gt;&lt;span class=&quot;insert&quot;&gt;+&lt;/span&gt;       short_feature_no_ext = rb_fstring(rb_str_freeze(rb_str_subseq(feature, 0, ext - feature_str)));&lt;/span&gt;
&lt;span class=&quot;line insert&quot;&gt;&lt;span class=&quot;insert&quot;&gt;+&lt;/span&gt;       feature_no_ext_str = StringValuePtr(short_feature_no_ext);&lt;/span&gt;
&lt;span class=&quot;line insert&quot;&gt;&lt;span class=&quot;insert&quot;&gt;+&lt;/span&gt;       rb_ary_push(get_loaded_features_index_pool_raw(), short_feature_no_ext);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Now all strings in the index hash are shared and kept alive.  This means we can
safely remove the &lt;code&gt;ruby_strdup&lt;/code&gt; without any strings getting free&amp;rsquo;d by the GC:&lt;/p&gt;

&lt;div class=&quot;language-diff highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;     if (NIL_P(this_feature_index)) {
&lt;span class=&quot;line delete&quot;&gt;&lt;span class=&quot;delete&quot;&gt;-&lt;/span&gt;       st_insert(features_index, (st_data_t)&lt;span class=&quot;eyecatcher&quot;&gt;ruby_strdup(short_feature_cstr)&lt;/span&gt;, (st_data_t)offset);&lt;/span&gt;
&lt;span class=&quot;line insert&quot;&gt;&lt;span class=&quot;insert&quot;&gt;+&lt;/span&gt;       st_insert(features_index, (st_data_t)&lt;span class=&quot;eyecatcher&quot;&gt;short_feature_cstr&lt;/span&gt;, (st_data_t)offset);&lt;/span&gt;
     }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;After this change, we don&amp;rsquo;t need to copy any memory because the hash keys can
point directly in to the underlying character array inside the Ruby string
object:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/hash-substrings.png&quot; alt=&quot;Use string indexes for keys&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This new algorithm does 2 allocations: one to create a &amp;ldquo;no extension&amp;rdquo; copy of
the original string, and one &lt;code&gt;RString&lt;/code&gt; object to wrap it.  The &amp;ldquo;loaded features
index pool&amp;rdquo; array keeps the newly created string from being garbage collected,
and now we can point directly in to the string arrays without needing to copy
the strings.&lt;/p&gt;

&lt;p&gt;For any file added to the &amp;ldquo;loaded features&amp;rdquo; array, we changed it from requiring
O(N) allocations (where N is the number of slashes in a string) to always
requiring only two allocations regardless of the number of slashes in the
string.&lt;/p&gt;

&lt;h2 id=&quot;end&quot;&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;By using shared strings I was able to eliminate over 76000 system calls during
the Rails boot process on a basic app, reduce the memory footprint by 4%, and
speed up &lt;code&gt;require&lt;/code&gt; by 35%.  Next week I will try to get some statistics from a
large application and see how well it performs there!&lt;/p&gt;

&lt;p&gt;Thanks for reading!&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2018/01/23/reducing-memory-usage-in-ruby.html</id>
      <title>Reducing Memory Usage in Ruby</title>
      <updated>2018-01-23T13:36:37-08:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2018/01/23/reducing-memory-usage-in-ruby.html">

      <published>2018-01-23T13:36:37-08:00</published>
      <content type="html">&lt;p&gt;I&amp;rsquo;ve been working on building a compacting garbage collector in Ruby for a
while now, and one of the biggest hurdles for implementing a compacting GC is
updating references.  For example, if Object A points to Object B, but the
compacting GC moves Object B, how do we make sure that Object A points to the
new location?&lt;/p&gt;

&lt;p&gt;Solving this problem has been fairly straight forward for most objects.  Ruby&amp;rsquo;s
garbage collector knows about the internals of most Ruby Objects, so after the
compactor runs, it just walks through all objects and updates their internals
to point at new locations for any moved objects.  If the GC &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; know
about the internals of some object (for example an Object implemented in a C
extension), it doesn&amp;rsquo;t allow things referred to by that object to move.  For
example, Object A points to Object B.  If the GC doesn&amp;rsquo;t know how to update the
internals of Object A, it won&amp;rsquo;t allow Object B to move (I call this &amp;ldquo;pinning&amp;rdquo;
an object).&lt;/p&gt;

&lt;p&gt;Of course, the more objects we allow to move, the better.&lt;/p&gt;

&lt;p&gt;Earlier I wrote that updating references for most objects is fairly straight
forward.  Unfortunately there has been one thorn in my side for a while, and
that has been Instruction Sequences.&lt;/p&gt;

&lt;h2 id=&quot;instruction-sequences&quot;&gt;Instruction Sequences&lt;/h2&gt;

&lt;p&gt;When your Ruby code is compiled, it is turned in to instruction sequence
objects, and those objects are Ruby objects.  Typically you don&amp;rsquo;t interact with
these Ruby objects, but they are there.  These objects store byte code for your
Ruby program, any literals in your code, and some other miscellaneous
information about the code that was compiled (source location, coverage info,
etc).&lt;/p&gt;

&lt;p&gt;Internally, these instruction sequence objects are referred to as &amp;ldquo;IMEMO&amp;rdquo;
objects.  There are multiple sub-types of IMEMO objects, and the instruction
sequence sub-type is &amp;ldquo;iseq&amp;rdquo;.  If you are using Ruby 2.5, and you dump the heap
using &lt;code&gt;ObjectSpace&lt;/code&gt;, you&amp;rsquo;ll see the dump now contains these IMEMO subtypes.
Lets look at an example.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve been using the following code to dump the heap in a Rails application:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;objspace&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;config/environment&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;File&lt;/span&gt;.open(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;output.txt&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |f|
  &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.dump_all(&lt;span class=&quot;key&quot;&gt;output&lt;/span&gt;: f)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The above code outputs all objects in memory to a file called &amp;ldquo;output.txt&amp;rdquo; in &lt;a href=&quot;http://jsonlines.org&quot;&gt;JSON lines&lt;/a&gt; format.
Here are a couple IMEMO records from a Rails heap dump:&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;{
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;0x7fc89d00c400&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;IMEMO&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;0x7fc89e95c130&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;imemo_type&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;ment&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;memsize&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;integer&quot;&gt;40&lt;/span&gt;,
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: {
    &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;wb_protected&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;value&quot;&gt;true&lt;/span&gt;,
    &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;value&quot;&gt;true&lt;/span&gt;,
    &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;uncollectible&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;value&quot;&gt;true&lt;/span&gt;,
    &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;marked&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;value&quot;&gt;true&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;language-json highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;{
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;0x7fc89d00c2e8&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;IMEMO&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;imemo_type&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;iseq&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;references&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: [
    &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;0x7fc89d00c270&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;0x7fc89e989a68&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;0x7fc89e989a68&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;,
    &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;0x7fc89d00ef48&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  ],
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;memsize&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;integer&quot;&gt;40&lt;/span&gt;,
  &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: {
    &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;wb_protected&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;value&quot;&gt;true&lt;/span&gt;,
    &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;old&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;value&quot;&gt;true&lt;/span&gt;,
    &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;uncollectible&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;value&quot;&gt;true&lt;/span&gt;,
    &lt;span class=&quot;key&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;marked&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;: &lt;span class=&quot;value&quot;&gt;true&lt;/span&gt;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;This example came from Ruby 2.5, so both records contain an &lt;code&gt;imemo_type&lt;/code&gt; field.
The first example is a &amp;ldquo;ment&amp;rdquo; or &amp;ldquo;method entry&amp;rdquo;, and the second example is an
&amp;ldquo;iseq&amp;rdquo; or an &amp;ldquo;instruction sequence&amp;rdquo;.  Today we&amp;rsquo;ll look at instruction
sequences.&lt;/p&gt;

&lt;h2 id=&quot;format-of-instruction-sequence&quot;&gt;Format of Instruction Sequence&lt;/h2&gt;

&lt;p&gt;The instruction sequences are the result of compiling our Ruby code.  The
instruction sequences are a binary representation of our Ruby code.  These
instructions are stored on the instruction sequence object, specifically &lt;a href=&quot;https://github.com/ruby/ruby/blob/36d91068ed9297cb792735f93f31d0bf186afeec/vm_core.h#L309&quot;&gt;this
&lt;code&gt;iseq_encoded&lt;/code&gt; field&lt;/a&gt; (&lt;code&gt;iseq_size&lt;/code&gt; is the length of the &lt;code&gt;iseq_encoded&lt;/code&gt; field).&lt;/p&gt;

&lt;p&gt;If you were to examine &lt;code&gt;iseq_encoded&lt;/code&gt;, you&amp;rsquo;ll find it&amp;rsquo;s just a list of numbers.
The list of numbers is virtual machine instructions as well as parameters
(operands) for the instructions.&lt;/p&gt;

&lt;p&gt;If we examine the &lt;code&gt;iseq_encoded&lt;/code&gt; list, it might look something like this:&lt;/p&gt;

&lt;table class=&quot;table&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;&amp;nbsp;&lt;/th&gt;
      &lt;th&gt;Address&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0x00000001001cddad&lt;/td&gt;
      &lt;td&gt;Instruction (0 operands)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0x00000001001cdeee&lt;/td&gt;
      &lt;td&gt;Instruction (2 operands)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;0x00000001001cdf1e&lt;/td&gt;
      &lt;td&gt;Operand&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0x000000010184c400&lt;/td&gt;
      &lt;td&gt;Operand&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;0x00000001001cdeee&lt;/td&gt;
      &lt;td&gt;Instruction (2 operands)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;0x00000001001c8040&lt;/td&gt;
      &lt;td&gt;Operand&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;0x0000000100609e40&lt;/td&gt;
      &lt;td&gt;Operand&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;0x0000000100743d10&lt;/td&gt;
      &lt;td&gt;Instruction (1 operand)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;0x00000001001c8040&lt;/td&gt;
      &lt;td&gt;Operand&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;0x0000000100609e50&lt;/td&gt;
      &lt;td&gt;Instruction (1 operand)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;10&lt;/td&gt;
      &lt;td&gt;0x0000000100743d38&lt;/td&gt;
      &lt;td&gt;Operand&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Each element of the list corresponds to either an instruction, or the operands
for an instruction.  All of the operands for an instruction follow that
instruction in the list.  The operands are anything required for executing the
corresponding instruction, including Ruby objects.  In other words, some of
these addresses could be addresses for Ruby objects.&lt;/p&gt;

&lt;p&gt;Since some of these addresses could be Ruby objects, it means that instruction
sequences reference Ruby objects.  But, if instruction sequences reference Ruby
objects, how do the instruction sequences prevent those Ruby objects from
getting garbage collected?&lt;/p&gt;

&lt;h2 id=&quot;liveness-and-code-compilation&quot;&gt;Liveness and Code Compilation&lt;/h2&gt;

&lt;p&gt;As I said, instruction sequences are the result of compiling your Ruby code.
During compilation, some parts of your code are converted to Ruby objects and
then the addresses for those objects are embedded in the byte code.  Lets take
a look at an example of when a Ruby object will be embedded in instruction
sequences, then look at how those objects are kept alive.&lt;/p&gt;

&lt;p&gt;Our sample code is just going to be &lt;code&gt;puts &quot;hello world&quot;&lt;/code&gt;.  We can use &lt;code&gt;RubyVM::InstructionSequence&lt;/code&gt; to compile the code, then disassemble it.  Disassembly decodes &lt;code&gt;iseq_encoded&lt;/code&gt; and prints out something more readable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; insns = RubyVM::InstructionSequence.compile 'puts &quot;hello world&quot;'
=&amp;gt; &amp;lt;RubyVM::InstructionSequence:&amp;lt;compiled&amp;gt;@&amp;lt;compiled&amp;gt;&amp;gt;
&amp;gt;&amp;gt; puts insns.disasm
== disasm: #&amp;lt;ISeq:&amp;lt;compiled&amp;gt;@&amp;lt;compiled&amp;gt;&amp;gt;================================
0000 trace            1                                               (   1)
0002 putself          
0003 putstring        &quot;hello world&quot;
0005 opt_send_without_block &amp;lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SIMPLE&amp;gt;, &amp;lt;callcache&amp;gt;
0008 leave            
=&amp;gt; nil
&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instruction &lt;code&gt;003&lt;/code&gt; is the &lt;code&gt;putstring&lt;/code&gt; instruction.  Lets look at the definition
of the &lt;code&gt;putstring&lt;/code&gt; instruction &lt;a href=&quot;https://github.com/ruby/ruby/blob/36d91068ed9297cb792735f93f31d0bf186afeec/insns.def#L345-L353&quot;&gt;which can be found in &lt;code&gt;insns.def&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* put string val. string will be copied. */
DEFINE_INSN
putstring
(VALUE str)
()
(VALUE val)
{
    val = rb_str_resurrect(str);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the virtual machine executes, it will jump to the location of the
&lt;code&gt;putstring&lt;/code&gt; instruction, decode operands, and provide those operands to the
instruction.  In this case, the &lt;code&gt;putstring&lt;/code&gt; instruction has one operand called
&lt;code&gt;str&lt;/code&gt; which is of type &lt;code&gt;VALUE&lt;/code&gt;, and one return value called &lt;code&gt;val&lt;/code&gt; which is also
of type &lt;code&gt;VALUE&lt;/code&gt;.  The instruction body itself simply calls &lt;code&gt;rb_str_resurrect&lt;/code&gt;,
passing in &lt;code&gt;str&lt;/code&gt;, and assigning the return value to &lt;code&gt;val&lt;/code&gt;.  &lt;code&gt;rb_str_resurrect&lt;/code&gt;
&lt;a href=&quot;https://github.com/ruby/ruby/blob/36d91068ed9297cb792735f93f31d0bf186afeec/string.c#L1520-L1525&quot;&gt;just duplicates a Ruby string&lt;/a&gt;.
So this instruction takes a Ruby object (a string which has been stored in the
instruction sequences), duplicates that string, then the virtual machines
pushes that duplicated string on to the stack.  For a fun exercise, try going
through this process with &lt;code&gt;puts &quot;hello world&quot;.freeze&lt;/code&gt; and take a look at the
difference.&lt;/p&gt;

&lt;p&gt;Now, how does the string &amp;ldquo;hello world&amp;rdquo; stay alive until this instruction is
executed?  Something must mark the string object so the garbage collector knows
that a reference is being held.&lt;/p&gt;

&lt;p&gt;The way the instruction sequences keep these objects alive is through the use
of what it calls a &amp;ldquo;mark array&amp;rdquo;.  As the compiler converts your code in to
instruction sequences, it will allocate a string for &amp;ldquo;hello world&amp;rdquo;, then push
that string on to an array.  Here is an excerpt &lt;a href=&quot;https://github.com/ruby/ruby/blob/47d9ee39df63f0b87e041d46160e429eea19f3c6/compile.c#L2042-L2049&quot;&gt;from &lt;code&gt;compile.c&lt;/code&gt;&lt;/a&gt; that does this:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; TS_VALUE:    &lt;span class=&quot;comment&quot;&gt;/* VALUE */&lt;/span&gt;
{
    VALUE v = operands[j];
    generated_iseq[code_index + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt; + j] = v;
    &lt;span class=&quot;comment&quot;&gt;/* to mark ruby object */&lt;/span&gt;
    iseq_add_mark_object(iseq, v);
    &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;All &lt;code&gt;iseq_add_mark_object&lt;/code&gt; does is push the &lt;code&gt;VALUE&lt;/code&gt; on to an array which is
stored on the instruction sequence object.  &lt;code&gt;iseq&lt;/code&gt; is the instruction sequence
object, and &lt;code&gt;v&lt;/code&gt; is the &lt;code&gt;VALUE&lt;/code&gt; we want to keep alive (in this case the string
&amp;ldquo;hello world&amp;rdquo;).  If you look in &lt;code&gt;vm_core.h&lt;/code&gt;, you can &lt;a href=&quot;https://github.com/ruby/ruby/blob/47d9ee39df63f0b87e041d46160e429eea19f3c6/vm_core.h#L410&quot;&gt;find the location of that
mark array&lt;/a&gt; with a comment that says:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;VALUE mark_ary;     &lt;span class=&quot;comment&quot;&gt;/* Array: includes operands which should be GC marked */&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&quot;instruction-sequence-references-and-compaction&quot;&gt;Instruction Sequence References and Compaction&lt;/h2&gt;

&lt;p&gt;So, instruction sequences contain two references to a string literal: one in
the instructions in &lt;code&gt;iseq_encoded&lt;/code&gt;, and one via the mark array.  If the string
literal moves, then both locations will need to be updated.  Updating array
internals is fairly trivial: it&amp;rsquo;s just a list.  Updating instruction sequences
on the other hand is not so easy.&lt;/p&gt;

&lt;p&gt;To update references in the instruction sequences, we have to disassemble the
instructions, locate any &lt;code&gt;VALUE&lt;/code&gt; operands, and update those locations.  There
wasn&amp;rsquo;t any code to walk these instructions, so I introduced a
function that would &lt;a href=&quot;https://github.com/ruby/ruby/blob/36d91068ed9297cb792735f93f31d0bf186afeec/iseq.c#L170-L194&quot;&gt;disassemble instructions and call a function pointer with
those objects&lt;/a&gt;.
This allows us to find new locations of Ruby objects and update the
instructions.  But what if we could use this function for something more?&lt;/p&gt;

&lt;h2 id=&quot;reducing-memory&quot;&gt;Reducing Memory&lt;/h2&gt;

&lt;p&gt;Now we&amp;rsquo;re finally on to the part about saving memory.  The point of the mark
arrays stored on the instruction sequence objects is to keep any objects
referred to by instruction sequences alive:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/literal_marking.png&quot; alt=&quot;ISeq and Array marking paths&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can reuse the &amp;ldquo;update reference&amp;rdquo; function to mark references contained
directly in instruction sequences.  This means we can reduce the size of the
mark array:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/iseq_mark_literals.png&quot; alt=&quot;Mark Literals via disasm&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Completely eliminating the mark array is a different story as there are things
stored in the mark array that aren&amp;rsquo;t just literals.  However, if we directly
mark objects from the instruction sequences, then we rarely have to grow the
array.  The amount of memory we save is the size of the array &lt;a href=&quot;https://twitter.com/tenderlove/status/951204087382491136&quot;&gt;plus any unused
extra capacity in the array&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve made a patch that implements this strategy, and you can find it on the
&lt;a href=&quot;https://github.com/github/ruby/pull/39&quot;&gt;GitHub fork of Ruby&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I found that this saves approximately 3% memory on a basic Rails application
set to production mode.  Of course, the more code you load, the more memory you
save.  I expected the patch to impact GC performance because disassembling
instructions and iterating through them should be harder than just iterating an
array.  However, since instruction sequences get old, and we have a
generational garbage collector, the impact to real apps is very small.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m working to upstream this patch to Ruby, and you can follow along and read
more information about the analysis &lt;a href=&quot;https://bugs.ruby-lang.org/issues/14370&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Anyway, I hope you found this blurgh post informative, and please have a good
day!&lt;/p&gt;

&lt;p&gt;&amp;lt;3 &amp;lt;3 &amp;lt;3&lt;/p&gt;

&lt;p&gt;I want to give a huge thanks to &lt;a href=&quot;https://twitter.com/allie_p&quot;&gt;Allison McMillan&lt;/a&gt;.
Every week she&amp;rsquo;s been helping me figure out what is going on with this complex code.
I definitely recommend that you &lt;a href=&quot;https://twitter.com/allie_p&quot;&gt;follow her on Twitter&lt;/a&gt;.&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2017/09/27/visualizing-your-ruby-heap.html</id>
      <title>Visualizing Your Ruby Heap</title>
      <updated>2017-09-27T11:50:52-07:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2017/09/27/visualizing-your-ruby-heap.html">

      <published>2017-09-27T11:50:52-07:00</published>
      <content type="html">&lt;p&gt;In a previous post, I wrote a bit about how Ruby objects are laid out in memory.
Today we&amp;rsquo;ll use that information to write a program that will allow us to take
a Ruby heap dump and visualize the layout and fragmentation of that heap.&lt;/p&gt;

&lt;h2 id=&quot;ruby-object-layout-recap&quot;&gt;Ruby Object Layout Recap&lt;/h2&gt;

&lt;p&gt;Just as a recap, Ruby objects are fixed width.  That is, every Ruby object is
the same size: 40 bytes.  Objects are not really allocated with &lt;code&gt;malloc&lt;/code&gt;, but
instead they are placed inside of pages.&lt;/p&gt;

&lt;p&gt;A Ruby process has many pages.  Pages have many objects.&lt;/p&gt;

&lt;h2 id=&quot;which-page-does-this-object-belong-to&quot;&gt;Which Page Does This Object Belong To?&lt;/h2&gt;

&lt;p&gt;Objects are allocated in to a page.  Each page is 2 ^ 14th bytes.  In other
words, Ruby objects aren&amp;rsquo;t allocated one at a time, but the GC allocates one
page (also known as an &amp;ldquo;arena&amp;rdquo;), and when a new Ruby object is requested, it is
placed inside that page.&lt;/p&gt;

&lt;p&gt;Pages aren&amp;rsquo;t exactly 2 ^ 14 bytes.  When we allocate a page, we want that page
to be aligned with Operating System memory pages, so the total malloc&amp;rsquo;d size
needs to be some number less than a multiple of 4kb (which is the OS page size).
Since the &lt;code&gt;malloc&lt;/code&gt; system call has some overhead, we have to subtract some
some amount from the actual malloc&amp;rsquo;d size so that the Ruby page aligns and fits
on contiguous OS pages.  The padding size we use is &lt;code&gt;sizeof(size_t) * 5&lt;/code&gt;.  So
the size of a page is actually &lt;code&gt;(2 ^ 14) - (sizeof(size_t) * 5)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Each page has a header that contains some information about the page.  The size
of that header is &lt;code&gt;sizeof(void *)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This means the maximum number of Ruby objects that can be stored on a Ruby page
is &lt;code&gt;((2 ^ 14) - (sizeof(size_t) * 5) - sizeof(void *)) / 40&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Since the number of objects per page is bounded, we can apply a bitmask to the
bottom 14 bits (remember page sizes are 2 ^ 14, IOW 1 left shifted 14) of a
Ruby object address and calculate the page that object lives on.  That bitmask
is &lt;code&gt;~0 &amp;lt;&amp;lt; 14&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In ASCII art, say we have a Ruby object address &lt;code&gt;0x7fcc6c845108&lt;/code&gt;.  In binary:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;11111111100110001101100100001000101000100001000
^---------- page address --------^- object id ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;object id&amp;rdquo; in the above chart isn&amp;rsquo;t the traditional Ruby object id, it&amp;rsquo;s just
the part of the bits that represent that individual object on the page.  The
entire address is considered the traditional &amp;ldquo;object id&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Lets extract these numbers to some Ruby code:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;fiddle&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;SIZEOF_HEAP_PAGE_HEADER_STRUCT&lt;/span&gt; = &lt;span class=&quot;constant&quot;&gt;Fiddle&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;SIZEOF_VOIDP&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;SIZEOF_RVALUE&lt;/span&gt;           = &lt;span class=&quot;integer&quot;&gt;40&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_ALIGN_LOG&lt;/span&gt;     = &lt;span class=&quot;integer&quot;&gt;14&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_ALIGN&lt;/span&gt;         = &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_ALIGN_LOG&lt;/span&gt;      &lt;span class=&quot;comment&quot;&gt;# 2 ^ 14&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_ALIGN_MASK&lt;/span&gt;    = ~(~&lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_ALIGN_LOG&lt;/span&gt;)  &lt;span class=&quot;comment&quot;&gt;# Mask for getting page address&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;REQUIRED_SIZE_BY_MALLOC&lt;/span&gt; = &lt;span class=&quot;constant&quot;&gt;Fiddle&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;SIZEOF_SIZE_T&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;5&lt;/span&gt;     &lt;span class=&quot;comment&quot;&gt;# padding needed by malloc&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_SIZE&lt;/span&gt;          = &lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_ALIGN&lt;/span&gt; - &lt;span class=&quot;constant&quot;&gt;REQUIRED_SIZE_BY_MALLOC&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# Actual page size&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_OBJ_LIMIT&lt;/span&gt;     = (&lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_SIZE&lt;/span&gt; - &lt;span class=&quot;constant&quot;&gt;SIZEOF_HEAP_PAGE_HEADER_STRUCT&lt;/span&gt;) / &lt;span class=&quot;constant&quot;&gt;SIZEOF_RVALUE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;I mentioned this a little earlier, but I will be explicit here: Ruby pages are
allocated with aligned mallocs.  In other words, when a Ruby page is allocated
it&amp;rsquo;s allocated on an address that is divisible by  2 ^ 14, and the size of the
page is slightly smaller than 2 ^ 14.&lt;/p&gt;

&lt;p&gt;Lets write a function that, given an object address, returns the address of the
page where that object was placed:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;page_address_from_object_address&lt;/span&gt; object_address
  object_address &amp;amp; ~&lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_ALIGN_MASK&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Now lets print the page addresses for 3 object addresses:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;p page_address_from_object_address(&lt;span class=&quot;integer&quot;&gt;0x7fcc6c8367e8&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; 140515970596864&lt;/span&gt;
p page_address_from_object_address(&lt;span class=&quot;integer&quot;&gt;0x7fcc6c836838&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; 140515970596864&lt;/span&gt;
p page_address_from_object_address(&lt;span class=&quot;integer&quot;&gt;0x7fcc6c847b88&lt;/span&gt;) &lt;span class=&quot;comment&quot;&gt;# =&amp;gt; 140515970662400&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;We can see from the output that the first two objects live on the same page,
but the third object lives on a different page.&lt;/p&gt;

&lt;h3 id=&quot;how-many-objects-are-on-this-page&quot;&gt;How many objects are on this page?&lt;/h3&gt;

&lt;p&gt;Ruby objects are also aligned, but they are aligned &lt;em&gt;inside&lt;/em&gt; the existing page.
They are aligned at 40 bytes (which is also the size of the object).  That means
that every Ruby object address is guaranteed to be divisible by 40 (this
statement isn&amp;rsquo;t true for non heap allocated objects like numbers).&lt;/p&gt;

&lt;p&gt;Ruby objects are never allocated, but they are placed inside a page that has
been allocated.  The pages are aligned on 2 ^ 14, but not every number divisible
by 2 ^ 14 is also evenly divisible by 40.  That means some pages store more
objects than others.  Pages that are evenly divisible by 40 will store one more
object than objects that aren&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;Lets write a function that, given a page address, calculates the number of
objects it can store as well as where those object are placed, and returns an
object that represents the page information.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;constant&quot;&gt;Page&lt;/span&gt; = &lt;span class=&quot;constant&quot;&gt;Struct&lt;/span&gt;.new &lt;span class=&quot;symbol&quot;&gt;:address&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:obj_start_address&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:obj_count&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;page_info&lt;/span&gt; page_address
  limit = &lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_OBJ_LIMIT&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# Max number of objects per page&lt;/span&gt;

  &lt;span class=&quot;comment&quot;&gt;# Pages have a header with information, so we have to take that in to account&lt;/span&gt;
  obj_start_address = page_address + &lt;span class=&quot;constant&quot;&gt;SIZEOF_HEAP_PAGE_HEADER_STRUCT&lt;/span&gt;

  &lt;span class=&quot;comment&quot;&gt;# If the object start address isn't evenly divisible by the size of a&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;# Ruby object, we need to calculate the padding required to find the first&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;# address that is divisible by SIZEOF_RVALUE&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; obj_start_address % &lt;span class=&quot;constant&quot;&gt;SIZEOF_RVALUE&lt;/span&gt; != &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;
    delta = &lt;span class=&quot;constant&quot;&gt;SIZEOF_RVALUE&lt;/span&gt; - (obj_start_address % &lt;span class=&quot;constant&quot;&gt;SIZEOF_RVALUE&lt;/span&gt;)
    obj_start_address += delta &lt;span class=&quot;comment&quot;&gt;# Move forward to first address&lt;/span&gt;

    &lt;span class=&quot;comment&quot;&gt;# Calculate the number of objects this page can actually hold&lt;/span&gt;
    limit = (&lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_SIZE&lt;/span&gt; - (obj_start_address - page_address)) / &lt;span class=&quot;constant&quot;&gt;SIZEOF_RVALUE&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;constant&quot;&gt;Page&lt;/span&gt;.new page_address, obj_start_address, limit
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Now that we can get information about the page where the object is stored,
lets examine page information for the object addresses we were working with in
the previous example.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;page_address = page_address_from_object_address(&lt;span class=&quot;integer&quot;&gt;0x7fcc6c8367e8&lt;/span&gt;)
p page_info(page_address)
&lt;span class=&quot;comment&quot;&gt;# =&amp;gt; #&amp;lt;struct Page address=140515970596864, obj_start_address=140515970596880, obj_count=408&amp;gt;&lt;/span&gt;

page_address = page_address_from_object_address(&lt;span class=&quot;integer&quot;&gt;0x7fcc6c836838&lt;/span&gt;)
p page_info(page_address)
&lt;span class=&quot;comment&quot;&gt;# =&amp;gt; #&amp;lt;struct Page address=140515970596864, obj_start_address=140515970596880, obj_count=408&amp;gt;&lt;/span&gt;

page_address = page_address_from_object_address(&lt;span class=&quot;integer&quot;&gt;0x7fcc6c847b88&lt;/span&gt;)
p page_info(page_address)
&lt;span class=&quot;comment&quot;&gt;# =&amp;gt; #&amp;lt;struct Page address=140515970662400, obj_start_address=140515970662440, obj_count=407&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The first two objects live on the same page, and that page can store 408
objects.  The third object lives on a different page, and that page can only
store 407 objects.&lt;/p&gt;

&lt;p&gt;It may not seem like it, but we now have all of the key pieces of information
we need in order to visualize the contents of our heap.&lt;/p&gt;

&lt;h2 id=&quot;data-acquisition&quot;&gt;Data Acquisition&lt;/h2&gt;

&lt;p&gt;In order to visualize a heap, we actually need a heap to visualize.  I will use
&lt;code&gt;ObjectSpace&lt;/code&gt; to dump the heap to a JSON file, and we&amp;rsquo;ll used the code from
above along with a JSON parser and ChunkyPNG to generate a graph.&lt;/p&gt;

&lt;p&gt;Here is our test program:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;objspace&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;

x = &lt;span class=&quot;integer&quot;&gt;100000&lt;/span&gt;.times.map { &lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt;.new }
&lt;span class=&quot;constant&quot;&gt;GC&lt;/span&gt;.start
&lt;span class=&quot;constant&quot;&gt;File&lt;/span&gt;.open(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;heap.json&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;) { |f|
  &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.dump_all(&lt;span class=&quot;key&quot;&gt;output&lt;/span&gt;: f)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;All it does is allocate a bunch of objects, GC, then dump the heap to a JSON
file called &lt;code&gt;heap.json&lt;/code&gt;.  Each line in the JSON document is one object in the
Ruby heap.&lt;/p&gt;

&lt;p&gt;Now lets write a program to process the JSON file.  What we&amp;rsquo;ll do is change the
&lt;code&gt;Page&lt;/code&gt; class so that it can keep track of objects that are living on that page,
then iterate over the JSON document and add each object to its respective page.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Page&lt;/span&gt; &amp;lt; &lt;span class=&quot;constant&quot;&gt;Struct&lt;/span&gt;.new &lt;span class=&quot;symbol&quot;&gt;:address&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:obj_start_address&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:obj_count&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt; address, obj_start_address, obj_count
    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@live_objects&lt;/span&gt; = []
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;add_object&lt;/span&gt; address
    &lt;span class=&quot;instance-variable&quot;&gt;@live_objects&lt;/span&gt; &amp;lt;&amp;lt; address
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;comment&quot;&gt;# Keep track of pages&lt;/span&gt;
pages = {}

&lt;span class=&quot;constant&quot;&gt;File&lt;/span&gt;.open(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;heap.json&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |f|
  f.each_line &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |line|
    object = &lt;span class=&quot;constant&quot;&gt;JSON&lt;/span&gt;.load line

    &lt;span class=&quot;comment&quot;&gt;# Skip roots. I don't want to cover this today :)&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; object[&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;] != &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;ROOT&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
      &lt;span class=&quot;comment&quot;&gt;# The object addresses are stored as strings in base 16&lt;/span&gt;
      address      = object[&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;].to_i(&lt;span class=&quot;integer&quot;&gt;16&lt;/span&gt;)

      &lt;span class=&quot;comment&quot;&gt;# Get the address for the page&lt;/span&gt;
      page_address = page_address_from_object_address(address)

      &lt;span class=&quot;comment&quot;&gt;# Get the page, or make a new one&lt;/span&gt;
      page         = pages[page_address] ||= page_info(page_address)

      page.add_object address
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&quot;visualizing-the-heap&quot;&gt;Visualizing the Heap&lt;/h2&gt;

&lt;p&gt;So far our processing program has divided the objects up by which pages they
belong to.  Now it&amp;rsquo;s time to turn that data in to a visualization of the heap.
Unfortunately, we have one slight problem: the heap dump gave us information
about &lt;em&gt;live&lt;/em&gt; objects in the system.  How can we visualize empty spaces in the
heap?&lt;/p&gt;

&lt;p&gt;We have a few bits of information we can use to figure out where the empty
spots are in our heap.  First, we know that object addresses are divisible by
40.  Second, we know which address is the first address for storage
(&lt;code&gt;Page#obj_start_address&lt;/code&gt;).  Third, we know how many objects a page can store
(&lt;code&gt;Page#obj_count&lt;/code&gt;).  So if we start at &lt;code&gt;obj_start_address&lt;/code&gt;, and increment by
&lt;code&gt;SIZEOF_RVALUE&lt;/code&gt;, we should either find that we read that address from the JSON
file, or not.  If we read the address from the JSON file, we know it&amp;rsquo;s a live
object, if not, then it&amp;rsquo;s an empty slot.&lt;/p&gt;

&lt;p&gt;So lets add a method to the &lt;code&gt;Page&lt;/code&gt; object that iterates over the possible object
addresses on the page, and yields &lt;code&gt;:full&lt;/code&gt; if there is an object, or &lt;code&gt;:empty&lt;/code&gt; if
there is no object:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;Page&lt;/span&gt; &amp;lt; &lt;span class=&quot;constant&quot;&gt;Struct&lt;/span&gt;.new &lt;span class=&quot;symbol&quot;&gt;:address&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:obj_start_address&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:obj_count&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;each_slot&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; enum_for(&lt;span class=&quot;symbol&quot;&gt;:each_slot&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; block_given?

    objs = &lt;span class=&quot;instance-variable&quot;&gt;@live_objects&lt;/span&gt;.sort

    obj_count.times &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |i|
      expected = obj_start_address + (i * &lt;span class=&quot;constant&quot;&gt;SIZEOF_RVALUE&lt;/span&gt;)
      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; objs.any? &amp;amp;&amp;amp; objs.first == expected
        objs.shift
        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:full&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;:empty&lt;/span&gt;
      &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Now, from page to page, we&amp;rsquo;re able to differentiate empty slots from full
slots.  Lets use ChunkyPNG to generate a PNG file where each column in the PNG
represent one page, and each 2 x 2 pixel square in each page represents an
object.  We&amp;rsquo;ll color the object red if it&amp;rsquo;s full, but just leave it empty if
it&amp;rsquo;s empty:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;chunky_png&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;

pages = pages.values

&lt;span class=&quot;comment&quot;&gt;# We're using 2x2 pixel squares to represent objects, so the height of&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# the PNG will be 2x the max number of objects, and the width will be 2x the&lt;/span&gt;
&lt;span class=&quot;comment&quot;&gt;# number of pages&lt;/span&gt;
height = &lt;span class=&quot;constant&quot;&gt;HEAP_PAGE_OBJ_LIMIT&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;2&lt;/span&gt;
width = pages.size * &lt;span class=&quot;integer&quot;&gt;2&lt;/span&gt;

png = &lt;span class=&quot;constant&quot;&gt;ChunkyPNG&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Image&lt;/span&gt;.new(width, height, &lt;span class=&quot;constant&quot;&gt;ChunkyPNG&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Color&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;TRANSPARENT&lt;/span&gt;)

pages.each_with_index &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |page, i|
  i = i * &lt;span class=&quot;integer&quot;&gt;2&lt;/span&gt;

  page.each_slot.with_index &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |slot, j|
    &lt;span class=&quot;comment&quot;&gt;# If the slot is full, color it red&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; slot == &lt;span class=&quot;symbol&quot;&gt;:full&lt;/span&gt;
      j = j * &lt;span class=&quot;integer&quot;&gt;2&lt;/span&gt;
      png[i, j] = &lt;span class=&quot;constant&quot;&gt;ChunkyPNG&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Color&lt;/span&gt;.rgba(&lt;span class=&quot;integer&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;255&lt;/span&gt;)
      png[i + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;, j] = &lt;span class=&quot;constant&quot;&gt;ChunkyPNG&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Color&lt;/span&gt;.rgba(&lt;span class=&quot;integer&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;255&lt;/span&gt;)
      png[i, j + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;constant&quot;&gt;ChunkyPNG&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Color&lt;/span&gt;.rgba(&lt;span class=&quot;integer&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;255&lt;/span&gt;)
      png[i + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;, j + &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;constant&quot;&gt;ChunkyPNG&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Color&lt;/span&gt;.rgba(&lt;span class=&quot;integer&quot;&gt;255&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;integer&quot;&gt;255&lt;/span&gt;)
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

png.save(&lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;heap.png&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;symbol&quot;&gt;:interlace&lt;/span&gt; =&amp;gt; &lt;span class=&quot;predefined-constant&quot;&gt;true&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;After running this, we should have a file output called &lt;code&gt;heap.png&lt;/code&gt;.  Here&amp;rsquo;s
the one I generated:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/full_heap.png&quot; alt=&quot;filled heap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This one doesn&amp;rsquo;t look as neat because we filled the heap up.  Lets try dumping
the heap from a relatively empty process and see what it looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -robjspace -e'File.open(&quot;heap.json&quot;, &quot;wb&quot;) { |t| ObjectSpace.dump_all(output: t) }'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If I process this heap, the output looks like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/empty_heap.png&quot; alt=&quot;empty heap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ok that&amp;rsquo;s the end.  Thank you!&lt;/p&gt;

&lt;p&gt;You can find the full code listing from this post &lt;a href=&quot;https://gist.github.com/tenderlove/f28373d56fdd03d8b514af7191611b88&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&amp;lt;3&amp;lt;3&amp;lt;3&amp;lt;3&amp;lt;3&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2017/02/01/object-id-in-mri.html</id>
      <title>Object ID in MRI</title>
      <updated>2017-02-01T09:41:34-08:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2017/02/01/object-id-in-mri.html">

      <published>2017-02-01T09:41:34-08:00</published>
      <content type="html">&lt;p&gt;Objects in Ruby are 40 bytes.
Objects are allocated in to pages (or arenas) that are 2^14 (2 to the 14th power) bytes.
Pages are allocated with an aligned malloc where the divisor is the size of a page.
The first object is allocated at the first address inside the page that is divisible by 40 (or &lt;code&gt;page_start + (40 - page_start % 40) % 40&lt;/code&gt;).
This means all Ruby object addresses are divisible by 40, and that some pages hold one more object than others.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/page_layout.png&quot; alt=&quot;page layout&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The code to find the &amp;ldquo;first object inside the page&amp;rdquo; can be found &lt;a href=&quot;https://github.com/ruby/ruby/blob/8395d5a7c33b1a539d42ecabadd094f0871397a7/gc.c#L1498-L1502&quot;&gt;here&lt;/a&gt;.  If the page address isn&amp;rsquo;t divisible by 40, this calculates the first offset inside the page where an object can be allocated.  Objects are allocated at 40 byte offsets in order to support tagged pointers.&lt;/p&gt;

&lt;h2 id=&quot;tagged-pointers&quot;&gt;Tagged pointers&lt;/h2&gt;

&lt;p&gt;Every number divisible by 40 when represented in binary always ends in three 0s:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;irb(main):012:0&amp;gt; sprintf(&quot;%0#15b&quot;, 80)
=&amp;gt; &quot;0b0000001010000&quot;
irb(main):013:0&amp;gt; sprintf(&quot;%0#15b&quot;, 120)
=&amp;gt; &quot;0b0000001111000&quot;
irb(main):014:0&amp;gt; sprintf(&quot;%0#15b&quot;, 160)
=&amp;gt; &quot;0b0000010100000&quot;
irb(main):015:0&amp;gt; sprintf(&quot;%0#15b&quot;, 200)
=&amp;gt; &quot;0b0000011001000&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MRI exploits this fact in order to represent some objects like integers without allocating anything.
Pointers are just numbers, so if the number is not divisible by 40 (in other words &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; end in 000), then we know it is something special.&lt;/p&gt;

&lt;p&gt;Integers are examples of tagged pointers.  Integers are encoded by shifting the number left one, then setting the last bit to 1.  So the number 1 will be encoded as 3 (or in binary 11), and the number 40 will be encoded as 81 (or 1010001 in binary).  If the pointer we&amp;rsquo;re dealing with has a 1 in the last bit, we know it&amp;rsquo;s a Ruby integer, and we can decode it (convert to a C integer) by shifting right 1.&lt;/p&gt;

&lt;p&gt;Just to reiterate, a Ruby integer 20 (0b10100), is encoded to 41 (0b101001) by shifting left, then adding 1.&lt;/p&gt;

&lt;p&gt;So C integers are converted to Ruby integers by shifting left by one, then adding one.  Ruby integers are converted to C integers by shifting right by one.  This is one reason why Ruby can&amp;rsquo;t represent a full 64bit number as an &amp;ldquo;immediate&amp;rdquo; value.  One bit is used for encoding (the other bit is used for the sign).&lt;/p&gt;

&lt;p&gt;A diagram of the tagging scheme is &lt;a href=&quot;https://github.com/ruby/ruby/blob/8395d5a7c33b1a539d42ecabadd094f0871397a7/gc.c#L3087-L3114&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;calculating-object-id&quot;&gt;Calculating Object ID&lt;/h2&gt;

&lt;p&gt;&amp;ldquo;Non special objects&amp;rdquo; are objects that don&amp;rsquo;t use the 3 bits on the right side for any meaning.  An example of a &amp;ldquo;non special object&amp;rdquo; would be &lt;code&gt;Object.new&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Non special objects encode their object id as their address in memory + 1.  The encoding code is &lt;a href=&quot;https://github.com/ruby/ruby/blob/8395d5a7c33b1a539d42ecabadd094f0871397a7/gc.c#L789&quot;&gt;here&lt;/a&gt;.  Normally, to convert a C integer to a Ruby integer, the integer is shifted left, then add one.  But the address of a non special Ruby object will always be divisible by 40, so we know that the last bit is 0.  So this code simply changes the last bit from a 0 to a 1.  Clobbering the last bit means that when Ruby side of the program see it, it will be the address of the object shifted right by one.&lt;/p&gt;

&lt;p&gt;If object X is at memory location 40, then the object id (in Ruby) will be 20.  The Ruby integer 20 (0b10100) is encoded by shifting left then adding one, which results in 41 (0b101001).  Since this code simply takes the location (in this case 40) and adds one, the result is 41 (0b101001) which is the same as 20 on the Ruby side.&lt;/p&gt;

&lt;p&gt;In other words, &lt;code&gt;object_id&lt;/code&gt; returns the address of the object shifted right one and we can get the actual address of the object back by shifting left one.&lt;/p&gt;

&lt;p&gt;Calling &lt;code&gt;inspect&lt;/code&gt; shows the actual address as hex.  We can see that shifting left one, then converting to hex will give us the same number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;irb(main):021:0&amp;gt; x = Object.new
=&amp;gt; #&amp;lt;Object:0x00000100827400&amp;gt;
irb(main):022:0&amp;gt; x.object_id.to_s(16)
=&amp;gt; &quot;80413a00&quot; # not what we want
irb(main):023:0&amp;gt; (x.object_id &amp;lt;&amp;lt; 1).to_s(16)
=&amp;gt; &quot;100827400&quot; # this is it!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;calculating-page-number&quot;&gt;Calculating Page Number&lt;/h2&gt;

&lt;p&gt;We can use the address of an object to calculate the arena (or page) in to which the object was allocated.  Pages are aligned at 2^14, so the page header will always be divisible by 2^14.  The page size is never larger than 2^14, so any offset inside the page &lt;em&gt;will not&lt;/em&gt; be evenly divisible by 2^14.  Knowing this, we can remove the lower bits of the object by using a mask that is 14 bits wide:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;irb(main):&lt;span class=&quot;integer&quot;&gt;001&lt;/span&gt;:&lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;&amp;gt; &lt;span class=&quot;constant&quot;&gt;MASK&lt;/span&gt; = ~(&lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span class=&quot;integer&quot;&gt;14&lt;/span&gt;
=&amp;gt; &lt;span class=&quot;integer&quot;&gt;-16384&lt;/span&gt;
irb(main):&lt;span class=&quot;integer&quot;&gt;002&lt;/span&gt;:&lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;&amp;gt; &lt;span class=&quot;integer&quot;&gt;10&lt;/span&gt;.times { p (&lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt;.new.object_id &amp;lt;&amp;lt; &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;) &amp;amp; &lt;span class=&quot;constant&quot;&gt;MASK&lt;/span&gt; }
&lt;span class=&quot;integer&quot;&gt;4305141760&lt;/span&gt;
&lt;span class=&quot;integer&quot;&gt;4305141760&lt;/span&gt;
&lt;span class=&quot;integer&quot;&gt;4305141760&lt;/span&gt;
&lt;span class=&quot;integer&quot;&gt;4305141760&lt;/span&gt;
&lt;span class=&quot;integer&quot;&gt;4305141760&lt;/span&gt;
&lt;span class=&quot;integer&quot;&gt;4305141760&lt;/span&gt;
&lt;span class=&quot;integer&quot;&gt;4305141760&lt;/span&gt;
&lt;span class=&quot;integer&quot;&gt;4305141760&lt;/span&gt;
&lt;span class=&quot;integer&quot;&gt;4305141760&lt;/span&gt;
&lt;span class=&quot;integer&quot;&gt;4305141760&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Now we can group objects by what page they were allocated on.&lt;/p&gt;

&lt;p&gt;The End.&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2017/01/17/evented-gpio-on-raspberry-pi-with-ruby.html</id>
      <title>Evented GPIO on Raspberry PI with Ruby</title>
      <updated>2017-01-17T10:24:34-08:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2017/01/17/evented-gpio-on-raspberry-pi-with-ruby.html">

      <published>2017-01-17T10:24:34-08:00</published>
      <content type="html">&lt;p&gt;I need to know when my cats are pooping so over the weekend I hooked up a motion sensor to my Raspberry PI.  This is the code I used to get an interrupt when the motion sensor turns on or off:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;epoll&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;watch&lt;/span&gt; pin, &lt;span class=&quot;key&quot;&gt;on&lt;/span&gt;:
  &lt;span class=&quot;comment&quot;&gt;# Export the pin we want to watch&lt;/span&gt;
  &lt;span class=&quot;constant&quot;&gt;File&lt;/span&gt;.binwrite &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;/sys/class/gpio/export&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, pin.to_s

  &lt;span class=&quot;comment&quot;&gt;# It takes time for the pin support files to appear, so retry a few times&lt;/span&gt;
  retries = &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;begin&lt;/span&gt;
    &lt;span class=&quot;comment&quot;&gt;# `on` should be &amp;quot;none&amp;quot;, &amp;quot;rising&amp;quot;, &amp;quot;falling&amp;quot;, or &amp;quot;both&amp;quot;&lt;/span&gt;
    &lt;span class=&quot;constant&quot;&gt;File&lt;/span&gt;.binwrite &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;/sys/class/gpio/gpio&lt;/span&gt;&lt;span class=&quot;inline&quot;&gt;&lt;span class=&quot;inline-delimiter&quot;&gt;#{&lt;/span&gt;pin&lt;span class=&quot;inline-delimiter&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;/edge&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, on
  &lt;span class=&quot;keyword&quot;&gt;rescue&lt;/span&gt;
    raise &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; retries &amp;gt; &lt;span class=&quot;integer&quot;&gt;3&lt;/span&gt;
    sleep &lt;span class=&quot;float&quot;&gt;0.1&lt;/span&gt;
    retries += &lt;span class=&quot;integer&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;retry&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

  &lt;span class=&quot;comment&quot;&gt;# Read the initial pin value and yield it to the block&lt;/span&gt;
  fd = &lt;span class=&quot;constant&quot;&gt;File&lt;/span&gt;.open &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;/sys/class/gpio/gpio&lt;/span&gt;&lt;span class=&quot;inline&quot;&gt;&lt;span class=&quot;inline-delimiter&quot;&gt;#{&lt;/span&gt;pin&lt;span class=&quot;inline-delimiter&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;/value&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; fd.read.chomp

  epoll = &lt;span class=&quot;constant&quot;&gt;Epoll&lt;/span&gt;.create
  epoll.add fd, &lt;span class=&quot;constant&quot;&gt;Epoll&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;PRI&lt;/span&gt;

  loop &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
    fd.seek &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;constant&quot;&gt;IO&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;SEEK_SET&lt;/span&gt;
    epoll.wait &lt;span class=&quot;comment&quot;&gt;# put the program to sleep until the status changes&lt;/span&gt;
    &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; fd.read.chomp
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;ensure&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;# Unexport the pin when we're done&lt;/span&gt;
  &lt;span class=&quot;constant&quot;&gt;File&lt;/span&gt;.binwrite &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;/sys/class/gpio/unexport&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;, pin.to_s
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

pin = &lt;span class=&quot;integer&quot;&gt;5&lt;/span&gt;

watch pin, &lt;span class=&quot;key&quot;&gt;on&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;both&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |value|
  p value
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Whenever an event happens on the GPIO pin, the block will be executed.  I want the block to be executed when the sensor detects movement and when it detects no movement (if you imagine that as a wave, I want to know about the rising and falling edges), so I passed &amp;ldquo;both&amp;rdquo; to the &lt;code&gt;watch&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;I am very new to developing on Raspberry PI, and I&amp;rsquo;m not sure what people normally use for Ruby + GPIO on Raspberry PI.  I looked at the &lt;a href=&quot;https://github.com/ClockVapor/rpi_gpio&quot;&gt;rpi_gpio&lt;/a&gt; gem.  It gives access to read values of GPIO, but doesn&amp;rsquo;t give you any events.  In other words, you can use it to read the current value of a pin, but it won&amp;rsquo;t let you know when the value of a pin has changed.  It looks like &lt;a href=&quot;https://github.com/ClockVapor/rpi_gpio/blob/cbf23516be40edc93bbb121dc4583d8578ebd395/ext/rpi_gpio/event_gpio.c&quot;&gt;there is code to support this&lt;/a&gt;, but &lt;a href=&quot;https://github.com/ClockVapor/rpi_gpio/issues/4&quot;&gt;it&amp;rsquo;s not fully hooked up yet&lt;/a&gt;.  I noticed that the C code is just using Epoll, so I tried using the &lt;a href=&quot;https://github.com/ksss/epoll&quot;&gt;epoll gem&lt;/a&gt;, and it works.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;rpi_gpio&lt;/code&gt; gem is cool because it allows your program to read from a pin without echoing to &amp;ldquo;exports&amp;rdquo; and reading from a file.  The gem just &lt;code&gt;mmap&lt;/code&gt;s a special device, and then reads from memory.  Unfortunately, it doesn&amp;rsquo;t seem like there is a way to generate &amp;ldquo;on change&amp;rdquo; events with that system.  That means we have to write to the &amp;ldquo;export&amp;rdquo; file and run &lt;code&gt;poll&lt;/code&gt; on the &amp;ldquo;value&amp;rdquo; file.  As you can see from the example above, waiting for events (the thing we &lt;em&gt;want&lt;/em&gt; to do) accounts for only a few lines of code where managing export / value files accounts for most of the function.&lt;/p&gt;

&lt;p&gt;I am new to Raspberry PI development, so maybe there is an easier way, but I haven&amp;rsquo;t found it.  At least this works so I can know when my cats are pooping.&lt;/p&gt;

&lt;p&gt;The End.&lt;/p&gt;
</content>
    </entry>
  
    <entry>
      <id>http://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html</id>
      <title>I am a puts debuggerer</title>
      <updated>2016-02-05T15:26:48-08:00</updated>

      <link rel="alternate" href="http://tenderlovemaking.com/2016/02/05/i-am-a-puts-debuggerer.html">

      <published>2016-02-05T15:26:48-08:00</published>
      <content type="html">&lt;h2 id=&quot;i-love-puts-debugging&quot;&gt;I love puts debugging&lt;/h2&gt;

&lt;p&gt;I am a &lt;code&gt;puts&lt;/code&gt; debuggerer.
I don&amp;rsquo;t say this to disparage people that use a Real Debugger.
I think Real Debuggers are great, I&amp;rsquo;ve just never taken the time to learn one well.
Every time I try to lean one, I end up not using it for a while and have to re-learn how to use it.
Anyway, I want to share some tricks I use for puts debugging with you.
I use these tricks whenever I don&amp;rsquo;t understand how something works and I want to know more.
Most of the stuff below is definitely &lt;em&gt;not&lt;/em&gt; a &amp;ldquo;best practice&amp;rdquo; and you should never leave this code around when you&amp;rsquo;re done with a debugging session.
However, I think it&amp;rsquo;s important to say that when you&amp;rsquo;re debugging &lt;strong&gt;anything goes&lt;/strong&gt;.
I mean anything.
Global variables, redefining methods, adding conditionals, manipulating the load path, monkey patching, printing the call stack, &lt;strong&gt;anything&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve tried to stick to real world examples in this post.
However, many of these examples came from when I was trying to debug security issues in Rails, so please reuse the techniques I&amp;rsquo;m showing here &lt;strong&gt;but not the target code&lt;/strong&gt;.
The target code I&amp;rsquo;m trying to debug is broken, and I don&amp;rsquo;t want you to use it.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve tried to organize each section in to a headline with the problem I have, and the body as the solution I used.&lt;/p&gt;

&lt;p&gt;Also, I gave up on using a consistent voice because this is a blog post and I don&amp;rsquo;t care.&lt;/p&gt;

&lt;h2 id=&quot;i-know-where-i-am-but-not-how-i-got-here&quot;&gt;I know where I am but not how I got here&lt;/h2&gt;

&lt;p&gt;Sometimes I&amp;rsquo;ll be debugging an issue and know where the problem is, but not how I got there.  For those times I&amp;rsquo;ll just do &lt;code&gt;puts caller&lt;/code&gt; to get the callstack.&lt;/p&gt;

&lt;p&gt;For example I have this code:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;constant&quot;&gt;LOOKUP&lt;/span&gt;           = &lt;span class=&quot;constant&quot;&gt;Hash&lt;/span&gt;.new { |h, k| h[k] = &lt;span class=&quot;constant&quot;&gt;Type&lt;/span&gt;.new(k) &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; k.blank? }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;But I need to know how the default block is getting called, I do this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;constant&quot;&gt;LOOKUP&lt;/span&gt;           = &lt;span class=&quot;constant&quot;&gt;Hash&lt;/span&gt;.new { |h, k|
    puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;90&lt;/span&gt;
    puts caller
    puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;90&lt;/span&gt;
    h[k] = &lt;span class=&quot;constant&quot;&gt;Type&lt;/span&gt;.new(k) &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; k.blank?
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The above code will print out 90 hash tags, then the call stack, then 90 more hash tags.  I print out the hash tags so that if it gets called multiple times, I can easily differentiate the call stacks.  Note that I am calling them &amp;ldquo;hash tags&amp;rdquo; in order to annoy you.&lt;/p&gt;

&lt;p&gt;I do this pretty frequently, so I have a Vim shortcut to do it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&quot; puts the caller
nnoremap &amp;lt;leader&amp;gt;wtf oputs &quot;#&quot; * 90&amp;lt;c-m&amp;gt;puts caller&amp;lt;c-m&amp;gt;puts &quot;#&quot; * 90&amp;lt;esc&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That lets me do &lt;code&gt;&amp;lt;leader&amp;gt;wtf&lt;/code&gt; and inserts those three lines below the line that I&amp;rsquo;m on.&lt;/p&gt;

&lt;h3 id=&quot;i-only-want-to-print-the-call-stack-once&quot;&gt;I only want to print the call stack once&lt;/h3&gt;

&lt;p&gt;Just use &lt;code&gt;exit!&lt;/code&gt; after printing the callstack, or call &lt;code&gt;raise&lt;/code&gt;.  &lt;code&gt;raise&lt;/code&gt; will show an exception so you see the stack anyway.&lt;/p&gt;

&lt;h3 id=&quot;i-only-want-to-see-the-stack-in-certain-cases&quot;&gt;I only want to see the stack in certain cases&lt;/h3&gt;

&lt;p&gt;This is debugging code, so you can do whatever you want.  Lets say I just want to see the stack when adding something to the hash.  Just do this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;constant&quot;&gt;LOOKUP&lt;/span&gt;           = &lt;span class=&quot;constant&quot;&gt;Hash&lt;/span&gt;.new { |h, k|
    &lt;span class=&quot;keyword&quot;&gt;unless&lt;/span&gt; k.blank?
      puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;90&lt;/span&gt;
      puts caller
      puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;90&lt;/span&gt;
      h[k] = &lt;span class=&quot;constant&quot;&gt;Type&lt;/span&gt;.new(k)
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Since I&amp;rsquo;m going to throw this code away anyway, I&amp;rsquo;m free to add any kind of weird conditionals I&amp;rsquo;d like!&lt;/p&gt;

&lt;h2 id=&quot;im-calling-a-method-but-i-dont-know-where-it-goes&quot;&gt;I&amp;rsquo;m calling a method, but I don&amp;rsquo;t know where it goes&lt;/h2&gt;

&lt;p&gt;In the case where I&amp;rsquo;m calling a method, but I don&amp;rsquo;t know where that method is implemented, I&amp;rsquo;ll use the &lt;code&gt;method&lt;/code&gt; method along with the &lt;code&gt;source_location&lt;/code&gt; method.  For example, I have an action in a controller that calls &lt;code&gt;render&lt;/code&gt; and I want to find that method:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;show&lt;/span&gt;
  render params[&lt;span class=&quot;symbol&quot;&gt;:id&lt;/span&gt;]
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;I&amp;rsquo;ll change the above code to this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;index&lt;/span&gt;
  p method(&lt;span class=&quot;symbol&quot;&gt;:render&lt;/span&gt;).source_location
  render params[&lt;span class=&quot;symbol&quot;&gt;:id&lt;/span&gt;]
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Run this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ curl http://localhost:3000/users/xxxx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then in the logs I see this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Processing by UsersController#show as */*
  Parameters: {&quot;id&quot;=&amp;gt;&quot;xxxx&quot;}
[&quot;/Users/aaron/git/rails/actionpack/lib/action_controller/metal/instrumentation.rb&quot;, 40]
Completed 500 Internal Server Error in 35ms (ActiveRecord: 0.0ms)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I know that the &lt;code&gt;render&lt;/code&gt; method is in &lt;a href=&quot;https://github.com/rails/rails/blob/6fcc3c47eb363d0d3753ee284de2fbc68df03194/actionpack/lib/action_controller/metal/instrumentation.rb#L40&quot;&gt;instrumentation.rb on line 40&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;im-calling-super-but-i-dont-know-where-that-goes&quot;&gt;I&amp;rsquo;m calling &lt;code&gt;super&lt;/code&gt; but I don&amp;rsquo;t know where that goes&lt;/h2&gt;

&lt;p&gt;Here I can see that &lt;code&gt;render&lt;/code&gt; &lt;a href=&quot;https://github.com/rails/rails/blob/6fcc3c47eb363d0d3753ee284de2fbc68df03194/actionpack/lib/action_controller/metal/instrumentation.rb#L43&quot;&gt;calls super&lt;/a&gt;, but I don&amp;rsquo;t know where that is implemented.  In that case, I use &lt;code&gt;super_method&lt;/code&gt; on the return value of &lt;code&gt;method&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So I change this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;index&lt;/span&gt;
  p method(&lt;span class=&quot;symbol&quot;&gt;:render&lt;/span&gt;).source_location
  render params[&lt;span class=&quot;symbol&quot;&gt;:id&lt;/span&gt;]
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;To this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;index&lt;/span&gt;
  p method(&lt;span class=&quot;symbol&quot;&gt;:render&lt;/span&gt;).super_method.source_location
  render params[&lt;span class=&quot;symbol&quot;&gt;:id&lt;/span&gt;]
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Run the same request through, and I get this for the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Processing by UsersController#show as */*
  Parameters: {&quot;id&quot;=&amp;gt;&quot;xxxx&quot;}
[&quot;/Users/aaron/git/rails/actionpack/lib/action_controller/metal/rendering.rb&quot;, 34]
Completed 500 Internal Server Error in 34ms (ActiveRecord: 0.0ms)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I see that &lt;code&gt;super&lt;/code&gt; &lt;a href=&quot;https://github.com/rails/rails/blob/6fcc3c47eb363d0d3753ee284de2fbc68df03194/actionpack/lib/action_controller/metal/rendering.rb#L34&quot;&gt;goes here&lt;/a&gt;.  That method also calls super, but I can just rinse and repeat the above process (or use a loop!) to find the method I actually care about.&lt;/p&gt;

&lt;h2 id=&quot;what-if-the-thing-implements-the-method-method&quot;&gt;What if the thing implements the &lt;code&gt;method&lt;/code&gt; method?&lt;/h2&gt;

&lt;p&gt;Sometimes the &lt;code&gt;method&lt;/code&gt; trick doesn&amp;rsquo;t work because the object I want to know about implements it&amp;rsquo;s own version of &lt;code&gt;method&lt;/code&gt;.  For example, I am trying to find where the &lt;code&gt;headers&lt;/code&gt; method is implemented on the request object with this code:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;index&lt;/span&gt;
  p request.method(&lt;span class=&quot;symbol&quot;&gt;:headers&lt;/span&gt;).source_location
  &lt;span class=&quot;instance-variable&quot;&gt;@users&lt;/span&gt; = &lt;span class=&quot;constant&quot;&gt;User&lt;/span&gt;.all
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;When I run a request, I get this error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ArgumentError (wrong number of arguments (given 1, expected 0)):
  app/controllers/users_controller.rb:5:in `index'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is because the &lt;code&gt;request&lt;/code&gt; object implements it&amp;rsquo;s own method called &lt;code&gt;method&lt;/code&gt;.  To figure out where the &lt;code&gt;headers&lt;/code&gt; method is, I will unbind the method from &lt;code&gt;Kernel&lt;/code&gt;, rebind it to the request, then execute it like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;index&lt;/span&gt;
  method = &lt;span class=&quot;constant&quot;&gt;Kernel&lt;/span&gt;.instance_method(&lt;span class=&quot;symbol&quot;&gt;:method&lt;/span&gt;)
  p method.bind(request).call(&lt;span class=&quot;symbol&quot;&gt;:headers&lt;/span&gt;).source_location
  &lt;span class=&quot;instance-variable&quot;&gt;@users&lt;/span&gt; = &lt;span class=&quot;constant&quot;&gt;User&lt;/span&gt;.all
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Running the request again, I get this for the output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Processing by UsersController#index as */*
[&quot;/Users/aaron/git/rails/actionpack/lib/action_dispatch/http/request.rb&quot;, 201]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I know the &lt;code&gt;headers&lt;/code&gt; method is implemented &lt;a href=&quot;https://github.com/rails/rails/blob/6fcc3c47eb363d0d3753ee284de2fbc68df03194/actionpack/lib/action_dispatch/http/request.rb#L201&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I can even find the implementation of the &lt;code&gt;method&lt;/code&gt; method like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;index&lt;/span&gt;
  method = &lt;span class=&quot;constant&quot;&gt;Kernel&lt;/span&gt;.instance_method(&lt;span class=&quot;symbol&quot;&gt;:method&lt;/span&gt;)
  p method.bind(request).call(&lt;span class=&quot;symbol&quot;&gt;:method&lt;/span&gt;).source_location
  &lt;span class=&quot;instance-variable&quot;&gt;@users&lt;/span&gt; = &lt;span class=&quot;constant&quot;&gt;User&lt;/span&gt;.all
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;h2 id=&quot;im-calling-something-but-i-dont-know-where-it-goes-again&quot;&gt;I&amp;rsquo;m calling something but I don&amp;rsquo;t know where it goes (again)&lt;/h2&gt;

&lt;p&gt;Sometimes the immediate method isn&amp;rsquo;t the method I actually care about, so using the &lt;code&gt;method&lt;/code&gt; trick to figure out where I&amp;rsquo;m going won&amp;rsquo;t help.
In that case, I&amp;rsquo;ll use a larger hammer which is &lt;code&gt;TracePoint&lt;/code&gt;.
We can redo the &lt;code&gt;render&lt;/code&gt; example to get a list of &lt;em&gt;all&lt;/em&gt; methods that are called from &lt;code&gt;render&lt;/code&gt;.
The methods we&amp;rsquo;ll see listed may not be called directly from &lt;code&gt;render&lt;/code&gt; but from somewhere.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;  &lt;span class=&quot;comment&quot;&gt;# GET /users&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;# GET /users.json&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;index&lt;/span&gt;
    &lt;span class=&quot;instance-variable&quot;&gt;@users&lt;/span&gt; = &lt;span class=&quot;constant&quot;&gt;User&lt;/span&gt;.all
    tp = &lt;span class=&quot;constant&quot;&gt;TracePoint&lt;/span&gt;.new(&lt;span class=&quot;symbol&quot;&gt;:call&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |x|
      p x
    &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
    tp.enable
    render &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;ensure&lt;/span&gt;
    tp.disable
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;TracePoint&lt;/code&gt; allocated here will fire on every &amp;ldquo;call&amp;rdquo; event and the block will print out the method name and location of the call.  A &amp;ldquo;call&amp;rdquo; even it when a Ruby method gets called (not a C method).  If you want to see C methods as well, use &lt;code&gt;:c_call&lt;/code&gt;.  This example will produce a &lt;em&gt;ton&lt;/em&gt; of output.  I really only use this technique when the number of methods being called is fairly small, or I don&amp;rsquo;t even know where to begin looking.&lt;/p&gt;

&lt;h2 id=&quot;i-know-an-exception-is-getting-raised-but-i-dont-know-where&quot;&gt;I know an exception is getting raised, but I don&amp;rsquo;t know where&lt;/h2&gt;

&lt;p&gt;Sometimes an exception gets raised, but I don&amp;rsquo;t know where the exception &lt;em&gt;actually&lt;/em&gt; got raised.  This example uses Rails 3.0.0 (we&amp;rsquo;ve since fixed this issue), but say you have this code:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;constant&quot;&gt;ActiveRecord&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Base&lt;/span&gt;.logger = &lt;span class=&quot;constant&quot;&gt;Logger&lt;/span&gt;.new &lt;span class=&quot;global-variable&quot;&gt;$stdout&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;User&lt;/span&gt;.connection.execute &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;oh no!&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;I know this SQL won&amp;rsquo;t work, and there will be an exception.  But lets see what the exception actually looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  SQL (0.1ms)  oh no!
SQLite3::SQLException: near &quot;oh&quot;: syntax error: oh no!
activerecord-3.0.0/lib/active_record/connection_adapters/abstract_adapter.rb:202:in `rescue in log': SQLite3::SQLException: near &quot;oh&quot;: syntax error: oh no! (ActiveRecord::StatementInvalid)
	from activerecord-3.0.0/lib/active_record/connection_adapters/abstract_adapter.rb:194:in `log'
	from activerecord-3.0.0/lib/active_record/connection_adapters/sqlite_adapter.rb:135:in `execute'
	from test.rb:6:in `&amp;lt;top (required)&amp;gt;'
	from railties-3.0.0/lib/rails/commands/runner.rb:48:in `eval'
	from railties-3.0.0/lib/rails/commands/runner.rb:48:in `&amp;lt;top (required)&amp;gt;'
	from railties-3.0.0/lib/rails/commands.rb:39:in `require'
	from railties-3.0.0/lib/rails/commands.rb:39:in `&amp;lt;top (required)&amp;gt;'
	from script/rails:6:in `require'
	from script/rails:6:in `&amp;lt;main&amp;gt;'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you read this backtrace, it looks like the exception came from &lt;a href=&quot;https://github.com/rails/rails/blob/9891ca8/activerecord/lib/active_record/connection_adapters/abstract_adapter.rb#L202&quot;&gt;abstract_adapter.rb line 202&lt;/a&gt;.  However, what you&amp;rsquo;ll quickly notice is that this code is &lt;a href=&quot;https://github.com/rails/rails/blob/9891ca8/activerecord/lib/active_record/connection_adapters/abstract_adapter.rb#L199-L202&quot;&gt;rescuing an exception, and then re-raising&lt;/a&gt;.  So where did the real exception get raised?  To find it, we could add some &lt;code&gt;puts&lt;/code&gt; statements, or use the &lt;code&gt;-d&lt;/code&gt; flag on Ruby like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[aaron@TC okokok (master)]$ bundle exec ruby -d script/rails runner test.rb
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;-d&lt;/code&gt; flag will enable warnings and also print out every line where an exception was raised.  Yes, this definitely prints a bunch of stuff, but if you look at the output near the end it will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exception `NameError' at activesupport-3.0.0/lib/active_support/core_ext/module/remove_method.rb:3 - method `_validators' not defined in Class
Exception `SQLite3::SQLException' at sqlite3-1.3.11/lib/sqlite3/database.rb:91 - near &quot;oh&quot;: syntax error
Exception `SQLite3::SQLException' at activesupport-3.0.0/lib/active_support/notifications/instrumenter.rb:24 - near &quot;oh&quot;: syntax error
  SQL (0.1ms)  oh no!
SQLite3::SQLException: near &quot;oh&quot;: syntax error: oh no!
Exception `ActiveRecord::StatementInvalid' at activerecord-3.0.0/lib/active_record/connection_adapters/abstract_adapter.rb:202 - SQLite3::SQLException: near &quot;oh&quot;: syntax error: oh no!
Exception `ActiveRecord::StatementInvalid' at railties-3.0.0/lib/rails/commands/runner.rb:48 - SQLite3::SQLException: near &quot;oh&quot;: syntax error: oh no!
activerecord-3.0.0/lib/active_record/connection_adapters/abstract_adapter.rb:202:in `rescue in log': SQLite3::SQLException: near &quot;oh&quot;: syntax error: oh no! (ActiveRecord::StatementInvalid)
	from activerecord-3.0.0/lib/active_record/connection_adapters/abstract_adapter.rb:194:in `log'
	from activerecord-3.0.0/lib/active_record/connection_adapters/sqlite_adapter.rb:135:in `execute'
	from test.rb:6:in `&amp;lt;top (required)&amp;gt;'
	from railties-3.0.0/lib/rails/commands/runner.rb:48:in `eval'
	from railties-3.0.0/lib/rails/commands/runner.rb:48:in `&amp;lt;top (required)&amp;gt;'
	from railties-3.0.0/lib/rails/commands.rb:39:in `require'
	from railties-3.0.0/lib/rails/commands.rb:39:in `&amp;lt;top (required)&amp;gt;'
	from script/rails:6:in `require'
	from script/rails:6:in `&amp;lt;main&amp;gt;'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;ll see the original exception happened here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exception `SQLite3::SQLException' at sqlite3-1.3.11/lib/sqlite3/database.rb:91 - near &quot;oh&quot;: syntax error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And it was re-raised here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Exception `SQLite3::SQLException' at activesupport-3.0.0/lib/active_support/notifications/instrumenter.rb:24 - near &quot;oh&quot;: syntax error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Cases where exceptions are getting wrapped and re-raised &lt;em&gt;should&lt;/em&gt; expose the originating backtrace.  So this is a bug, but it has been fixed, and we can cover how to fix that another day.&lt;/p&gt;

&lt;h2 id=&quot;i-want-to-run-a-command-line-tool-with--d&quot;&gt;I want to run a command line tool with &lt;code&gt;-d&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Say you want to use the above technique to run your RSpec tests with the &lt;code&gt;-d&lt;/code&gt; flag, you can do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -d -S rspec
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;i-want-to-use-the--d-flag-but-i-dont-know-how-to-run-the-process&quot;&gt;I want to use the &lt;code&gt;-d&lt;/code&gt; flag but I don&amp;rsquo;t know how to run the process&lt;/h2&gt;

&lt;p&gt;The default Rake test task will &lt;a href=&quot;https://github.com/ruby/rake/blob/3c4fe3e25e5ab6b052f9e81bc2920ca4b4fc1094/lib/rake/testtask.rb#L105&quot;&gt;run your tests in a sub process&lt;/a&gt;.  This means that running &lt;code&gt;ruby -d -S rake&lt;/code&gt; will not set the debug flag in the sub-process that runs your tests.  In this case I use the &lt;code&gt;RUBYOPT&lt;/code&gt; environment variable like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[aaron@TC okokok (master)]$ RUBYOPT=-d bundle exec rake test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;RUBYOPT&lt;/code&gt; environment variable will get applied to every Ruby program that is executed in this shell, even sub shells executed by rake.  This means the &lt;code&gt;rspec&lt;/code&gt; command above could be rewritten as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ RUBYOPT=-d rspec
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;i-need-to-find-where-this-object-came-from&quot;&gt;I need to find where this object came from&lt;/h2&gt;

&lt;p&gt;Usually printing the callstack will tell me where an object came from.  But sometimes the object is allocated outside of the stack, so it&amp;rsquo;s difficult to figure out where it came from.  Take this code for example:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;foo&lt;/span&gt;
  x = baz
  bar x
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;bar&lt;/span&gt; x
  puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;90&lt;/span&gt;
  puts caller
  puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;90&lt;/span&gt;
  p x
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;baz&lt;/span&gt;; zot;        &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;zot&lt;/span&gt;; &lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt;.new; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

foo
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;I used the &amp;ldquo;&lt;leader&gt;wtf&quot; technique from &quot;I know where I am but not how I got here&quot;, and printed out the value of `x`.  From that, I learned that I really care how that `x` value was allocated, but if I trace back up the stack to the `foo` method, I can see that it calls `baz` to get the value.  In large code bases, it can be very tricky to follow all the calls and logic through a sibling tree (if you think about the code as a graph, then the `foo` method has two children, `baz` and `bar`, so you can think of `baz` as being a sibling to `bar`).
I am lazy and I don't want to go chasing through all the methods to find how this object came to be, so I like to use Ruby's object allocation tracer.
Ruby's allocation tracer has been available since Ruby 2.1 (don't quote me on that).
When I use it, I require and enable it as soon as possible.
Then I print out the allocation location at the place I care about, like this:&lt;/leader&gt;&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;objspace&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.trace_object_allocations_start

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;foo&lt;/span&gt;
  x = baz
  bar x
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;bar&lt;/span&gt; x
  p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.allocation_sourcefile(x) =&amp;gt; &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.allocation_sourceline(x)
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;baz&lt;/span&gt;; zot;        &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;zot&lt;/span&gt;; &lt;span class=&quot;constant&quot;&gt;Object&lt;/span&gt;.new; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

foo
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;When I run the program, the output is like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[aaron@TC tlm.com (master)]$ ruby x.rb 
{&quot;x.rb&quot;=&amp;gt;14}
[aaron@TC tlm.com (master)]$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I see that the object is allocated on line 14 in &lt;code&gt;x.rb&lt;/code&gt;.  So I go to that line and that method, then repeat the &amp;ldquo;&lt;leader&gt;wtf&quot; trick or this trick until I figure out what is wrong with the program.&lt;/leader&gt;&lt;/p&gt;

&lt;p&gt;I usually start object tracing ASAP because I don&amp;rsquo;t know where my object will be allocated.  The tracing slows down the program, but not enough to really matter while I&amp;rsquo;m debugging.&lt;/p&gt;

&lt;h2 id=&quot;i-need-to-require-something-really-really-early&quot;&gt;I need to require something really, really early&lt;/h2&gt;

&lt;p&gt;The above technique will only give you allocation information for objects that have been allocated &lt;em&gt;after&lt;/em&gt; &lt;code&gt;trace_object_allocations_start&lt;/code&gt; has been called.
Lets say the object is being allocated at file require time, but you don&amp;rsquo;t know &lt;em&gt;what&lt;/em&gt; file or &lt;em&gt;where&lt;/em&gt;.
In this case, I want to execute some code way before anything in the framework gets required.
To do that, I&amp;rsquo;ll use the &lt;code&gt;-r&lt;/code&gt; flag and write a script.&lt;/p&gt;

&lt;p&gt;Say there&amp;rsquo;s a script where we&amp;rsquo;re trying to find the allocation location of &lt;code&gt;User::BLACKLISTED_CLASS_METHODS&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;active_record&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;ActiveRecord&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Base&lt;/span&gt;.establish_connection &lt;span class=&quot;key&quot;&gt;adapter&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;sqlite3&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;, &lt;span class=&quot;key&quot;&gt;database&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;:memory:&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;

&lt;span class=&quot;constant&quot;&gt;ActiveRecord&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Base&lt;/span&gt;.connection.instance_eval &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt;
  create_table &lt;span class=&quot;symbol&quot;&gt;:users&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;User&lt;/span&gt; &amp;lt; &lt;span class=&quot;constant&quot;&gt;ActiveRecord&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;Base&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
p &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.allocation_sourcefile(&lt;span class=&quot;constant&quot;&gt;User&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;BLACKLISTED_CLASS_METHODS&lt;/span&gt;) =&amp;gt;
    &lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.allocation_sourceline(&lt;span class=&quot;constant&quot;&gt;User&lt;/span&gt;::&lt;span class=&quot;constant&quot;&gt;BLACKLISTED_CLASS_METHODS&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;But we don&amp;rsquo;t know which file allocates that constant, and don&amp;rsquo;t want to figure it out (yes this is slightly contrived).
I will write a file, in this case named &lt;code&gt;y.rb&lt;/code&gt; that looks like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;require &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;objspace&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;'&lt;/span&gt;&lt;/span&gt;
&lt;span class=&quot;constant&quot;&gt;ObjectSpace&lt;/span&gt;.trace_object_allocations_start
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Then I&amp;rsquo;ll use the command line arguments to Ruby to require this file and execute my program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[aaron@TC tlm.com (master)]$ ruby -I. -ry x.rb
{&quot;/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/activerecord-5.0.0.beta1/lib/active_record/attribute_methods.rb&quot;=&amp;gt;35}
[aaron@TC tlm.com (master)]$ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we break down the arguments to Ruby, the &lt;code&gt;-I.&lt;/code&gt; says &amp;ldquo;add . to the load path&amp;rdquo;, &lt;code&gt;-ry&lt;/code&gt; is the same as &lt;code&gt;require 'y'&lt;/code&gt;, then run &lt;code&gt;x.rb&lt;/code&gt;.
So &lt;code&gt;.&lt;/code&gt; is added to the load path, and &lt;code&gt;y.rb&lt;/code&gt; is required before Ruby even starts running &lt;code&gt;x.rb&lt;/code&gt;.
Then we see that the &lt;code&gt;BLACKLISTED_CLASS_METHODS&lt;/code&gt; was allocated in &lt;code&gt;attribute_methods.rb&lt;/code&gt; line 35.
You can combine this technique with the &lt;code&gt;RUBYOPT&lt;/code&gt; technique in case you code is run in a sub process like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ RUBYOPT='-I. -ry' rake test
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;an-object-is-being-mutated-but-i-dont-know-where&quot;&gt;An object is being mutated, but I don&amp;rsquo;t know where&lt;/h2&gt;

&lt;p&gt;Sometimes I run in to an object that I know is being mutated, but I don&amp;rsquo;t know where the mutation is happening.  In that case, I will call &lt;code&gt;freeze&lt;/code&gt; on the object, run my test, and then see where an exception occurs.  As an example, I needed to figure out where &lt;a href=&quot;https://github.com/rails/rails/blob/38b5af6595338cb2212980062d9aaf51241878cc/activesupport/lib/active_support/concurrency/share_lock.rb#L28&quot;&gt;this variable is being mutated&lt;/a&gt;.  I knew it was being mutated, I could see in the code it&amp;rsquo;s being mutated, but I didn&amp;rsquo;t know where that was happening first.  So I changed the code to be like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;initialize&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;()

  &lt;span class=&quot;instance-variable&quot;&gt;@cv&lt;/span&gt; = new_cond

  &lt;span class=&quot;instance-variable&quot;&gt;@sharing&lt;/span&gt; = &lt;span class=&quot;constant&quot;&gt;Hash&lt;/span&gt;.new(&lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;)
  &lt;span class=&quot;instance-variable&quot;&gt;@sharing&lt;/span&gt;.freeze
  &lt;span class=&quot;instance-variable&quot;&gt;@waiting&lt;/span&gt; = {}
  &lt;span class=&quot;instance-variable&quot;&gt;@exclusive_thread&lt;/span&gt; = &lt;span class=&quot;predefined-constant&quot;&gt;nil&lt;/span&gt;
  &lt;span class=&quot;instance-variable&quot;&gt;@exclusive_depth&lt;/span&gt; = &lt;span class=&quot;integer&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Booting the server gave me a exception with stack trace:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;active_support/concurrency/share_lock.rb:151:in `delete': can't modify frozen Hash (RuntimeError)
	from active_support/concurrency/share_lock.rb:151:in `yield_shares'
	from active_support/concurrency/share_lock.rb:79:in `block in stop_exclusive'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I know where the first mutation happened.  If that&amp;rsquo;s not the one I care about, I can remove the &lt;code&gt;freeze&lt;/code&gt; I added earlier, and add it &lt;em&gt;after&lt;/em&gt; this mutation.&lt;/p&gt;

&lt;h2 id=&quot;i-have-a-deadlock-but-i-dont-know-where&quot;&gt;I have a deadlock, but I don&amp;rsquo;t know where&lt;/h2&gt;

&lt;p&gt;When I&amp;rsquo;m having issues with threads and I don&amp;rsquo;t know where it is, I&amp;rsquo;ll add some code to inspect the live threads.  For example, I was &lt;a href=&quot;https://github.com/rails/rails/issues/23503&quot;&gt;debugging this issue&lt;/a&gt;.  The application server was hanging, but I didn&amp;rsquo;t know where.  To find where the threads were hanging, I wrote a file called &lt;code&gt;x.rb&lt;/code&gt; with code like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;trap(&lt;span class=&quot;symbol&quot;&gt;:INFO&lt;/span&gt;) {
  &lt;span class=&quot;constant&quot;&gt;Thread&lt;/span&gt;.list.each &lt;span class=&quot;keyword&quot;&gt;do&lt;/span&gt; |t|
    puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;90&lt;/span&gt;
    p t
    puts t.backtrace
    puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;90&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Then booted the app server like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ruby -I. -rx bin/rails s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when the app server hangs, I hit Ctrl-T (sorry, this only works on OS X, you&amp;rsquo;ll need to use &lt;code&gt;kill&lt;/code&gt; on Linux), and I&amp;rsquo;ll see a stack trace for every thread:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;##########################################################################################
#&amp;lt;Thread:0x007f90bc07cb38 run&amp;gt;
omglolwut/x.rb:7:in `backtrace'
omglolwut/x.rb:7:in `block (2 levels) in &amp;lt;top (required)&amp;gt;'
omglolwut/x.rb:4:in `each'
omglolwut/x.rb:4:in `block in &amp;lt;top (required)&amp;gt;'
gems/puma-2.16.0/lib/rack/handler/puma.rb:43:in `join'
gems/puma-2.16.0/lib/rack/handler/puma.rb:43:in `run'
gems/rack-2.0.0.alpha/lib/rack/server.rb:296:in `start'
rails/commands/server.rb:78:in `start'
rails/commands/commands_tasks.rb:90:in `block in server'
rails/commands/commands_tasks.rb:85:in `tap'
rails/commands/commands_tasks.rb:85:in `server'
rails/commands/commands_tasks.rb:49:in `run_command!'
rails/command.rb:20:in `run'
rails/commands.rb:19:in `&amp;lt;top (required)&amp;gt;'
bin/rails:4:in `require'
bin/rails:4:in `&amp;lt;main&amp;gt;'
##########################################################################################
##########################################################################################
#&amp;lt;Thread:0x007f90bef3b668@/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/puma-2.16.0/lib/puma/reactor.rb:136 sleep&amp;gt;
lib/puma/reactor.rb:29:in `select'
lib/puma/reactor.rb:29:in `run_internal'
lib/puma/reactor.rb:138:in `block in run_in_thread'
##########################################################################################
##########################################################################################
#&amp;lt;Thread:0x007f90bef3b500@/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/puma-2.16.0/lib/puma/thread_pool.rb:216 sleep&amp;gt;
lib/puma/thread_pool.rb:219:in `sleep'
lib/puma/thread_pool.rb:219:in `block in start!'
##########################################################################################
##########################################################################################
#&amp;lt;Thread:0x007f90bef3b3c0@/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/puma-2.16.0/lib/puma/thread_pool.rb:187 sleep&amp;gt;
lib/puma/thread_pool.rb:190:in `sleep'
lib/puma/thread_pool.rb:190:in `block in start!'
##########################################################################################
##########################################################################################
#&amp;lt;Thread:0x007f90bef3b258@/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/puma-2.16.0/lib/puma/server.rb:296 sleep&amp;gt;
lib/puma/server.rb:322:in `select'
lib/puma/server.rb:322:in `handle_servers'
lib/puma/server.rb:296:in `block in run'
##########################################################################################
##########################################################################################
#&amp;lt;Thread:0x007f90c1ef9a08@/Users/aaron/.rbenv/versions/ruby-trunk/lib/ruby/gems/2.4.0/gems/puma-2.16.0/lib/puma/thread_pool.rb:61 sleep&amp;gt;
lib/ruby/2.4.0/monitor.rb:111:in `sleep'
lib/ruby/2.4.0/monitor.rb:111:in `wait'
lib/ruby/2.4.0/monitor.rb:111:in `wait'
lib/ruby/2.4.0/monitor.rb:132:in `wait_until'
action_dispatch/http/response.rb:170:in `block in await_commit'
lib/ruby/2.4.0/monitor.rb:214:in `mon_synchronize'
action_dispatch/http/response.rb:169:in `await_commit'
action_controller/metal/live.rb:270:in `process'
action_controller/metal.rb:193:in `dispatch'
action_controller/metal.rb:265:in `dispatch'
action_dispatch/routing/route_set.rb:50:in `dispatch'
action_dispatch/routing/route_set.rb:32:in `serve'
##########################################################################################
##########################################################################################
#&amp;lt;Thread:0x007f90bd1d5f38@/Users/aaron/git/rails/actionpack/lib/action_controller/metal/live.rb:279 sleep&amp;gt;
lib/ruby/2.4.0/monitor.rb:111:in `sleep'
lib/ruby/2.4.0/monitor.rb:111:in `wait'
lib/ruby/2.4.0/monitor.rb:111:in `wait'
lib/ruby/2.4.0/monitor.rb:123:in `wait_while'
active_support/concurrency/share_lock.rb:57:in `block (2 levels) in start_exclusive'
active_support/concurrency/share_lock.rb:154:in `yield_shares'
active_support/concurrency/share_lock.rb:56:in `block in start_exclusive'
lib/ruby/2.4.0/monitor.rb:214:in `mon_synchronize'
active_support/concurrency/share_lock.rb:51:in `start_exclusive'
active_support/concurrency/share_lock.rb:113:in `exclusive'
active_support/dependencies/interlock.rb:12:in `loading'
active_support/dependencies.rb:37:in `load_interlock'
active_support/dependencies.rb:369:in `require_or_load'
active_support/dependencies.rb:529:in `load_missing_constant'
active_support/dependencies.rb:212:in `const_missing'
active_support/dependencies.rb:561:in `load_missing_constant'
active_support/dependencies.rb:212:in `const_missing'
app/controllers/users_controller.rb:9:in `index'
##########################################################################################
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve trimmed the output a bit to make it easier to read, but you can now see what each thread is doing, and it&amp;rsquo;s clear which two threads are deadlocking (it&amp;rsquo;s the last two).&lt;/p&gt;

&lt;h2 id=&quot;i-want-to-know-when-a-method-is-executed-but-only-at-a-certain-time&quot;&gt;I want to know when a method is executed, but only at a certain time&lt;/h2&gt;

&lt;p&gt;Sometimes I want to know when a method is executed, but I want to do it after a certain time.  For example, I want to know when &lt;a href=&quot;https://github.com/rails/rails/blob/38b5af6595338cb2212980062d9aaf51241878cc/activesupport/lib/active_support/concurrency/share_lock.rb#L48&quot;&gt;&lt;code&gt;start_exclusive&lt;/code&gt;&lt;/a&gt; is called, but &lt;em&gt;after&lt;/em&gt; the application boots up.  In these cases, I&amp;rsquo;ll mix global variables along with the &lt;code&gt;trap&lt;/code&gt; trick I showed earlier.&lt;/p&gt;

&lt;p&gt;First I modify &lt;code&gt;start_exclusive&lt;/code&gt; to look like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;start_exclusive&lt;/span&gt;(&lt;span class=&quot;key&quot;&gt;purpose&lt;/span&gt;: &lt;span class=&quot;predefined-constant&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;key&quot;&gt;compatible&lt;/span&gt;: [], &lt;span class=&quot;key&quot;&gt;no_wait&lt;/span&gt;: &lt;span class=&quot;predefined-constant&quot;&gt;false&lt;/span&gt;)
  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;global-variable&quot;&gt;$foo&lt;/span&gt;
    puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;90&lt;/span&gt;
    puts caller
    puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt; * &lt;span class=&quot;integer&quot;&gt;90&lt;/span&gt;
  &lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;comment&quot;&gt;# ..&lt;/span&gt;
&lt;span class=&quot;keyword&quot;&gt;end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Then I write an &lt;code&gt;x.rb&lt;/code&gt; file like this:&lt;/p&gt;

&lt;div class=&quot;language-ruby highlighter-coderay&quot;&gt;&lt;div class=&quot;CodeRay&quot;&gt;
  &lt;div class=&quot;code&quot;&gt;&lt;pre&gt;trap(&lt;span class=&quot;symbol&quot;&gt;:INFO&lt;/span&gt;) {
  puts &lt;span class=&quot;string&quot;&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&quot;content&quot;&gt;turning on debugging!&lt;/span&gt;&lt;span class=&quot;delimiter&quot;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;
  &lt;span class=&quot;global-variable&quot;&gt;$foo&lt;/span&gt; = &lt;span class=&quot;predefined-constant&quot;&gt;true&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;Then I boot the app server, and once everything has warmed up, I hit Ctrl-T and now my global variable is set to &lt;code&gt;true&lt;/code&gt; and I start seeing logging messages.&lt;/p&gt;

&lt;h2 id=&quot;end&quot;&gt;END&lt;/h2&gt;

&lt;p&gt;This is everything I can think of right now. You should also check out &lt;a href=&quot;http://www.schneems.com/2016/01/25/ruby-debugging-magic-cheat-sheet.html&quot;&gt;Richard&amp;rsquo;s post on puts debugging&lt;/a&gt;.  Have a good day. The End.&lt;/p&gt;
</content>
    </entry>
  
</feed>
